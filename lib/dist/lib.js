(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"), require("react-dom"));
	else if(typeof define === 'function' && define.amd)
		define(["react", "react-dom"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("react"), require("react-dom")) : factory(root["React"], root["ReactDOM"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function(__WEBPACK_EXTERNAL_MODULE_react__, __WEBPACK_EXTERNAL_MODULE_react_dom__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/lib.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/compute-scroll-into-view/es/index.js":
/*!************************************************************!*\
  !*** ../node_modules/compute-scroll-into-view/es/index.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function isElement(el) {
  return el != null && typeof el === 'object' && el.nodeType === 1;
}

function canOverflow(overflow, skipOverflowHiddenElements) {
  if (skipOverflowHiddenElements && overflow === 'hidden') {
    return false;
  }

  return overflow !== 'visible' && overflow !== 'clip';
}

function getFrameElement(el) {
  if (!el.ownerDocument || !el.ownerDocument.defaultView) {
    return null;
  }

  try {
    return el.ownerDocument.defaultView.frameElement;
  } catch (e) {
    return null;
  }
}

function isHiddenByFrame(el) {
  var frame = getFrameElement(el);

  if (!frame) {
    return false;
  }

  return frame.clientHeight < el.scrollHeight || frame.clientWidth < el.scrollWidth;
}

function isScrollable(el, skipOverflowHiddenElements) {
  if (el.clientHeight < el.scrollHeight || el.clientWidth < el.scrollWidth) {
    var style = getComputedStyle(el, null);
    return canOverflow(style.overflowY, skipOverflowHiddenElements) || canOverflow(style.overflowX, skipOverflowHiddenElements) || isHiddenByFrame(el);
  }

  return false;
}

function alignNearest(scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, scrollingBorderStart, scrollingBorderEnd, elementEdgeStart, elementEdgeEnd, elementSize) {
  if (elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd || elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd) {
    return 0;
  }

  if (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize || elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize) {
    return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart;
  }

  if (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize || elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize) {
    return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd;
  }

  return 0;
}

/* harmony default export */ __webpack_exports__["default"] = (function (target, options) {
  var scrollMode = options.scrollMode,
      block = options.block,
      inline = options.inline,
      boundary = options.boundary,
      skipOverflowHiddenElements = options.skipOverflowHiddenElements;
  var checkBoundary = typeof boundary === 'function' ? boundary : function (node) {
    return node !== boundary;
  };

  if (!isElement(target)) {
    throw new TypeError('Invalid target');
  }

  var scrollingElement = document.scrollingElement || document.documentElement;
  var frames = [];
  var cursor = target;

  while (isElement(cursor) && checkBoundary(cursor)) {
    cursor = cursor.parentNode;

    if (cursor === scrollingElement) {
      frames.push(cursor);
      break;
    }

    if (cursor === document.body && isScrollable(cursor) && !isScrollable(document.documentElement)) {
      continue;
    }

    if (isScrollable(cursor, skipOverflowHiddenElements)) {
      frames.push(cursor);
    }
  }

  var viewportWidth = window.visualViewport ? visualViewport.width : innerWidth;
  var viewportHeight = window.visualViewport ? visualViewport.height : innerHeight;
  var viewportX = window.scrollX || pageXOffset;
  var viewportY = window.scrollY || pageYOffset;

  var _target$getBoundingCl = target.getBoundingClientRect(),
      targetHeight = _target$getBoundingCl.height,
      targetWidth = _target$getBoundingCl.width,
      targetTop = _target$getBoundingCl.top,
      targetRight = _target$getBoundingCl.right,
      targetBottom = _target$getBoundingCl.bottom,
      targetLeft = _target$getBoundingCl.left;

  var targetBlock = block === 'start' || block === 'nearest' ? targetTop : block === 'end' ? targetBottom : targetTop + targetHeight / 2;
  var targetInline = inline === 'center' ? targetLeft + targetWidth / 2 : inline === 'end' ? targetRight : targetLeft;
  var computations = [];

  for (var index = 0; index < frames.length; index++) {
    var frame = frames[index];

    var _frame$getBoundingCli = frame.getBoundingClientRect(),
        height = _frame$getBoundingCli.height,
        width = _frame$getBoundingCli.width,
        top = _frame$getBoundingCli.top,
        right = _frame$getBoundingCli.right,
        bottom = _frame$getBoundingCli.bottom,
        left = _frame$getBoundingCli.left;

    if (scrollMode === 'if-needed' && targetTop >= 0 && targetLeft >= 0 && targetBottom <= viewportHeight && targetRight <= viewportWidth && targetTop >= top && targetBottom <= bottom && targetLeft >= left && targetRight <= right) {
      return computations;
    }

    var frameStyle = getComputedStyle(frame);
    var borderLeft = parseInt(frameStyle.borderLeftWidth, 10);
    var borderTop = parseInt(frameStyle.borderTopWidth, 10);
    var borderRight = parseInt(frameStyle.borderRightWidth, 10);
    var borderBottom = parseInt(frameStyle.borderBottomWidth, 10);
    var blockScroll = 0;
    var inlineScroll = 0;
    var scrollbarWidth = 'offsetWidth' in frame ? frame.offsetWidth - frame.clientWidth - borderLeft - borderRight : 0;
    var scrollbarHeight = 'offsetHeight' in frame ? frame.offsetHeight - frame.clientHeight - borderTop - borderBottom : 0;

    if (scrollingElement === frame) {
      if (block === 'start') {
        blockScroll = targetBlock;
      } else if (block === 'end') {
        blockScroll = targetBlock - viewportHeight;
      } else if (block === 'nearest') {
        blockScroll = alignNearest(viewportY, viewportY + viewportHeight, viewportHeight, borderTop, borderBottom, viewportY + targetBlock, viewportY + targetBlock + targetHeight, targetHeight);
      } else {
        blockScroll = targetBlock - viewportHeight / 2;
      }

      if (inline === 'start') {
        inlineScroll = targetInline;
      } else if (inline === 'center') {
        inlineScroll = targetInline - viewportWidth / 2;
      } else if (inline === 'end') {
        inlineScroll = targetInline - viewportWidth;
      } else {
        inlineScroll = alignNearest(viewportX, viewportX + viewportWidth, viewportWidth, borderLeft, borderRight, viewportX + targetInline, viewportX + targetInline + targetWidth, targetWidth);
      }

      blockScroll = Math.max(0, blockScroll + viewportY);
      inlineScroll = Math.max(0, inlineScroll + viewportX);
    } else {
      if (block === 'start') {
        blockScroll = targetBlock - top - borderTop;
      } else if (block === 'end') {
        blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight;
      } else if (block === 'nearest') {
        blockScroll = alignNearest(top, bottom, height, borderTop, borderBottom + scrollbarHeight, targetBlock, targetBlock + targetHeight, targetHeight);
      } else {
        blockScroll = targetBlock - (top + height / 2) + scrollbarHeight / 2;
      }

      if (inline === 'start') {
        inlineScroll = targetInline - left - borderLeft;
      } else if (inline === 'center') {
        inlineScroll = targetInline - (left + width / 2) + scrollbarWidth / 2;
      } else if (inline === 'end') {
        inlineScroll = targetInline - right + borderRight + scrollbarWidth;
      } else {
        inlineScroll = alignNearest(left, right, width, borderLeft, borderRight + scrollbarWidth, targetInline, targetInline + targetWidth, targetWidth);
      }

      var scrollLeft = frame.scrollLeft,
          scrollTop = frame.scrollTop;
      blockScroll = Math.max(0, Math.min(scrollTop + blockScroll, frame.scrollHeight - height + scrollbarHeight));
      inlineScroll = Math.max(0, Math.min(scrollLeft + inlineScroll, frame.scrollWidth - width + scrollbarWidth));
      targetBlock += scrollTop - blockScroll;
      targetInline += scrollLeft - inlineScroll;
    }

    computations.push({
      el: frame,
      top: blockScroll,
      left: inlineScroll
    });
  }

  return computations;
});

/***/ }),

/***/ "../node_modules/direction/index.js":
/*!******************************************!*\
  !*** ../node_modules/direction/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = direction

var RTL = '\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC'
var LTR =
  'A-Za-z\u00C0-\u00D6\u00D8-\u00F6' +
  '\u00F8-\u02B8\u0300-\u0590\u0800-\u1FFF\u200E\u2C00-\uFB1C' +
  '\uFE00-\uFE6F\uFEFD-\uFFFF'

var rtl = new RegExp('^[^' + LTR + ']*[' + RTL + ']')
var ltr = new RegExp('^[^' + RTL + ']*[' + LTR + ']')

function direction(value) {
  value = String(value || '')

  if (rtl.test(value)) {
    return 'rtl'
  }

  if (ltr.test(value)) {
    return 'ltr'
  }

  return 'neutral'
}


/***/ }),

/***/ "../node_modules/esrever/esrever.js":
/*!******************************************!*\
  !*** ../node_modules/esrever/esrever.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/esrever v0.2.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports =  true && exports;

	// Detect free variable `module`
	var freeModule =  true && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var regexSymbolWithCombiningMarks = /([\0-\u02FF\u0370-\u1AAF\u1B00-\u1DBF\u1E00-\u20CF\u2100-\uD7FF\uE000-\uFE1F\uFE30-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])([\u0300-\u036F\u1AB0-\u1AFF\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]+)/g;
	var regexSurrogatePair = /([\uD800-\uDBFF])([\uDC00-\uDFFF])/g;

	var reverse = function(string) {
		// Step 1: deal with combining marks and astral symbols (surrogate pairs)
		string = string
			// Swap symbols with their combining marks so the combining marks go first
			.replace(regexSymbolWithCombiningMarks, function($0, $1, $2) {
				// Reverse the combining marks so they will end up in the same order
				// later on (after another round of reversing)
				return reverse($2) + $1;
			})
			// Swap high and low surrogates so the low surrogates go first
			.replace(regexSurrogatePair, '$2$1');
		// Step 2: reverse the code units in the string
		var result = '';
		var index = string.length;
		while (index--) {
			result += string.charAt(index);
		}
		return result;
	};

	/*--------------------------------------------------------------------------*/

	var esrever = {
		'version': '0.2.0',
		'reverse': reverse
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return esrever;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}	else { var key; }

}(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "../node_modules/webpack/buildin/module.js")(module), __webpack_require__(/*! ./../webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/immer/dist/immer.module.js":
/*!**************************************************!*\
  !*** ../node_modules/immer/dist/immer.module.js ***!
  \**************************************************/
/*! exports provided: default, Immer, applyPatches, castDraft, castImmutable, createDraft, finishDraft, immerable, isDraft, isDraftable, nothing, original, produce, produceWithPatches, setAutoFreeze, setUseProxies */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Immer", function() { return Immer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyPatches", function() { return applyPatches$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "castDraft", function() { return castDraft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "castImmutable", function() { return castImmutable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createDraft", function() { return createDraft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "finishDraft", function() { return finishDraft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "immerable", function() { return DRAFTABLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDraft", function() { return isDraft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDraftable", function() { return isDraftable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nothing", function() { return NOTHING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "original", function() { return original; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "produce", function() { return produce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "produceWithPatches", function() { return produceWithPatches; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAutoFreeze", function() { return setAutoFreeze; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setUseProxies", function() { return setUseProxies; });
// Should be no imports here!
var _a; // SOme things that should be evaluated before all else...


var hasSymbol = typeof Symbol !== "undefined";
var hasMap = typeof Map !== "undefined";
var hasSet = typeof Set !== "undefined";
/**
 * The sentinel value returned by producers to replace the draft with undefined.
 */

var NOTHING = hasSymbol ? Symbol("immer-nothing") : (_a = {}, _a["immer-nothing"] = true, _a);
/**
 * To let Immer treat your class instances as plain immutable objects
 * (albeit with a custom prototype), you must define either an instance property
 * or a static property on each of your custom classes.
 *
 * Otherwise, your class instance will never be drafted, which means it won't be
 * safe to mutate in a produce callback.
 */

var DRAFTABLE = hasSymbol ? Symbol("immer-draftable") : "__$immer_draftable";
var DRAFT_STATE = hasSymbol ? Symbol("immer-state") : "__$immer_state";
var iteratorSymbol = hasSymbol ? Symbol.iterator : "@@iterator";

/* istanbul ignore next */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) { if (b.hasOwnProperty(p)) { d[p] = b[p]; } }
  };

  return extendStatics(d, b);
}; // Ugly hack to resolve #502 and inherit built in Map / Set


function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = ( // @ts-ignore
  __.prototype = b.prototype, new __());
}

var Archtype;

(function (Archtype) {
  Archtype[Archtype["Object"] = 0] = "Object";
  Archtype[Archtype["Array"] = 1] = "Array";
  Archtype[Archtype["Map"] = 2] = "Map";
  Archtype[Archtype["Set"] = 3] = "Set";
})(Archtype || (Archtype = {}));

var ProxyType;

(function (ProxyType) {
  ProxyType[ProxyType["ProxyObject"] = 0] = "ProxyObject";
  ProxyType[ProxyType["ProxyArray"] = 1] = "ProxyArray";
  ProxyType[ProxyType["ES5Object"] = 2] = "ES5Object";
  ProxyType[ProxyType["ES5Array"] = 3] = "ES5Array";
  ProxyType[ProxyType["Map"] = 4] = "Map";
  ProxyType[ProxyType["Set"] = 5] = "Set";
})(ProxyType || (ProxyType = {}));

/** Returns true if the given value is an Immer draft */

function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
/** Returns true if the given value can be drafted by Immer */

function isDraftable(value) {
  if (!value) { return false; }
  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE] || isMap(value) || isSet(value);
}
function isPlainObject(value) {
  if (!value || typeof value !== "object") { return false; }
  var proto = Object.getPrototypeOf(value);
  return !proto || proto === Object.prototype;
}
function original(value) {
  if (value && value[DRAFT_STATE]) {
    return value[DRAFT_STATE].base;
  } // otherwise return undefined

}
var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== "undefined" ? function (obj) {
  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
} :
/* istanbul ignore next */
Object.getOwnPropertyNames;
function each(obj, iter) {
  if (getArchtype(obj) === Archtype.Object) {
    ownKeys(obj).forEach(function (key) {
      return iter(key, obj[key], obj);
    });
  } else {
    obj.forEach(function (entry, index) {
      return iter(index, entry, obj);
    });
  }
}
function isEnumerable(base, prop) {
  var desc = Object.getOwnPropertyDescriptor(base, prop);
  return desc && desc.enumerable ? true : false;
}
function getArchtype(thing) {
  /* istanbul ignore next */
  if (!thing) { die(); }

  if (thing[DRAFT_STATE]) {
    switch (thing[DRAFT_STATE].type) {
      case ProxyType.ES5Object:
      case ProxyType.ProxyObject:
        return Archtype.Object;

      case ProxyType.ES5Array:
      case ProxyType.ProxyArray:
        return Archtype.Array;

      case ProxyType.Map:
        return Archtype.Map;

      case ProxyType.Set:
        return Archtype.Set;
    }
  }

  return Array.isArray(thing) ? Archtype.Array : isMap(thing) ? Archtype.Map : isSet(thing) ? Archtype.Set : Archtype.Object;
}
function has(thing, prop) {
  return getArchtype(thing) === Archtype.Map ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function get(thing, prop) {
  // @ts-ignore
  return getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop];
}
function set(thing, propOrOldValue, value) {
  switch (getArchtype(thing)) {
    case Archtype.Map:
      thing.set(propOrOldValue, value);
      break;

    case Archtype.Set:
      thing.delete(propOrOldValue);
      thing.add(value);
      break;

    default:
      thing[propOrOldValue] = value;
  }
}
function is(x, y) {
  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function isMap(target) {
  return hasMap && target instanceof Map;
}
function isSet(target) {
  return hasSet && target instanceof Set;
}
function latest(state) {
  return state.copy || state.base;
}
function shallowCopy(base, invokeGetters) {
  if (invokeGetters === void 0) {
    invokeGetters = false;
  }

  if (Array.isArray(base)) { return base.slice(); }
  var clone = Object.create(Object.getPrototypeOf(base));
  ownKeys(base).forEach(function (key) {
    if (key === DRAFT_STATE) {
      return; // Never copy over draft state.
    }

    var desc = Object.getOwnPropertyDescriptor(base, key);
    var value = desc.value;

    if (desc.get) {
      if (!invokeGetters) {
        throw new Error("Immer drafts cannot have computed properties");
      }

      value = desc.get.call(base);
    }

    if (desc.enumerable) {
      clone[key] = value;
    } else {
      Object.defineProperty(clone, key, {
        value: value,
        writable: true,
        configurable: true
      });
    }
  });
  return clone;
}
function freeze(obj, deep) {
  if (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) { return; }
  var type = getArchtype(obj);

  if (type === Archtype.Set) {
    obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
  } else if (type === Archtype.Map) {
    obj.set = obj.clear = obj.delete = dontMutateFrozenCollections;
  }

  Object.freeze(obj);
  if (deep) { each(obj, function (_, value) {
    return freeze(value, true);
  }); }
}

function dontMutateFrozenCollections() {
  throw new Error("This object has been frozen and should not be mutated");
}

function createHiddenProperty(target, prop, value) {
  Object.defineProperty(target, prop, {
    value: value,
    enumerable: false,
    writable: true
  });
}
/* istanbul ignore next */

function die() {
  throw new Error("Illegal state, please file a bug");
}

/** Each scope represents a `produce` call. */

var ImmerScope =
/** @class */
function () {
  function ImmerScope(parent, immer) {
    this.drafts = [];
    this.parent = parent;
    this.immer = immer; // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.

    this.canAutoFreeze = true;
  }

  ImmerScope.prototype.usePatches = function (patchListener) {
    if (patchListener) {
      this.patches = [];
      this.inversePatches = [];
      this.patchListener = patchListener;
    }
  };

  ImmerScope.prototype.revoke = function () {
    this.leave();
    this.drafts.forEach(revoke); // @ts-ignore

    this.drafts = null;
  };

  ImmerScope.prototype.leave = function () {
    if (this === ImmerScope.current) {
      ImmerScope.current = this.parent;
    }
  };

  ImmerScope.enter = function (immer) {
    var scope = new ImmerScope(ImmerScope.current, immer);
    ImmerScope.current = scope;
    return scope;
  };

  return ImmerScope;
}();

function revoke(draft) {
  var state = draft[DRAFT_STATE];
  if (state.type === ProxyType.ProxyObject || state.type === ProxyType.ProxyArray) { state.revoke(); }else { state.revoked = true; }
}

function processResult(immer, result, scope) {
  var baseDraft = scope.drafts[0];
  var isReplaced = result !== undefined && result !== baseDraft;
  immer.willFinalize(scope, result, isReplaced);

  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified) {
      scope.revoke();
      throw new Error("An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft."); // prettier-ignore
    }

    if (isDraftable(result)) {
      // Finalize the result in case it contains (or is) a subset of the draft.
      result = finalize(immer, result, scope);
      if (!scope.parent) { maybeFreeze(immer, result); }
    }

    if (scope.patches) {
      scope.patches.push({
        op: "replace",
        path: [],
        value: result
      });
      scope.inversePatches.push({
        op: "replace",
        path: [],
        value: baseDraft[DRAFT_STATE].base
      });
    }
  } else {
    // Finalize the base draft.
    result = finalize(immer, baseDraft, scope, []);
  }

  scope.revoke();

  if (scope.patches) {
    scope.patchListener(scope.patches, scope.inversePatches);
  }

  return result !== NOTHING ? result : undefined;
}

function finalize(immer, draft, scope, path) {
  var state = draft[DRAFT_STATE];

  if (!state) {
    if (Object.isFrozen(draft)) { return draft; }
    return finalizeTree(immer, draft, scope);
  } // Never finalize drafts owned by another scope.


  if (state.scope !== scope) {
    return draft;
  }

  if (!state.modified) {
    maybeFreeze(immer, state.base, true);
    return state.base;
  }

  if (!state.finalized) {
    state.finalized = true;
    finalizeTree(immer, state.draft, scope, path); // We cannot really delete anything inside of a Set. We can only replace the whole Set.

    if (immer.onDelete && state.type !== ProxyType.Set) {
      // The `assigned` object is unreliable with ES5 drafts.
      if (immer.useProxies) {
        var assigned = state.assigned;
        each(assigned, function (prop, exists) {
          if (!exists) { immer.onDelete(state, prop); }
        });
      } else {
        var base = state.base,
            copy_1 = state.copy;
        each(base, function (prop) {
          if (!has(copy_1, prop)) { immer.onDelete(state, prop); }
        });
      }
    }

    if (immer.onCopy) {
      immer.onCopy(state);
    } // At this point, all descendants of `state.copy` have been finalized,
    // so we can be sure that `scope.canAutoFreeze` is accurate.


    if (immer.autoFreeze && scope.canAutoFreeze) {
      freeze(state.copy, false);
    }

    if (path && scope.patches) {
      generatePatches(state, path, scope.patches, scope.inversePatches);
    }
  }

  return state.copy;
}

function finalizeTree(immer, root, scope, rootPath) {
  var state = root[DRAFT_STATE];

  if (state) {
    if (state.type === ProxyType.ES5Object || state.type === ProxyType.ES5Array) {
      // Create the final copy, with added keys and without deleted keys.
      state.copy = shallowCopy(state.draft, true);
    }

    root = state.copy;
  }

  each(root, function (key, value) {
    return finalizeProperty(immer, scope, root, state, root, key, value, rootPath);
  });
  return root;
}

function finalizeProperty(immer, scope, root, rootState, parentValue, prop, childValue, rootPath) {
  if (childValue === parentValue) {
    throw Error("Immer forbids circular references");
  } // In the `finalizeTree` method, only the `root` object may be a draft.


  var isDraftProp = !!rootState && parentValue === root;
  var isSetMember = isSet(parentValue);

  if (isDraft(childValue)) {
    var path = rootPath && isDraftProp && !isSetMember && // Set objects are atomic since they have no keys.
    !has(rootState.assigned, prop) // Skip deep patches for assigned keys.
    ? rootPath.concat(prop) : undefined; // Drafts owned by `scope` are finalized here.

    childValue = finalize(immer, childValue, scope, path);
    set(parentValue, prop, childValue); // Drafts from another scope must prevent auto-freezing.

    if (isDraft(childValue)) {
      scope.canAutoFreeze = false;
    }
  } // Unchanged draft properties are ignored.
  else if (isDraftProp && is(childValue, get(rootState.base, prop))) {
      return;
    } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.
    // TODO: the recursion over here looks weird, shouldn't non-draft stuff have it's own recursion?
    // especially the passing on of root and rootState doesn't make sense...
    else if (isDraftable(childValue)) {
        each(childValue, function (key, grandChild) {
          return finalizeProperty(immer, scope, root, rootState, childValue, key, grandChild, rootPath);
        });
        if (!scope.parent) { maybeFreeze(immer, childValue); }
      }

  if (isDraftProp && immer.onAssign && !isSetMember) {
    immer.onAssign(rootState, prop, childValue);
  }
}

function maybeFreeze(immer, value, deep) {
  if (deep === void 0) {
    deep = false;
  }

  if (immer.autoFreeze && !isDraft(value)) {
    freeze(value, deep);
  }
}

/**
 * Returns a new draft of the `base` object.
 *
 * The second argument is the parent draft-state (used internally).
 */

function createProxy(base, parent) {
  var isArray = Array.isArray(base);
  var state = {
    type: isArray ? ProxyType.ProxyArray : ProxyType.ProxyObject,
    // Track which produce call this is associated with.
    scope: parent ? parent.scope : ImmerScope.current,
    // True for both shallow and deep changes.
    modified: false,
    // Used during finalization.
    finalized: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned: {},
    // The parent draft state.
    parent: parent,
    // The base state.
    base: base,
    // The base proxy.
    draft: null,
    // Any property proxies.
    drafts: {},
    // The base copy with any updated values.
    copy: null,
    // Called by the `produce` function.
    revoke: null,
    isManual: false
  }; // the traps must target something, a bit like the 'real' base.
  // but also, we need to be able to determine from the target what the relevant state is
  // (to avoid creating traps per instance to capture the state in closure,
  // and to avoid creating weird hidden properties as well)
  // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)
  // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb

  var target = state;
  var traps = objectTraps;

  if (isArray) {
    target = [state];
    traps = arrayTraps;
  } // TODO: optimization: might be faster, cheaper if we created a non-revocable proxy
  // and administrate revoking ourselves


  var _a = Proxy.revocable(target, traps),
      revoke = _a.revoke,
      proxy = _a.proxy;

  state.draft = proxy;
  state.revoke = revoke;
  return proxy;
}
/**
 * Object drafts
 */

var objectTraps = {
  get: function (state, prop) {
    if (prop === DRAFT_STATE) { return state; }
    var drafts = state.drafts; // Check for existing draft in unmodified state.

    if (!state.modified && has(drafts, prop)) {
      return drafts[prop];
    }

    var value = latest(state)[prop];

    if (state.finalized || !isDraftable(value)) {
      return value;
    } // Check for existing draft in modified state.


    if (state.modified) {
      // Assigned values are never drafted. This catches any drafts we created, too.
      if (value !== peek(state.base, prop)) { return value; } // Store drafts on the copy (when one exists).
      // @ts-ignore

      drafts = state.copy;
    }

    return drafts[prop] = state.scope.immer.createProxy(value, state);
  },
  has: function (state, prop) {
    return prop in latest(state);
  },
  ownKeys: function (state) {
    return Reflect.ownKeys(latest(state));
  },
  set: function (state, prop
  /* strictly not, but helps TS */
  , value) {
    if (!state.modified) {
      var baseValue = peek(state.base, prop); // Optimize based on value's truthiness. Truthy values are guaranteed to
      // never be undefined, so we can avoid the `in` operator. Lastly, truthy
      // values may be drafts, but falsy values are never drafts.

      var isUnchanged = value ? is(baseValue, value) || value === state.drafts[prop] : is(baseValue, value) && prop in state.base;
      if (isUnchanged) { return true; }
      prepareCopy(state);
      markChanged(state);
    }

    state.assigned[prop] = true; // @ts-ignore

    state.copy[prop] = value;
    return true;
  },
  deleteProperty: function (state, prop) {
    // The `undefined` check is a fast path for pre-existing keys.
    if (peek(state.base, prop) !== undefined || prop in state.base) {
      state.assigned[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else if (state.assigned[prop]) {
      // if an originally not assigned property was deleted
      delete state.assigned[prop];
    } // @ts-ignore


    if (state.copy) { delete state.copy[prop]; }
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor: function (state, prop) {
    var owner = latest(state);
    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);

    if (desc) {
      desc.writable = true;
      desc.configurable = state.type !== ProxyType.ProxyArray || prop !== "length";
    }

    return desc;
  },
  defineProperty: function () {
    throw new Error("Object.defineProperty() cannot be used on an Immer draft"); // prettier-ignore
  },
  getPrototypeOf: function (state) {
    return Object.getPrototypeOf(state.base);
  },
  setPrototypeOf: function () {
    throw new Error("Object.setPrototypeOf() cannot be used on an Immer draft"); // prettier-ignore
  }
};
/**
 * Array drafts
 */

var arrayTraps = {};
each(objectTraps, function (key, fn) {
  // @ts-ignore
  arrayTraps[key] = function () {
    arguments[0] = arguments[0][0];
    return fn.apply(this, arguments);
  };
});

arrayTraps.deleteProperty = function (state, prop) {
  if (isNaN(parseInt(prop))) {
    throw new Error("Immer only supports deleting array indices"); // prettier-ignore
  }

  return objectTraps.deleteProperty.call(this, state[0], prop);
};

arrayTraps.set = function (state, prop, value) {
  if (prop !== "length" && isNaN(parseInt(prop))) {
    throw new Error("Immer only supports setting array indices and the 'length' property"); // prettier-ignore
  }

  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
/**
 * Map drafts
 */
// Access a property without creating an Immer draft.


function peek(draft, prop) {
  var state = draft[DRAFT_STATE];
  var desc = Reflect.getOwnPropertyDescriptor(state ? latest(state) : draft, prop);
  return desc && desc.value;
}

function markChanged(state) {
  if (!state.modified) {
    state.modified = true;

    if (state.type === ProxyType.ProxyObject || state.type === ProxyType.ProxyArray) {
      var copy_1 = state.copy = shallowCopy(state.base);
      each(state.drafts, function (key, value) {
        // @ts-ignore
        copy_1[key] = value;
      });
      state.drafts = undefined;
    }

    if (state.parent) {
      markChanged(state.parent);
    }
  }
}

function prepareCopy(state) {
  if (!state.copy) {
    state.copy = shallowCopy(state.base);
  }
}

function willFinalizeES5(scope, result, isReplaced) {
  scope.drafts.forEach(function (draft) {
    draft[DRAFT_STATE].finalizing = true;
  });

  if (!isReplaced) {
    if (scope.patches) {
      markChangesRecursively(scope.drafts[0]);
    } // This is faster when we don't care about which attributes changed.


    markChangesSweep(scope.drafts);
  } // When a child draft is returned, look for changes.
  else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {
      markChangesSweep(scope.drafts);
    }
}
function createES5Proxy(base, parent) {
  var isArray = Array.isArray(base);
  var draft = clonePotentialDraft(base);
  each(draft, function (prop) {
    proxyProperty(draft, prop, isArray || isEnumerable(base, prop));
  });
  var state = {
    type: isArray ? ProxyType.ES5Array : ProxyType.ES5Object,
    scope: parent ? parent.scope : ImmerScope.current,
    modified: false,
    finalizing: false,
    finalized: false,
    assigned: {},
    parent: parent,
    base: base,
    draft: draft,
    copy: null,
    revoked: false,
    isManual: false
  };
  createHiddenProperty(draft, DRAFT_STATE, state);
  return draft;
} // Access a property without creating an Immer draft.

function peek$1(draft, prop) {
  var state = draft[DRAFT_STATE];

  if (state && !state.finalizing) {
    state.finalizing = true;
    var value = draft[prop];
    state.finalizing = false;
    return value;
  }

  return draft[prop];
}

function get$1(state, prop) {
  assertUnrevoked(state);
  var value = peek$1(latest(state), prop);
  if (state.finalizing) { return value; } // Create a draft if the value is unmodified.

  if (value === peek$1(state.base, prop) && isDraftable(value)) {
    prepareCopy$1(state); // @ts-ignore

    return state.copy[prop] = state.scope.immer.createProxy(value, state);
  }

  return value;
}

function set$1(state, prop, value) {
  assertUnrevoked(state);
  state.assigned[prop] = true;

  if (!state.modified) {
    if (is(value, peek$1(latest(state), prop))) { return; }
    markChangedES5(state);
    prepareCopy$1(state);
  } // @ts-ignore


  state.copy[prop] = value;
}

function markChangedES5(state) {
  if (!state.modified) {
    state.modified = true;
    if (state.parent) { markChangedES5(state.parent); }
  }
}

function prepareCopy$1(state) {
  if (!state.copy) { state.copy = clonePotentialDraft(state.base); }
}

function clonePotentialDraft(base) {
  var state = base && base[DRAFT_STATE];

  if (state) {
    state.finalizing = true;
    var draft = shallowCopy(state.draft, true);
    state.finalizing = false;
    return draft;
  }

  return shallowCopy(base);
} // property descriptors are recycled to make sure we don't create a get and set closure per property,
// but share them all instead


var descriptors = {};

function proxyProperty(draft, prop, enumerable) {
  var desc = descriptors[prop];

  if (desc) {
    desc.enumerable = enumerable;
  } else {
    descriptors[prop] = desc = {
      configurable: true,
      enumerable: enumerable,
      get: function () {
        return get$1(this[DRAFT_STATE], prop);
      },
      set: function (value) {
        set$1(this[DRAFT_STATE], prop, value);
      }
    };
  }

  Object.defineProperty(draft, prop, desc);
}

function assertUnrevoked(state) {
  if (state.revoked === true) { throw new Error("Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + JSON.stringify(latest(state))); }
} // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.

function markChangesSweep(drafts) {
  // The natural order of drafts in the `scope` array is based on when they
  // were accessed. By processing drafts in reverse natural order, we have a
  // better chance of processing leaf nodes first. When a leaf node is known to
  // have changed, we can avoid any traversal of its ancestor nodes.
  for (var i = drafts.length - 1; i >= 0; i--) {
    var state = drafts[i][DRAFT_STATE];

    if (!state.modified) {
      switch (state.type) {
        case ProxyType.ES5Array:
          if (hasArrayChanges(state)) { markChangedES5(state); }
          break;

        case ProxyType.ES5Object:
          if (hasObjectChanges(state)) { markChangedES5(state); }
          break;
      }
    }
  }
}

function markChangesRecursively(object) {
  if (!object || typeof object !== "object") { return; }
  var state = object[DRAFT_STATE];
  if (!state) { return; }
  var base = state.base,
      draft = state.draft,
      assigned = state.assigned,
      type = state.type;

  if (type === ProxyType.ES5Object) {
    // Look for added keys.
    // TODO: looks quite duplicate to hasObjectChanges,
    // probably there is a faster way to detect changes, as sweep + recurse seems to do some
    // unnecessary work.
    // also: probably we can store the information we detect here, to speed up tree finalization!
    each(draft, function (key) {
      if (key === DRAFT_STATE) { return; } // The `undefined` check is a fast path for pre-existing keys.

      if (base[key] === undefined && !has(base, key)) {
        assigned[key] = true;
        markChangedES5(state);
      } else if (!assigned[key]) {
        // Only untouched properties trigger recursion.
        markChangesRecursively(draft[key]);
      }
    }); // Look for removed keys.

    each(base, function (key) {
      // The `undefined` check is a fast path for pre-existing keys.
      if (draft[key] === undefined && !has(draft, key)) {
        assigned[key] = false;
        markChangedES5(state);
      }
    });
  } else if (type === ProxyType.ES5Array) {
    if (hasArrayChanges(state)) {
      markChangedES5(state);
      assigned.length = true;
    }

    if (draft.length < base.length) {
      for (var i = draft.length; i < base.length; i++) { assigned[i] = false; }
    } else {
      for (var i = base.length; i < draft.length; i++) { assigned[i] = true; }
    } // Minimum count is enough, the other parts has been processed.


    var min = Math.min(draft.length, base.length);

    for (var i = 0; i < min; i++) {
      // Only untouched indices trigger recursion.
      if (assigned[i] === undefined) { markChangesRecursively(draft[i]); }
    }
  }
}

function hasObjectChanges(state) {
  var base = state.base,
      draft = state.draft; // Search for added keys and changed keys. Start at the back, because
  // non-numeric keys are ordered by time of definition on the object.

  var keys = Object.keys(draft);

  for (var i = keys.length - 1; i >= 0; i--) {
    var key = keys[i];
    var baseValue = base[key]; // The `undefined` check is a fast path for pre-existing keys.

    if (baseValue === undefined && !has(base, key)) {
      return true;
    } // Once a base key is deleted, future changes go undetected, because its
    // descriptor is erased. This branch detects any missed changes.
    else {
        var value = draft[key];
        var state_1 = value && value[DRAFT_STATE];

        if (state_1 ? state_1.base !== baseValue : !is(value, baseValue)) {
          return true;
        }
      }
  } // At this point, no keys were added or changed.
  // Compare key count to determine if keys were deleted.


  return keys.length !== Object.keys(base).length;
}

function hasArrayChanges(state) {
  var draft = state.draft;
  if (draft.length !== state.base.length) { return true; } // See #116
  // If we first shorten the length, our array interceptors will be removed.
  // If after that new items are added, result in the same original length,
  // those last items will have no intercepting property.
  // So if there is no own descriptor on the last position, we know that items were removed and added
  // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check
  // the last one

  var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)

  if (descriptor && !descriptor.get) { return true; } // For all other cases, we don't have to compare, as they would have been picked up by the index setters

  return false;
}

var DraftMap = function (_super) {
  if (!_super) {
    /* istanbul ignore next */
    throw new Error("Map is not polyfilled");
  }

  __extends(DraftMap, _super); // Create class manually, cause #502


  function DraftMap(target, parent) {
    this[DRAFT_STATE] = {
      type: ProxyType.Map,
      parent: parent,
      scope: parent ? parent.scope : ImmerScope.current,
      modified: false,
      finalized: false,
      copy: undefined,
      assigned: undefined,
      base: target,
      draft: this,
      isManual: false,
      revoked: false
    };
    return this;
  }

  var p = DraftMap.prototype; // TODO: smaller build size if we create a util for Object.defineProperty

  Object.defineProperty(p, "size", {
    get: function () {
      return latest(this[DRAFT_STATE]).size;
    },
    enumerable: true,
    configurable: true
  });

  p.has = function (key) {
    return latest(this[DRAFT_STATE]).has(key);
  };

  p.set = function (key, value) {
    var state = this[DRAFT_STATE];
    assertUnrevoked(state);

    if (latest(state).get(key) !== value) {
      prepareCopy$2(state);
      state.scope.immer.markChanged(state);
      state.assigned.set(key, true);
      state.copy.set(key, value);
      state.assigned.set(key, true);
    }

    return this;
  };

  p.delete = function (key) {
    if (!this.has(key)) {
      return false;
    }

    var state = this[DRAFT_STATE];
    assertUnrevoked(state);
    prepareCopy$2(state);
    state.scope.immer.markChanged(state);
    state.assigned.set(key, false);
    state.copy.delete(key);
    return true;
  };

  p.clear = function () {
    var state = this[DRAFT_STATE];
    assertUnrevoked(state);
    prepareCopy$2(state);
    state.scope.immer.markChanged(state);
    state.assigned = new Map();
    return state.copy.clear();
  };

  p.forEach = function (cb, thisArg) {
    var _this = this;

    var state = this[DRAFT_STATE];
    latest(state).forEach(function (_value, key, _map) {
      cb.call(thisArg, _this.get(key), key, _this);
    });
  };

  p.get = function (key) {
    var state = this[DRAFT_STATE];
    assertUnrevoked(state);
    var value = latest(state).get(key);

    if (state.finalized || !isDraftable(value)) {
      return value;
    }

    if (value !== state.base.get(key)) {
      return value; // either already drafted or reassigned
    } // despite what it looks, this creates a draft only once, see above condition


    var draft = state.scope.immer.createProxy(value, state);
    prepareCopy$2(state);
    state.copy.set(key, draft);
    return draft;
  };

  p.keys = function () {
    return latest(this[DRAFT_STATE]).keys();
  };

  p.values = function () {
    var _a;

    var _this = this;

    var iterator = this.keys();
    return _a = {}, _a[iteratorSymbol] = function () {
      return _this.values();
    }, _a.next = function () {
      var r = iterator.next();
      /* istanbul ignore next */

      if (r.done) { return r; }

      var value = _this.get(r.value);

      return {
        done: false,
        value: value
      };
    }, _a;
  };

  p.entries = function () {
    var _a;

    var _this = this;

    var iterator = this.keys();
    return _a = {}, _a[iteratorSymbol] = function () {
      return _this.entries();
    }, _a.next = function () {
      var r = iterator.next();
      /* istanbul ignore next */

      if (r.done) { return r; }

      var value = _this.get(r.value);

      return {
        done: false,
        value: [r.value, value]
      };
    }, _a;
  };

  p[iteratorSymbol] = function () {
    return this.entries();
  };

  return DraftMap;
}(Map);

function proxyMap(target, parent) {
  // @ts-ignore
  return new DraftMap(target, parent);
}

function prepareCopy$2(state) {
  if (!state.copy) {
    state.assigned = new Map();
    state.copy = new Map(state.base);
  }
}

var DraftSet = function (_super) {
  if (!_super) {
    /* istanbul ignore next */
    throw new Error("Set is not polyfilled");
  }

  __extends(DraftSet, _super); // Create class manually, cause #502


  function DraftSet(target, parent) {
    this[DRAFT_STATE] = {
      type: ProxyType.Set,
      parent: parent,
      scope: parent ? parent.scope : ImmerScope.current,
      modified: false,
      finalized: false,
      copy: undefined,
      base: target,
      draft: this,
      drafts: new Map(),
      revoked: false,
      isManual: false
    };
    return this;
  }

  var p = DraftSet.prototype;
  Object.defineProperty(p, "size", {
    get: function () {
      return latest(this[DRAFT_STATE]).size;
    },
    enumerable: true,
    configurable: true
  });

  p.has = function (value) {
    var state = this[DRAFT_STATE];
    assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value

    if (!state.copy) {
      return state.base.has(value);
    }

    if (state.copy.has(value)) { return true; }
    if (state.drafts.has(value) && state.copy.has(state.drafts.get(value))) { return true; }
    return false;
  };

  p.add = function (value) {
    var state = this[DRAFT_STATE];
    assertUnrevoked(state);

    if (state.copy) {
      state.copy.add(value);
    } else if (!state.base.has(value)) {
      prepareCopy$3(state);
      state.scope.immer.markChanged(state);
      state.copy.add(value);
    }

    return this;
  };

  p.delete = function (value) {
    if (!this.has(value)) {
      return false;
    }

    var state = this[DRAFT_STATE];
    assertUnrevoked(state);
    prepareCopy$3(state);
    state.scope.immer.markChanged(state);
    return state.copy.delete(value) || (state.drafts.has(value) ? state.copy.delete(state.drafts.get(value)) :
    /* istanbul ignore next */
    false);
  };

  p.clear = function () {
    var state = this[DRAFT_STATE];
    assertUnrevoked(state);
    prepareCopy$3(state);
    state.scope.immer.markChanged(state);
    return state.copy.clear();
  };

  p.values = function () {
    var state = this[DRAFT_STATE];
    assertUnrevoked(state);
    prepareCopy$3(state);
    return state.copy.values();
  };

  p.entries = function entries() {
    var state = this[DRAFT_STATE];
    assertUnrevoked(state);
    prepareCopy$3(state);
    return state.copy.entries();
  };

  p.keys = function () {
    return this.values();
  };

  p[iteratorSymbol] = function () {
    return this.values();
  };

  p.forEach = function forEach(cb, thisArg) {
    var iterator = this.values();
    var result = iterator.next();

    while (!result.done) {
      cb.call(thisArg, result.value, result.value, this);
      result = iterator.next();
    }
  };

  return DraftSet;
}(Set);

function proxySet(target, parent) {
  // @ts-ignore
  return new DraftSet(target, parent);
}

function prepareCopy$3(state) {
  if (!state.copy) {
    // create drafts for all entries to preserve insertion order
    state.copy = new Set();
    state.base.forEach(function (value) {
      if (isDraftable(value)) {
        var draft = state.scope.immer.createProxy(value, state);
        state.drafts.set(value, draft);
        state.copy.add(draft);
      } else {
        state.copy.add(value);
      }
    });
  }
}

function generatePatches(state, basePath, patches, inversePatches) {
  switch (state.type) {
    case ProxyType.ProxyObject:
    case ProxyType.ES5Object:
    case ProxyType.Map:
      return generatePatchesFromAssigned(state, basePath, patches, inversePatches);

    case ProxyType.ES5Array:
    case ProxyType.ProxyArray:
      return generateArrayPatches(state, basePath, patches, inversePatches);

    case ProxyType.Set:
      return generateSetPatches(state, basePath, patches, inversePatches);
  }
}

function generateArrayPatches(state, basePath, patches, inversePatches) {
  var _a, _b;

  var base = state.base,
      assigned = state.assigned,
      copy = state.copy;
  /* istanbul ignore next */

  if (!copy) { die(); } // Reduce complexity by ensuring `base` is never longer.

  if (copy.length < base.length) {
    _a = [copy, base], base = _a[0], copy = _a[1];
    _b = [inversePatches, patches], patches = _b[0], inversePatches = _b[1];
  }

  var delta = copy.length - base.length; // Find the first replaced index.

  var start = 0;

  while (base[start] === copy[start] && start < base.length) {
    ++start;
  } // Find the last replaced index. Search from the end to optimize splice patches.


  var end = base.length;

  while (end > start && base[end - 1] === copy[end + delta - 1]) {
    --end;
  } // Process replaced indices.


  for (var i = start; i < end; ++i) {
    if (assigned[i] && copy[i] !== base[i]) {
      var path = basePath.concat([i]);
      patches.push({
        op: "replace",
        path: path,
        value: copy[i]
      });
      inversePatches.push({
        op: "replace",
        path: path,
        value: base[i]
      });
    }
  }

  var replaceCount = patches.length; // Process added indices.

  for (var i = end + delta - 1; i >= end; --i) {
    var path = basePath.concat([i]);
    patches[replaceCount + i - end] = {
      op: "add",
      path: path,
      value: copy[i]
    };
    inversePatches.push({
      op: "remove",
      path: path
    });
  }
} // This is used for both Map objects and normal objects.


function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
  var base = state.base,
      copy = state.copy;
  each(state.assigned, function (key, assignedValue) {
    var origValue = get(base, key);
    var value = get(copy, key);
    var op = !assignedValue ? "remove" : has(base, key) ? "replace" : "add";
    if (origValue === value && op === "replace") { return; }
    var path = basePath.concat(key);
    patches.push(op === "remove" ? {
      op: op,
      path: path
    } : {
      op: op,
      path: path,
      value: value
    });
    inversePatches.push(op === "add" ? {
      op: "remove",
      path: path
    } : op === "remove" ? {
      op: "add",
      path: path,
      value: origValue
    } : {
      op: "replace",
      path: path,
      value: origValue
    });
  });
}

function generateSetPatches(state, basePath, patches, inversePatches) {
  var base = state.base,
      copy = state.copy;
  var i = 0;
  base.forEach(function (value) {
    if (!copy.has(value)) {
      var path = basePath.concat([i]);
      patches.push({
        op: "remove",
        path: path,
        value: value
      });
      inversePatches.unshift({
        op: "add",
        path: path,
        value: value
      });
    }

    i++;
  });
  i = 0;
  copy.forEach(function (value) {
    if (!base.has(value)) {
      var path = basePath.concat([i]);
      patches.push({
        op: "add",
        path: path,
        value: value
      });
      inversePatches.unshift({
        op: "remove",
        path: path,
        value: value
      });
    }

    i++;
  });
}

function applyPatches(draft, patches) {
  patches.forEach(function (patch) {
    var path = patch.path,
        op = patch.op;
    /* istanbul ignore next */

    if (!path.length) { die(); }
    var base = draft;

    for (var i = 0; i < path.length - 1; i++) {
      base = get(base, path[i]);
      if (!base || typeof base !== "object") { throw new Error("Cannot apply patch, path doesn't resolve: " + path.join("/")); } // prettier-ignore
    }

    var type = getArchtype(base);
    var value = deepClonePatchValue(patch.value); // used to clone patch to ensure original patch is not modified, see #411

    var key = path[path.length - 1];

    switch (op) {
      case "replace":
        switch (type) {
          case Archtype.Map:
            return base.set(key, value);

          /* istanbul ignore next */

          case Archtype.Set:
            throw new Error('Sets cannot have "replace" patches.');

          default:
            // if value is an object, then it's assigned by reference
            // in the following add or remove ops, the value field inside the patch will also be modifyed
            // so we use value from the cloned patch
            // @ts-ignore
            return base[key] = value;
        }

      case "add":
        switch (type) {
          case Archtype.Array:
            return base.splice(key, 0, value);

          case Archtype.Map:
            return base.set(key, value);

          case Archtype.Set:
            return base.add(value);

          default:
            return base[key] = value;
        }

      case "remove":
        switch (type) {
          case Archtype.Array:
            return base.splice(key, 1);

          case Archtype.Map:
            return base.delete(key);

          case Archtype.Set:
            return base.delete(patch.value);

          default:
            return delete base[key];
        }

      default:
        throw new Error("Unsupported patch operation: " + op);
    }
  });
  return draft;
}

function deepClonePatchValue(obj) {
  if (!obj || typeof obj !== "object") { return obj; }
  if (Array.isArray(obj)) { return obj.map(deepClonePatchValue); }
  if (isMap(obj)) { return new Map(Array.from(obj.entries()).map(function (_a) {
    var k = _a[0],
        v = _a[1];
    return [k, deepClonePatchValue(v)];
  })); }
  if (isSet(obj)) { return new Set(Array.from(obj).map(deepClonePatchValue)); }
  var cloned = Object.create(Object.getPrototypeOf(obj));

  for (var key in obj) { cloned[key] = deepClonePatchValue(obj[key]); }

  return cloned;
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

/* istanbul ignore next */

function verifyMinified() {}

var configDefaults = {
  useProxies: typeof Proxy !== "undefined" && typeof Proxy.revocable !== "undefined" && typeof Reflect !== "undefined",
  autoFreeze: typeof process !== "undefined" ? "development" !== "production" :
  /* istanbul ignore next */
  verifyMinified.name === "verifyMinified",
  onAssign: null,
  onDelete: null,
  onCopy: null
};

var Immer =
/** @class */
function () {
  function Immer(config) {
    var _this = this;

    this.useProxies = false;
    this.autoFreeze = false;
    each(configDefaults, function (key, value) {
      var _a, _b; // @ts-ignore


      _this[key] = (_b = (_a = config) === null || _a === void 0 ? void 0 : _a[key], _b !== null && _b !== void 0 ? _b : value);
    });
    this.setUseProxies(this.useProxies);
    this.produce = this.produce.bind(this);
    this.produceWithPatches = this.produceWithPatches.bind(this);
  }
  /**
   * The `produce` function takes a value and a "recipe function" (whose
   * return value often depends on the base state). The recipe function is
   * free to mutate its first argument however it wants. All mutations are
   * only ever applied to a __copy__ of the base state.
   *
   * Pass only a function to create a "curried producer" which relieves you
   * from passing the recipe function every time.
   *
   * Only plain objects and arrays are made mutable. All other objects are
   * considered uncopyable.
   *
   * Note: This function is __bound__ to its `Immer` instance.
   *
   * @param {any} base - the initial state
   * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
   * @param {Function} patchListener - optional function that will be called with all the patches produced here
   * @returns {any} a new state, or the initial state if nothing was modified
   */


  Immer.prototype.produce = function (base, recipe, patchListener) {
    var _this = this; // curried invocation


    if (typeof base === "function" && typeof recipe !== "function") {
      var defaultBase_1 = recipe;
      recipe = base;
      var self_1 = this;
      return function curriedProduce(base) {
        var arguments$1 = arguments;

        var _this = this;

        if (base === void 0) {
          base = defaultBase_1;
        }

        var args = [];

        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments$1[_i];
        }

        return self_1.produce(base, function (draft) {
          return recipe.call.apply(recipe, __spreadArrays([_this, draft], args));
        }); // prettier-ignore
      };
    } // prettier-ignore


    {
      if (typeof recipe !== "function") {
        throw new Error("The first or second argument to `produce` must be a function");
      }

      if (patchListener !== undefined && typeof patchListener !== "function") {
        throw new Error("The third argument to `produce` must be a function or undefined");
      }
    }
    var result; // Only plain objects, arrays, and "immerable classes" are drafted.

    if (isDraftable(base)) {
      var scope_1 = ImmerScope.enter(this);
      var proxy = this.createProxy(base, undefined);
      var hasError = true;

      try {
        result = recipe(proxy);
        hasError = false;
      } finally {
        // finally instead of catch + rethrow better preserves original stack
        if (hasError) { scope_1.revoke(); }else { scope_1.leave(); }
      }

      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then(function (result) {
          scope_1.usePatches(patchListener);
          return processResult(_this, result, scope_1);
        }, function (error) {
          scope_1.revoke();
          throw error;
        });
      }

      scope_1.usePatches(patchListener);
      return processResult(this, result, scope_1);
    } else {
      result = recipe(base);
      if (result === NOTHING) { return undefined; }
      if (result === undefined) { result = base; }
      maybeFreeze(this, result, true);
      return result;
    }
  };

  Immer.prototype.produceWithPatches = function (arg1, arg2, arg3) {
    var _this = this;

    if (typeof arg1 === "function") {
      return function (state) {
        var arguments$1 = arguments;

        var args = [];

        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments$1[_i];
        }

        return _this.produceWithPatches(state, function (draft) {
          return arg1.apply(void 0, __spreadArrays([draft], args));
        });
      };
    } // non-curried form

    /* istanbul ignore next */


    if (arg3) { die(); }
    var patches, inversePatches;
    var nextState = this.produce(arg1, arg2, function (p, ip) {
      patches = p;
      inversePatches = ip;
    });
    return [nextState, patches, inversePatches];
  };

  Immer.prototype.createDraft = function (base) {
    if (!isDraftable(base)) {
      throw new Error("First argument to `createDraft` must be a plain object, an array, or an immerable object"); // prettier-ignore
    }

    var scope = ImmerScope.enter(this);
    var proxy = this.createProxy(base, undefined);
    proxy[DRAFT_STATE].isManual = true;
    scope.leave();
    return proxy;
  };

  Immer.prototype.finishDraft = function (draft, patchListener) {
    var state = draft && draft[DRAFT_STATE];

    if (!state || !state.isManual) {
      throw new Error("First argument to `finishDraft` must be a draft returned by `createDraft`"); // prettier-ignore
    }

    if (state.finalized) {
      throw new Error("The given draft is already finalized"); // prettier-ignore
    }

    var scope = state.scope;
    scope.usePatches(patchListener);
    return processResult(this, undefined, scope);
  };
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is disabled in production.
   */


  Immer.prototype.setAutoFreeze = function (value) {
    this.autoFreeze = value;
  };
  /**
   * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
   * always faster than using ES5 proxies.
   *
   * By default, feature detection is used, so calling this is rarely necessary.
   */


  Immer.prototype.setUseProxies = function (value) {
    this.useProxies = value;
  };

  Immer.prototype.applyPatches = function (base, patches) {
    // If a patch replaces the entire state, take that replacement as base
    // before applying patches
    var i;

    for (i = patches.length - 1; i >= 0; i--) {
      var patch = patches[i];

      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    }

    if (isDraft(base)) {
      // N.B: never hits if some patch a replacement, patches are never drafts
      return applyPatches(base, patches);
    } // Otherwise, produce a copy of the base state.


    return this.produce(base, function (draft) {
      return applyPatches(draft, patches.slice(i + 1));
    });
  };

  Immer.prototype.createProxy = function (value, parent) {
    // precondition: createProxy should be guarded by isDraftable, so we know we can safely draft
    var draft = isMap(value) ? proxyMap(value, parent) : isSet(value) ? proxySet(value, parent) : this.useProxies ? createProxy(value, parent) : createES5Proxy(value, parent);
    var scope = parent ? parent.scope : ImmerScope.current;
    scope.drafts.push(draft);
    return draft;
  };

  Immer.prototype.willFinalize = function (scope, thing, isReplaced) {
    if (!this.useProxies) { willFinalizeES5(scope, thing, isReplaced); }
  };

  Immer.prototype.markChanged = function (state) {
    if (this.useProxies) {
      markChanged(state);
    } else {
      markChangedES5(state);
    }
  };

  return Immer;
}();

var immer = new Immer();
/**
 * The `produce` function takes a value and a "recipe function" (whose
 * return value often depends on the base state). The recipe function is
 * free to mutate its first argument however it wants. All mutations are
 * only ever applied to a __copy__ of the base state.
 *
 * Pass only a function to create a "curried producer" which relieves you
 * from passing the recipe function every time.
 *
 * Only plain objects and arrays are made mutable. All other objects are
 * considered uncopyable.
 *
 * Note: This function is __bound__ to its `Immer` instance.
 *
 * @param {any} base - the initial state
 * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
 * @param {Function} patchListener - optional function that will be called with all the patches produced here
 * @returns {any} a new state, or the initial state if nothing was modified
 */

var produce = immer.produce;
/**
 * Like `produce`, but `produceWithPatches` always returns a tuple
 * [nextState, patches, inversePatches] (instead of just the next state)
 */

var produceWithPatches = immer.produceWithPatches.bind(immer);
/**
 * Pass true to automatically freeze all copies created by Immer.
 *
 * By default, auto-freezing is disabled in production.
 */

var setAutoFreeze = immer.setAutoFreeze.bind(immer);
/**
 * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
 * always faster than using ES5 proxies.
 *
 * By default, feature detection is used, so calling this is rarely necessary.
 */

var setUseProxies = immer.setUseProxies.bind(immer);
/**
 * Apply an array of Immer patches to the first argument.
 *
 * This function is a producer, which means copy-on-write is in effect.
 */

var applyPatches$1 = immer.applyPatches.bind(immer);
/**
 * Create an Immer draft from the given base state, which may be a draft itself.
 * The draft can be modified until you finalize it with the `finishDraft` function.
 */

var createDraft = immer.createDraft.bind(immer);
/**
 * Finalize an Immer draft from a `createDraft` call, returning the base state
 * (if no changes were made) or a modified copy. The draft must *not* be
 * mutated afterwards.
 *
 * Pass a function as the 2nd argument to generate Immer patches based on the
 * changes that were made.
 */

var finishDraft = immer.finishDraft.bind(immer);
/**
 * This function is actually a no-op, but can be used to cast an immutable type
 * to an draft type and make TypeScript happy
 *
 * @param value
 */

function castDraft(value) {
  return value;
}
/**
 * This function is actually a no-op, but can be used to cast a mutable type
 * to an immutable type and make TypeScript happy
 * @param value
 */

function castImmutable(value) {
  return value;
}

/* harmony default export */ __webpack_exports__["default"] = (produce);

//# sourceMappingURL=immer.module.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "../node_modules/process/browser.js")))

/***/ }),

/***/ "../node_modules/is-hotkey/lib/index.js":
/*!**********************************************!*\
  !*** ../node_modules/is-hotkey/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Constants.
 */

var IS_MAC = typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);

var MODIFIERS = {
  alt: 'altKey',
  control: 'ctrlKey',
  meta: 'metaKey',
  shift: 'shiftKey'
};

var ALIASES = {
  add: '+',
  break: 'pause',
  cmd: 'meta',
  command: 'meta',
  ctl: 'control',
  ctrl: 'control',
  del: 'delete',
  down: 'arrowdown',
  esc: 'escape',
  ins: 'insert',
  left: 'arrowleft',
  mod: IS_MAC ? 'meta' : 'control',
  opt: 'alt',
  option: 'alt',
  return: 'enter',
  right: 'arrowright',
  space: ' ',
  spacebar: ' ',
  up: 'arrowup',
  win: 'meta',
  windows: 'meta'
};

var CODES = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  ' ': 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ';': 186,
  '=': 187,
  ',': 188,
  '-': 189,
  '.': 190,
  '/': 191,
  '`': 192,
  '[': 219,
  '\\': 220,
  ']': 221,
  '\'': 222
};

for (var f = 1; f < 20; f++) {
  CODES['f' + f] = 111 + f;
}

/**
 * Is hotkey?
 */

function isHotkey(hotkey, options, event) {
  if (options && !('byKey' in options)) {
    event = options;
    options = null;
  }

  if (!Array.isArray(hotkey)) {
    hotkey = [hotkey];
  }

  var array = hotkey.map(function (string) {
    return parseHotkey(string, options);
  });
  var check = function check(e) {
    return array.some(function (object) {
      return compareHotkey(object, e);
    });
  };
  var ret = event == null ? check : check(event);
  return ret;
}

function isCodeHotkey(hotkey, event) {
  return isHotkey(hotkey, event);
}

function isKeyHotkey(hotkey, event) {
  return isHotkey(hotkey, { byKey: true }, event);
}

/**
 * Parse.
 */

function parseHotkey(hotkey, options) {
  var byKey = options && options.byKey;
  var ret = {};

  // Special case to handle the `+` key since we use it as a separator.
  hotkey = hotkey.replace('++', '+add');
  var values = hotkey.split('+');
  var length = values.length;

  // Ensure that all the modifiers are set to false unless the hotkey has them.

  for (var k in MODIFIERS) {
    ret[MODIFIERS[k]] = false;
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var value = _step.value;

      var optional = value.endsWith('?') && value.length > 1;

      if (optional) {
        value = value.slice(0, -1);
      }

      var name = toKeyName(value);
      var modifier = MODIFIERS[name];

      if (length === 1 || !modifier) {
        if (byKey) {
          ret.key = name;
        } else {
          ret.which = toKeyCode(value);
        }
      }

      if (modifier) {
        ret[modifier] = optional ? null : true;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return ret;
}

/**
 * Compare.
 */

function compareHotkey(object, event) {
  for (var key in object) {
    var expected = object[key];
    var actual = void 0;

    if (expected == null) {
      continue;
    }

    if (key === 'key' && event.key != null) {
      actual = event.key.toLowerCase();
    } else if (key === 'which') {
      actual = expected === 91 && event.which === 93 ? 91 : event.which;
    } else {
      actual = event[key];
    }

    if (actual == null && expected === false) {
      continue;
    }

    if (actual !== expected) {
      return false;
    }
  }

  return true;
}

/**
 * Utils.
 */

function toKeyCode(name) {
  name = toKeyName(name);
  var code = CODES[name] || name.toUpperCase().charCodeAt(0);
  return code;
}

function toKeyName(name) {
  name = name.toLowerCase();
  name = ALIASES[name] || name;
  return name;
}

/**
 * Export.
 */

exports.default = isHotkey;
exports.isHotkey = isHotkey;
exports.isCodeHotkey = isCodeHotkey;
exports.isKeyHotkey = isKeyHotkey;
exports.parseHotkey = parseHotkey;
exports.compareHotkey = compareHotkey;
exports.toKeyCode = toKeyCode;
exports.toKeyName = toKeyName;

/***/ }),

/***/ "../node_modules/lodash/_Symbol.js":
/*!*****************************************!*\
  !*** ../node_modules/lodash/_Symbol.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "../node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ "../node_modules/lodash/_baseGetTag.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_baseGetTag.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "../node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "../node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "../node_modules/lodash/_objectToString.js");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ "../node_modules/lodash/_freeGlobal.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_freeGlobal.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/lodash/_getRawTag.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/_getRawTag.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "../node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ "../node_modules/lodash/_objectToString.js":
/*!*************************************************!*\
  !*** ../node_modules/lodash/_objectToString.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "../node_modules/lodash/_root.js":
/*!***************************************!*\
  !*** ../node_modules/lodash/_root.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "../node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "../node_modules/lodash/debounce.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/debounce.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "../node_modules/lodash/isObject.js"),
    now = __webpack_require__(/*! ./now */ "../node_modules/lodash/now.js"),
    toNumber = __webpack_require__(/*! ./toNumber */ "../node_modules/lodash/toNumber.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;


/***/ }),

/***/ "../node_modules/lodash/isObject.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/isObject.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "../node_modules/lodash/isObjectLike.js":
/*!**********************************************!*\
  !*** ../node_modules/lodash/isObjectLike.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "../node_modules/lodash/isSymbol.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/isSymbol.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "../node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "../node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),

/***/ "../node_modules/lodash/now.js":
/*!*************************************!*\
  !*** ../node_modules/lodash/now.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "../node_modules/lodash/_root.js");

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;


/***/ }),

/***/ "../node_modules/lodash/throttle.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/throttle.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var debounce = __webpack_require__(/*! ./debounce */ "../node_modules/lodash/debounce.js"),
    isObject = __webpack_require__(/*! ./isObject */ "../node_modules/lodash/isObject.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;


/***/ }),

/***/ "../node_modules/lodash/toNumber.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/toNumber.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "../node_modules/lodash/isObject.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "../node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),

/***/ "../node_modules/process/browser.js":
/*!******************************************!*\
  !*** ../node_modules/process/browser.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../node_modules/scroll-into-view-if-needed/es/index.js":
/*!**************************************************************!*\
  !*** ../node_modules/scroll-into-view-if-needed/es/index.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var compute_scroll_into_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! compute-scroll-into-view */ "../node_modules/compute-scroll-into-view/es/index.js");


function isOptionsObject(options) {
  return options === Object(options) && Object.keys(options).length !== 0;
}

function defaultBehavior(actions, behavior) {
  if (behavior === void 0) {
    behavior = 'auto';
  }

  var canSmoothScroll = ('scrollBehavior' in document.body.style);
  actions.forEach(function (_ref) {
    var el = _ref.el,
        top = _ref.top,
        left = _ref.left;

    if (el.scroll && canSmoothScroll) {
      el.scroll({
        top: top,
        left: left,
        behavior: behavior
      });
    } else {
      el.scrollTop = top;
      el.scrollLeft = left;
    }
  });
}

function getOptions(options) {
  if (options === false) {
    return {
      block: 'end',
      inline: 'nearest'
    };
  }

  if (isOptionsObject(options)) {
    return options;
  }

  return {
    block: 'start',
    inline: 'nearest'
  };
}

function scrollIntoView(target, options) {
  var targetIsDetached = !target.ownerDocument.documentElement.contains(target);

  if (isOptionsObject(options) && typeof options.behavior === 'function') {
    return options.behavior(targetIsDetached ? [] : Object(compute_scroll_into_view__WEBPACK_IMPORTED_MODULE_0__["default"])(target, options));
  }

  if (targetIsDetached) {
    return;
  }

  var computeOptions = getOptions(options);
  return defaultBehavior(Object(compute_scroll_into_view__WEBPACK_IMPORTED_MODULE_0__["default"])(target, computeOptions), computeOptions.behavior);
}

/* harmony default export */ __webpack_exports__["default"] = (scrollIntoView);

/***/ }),

/***/ "../node_modules/slate-react/dist/index.es.js":
/*!****************************************************!*\
  !*** ../node_modules/slate-react/dist/index.es.js ***!
  \****************************************************/
/*! exports provided: DefaultElement, DefaultLeaf, Editable, ReactEditor, Slate, useEditor, useFocused, useReadOnly, useSelected, useSlate, withReact */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultElement", function() { return DefaultElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultLeaf", function() { return DefaultLeaf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Editable", function() { return Editable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReactEditor", function() { return ReactEditor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Slate", function() { return Slate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useEditor", function() { return useEditor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useFocused", function() { return useFocused; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useReadOnly", function() { return useReadOnly; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useSelected", function() { return useSelected; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useSlate", function() { return useSlate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withReact", function() { return withReact; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ "../node_modules/slate/dist/index.es.js");
/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/throttle */ "../node_modules/lodash/throttle.js");
/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_throttle__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var scroll_into_view_if_needed__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! scroll-into-view-if-needed */ "../node_modules/scroll-into-view-if-needed/es/index.js");
/* harmony import */ var direction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! direction */ "../node_modules/direction/index.js");
/* harmony import */ var direction__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(direction__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-dom */ "react-dom");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var is_hotkey__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! is-hotkey */ "../node_modules/is-hotkey/lib/index.js");
/* harmony import */ var is_hotkey__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(is_hotkey__WEBPACK_IMPORTED_MODULE_6__);








function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

/**
 * An auto-incrementing identifier for keys.
 */
var n = 0;
/**
 * A class that keeps track of a key string. We use a full class here because we
 * want to be able to use them as keys in `WeakMap` objects.
 */

class Key {
  constructor() {
    this.id = "".concat(n++);
  }

}

/**
 * Two weak maps that allow us rebuild a path given a node. They are populated
 * at render time such that after a render occurs we can always backtrack.
 */
var NODE_TO_INDEX = new WeakMap();
var NODE_TO_PARENT = new WeakMap();
/**
 * Weak maps that allow us to go between Slate nodes and DOM nodes. These
 * are used to resolve DOM event-related logic into Slate actions.
 */

var EDITOR_TO_ELEMENT = new WeakMap();
var ELEMENT_TO_NODE = new WeakMap();
var KEY_TO_ELEMENT = new WeakMap();
var NODE_TO_ELEMENT = new WeakMap();
var NODE_TO_KEY = new WeakMap();
/**
 * Weak maps for storing editor-related state.
 */

var IS_READ_ONLY = new WeakMap();
var IS_FOCUSED = new WeakMap();
/**
 * Weak map for associating the context `onChange` context with the plugin.
 */

var EDITOR_TO_ON_CHANGE = new WeakMap();
/**
 * Symbols.
 */

var PLACEHOLDER_SYMBOL = Symbol('placeholder');

/**
 * Types.
 */
/**
 * Check if a DOM node is a comment node.
 */

var isDOMComment = value => {
  return isDOMNode(value) && value.nodeType === 8;
};
/**
 * Check if a DOM node is an element node.
 */

var isDOMElement = value => {
  return isDOMNode(value) && value.nodeType === 1;
};
/**
 * Check if a value is a DOM node.
 */

var isDOMNode = value => {
  return value instanceof Node;
};
/**
 * Check if a DOM node is an element node.
 */

var isDOMText = value => {
  return isDOMNode(value) && value.nodeType === 3;
};
/**
 * Checks whether a paste event is a plaintext-only event.
 */

var isPlainTextOnlyPaste = event => {
  return event.clipboardData && event.clipboardData.getData('text/plain') !== '' && event.clipboardData.types.length === 1;
};
/**
 * Normalize a DOM point so that it always refers to a text node.
 */

var normalizeDOMPoint = domPoint => {
  var [node, offset] = domPoint; // If it's an element node, its offset refers to the index of its children
  // including comment nodes, so try to find the right text child node.

  if (isDOMElement(node) && node.childNodes.length) {
    var isLast = offset === node.childNodes.length;
    var direction = isLast ? 'backward' : 'forward';
    var index = isLast ? offset - 1 : offset;
    node = getEditableChild(node, index, direction); // If the node has children, traverse until we have a leaf node. Leaf nodes
    // can be either text nodes, or other void DOM nodes.

    while (isDOMElement(node) && node.childNodes.length) {
      var i = isLast ? node.childNodes.length - 1 : 0;
      node = getEditableChild(node, i, direction);
    } // Determine the new offset inside the text node.


    offset = isLast && node.textContent != null ? node.textContent.length : 0;
  } // Return the node and offset.


  return [node, offset];
};
/**
 * Get the nearest editable child at `index` in a `parent`, preferring
 * `direction`.
 */

var getEditableChild = (parent, index, direction) => {
  var {
    childNodes
  } = parent;
  var child = childNodes[index];
  var i = index;
  var triedForward = false;
  var triedBackward = false; // While the child is a comment node, or an element node with no children,
  // keep iterating to find a sibling non-void, non-comment node.

  while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute('contenteditable') === 'false') {
    if (triedForward && triedBackward) {
      break;
    }

    if (i >= childNodes.length) {
      triedForward = true;
      i = index - 1;
      direction = 'backward';
      continue;
    }

    if (i < 0) {
      triedBackward = true;
      i = index + 1;
      direction = 'forward';
      continue;
    }

    child = childNodes[i];
    i += direction === 'forward' ? 1 : -1;
  }

  return child;
};
/**
 * Get a plaintext representation of the content of a node, accounting for block
 * elements which get a newline appended.
 *
 * The domNode must be attached to the DOM.
 */

var getPlainText = domNode => {
  var text = '';

  if (isDOMText(domNode) && domNode.nodeValue) {
    return domNode.nodeValue;
  }

  if (isDOMElement(domNode)) {
    for (var childNode of Array.from(domNode.childNodes)) {
      text += getPlainText(childNode);
    }

    var display = getComputedStyle(domNode).getPropertyValue('display');

    if (display === 'block' || display === 'list' || domNode.tagName === 'BR') {
      text += '\n';
    }
  }

  return text;
};

var ReactEditor = {
  /**
   * Find a key for a Slate node.
   */
  findKey(editor, node) {
    var key = NODE_TO_KEY.get(node);

    if (!key) {
      key = new Key();
      NODE_TO_KEY.set(node, key);
    }

    return key;
  },

  /**
   * Find the path of Slate node.
   */
  findPath(editor, node) {
    var path = [];
    var child = node;

    while (true) {
      var parent = NODE_TO_PARENT.get(child);

      if (parent == null) {
        if (slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].isEditor(child)) {
          return path;
        } else {
          break;
        }
      }

      var i = NODE_TO_INDEX.get(child);

      if (i == null) {
        break;
      }

      path.unshift(i);
      child = parent;
    }

    throw new Error("Unable to find the path for Slate node: ".concat(JSON.stringify(node)));
  },

  /**
   * Check if the editor is focused.
   */
  isFocused(editor) {
    return !!IS_FOCUSED.get(editor);
  },

  /**
   * Check if the editor is in read-only mode.
   */
  isReadOnly(editor) {
    return !!IS_READ_ONLY.get(editor);
  },

  /**
   * Blur the editor.
   */
  blur(editor) {
    var el = ReactEditor.toDOMNode(editor, editor);
    IS_FOCUSED.set(editor, false);

    if (window.document.activeElement === el) {
      el.blur();
    }
  },

  /**
   * Focus the editor.
   */
  focus(editor) {
    var el = ReactEditor.toDOMNode(editor, editor);
    IS_FOCUSED.set(editor, true);

    if (window.document.activeElement !== el) {
      el.focus({
        preventScroll: true
      });
    }
  },

  /**
   * Deselect the editor.
   */
  deselect(editor) {
    var {
      selection
    } = editor;
    var domSelection = window.getSelection();

    if (domSelection && domSelection.rangeCount > 0) {
      domSelection.removeAllRanges();
    }

    if (selection) {
      slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].deselect(editor);
    }
  },

  /**
   * Check if a DOM node is within the editor.
   */
  hasDOMNode(editor, target) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      editable = false
    } = options;
    var editorEl = ReactEditor.toDOMNode(editor, editor);
    var targetEl; // COMPAT: In Firefox, reading `target.nodeType` will throw an error if
    // target is originating from an internal "restricted" element (e.g. a
    // stepper arrow on a number input). (2018/05/04)
    // https://github.com/ianstormtaylor/slate/issues/1819

    try {
      targetEl = isDOMElement(target) ? target : target.parentElement;
    } catch (err) {
      if (!err.message.includes('Permission denied to access property "nodeType"')) {
        throw err;
      }
    }

    if (!targetEl) {
      return false;
    }

    return targetEl.closest("[data-slate-editor]") === editorEl && (!editable || targetEl.isContentEditable || !!targetEl.getAttribute('data-slate-zero-width'));
  },

  /**
   * Insert data from a `DataTransfer` into the editor.
   */
  insertData(editor, data) {
    editor.insertData(data);
  },

  /**
   * Sets data from the currently selected fragment on a `DataTransfer`.
   */
  setFragmentData(editor, data) {
    editor.setFragmentData(data);
  },

  /**
   * Find the native DOM element from a Slate node.
   */
  toDOMNode(editor, node) {
    var domNode = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT.get(ReactEditor.findKey(editor, node));

    if (!domNode) {
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(JSON.stringify(node)));
    }

    return domNode;
  },

  /**
   * Find a native DOM selection point from a Slate point.
   */
  toDOMPoint(editor, point) {
    var [node] = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].node(editor, point.path);
    var el = ReactEditor.toDOMNode(editor, node);
    var domPoint; // If we're inside a void node, force the offset to 0, otherwise the zero
    // width spacing character will result in an incorrect offset of 1

    if (slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].void(editor, {
      at: point
    })) {
      point = {
        path: point.path,
        offset: 0
      };
    } // For each leaf, we need to isolate its content, which means filtering
    // to its direct text and zero-width spans. (We have to filter out any
    // other siblings that may have been rendered alongside them.)


    var selector = "[data-slate-string], [data-slate-zero-width]";
    var texts = Array.from(el.querySelectorAll(selector));
    var start = 0;

    for (var text of texts) {
      var domNode = text.childNodes[0];

      if (domNode == null || domNode.textContent == null) {
        continue;
      }

      var {
        length
      } = domNode.textContent;
      var attr = text.getAttribute('data-slate-length');
      var trueLength = attr == null ? length : parseInt(attr, 10);
      var end = start + trueLength;

      if (point.offset <= end) {
        var offset = Math.min(length, Math.max(0, point.offset - start));
        domPoint = [domNode, offset];
        break;
      }

      start = end;
    }

    if (!domPoint) {
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(JSON.stringify(point)));
    }

    return domPoint;
  },

  /**
   * Find a native DOM range from a Slate `range`.
   */
  toDOMRange(editor, range) {
    var {
      anchor,
      focus
    } = range;
    var isBackward = slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isBackward(range);
    var domAnchor = ReactEditor.toDOMPoint(editor, anchor);
    var domFocus = slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isCollapsed(range) ? domAnchor : ReactEditor.toDOMPoint(editor, focus);
    var domRange = window.document.createRange();
    var [startNode, startOffset] = isBackward ? domFocus : domAnchor;
    var [endNode, endOffset] = isBackward ? domAnchor : domFocus; // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at
    // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and
    // adjust the offset accordingly.

    var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;
    var isStartAtZeroWidth = !!startEl.getAttribute('data-slate-zero-width');
    var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;
    var isEndAtZeroWidth = !!endEl.getAttribute('data-slate-zero-width');
    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);
    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);
    return domRange;
  },

  /**
   * Find a Slate node from a native DOM `element`.
   */
  toSlateNode(editor, domNode) {
    var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;

    if (domEl && !domEl.hasAttribute('data-slate-node')) {
      domEl = domEl.closest("[data-slate-node]");
    }

    var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;

    if (!node) {
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(domEl));
    }

    return node;
  },

  /**
   * Get the target range from a DOM `event`.
   */
  findEventRange(editor, event) {
    if ('nativeEvent' in event) {
      event = event.nativeEvent;
    }

    var {
      clientX: x,
      clientY: y,
      target
    } = event;

    if (x == null || y == null) {
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(event));
    }

    var node = ReactEditor.toSlateNode(editor, event.target);
    var path = ReactEditor.findPath(editor, node); // If the drop target is inside a void node, move it into either the
    // next or previous node, depending on which side the `x` and `y`
    // coordinates are closest to.

    if (slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].isVoid(editor, node)) {
      var rect = target.getBoundingClientRect();
      var isPrev = editor.isInline(node) ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;
      var edge = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].point(editor, path, {
        edge: isPrev ? 'start' : 'end'
      });
      var point = isPrev ? slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].before(editor, edge) : slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].after(editor, edge);

      if (point) {
        var _range = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].range(editor, point);

        return _range;
      }
    } // Else resolve a range from the caret position where the drop occured.


    var domRange;
    var {
      document
    } = window; // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)

    if (document.caretRangeFromPoint) {
      domRange = document.caretRangeFromPoint(x, y);
    } else {
      var position = document.caretPositionFromPoint(x, y);

      if (position) {
        domRange = document.createRange();
        domRange.setStart(position.offsetNode, position.offset);
        domRange.setEnd(position.offsetNode, position.offset);
      }
    }

    if (!domRange) {
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(event));
    } // Resolve a Slate range from the DOM range.


    var range = ReactEditor.toSlateRange(editor, domRange);
    return range;
  },

  /**
   * Find a Slate point from a DOM selection's `domNode` and `domOffset`.
   */
  toSlatePoint(editor, domPoint) {
    var [nearestNode, nearestOffset] = normalizeDOMPoint(domPoint);
    var parentNode = nearestNode.parentNode;
    var textNode = null;
    var offset = 0;

    if (parentNode) {
      var voidNode = parentNode.closest('[data-slate-void="true"]');
      var leafNode = parentNode.closest('[data-slate-leaf]');
      var domNode = null; // Calculate how far into the text node the `nearestNode` is, so that we
      // can determine what the offset relative to the text node is.

      if (leafNode) {
        textNode = leafNode.closest('[data-slate-node="text"]');
        var range = window.document.createRange();
        range.setStart(textNode, 0);
        range.setEnd(nearestNode, nearestOffset);
        var contents = range.cloneContents();
        var removals = [...contents.querySelectorAll('[data-slate-zero-width]'), ...contents.querySelectorAll('[contenteditable=false]')];
        removals.forEach(el => {
          el.parentNode.removeChild(el);
        }); // COMPAT: Edge has a bug where Range.prototype.toString() will
        // convert \n into \r\n. The bug causes a loop when slate-react
        // attempts to reposition its cursor to match the native position. Use
        // textContent.length instead.
        // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/

        offset = contents.textContent.length;
        domNode = textNode;
      } else if (voidNode) {
        // For void nodes, the element with the offset key will be a cousin, not an
        // ancestor, so find it by going down from the nearest void parent.
        leafNode = voidNode.querySelector('[data-slate-leaf]');
        textNode = leafNode.closest('[data-slate-node="text"]');
        domNode = leafNode;
        offset = domNode.textContent.length;
      } // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.


      if (domNode && offset === domNode.textContent.length && parentNode.hasAttribute('data-slate-zero-width')) {
        offset--;
      }
    }

    if (!textNode) {
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(domPoint));
    } // COMPAT: If someone is clicking from one Slate editor into another,
    // the select event fires twice, once for the old editor's `element`
    // first, and then afterwards for the correct `element`. (2017/03/03)


    var slateNode = ReactEditor.toSlateNode(editor, textNode);
    var path = ReactEditor.findPath(editor, slateNode);
    return {
      path,
      offset
    };
  },

  /**
   * Find a Slate range from a DOM range or selection.
   */
  toSlateRange(editor, domRange) {
    var el = domRange instanceof Selection ? domRange.anchorNode : domRange.startContainer;
    var anchorNode;
    var anchorOffset;
    var focusNode;
    var focusOffset;
    var isCollapsed;

    if (el) {
      if (domRange instanceof Selection) {
        anchorNode = domRange.anchorNode;
        anchorOffset = domRange.anchorOffset;
        focusNode = domRange.focusNode;
        focusOffset = domRange.focusOffset;
        isCollapsed = domRange.isCollapsed;
      } else {
        anchorNode = domRange.startContainer;
        anchorOffset = domRange.startOffset;
        focusNode = domRange.endContainer;
        focusOffset = domRange.endOffset;
        isCollapsed = domRange.collapsed;
      }
    }

    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(domRange));
    }

    var anchor = ReactEditor.toSlatePoint(editor, [anchorNode, anchorOffset]);
    var focus = isCollapsed ? anchor : ReactEditor.toSlatePoint(editor, [focusNode, focusOffset]);
    return {
      anchor,
      focus
    };
  }

};

/**
 * A React context for sharing the `focused` state of the editor.
 */

var FocusedContext = Object(react__WEBPACK_IMPORTED_MODULE_0__["createContext"])(false);
/**
 * Get the current `focused` state of the editor.
 */

var useFocused = () => {
  return Object(react__WEBPACK_IMPORTED_MODULE_0__["useContext"])(FocusedContext);
};

/**
 * A React context for sharing the editor object.
 */

var EditorContext = Object(react__WEBPACK_IMPORTED_MODULE_0__["createContext"])(null);
/**
 * Get the current editor object from the React context.
 */

var useEditor = () => {
  var editor = Object(react__WEBPACK_IMPORTED_MODULE_0__["useContext"])(EditorContext);

  if (!editor) {
    throw new Error("The `useEditor` hook must be used inside the <Slate> component's context.");
  }

  return editor;
};

/**
 * A React context for sharing the editor object, in a way that re-renders the
 * context whenever changes occur.
 */

var SlateContext = Object(react__WEBPACK_IMPORTED_MODULE_0__["createContext"])(null);
/**
 * Get the current editor object from the React context.
 */

var useSlate = () => {
  var context = Object(react__WEBPACK_IMPORTED_MODULE_0__["useContext"])(SlateContext);

  if (!context) {
    throw new Error("The `useSlate` hook must be used inside the <SlateProvider> component's context.");
  }

  var [editor] = context;
  return editor;
};

/**
 * A wrapper around the provider to handle `onChange` events, because the editor
 * is a mutable singleton so it won't ever register as "changed" otherwise.
 */

var Slate = props => {
  var {
    editor,
    children,
    onChange,
    value
  } = props,
      rest = _objectWithoutProperties(props, ["editor", "children", "onChange", "value"]);

  var [key, setKey] = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(0);
  var context = Object(react__WEBPACK_IMPORTED_MODULE_0__["useMemo"])(() => {
    editor.children = value;
    Object.assign(editor, rest);
    return [editor];
  }, [key, value, ...Object.values(rest)]);
  var onContextChange = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(() => {
    onChange(editor.children);
    setKey(key + 1);
  }, [key, onChange]);
  EDITOR_TO_ON_CHANGE.set(editor, onContextChange);
  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(() => {
    return () => {
      EDITOR_TO_ON_CHANGE.set(editor, () => {});
    };
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(SlateContext.Provider, {
    value: context
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(EditorContext.Provider, {
    value: editor
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FocusedContext.Provider, {
    value: ReactEditor.isFocused(editor)
  }, children)));
};

/**
 * A React context for sharing the `readOnly` state of the editor.
 */

var ReadOnlyContext = Object(react__WEBPACK_IMPORTED_MODULE_0__["createContext"])(false);
/**
 * Get the current `readOnly` state of the editor.
 */

var useReadOnly = () => {
  return Object(react__WEBPACK_IMPORTED_MODULE_0__["useContext"])(ReadOnlyContext);
};

/**
 * A React context for sharing the `selected` state of an element.
 */

var SelectedContext = Object(react__WEBPACK_IMPORTED_MODULE_0__["createContext"])(false);
/**
 * Get the current `selected` state of an element.
 */

var useSelected = () => {
  return Object(react__WEBPACK_IMPORTED_MODULE_0__["useContext"])(SelectedContext);
};

/**
 * `withReact` adds React and DOM specific behaviors to the editor.
 */

var withReact = editor => {
  var e = editor;
  var {
    apply,
    onChange
  } = e;

  e.apply = op => {
    var matches = [];

    switch (op.type) {
      case 'insert_text':
      case 'remove_text':
      case 'set_node':
        {
          for (var [node, path] of slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].levels(e, {
            at: op.path
          })) {
            var key = ReactEditor.findKey(e, node);
            matches.push([path, key]);
          }

          break;
        }

      case 'insert_node':
      case 'remove_node':
      case 'merge_node':
      case 'split_node':
        {
          for (var [_node, _path] of slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].levels(e, {
            at: slate__WEBPACK_IMPORTED_MODULE_1__["Path"].parent(op.path)
          })) {
            var _key = ReactEditor.findKey(e, _node);

            matches.push([_path, _key]);
          }

          break;
        }
    }

    apply(op);

    for (var [_path2, _key2] of matches) {
      var [_node2] = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].node(e, _path2);
      NODE_TO_KEY.set(_node2, _key2);
    }
  };

  e.setFragmentData = data => {
    var {
      selection
    } = e;

    if (!selection) {
      return;
    }

    var [start, end] = slate__WEBPACK_IMPORTED_MODULE_1__["Range"].edges(selection);
    var startVoid = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].void(e, {
      at: start.path
    });
    var endVoid = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].void(e, {
      at: end.path
    });

    if (slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isCollapsed(selection) && !startVoid) {
      return;
    } // Create a fake selection so that we can add a Base64-encoded copy of the
    // fragment to the HTML, to decode on future pastes.


    var domRange = ReactEditor.toDOMRange(e, selection);
    var contents = domRange.cloneContents();
    var attach = contents.childNodes[0]; // Make sure attach is non-empty, since empty nodes will not get copied.

    contents.childNodes.forEach(node => {
      if (node.textContent && node.textContent.trim() !== '') {
        attach = node;
      }
    }); // COMPAT: If the end node is a void node, we need to move the end of the
    // range from the void node's spacer span, to the end of the void node's
    // content, since the spacer is before void's content in the DOM.

    if (endVoid) {
      var [voidNode] = endVoid;
      var r = domRange.cloneRange();
      var domNode = ReactEditor.toDOMNode(e, voidNode);
      r.setEndAfter(domNode);
      contents = r.cloneContents();
    } // COMPAT: If the start node is a void node, we need to attach the encoded
    // fragment to the void node's content node instead of the spacer, because
    // attaching it to empty `<div>/<span>` nodes will end up having it erased by
    // most browsers. (2018/04/27)


    if (startVoid) {
      attach = contents.querySelector('[data-slate-spacer]');
    } // Remove any zero-width space spans from the cloned DOM so that they don't
    // show up elsewhere when pasted.


    Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(zw => {
      var isNewline = zw.getAttribute('data-slate-zero-width') === 'n';
      zw.textContent = isNewline ? '\n' : '';
    }); // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up
    // in the HTML, and can be used for intra-Slate pasting. If it's a text
    // node, wrap it in a `<span>` so we have something to set an attribute on.

    if (isDOMText(attach)) {
      var span = document.createElement('span'); // COMPAT: In Chrome and Safari, if we don't add the `white-space` style
      // then leading and trailing spaces will be ignored. (2017/09/21)

      span.style.whiteSpace = 'pre';
      span.appendChild(attach);
      contents.appendChild(span);
      attach = span;
    }

    var fragment = e.getFragment();
    var string = JSON.stringify(fragment);
    var encoded = window.btoa(encodeURIComponent(string));
    attach.setAttribute('data-slate-fragment', encoded);
    data.setData('application/x-slate-fragment', encoded); // Add the content to a <div> so that we can get its inner HTML.

    var div = document.createElement('div');
    div.appendChild(contents);
    div.setAttribute('hidden', 'true');
    document.body.appendChild(div);
    data.setData('text/html', div.innerHTML);
    data.setData('text/plain', getPlainText(div));
    document.body.removeChild(div);
  };

  e.insertData = data => {
    var fragment = data.getData('application/x-slate-fragment');

    if (fragment) {
      var decoded = decodeURIComponent(window.atob(fragment));
      var parsed = JSON.parse(decoded);
      slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].insertFragment(e, parsed);
      return;
    }

    var text = data.getData('text/plain');

    if (text) {
      var lines = text.split(/\r\n|\r|\n/);
      var split = false;

      for (var line of lines) {
        if (split) {
          slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].splitNodes(e, {
            always: true
          });
        }

        slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].insertText(e, line);
        split = true;
      }
    }
  };

  e.onChange = () => {
    // COMPAT: React doesn't batch `setState` hook calls, which means that the
    // children and selection can get out of sync for one render pass. So we
    // have to use this unstable API to ensure it batches them. (2019/12/03)
    // https://github.com/facebook/react/issues/14259#issuecomment-439702367
    react_dom__WEBPACK_IMPORTED_MODULE_5___default.a.unstable_batchedUpdates(() => {
      var onContextChange = EDITOR_TO_ON_CHANGE.get(e);

      if (onContextChange) {
        onContextChange();
      }

      onChange();
    });
  };

  return e;
};

/**
 * Leaf content strings.
 */

var String = props => {
  var {
    isLast,
    leaf,
    parent,
    text
  } = props;
  var editor = useEditor();
  var path = ReactEditor.findPath(editor, text);
  var parentPath = slate__WEBPACK_IMPORTED_MODULE_1__["Path"].parent(path); // COMPAT: Render text inside void nodes with a zero-width space.
  // So the node can contain selection but the text is not visible.

  if (editor.isVoid(parent)) {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ZeroWidthString, {
      length: slate__WEBPACK_IMPORTED_MODULE_1__["Node"].string(parent).length
    });
  } // COMPAT: If this is the last text node in an empty block, render a zero-
  // width space that will convert into a line break when copying and pasting
  // to support expected plain text.


  if (leaf.text === '' && parent.children[parent.children.length - 1] === text && !editor.isInline(parent) && slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].string(editor, parentPath) === '') {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ZeroWidthString, {
      isLineBreak: true
    });
  } // COMPAT: If the text is empty, it's because it's on the edge of an inline
  // node, so we render a zero-width space so that the selection can be
  // inserted next to it still.


  if (leaf.text === '') {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ZeroWidthString, null);
  } // COMPAT: Browsers will collapse trailing new lines at the end of blocks,
  // so we need to add an extra trailing new lines to prevent that.


  if (isLast && leaf.text.slice(-1) === '\n') {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(TextString, {
      isTrailing: true,
      text: leaf.text
    });
  }

  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(TextString, {
    text: leaf.text
  });
};
/**
 * Leaf strings with text in them.
 */


var TextString = props => {
  var {
    text,
    isTrailing = false
  } = props;
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
    "data-slate-string": true
  }, text, isTrailing ? '\n' : null);
};
/**
 * Leaf strings without text, render as zero-width strings.
 */


var ZeroWidthString = props => {
  var {
    length = 0,
    isLineBreak = false
  } = props;
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
    "data-slate-zero-width": isLineBreak ? 'n' : 'z',
    "data-slate-length": length
  }, '\uFEFF', isLineBreak ? react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("br", null) : null);
};

/**
 * Individual leaves in a text node with unique formatting.
 */

var Leaf = props => {
  var {
    leaf,
    isLast,
    text,
    parent,
    renderLeaf = props => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(DefaultLeaf, Object.assign({}, props))
  } = props;
  var children = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(String, {
    isLast: isLast,
    leaf: leaf,
    parent: parent,
    text: text
  });

  if (leaf[PLACEHOLDER_SYMBOL]) {
    children = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
      contentEditable: false,
      style: {
        pointerEvents: 'none',
        display: 'inline-block',
        verticalAlign: 'text-top',
        width: '0',
        maxWidth: '100%',
        whiteSpace: 'nowrap',
        opacity: '0.333',
        userSelect: 'none',
        fontStyle: 'normal',
        fontWeight: 'normal',
        textDecoration: 'none'
      }
    }, leaf.placeholder), children);
  } // COMPAT: Having the `data-` attributes on these leaf elements ensures that
  // in certain misbehaving browsers they aren't weirdly cloned/destroyed by
  // contenteditable behaviors. (2019/05/08)


  var attributes = {
    'data-slate-leaf': true
  };
  return renderLeaf({
    attributes,
    children,
    leaf,
    text
  });
};

var MemoizedLeaf = react__WEBPACK_IMPORTED_MODULE_0___default.a.memo(Leaf, (prev, next) => {
  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.text === prev.text && slate__WEBPACK_IMPORTED_MODULE_1__["Text"].matches(next.leaf, prev.leaf);
});
/**
 * The default custom leaf renderer.
 */

var DefaultLeaf = props => {
  var {
    attributes,
    children
  } = props;
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", Object.assign({}, attributes), children);
};

/**
 * Prevent warning on SSR by falling back to useEffect when window is not defined
 */

var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_0__["useLayoutEffect"] : react__WEBPACK_IMPORTED_MODULE_0__["useEffect"];

/**
 * Text.
 */

var Text = props => {
  var {
    decorations,
    isLast,
    parent,
    renderLeaf,
    text
  } = props;
  var editor = useEditor();
  var ref = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(null);
  var leaves = slate__WEBPACK_IMPORTED_MODULE_1__["Text"].decorations(text, decorations);
  var key = ReactEditor.findKey(editor, text);
  var children = [];

  for (var i = 0; i < leaves.length; i++) {
    var leaf = leaves[i];
    children.push(react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(MemoizedLeaf, {
      isLast: isLast && i === leaves.length - 1,
      key: "".concat(key.id, "-").concat(i),
      leaf: leaf,
      text: text,
      parent: parent,
      renderLeaf: renderLeaf
    }));
  } // Update element-related weak maps with the DOM element ref.


  useIsomorphicLayoutEffect(() => {
    if (ref.current) {
      KEY_TO_ELEMENT.set(key, ref.current);
      NODE_TO_ELEMENT.set(text, ref.current);
      ELEMENT_TO_NODE.set(ref.current, text);
    } else {
      KEY_TO_ELEMENT.delete(key);
      NODE_TO_ELEMENT.delete(text);
    }
  });
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
    "data-slate-node": "text",
    ref: ref
  }, children);
};

var MemoizedText = react__WEBPACK_IMPORTED_MODULE_0___default.a.memo(Text, (prev, next) => {
  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.text === prev.text;
});

/**
 * Element.
 */

var Element = props => {
  var {
    decorate,
    decorations,
    element,
    renderElement = p => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(DefaultElement, Object.assign({}, p)),
    renderLeaf,
    selection
  } = props;
  var ref = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(null);
  var editor = useEditor();
  var readOnly = useReadOnly();
  var isInline = editor.isInline(element);
  var key = ReactEditor.findKey(editor, element);
  var children = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Children, {
    decorate: decorate,
    decorations: decorations,
    node: element,
    renderElement: renderElement,
    renderLeaf: renderLeaf,
    selection: selection
  }); // Attributes that the developer must mix into the element in their
  // custom node renderer component.

  var attributes = {
    'data-slate-node': 'element',
    ref
  };

  if (isInline) {
    attributes['data-slate-inline'] = true;
  } // If it's a block node with inline children, add the proper `dir` attribute
  // for text direction.


  if (!isInline && slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].hasInlines(editor, element)) {
    var text = slate__WEBPACK_IMPORTED_MODULE_1__["Node"].string(element);
    var dir = direction__WEBPACK_IMPORTED_MODULE_4___default()(text);

    if (dir === 'rtl') {
      attributes.dir = dir;
    }
  } // If it's a void node, wrap the children in extra void-specific elements.


  if (slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].isVoid(editor, element)) {
    attributes['data-slate-void'] = true;

    if (!readOnly && isInline) {
      attributes.contentEditable = false;
    }

    var Tag = isInline ? 'span' : 'div';
    var [[_text]] = slate__WEBPACK_IMPORTED_MODULE_1__["Node"].texts(element);
    children = readOnly ? null : react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Tag, {
      "data-slate-spacer": true,
      style: {
        height: '0',
        color: 'transparent',
        outline: 'none',
        position: 'absolute'
      }
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(MemoizedText, {
      decorations: [],
      isLast: false,
      parent: element,
      text: _text
    }));
    NODE_TO_INDEX.set(_text, 0);
    NODE_TO_PARENT.set(_text, element);
  } // Update element-related weak maps with the DOM element ref.


  useIsomorphicLayoutEffect(() => {
    if (ref.current) {
      KEY_TO_ELEMENT.set(key, ref.current);
      NODE_TO_ELEMENT.set(element, ref.current);
      ELEMENT_TO_NODE.set(ref.current, element);
    } else {
      KEY_TO_ELEMENT.delete(key);
      NODE_TO_ELEMENT.delete(element);
    }
  });
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(SelectedContext.Provider, {
    value: !!selection
  }, renderElement({
    attributes,
    children,
    element
  }));
};

var MemoizedElement = react__WEBPACK_IMPORTED_MODULE_0___default.a.memo(Element, (prev, next) => {
  return prev.decorate === next.decorate && prev.element === next.element && prev.renderElement === next.renderElement && prev.renderLeaf === next.renderLeaf && isRangeListEqual(prev.decorations, next.decorations) && (prev.selection === next.selection || !!prev.selection && !!next.selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].equals(prev.selection, next.selection));
});
/**
 * The default element renderer.
 */

var DefaultElement = props => {
  var {
    attributes,
    children,
    element
  } = props;
  var editor = useEditor();
  var Tag = editor.isInline(element) ? 'span' : 'div';
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Tag, Object.assign({}, attributes, {
    style: {
      position: 'relative'
    }
  }), children);
};
/**
 * Check if a list of ranges is equal to another.
 *
 * PERF: this requires the two lists to also have the ranges inside them in the
 * same order, but this is an okay constraint for us since decorations are
 * kept in order, and the odd case where they aren't is okay to re-render for.
 */

var isRangeListEqual = (list, another) => {
  if (list.length !== another.length) {
    return false;
  }

  for (var i = 0; i < list.length; i++) {
    var range = list[i];
    var other = another[i];

    if (!slate__WEBPACK_IMPORTED_MODULE_1__["Range"].equals(range, other)) {
      return false;
    }
  }

  return true;
};

/**
 * Children.
 */

var Children = props => {
  var {
    decorate,
    decorations,
    node,
    renderElement,
    renderLeaf,
    selection
  } = props;
  var editor = useEditor();
  var path = ReactEditor.findPath(editor, node);
  var children = [];
  var isLeafBlock = slate__WEBPACK_IMPORTED_MODULE_1__["Element"].isElement(node) && !editor.isInline(node) && slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].hasInlines(editor, node);

  for (var i = 0; i < node.children.length; i++) {
    var p = path.concat(i);
    var n = node.children[i];
    var key = ReactEditor.findKey(editor, n);
    var range = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].range(editor, p);
    var sel = selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].intersection(range, selection);
    var ds = decorate([n, p]);

    for (var dec of decorations) {
      var d = slate__WEBPACK_IMPORTED_MODULE_1__["Range"].intersection(dec, range);

      if (d) {
        ds.push(d);
      }
    }

    if (slate__WEBPACK_IMPORTED_MODULE_1__["Element"].isElement(n)) {
      children.push(react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(MemoizedElement, {
        decorate: decorate,
        decorations: ds,
        element: n,
        key: key.id,
        renderElement: renderElement,
        renderLeaf: renderLeaf,
        selection: sel
      }));
    } else {
      children.push(react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(MemoizedText, {
        decorations: ds,
        key: key.id,
        isLast: isLeafBlock && i === node.children.length - 1,
        parent: node,
        renderLeaf: renderLeaf,
        text: n
      }));
    }

    NODE_TO_INDEX.set(n, i);
    NODE_TO_PARENT.set(n, node);
  }

  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, children);
};

var IS_IOS = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent);
var IS_FIREFOX = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
var IS_SAFARI = typeof navigator !== 'undefined' && /Version\/[\d\.]+.*Safari/.test(navigator.userAgent); // "modern" Edge was released at 79.x

var IS_EDGE_LEGACY = typeof navigator !== 'undefined' && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])/i.test(navigator.userAgent);

/**
 * Hotkey mappings for each platform.
 */

var HOTKEYS = {
  bold: 'mod+b',
  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],
  moveBackward: 'left',
  moveForward: 'right',
  moveWordBackward: 'ctrl+left',
  moveWordForward: 'ctrl+right',
  deleteBackward: 'shift?+backspace',
  deleteForward: 'shift?+delete',
  extendBackward: 'shift+left',
  extendForward: 'shift+right',
  italic: 'mod+i',
  splitBlock: 'shift?+enter',
  undo: 'mod+z'
};
var APPLE_HOTKEYS = {
  moveLineBackward: 'opt+up',
  moveLineForward: 'opt+down',
  moveWordBackward: 'opt+left',
  moveWordForward: 'opt+right',
  deleteBackward: ['ctrl+backspace', 'ctrl+h'],
  deleteForward: ['ctrl+delete', 'ctrl+d'],
  deleteLineBackward: 'cmd+shift?+backspace',
  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],
  deleteWordBackward: 'opt+shift?+backspace',
  deleteWordForward: 'opt+shift?+delete',
  extendLineBackward: 'opt+shift+up',
  extendLineForward: 'opt+shift+down',
  redo: 'cmd+shift+z',
  transposeCharacter: 'ctrl+t'
};
var WINDOWS_HOTKEYS = {
  deleteWordBackward: 'ctrl+shift?+backspace',
  deleteWordForward: 'ctrl+shift?+delete',
  redo: ['ctrl+y', 'ctrl+shift+z']
};
/**
 * Create a platform-aware hotkey checker.
 */

var create = key => {
  var generic = HOTKEYS[key];
  var apple = APPLE_HOTKEYS[key];
  var windows = WINDOWS_HOTKEYS[key];
  var isGeneric = generic && Object(is_hotkey__WEBPACK_IMPORTED_MODULE_6__["isKeyHotkey"])(generic);
  var isApple = apple && Object(is_hotkey__WEBPACK_IMPORTED_MODULE_6__["isKeyHotkey"])(apple);
  var isWindows = windows && Object(is_hotkey__WEBPACK_IMPORTED_MODULE_6__["isKeyHotkey"])(windows);
  return event => {
    if (isGeneric && isGeneric(event)) return true;
    if (IS_APPLE && isApple && isApple(event)) return true;
    if (!IS_APPLE && isWindows && isWindows(event)) return true;
    return false;
  };
};
/**
 * Hotkeys.
 */


var Hotkeys = {
  isBold: create('bold'),
  isCompose: create('compose'),
  isMoveBackward: create('moveBackward'),
  isMoveForward: create('moveForward'),
  isDeleteBackward: create('deleteBackward'),
  isDeleteForward: create('deleteForward'),
  isDeleteLineBackward: create('deleteLineBackward'),
  isDeleteLineForward: create('deleteLineForward'),
  isDeleteWordBackward: create('deleteWordBackward'),
  isDeleteWordForward: create('deleteWordForward'),
  isExtendBackward: create('extendBackward'),
  isExtendForward: create('extendForward'),
  isExtendLineBackward: create('extendLineBackward'),
  isExtendLineForward: create('extendLineForward'),
  isItalic: create('italic'),
  isMoveLineBackward: create('moveLineBackward'),
  isMoveLineForward: create('moveLineForward'),
  isMoveWordBackward: create('moveWordBackward'),
  isMoveWordForward: create('moveWordForward'),
  isRedo: create('redo'),
  isSplitBlock: create('splitBlock'),
  isTransposeCharacter: create('transposeCharacter'),
  isUndo: create('undo')
};

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var HAS_BEFORE_INPUT_SUPPORT = !(IS_FIREFOX || IS_EDGE_LEGACY);
/**
 * Editable.
 */

var Editable = props => {
  var {
    autoFocus,
    decorate = defaultDecorate,
    onDOMBeforeInput: propsOnDOMBeforeInput,
    placeholder,
    readOnly = false,
    renderElement,
    renderLeaf,
    style = {},
    as: Component = 'div'
  } = props,
      attributes = _objectWithoutProperties(props, ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "style", "as"]);

  var editor = useSlate();
  var ref = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(null); // Update internal state on each render.

  IS_READ_ONLY.set(editor, readOnly); // Keep track of some state for the event handler logic.

  var state = Object(react__WEBPACK_IMPORTED_MODULE_0__["useMemo"])(() => ({
    isComposing: false,
    isUpdatingSelection: false,
    latestElement: null
  }), []); // Update element-related weak maps with the DOM element ref.

  useIsomorphicLayoutEffect(() => {
    if (ref.current) {
      EDITOR_TO_ELEMENT.set(editor, ref.current);
      NODE_TO_ELEMENT.set(editor, ref.current);
      ELEMENT_TO_NODE.set(ref.current, editor);
    } else {
      NODE_TO_ELEMENT.delete(editor);
    }
  }); // Whenever the editor updates, make sure the DOM selection state is in sync.

  useIsomorphicLayoutEffect(() => {
    var {
      selection
    } = editor;
    var domSelection = window.getSelection();

    if (state.isComposing || !domSelection || !ReactEditor.isFocused(editor)) {
      return;
    }

    var hasDomSelection = domSelection.type !== 'None'; // If the DOM selection is properly unset, we're done.

    if (!selection && !hasDomSelection) {
      return;
    } // verify that the dom selection is in the editor


    var editorElement = EDITOR_TO_ELEMENT.get(editor);
    var hasDomSelectionInEditor = false;

    if (editorElement.contains(domSelection.anchorNode) && editorElement.contains(domSelection.focusNode)) {
      hasDomSelectionInEditor = true;
    } // If the DOM selection is in the editor and the editor selection is already correct, we're done.


    if (hasDomSelection && hasDomSelectionInEditor && selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].equals(ReactEditor.toSlateRange(editor, domSelection), selection)) {
      return;
    } // Otherwise the DOM selection is out of sync, so update it.


    var el = ReactEditor.toDOMNode(editor, editor);
    state.isUpdatingSelection = true;
    domSelection.removeAllRanges();
    var newDomRange = selection && ReactEditor.toDOMRange(editor, selection);

    if (newDomRange) {
      domSelection.addRange(newDomRange);
      var leafEl = newDomRange.startContainer.parentElement;
      Object(scroll_into_view_if_needed__WEBPACK_IMPORTED_MODULE_3__["default"])(leafEl, {
        scrollMode: 'if-needed',
        boundary: el
      });
    }

    setTimeout(() => {
      // COMPAT: In Firefox, it's not enough to create a range, you also need
      // to focus the contenteditable element too. (2016/11/16)
      if (newDomRange && IS_FIREFOX) {
        el.focus();
      }

      state.isUpdatingSelection = false;
    });
  }); // The autoFocus TextareaHTMLAttribute doesn't do anything on a div, so it
  // needs to be manually focused.

  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(() => {
    if (ref.current && autoFocus) {
      ref.current.focus();
    }
  }, [autoFocus]); // Listen on the native `beforeinput` event to get real "Level 2" events. This
  // is required because React's `beforeinput` is fake and never really attaches
  // to the real event sadly. (2019/11/01)
  // https://github.com/facebook/react/issues/11211

  var onDOMBeforeInput = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
    if (!readOnly && hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {
      var {
        selection
      } = editor;
      var {
        inputType: type
      } = event;
      var data = event.dataTransfer || event.data || undefined; // These two types occur while a user is composing text and can't be
      // cancelled. Let them through and wait for the composition to end.

      if (type === 'insertCompositionText' || type === 'deleteCompositionText') {
        return;
      }

      event.preventDefault(); // COMPAT: For the deleting forward/backward input types we don't want
      // to change the selection because it is the range that will be deleted,
      // and those commands determine that for themselves.

      if (!type.startsWith('delete') || type.startsWith('deleteBy')) {
        var [targetRange] = event.getTargetRanges();

        if (targetRange) {
          var range = ReactEditor.toSlateRange(editor, targetRange);

          if (!selection || !slate__WEBPACK_IMPORTED_MODULE_1__["Range"].equals(selection, range)) {
            slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].select(editor, range);
          }
        }
      } // COMPAT: If the selection is expanded, even if the command seems like
      // a delete forward/backward command it should delete the selection.


      if (selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isExpanded(selection) && type.startsWith('delete')) {
        slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteFragment(editor);
        return;
      }

      switch (type) {
        case 'deleteByComposition':
        case 'deleteByCut':
        case 'deleteByDrag':
          {
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteFragment(editor);
            break;
          }

        case 'deleteContent':
        case 'deleteContentForward':
          {
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteForward(editor);
            break;
          }

        case 'deleteContentBackward':
          {
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteBackward(editor);
            break;
          }

        case 'deleteEntireSoftLine':
          {
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteBackward(editor, {
              unit: 'line'
            });
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteForward(editor, {
              unit: 'line'
            });
            break;
          }

        case 'deleteHardLineBackward':
          {
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteBackward(editor, {
              unit: 'block'
            });
            break;
          }

        case 'deleteSoftLineBackward':
          {
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteBackward(editor, {
              unit: 'line'
            });
            break;
          }

        case 'deleteHardLineForward':
          {
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteForward(editor, {
              unit: 'block'
            });
            break;
          }

        case 'deleteSoftLineForward':
          {
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteForward(editor, {
              unit: 'line'
            });
            break;
          }

        case 'deleteWordBackward':
          {
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteBackward(editor, {
              unit: 'word'
            });
            break;
          }

        case 'deleteWordForward':
          {
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteForward(editor, {
              unit: 'word'
            });
            break;
          }

        case 'insertLineBreak':
        case 'insertParagraph':
          {
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].insertBreak(editor);
            break;
          }

        case 'insertFromComposition':
        case 'insertFromDrop':
        case 'insertFromPaste':
        case 'insertFromYank':
        case 'insertReplacementText':
        case 'insertText':
          {
            if (data instanceof DataTransfer) {
              ReactEditor.insertData(editor, data);
            } else if (typeof data === 'string') {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].insertText(editor, data);
            }

            break;
          }
      }
    }
  }, [readOnly]); // Attach a native DOM event handler for `beforeinput` events, because React's
  // built-in `onBeforeInput` is actually a leaky polyfill that doesn't expose
  // real `beforeinput` events sadly... (2019/11/04)
  // https://github.com/facebook/react/issues/11211

  useIsomorphicLayoutEffect(() => {
    if (ref.current) {
      // @ts-ignore The `beforeinput` event isn't recognized.
      ref.current.addEventListener('beforeinput', onDOMBeforeInput);
    }

    return () => {
      if (ref.current) {
        // @ts-ignore The `beforeinput` event isn't recognized.
        ref.current.removeEventListener('beforeinput', onDOMBeforeInput);
      }
    };
  }, [onDOMBeforeInput]); // Listen on the native `selectionchange` event to be able to update any time
  // the selection changes. This is required because React's `onSelect` is leaky
  // and non-standard so it doesn't fire until after a selection has been
  // released. This causes issues in situations where another change happens
  // while a selection is being dragged.

  var onDOMSelectionChange = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(lodash_throttle__WEBPACK_IMPORTED_MODULE_2___default()(() => {
    if (!readOnly && !state.isComposing && !state.isUpdatingSelection) {
      var {
        activeElement
      } = window.document;
      var el = ReactEditor.toDOMNode(editor, editor);
      var domSelection = window.getSelection();

      if (activeElement === el) {
        state.latestElement = activeElement;
        IS_FOCUSED.set(editor, true);
      } else {
        IS_FOCUSED.delete(editor);
      }

      if (!domSelection) {
        return slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].deselect(editor);
      }

      var {
        anchorNode,
        focusNode
      } = domSelection;
      var anchorNodeSelectable = hasEditableTarget(editor, anchorNode) || isTargetInsideVoid(editor, anchorNode);
      var focusNodeSelectable = hasEditableTarget(editor, focusNode) || isTargetInsideVoid(editor, focusNode);

      if (anchorNodeSelectable && focusNodeSelectable) {
        var range = ReactEditor.toSlateRange(editor, domSelection);
        slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].select(editor, range);
      } else {
        slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].deselect(editor);
      }
    }
  }, 100), [readOnly]); // Attach a native DOM event handler for `selectionchange`, because React's
  // built-in `onSelect` handler doesn't fire for all selection changes. It's a
  // leaky polyfill that only fires on keypresses or clicks. Instead, we want to
  // fire for any change to the selection inside the editor. (2019/11/04)
  // https://github.com/facebook/react/issues/5785

  useIsomorphicLayoutEffect(() => {
    window.document.addEventListener('selectionchange', onDOMSelectionChange);
    return () => {
      window.document.removeEventListener('selectionchange', onDOMSelectionChange);
    };
  }, [onDOMSelectionChange]);
  var decorations = decorate([editor, []]);

  if (placeholder && editor.children.length === 1 && Array.from(slate__WEBPACK_IMPORTED_MODULE_1__["Node"].texts(editor)).length === 1 && slate__WEBPACK_IMPORTED_MODULE_1__["Node"].string(editor) === '') {
    var start = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].start(editor, []);
    decorations.push({
      [PLACEHOLDER_SYMBOL]: true,
      placeholder,
      anchor: start,
      focus: start
    });
  }

  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ReadOnlyContext.Provider, {
    value: readOnly
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Component // COMPAT: The Grammarly Chrome extension works by changing the DOM
  // out from under `contenteditable` elements, which leads to weird
  // behaviors so we have to disable it like editor. (2017/04/24)
  , Object.assign({
    "data-gramm": false,
    role: readOnly ? undefined : 'textbox'
  }, attributes, {
    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
    // have to use hacks to make these replacement-based features work.
    spellCheck: !HAS_BEFORE_INPUT_SUPPORT ? undefined : attributes.spellCheck,
    autoCorrect: !HAS_BEFORE_INPUT_SUPPORT ? undefined : attributes.autoCorrect,
    autoCapitalize: !HAS_BEFORE_INPUT_SUPPORT ? undefined : attributes.autoCapitalize,
    "data-slate-editor": true,
    "data-slate-node": "value",
    contentEditable: readOnly ? undefined : true,
    suppressContentEditableWarning: true,
    ref: ref,
    style: _objectSpread({
      // Prevent the default outline styles.
      outline: 'none',
      // Preserve adjacent whitespace and new lines.
      whiteSpace: 'pre-wrap',
      // Allow words to break if they are too long.
      wordWrap: 'break-word'
    }, style),
    onBeforeInput: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      // COMPAT: Certain browsers don't support the `beforeinput` event, so we
      // fall back to React's leaky polyfill instead just for it. It
      // only works for the `insertText` input type.
      if (!HAS_BEFORE_INPUT_SUPPORT && !readOnly && !isEventHandled(event, attributes.onBeforeInput) && hasEditableTarget(editor, event.target)) {
        event.preventDefault();
        var text = event.data;
        slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].insertText(editor, text);
      }
    }, [readOnly]),
    onBlur: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      if (readOnly || state.isUpdatingSelection || !hasEditableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {
        return;
      } // COMPAT: If the current `activeElement` is still the previous
      // one, this is due to the window being blurred when the tab
      // itself becomes unfocused, so we want to abort early to allow to
      // editor to stay focused when the tab becomes focused again.


      if (state.latestElement === window.document.activeElement) {
        return;
      }

      var {
        relatedTarget
      } = event;
      var el = ReactEditor.toDOMNode(editor, editor); // COMPAT: The event should be ignored if the focus is returning
      // to the editor from an embedded editable element (eg. an <input>
      // element inside a void node).

      if (relatedTarget === el) {
        return;
      } // COMPAT: The event should be ignored if the focus is moving from
      // the editor to inside a void node's spacer element.


      if (isDOMElement(relatedTarget) && relatedTarget.hasAttribute('data-slate-spacer')) {
        return;
      } // COMPAT: The event should be ignored if the focus is moving to a
      // non- editable section of an element that isn't a void node (eg.
      // a list item of the check list example).


      if (relatedTarget != null && isDOMNode(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {
        var node = ReactEditor.toSlateNode(editor, relatedTarget);

        if (slate__WEBPACK_IMPORTED_MODULE_1__["Element"].isElement(node) && !editor.isVoid(node)) {
          return;
        }
      }

      IS_FOCUSED.delete(editor);
    }, [readOnly, attributes.onBlur]),
    onClick: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      if (!readOnly && hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && isDOMNode(event.target)) {
        var node = ReactEditor.toSlateNode(editor, event.target);
        var path = ReactEditor.findPath(editor, node);

        var _start = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].start(editor, path);

        var end = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].end(editor, path);
        var startVoid = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].void(editor, {
          at: _start
        });
        var endVoid = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].void(editor, {
          at: end
        });

        if (startVoid && endVoid && slate__WEBPACK_IMPORTED_MODULE_1__["Path"].equals(startVoid[1], endVoid[1])) {
          var range = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].range(editor, _start);
          slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].select(editor, range);
        }
      }
    }, [readOnly, attributes.onClick]),
    onCompositionEnd: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionEnd)) {
        state.isComposing = false; // COMPAT: In Chrome, `beforeinput` events for compositions
        // aren't correct and never fire the "insertFromComposition"
        // type that we need. So instead, insert whenever a composition
        // ends since it will already have been committed to the DOM.

        if (!IS_SAFARI && !IS_FIREFOX && event.data) {
          slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].insertText(editor, event.data);
        }
      }
    }, [attributes.onCompositionEnd]),
    onCompositionStart: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionStart)) {
        state.isComposing = true;
      }
    }, [attributes.onCompositionStart]),
    onCopy: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy)) {
        event.preventDefault();
        ReactEditor.setFragmentData(editor, event.clipboardData);
      }
    }, [attributes.onCopy]),
    onCut: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      if (!readOnly && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut)) {
        event.preventDefault();
        ReactEditor.setFragmentData(editor, event.clipboardData);
        var {
          selection
        } = editor;

        if (selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isExpanded(selection)) {
          slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteFragment(editor);
        }
      }
    }, [readOnly, attributes.onCut]),
    onDragOver: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      if (hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {
        // Only when the target is void, call `preventDefault` to signal
        // that drops are allowed. Editable content is droppable by
        // default, and calling `preventDefault` hides the cursor.
        var node = ReactEditor.toSlateNode(editor, event.target);

        if (slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].isVoid(editor, node)) {
          event.preventDefault();
        }
      }
    }, [attributes.onDragOver]),
    onDragStart: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      if (hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {
        var node = ReactEditor.toSlateNode(editor, event.target);
        var path = ReactEditor.findPath(editor, node);
        var voidMatch = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].void(editor, {
          at: path
        }); // If starting a drag on a void node, make sure it is selected
        // so that it shows up in the selection's fragment.

        if (voidMatch) {
          var range = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].range(editor, path);
          slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].select(editor, range);
        }

        ReactEditor.setFragmentData(editor, event.dataTransfer);
      }
    }, [attributes.onDragStart]),
    onDrop: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      if (hasTarget(editor, event.target) && !readOnly && !isEventHandled(event, attributes.onDrop)) {
        // COMPAT: Certain browsers don't fire `beforeinput` events at all, and
        // Chromium browsers don't properly fire them for files being
        // dropped into a `contenteditable`. (2019/11/26)
        // https://bugs.chromium.org/p/chromium/issues/detail?id=1028668
        if (!HAS_BEFORE_INPUT_SUPPORT || !IS_SAFARI && event.dataTransfer.files.length > 0) {
          event.preventDefault();
          var range = ReactEditor.findEventRange(editor, event);
          var data = event.dataTransfer;
          slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].select(editor, range);
          ReactEditor.insertData(editor, data);
        }
      }
    }, [readOnly, attributes.onDrop]),
    onFocus: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      if (!readOnly && !state.isUpdatingSelection && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {
        var el = ReactEditor.toDOMNode(editor, editor);
        state.latestElement = window.document.activeElement; // COMPAT: If the editor has nested editable elements, the focus
        // can go to them. In Firefox, this must be prevented because it
        // results in issues with keyboard navigation. (2017/03/30)

        if (IS_FIREFOX && event.target !== el) {
          el.focus();
          return;
        }

        IS_FOCUSED.set(editor, true);
      }
    }, [readOnly, attributes.onFocus]),
    onKeyDown: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      if (!readOnly && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onKeyDown)) {
        var {
          nativeEvent
        } = event;
        var {
          selection
        } = editor; // COMPAT: Since we prevent the default behavior on
        // `beforeinput` events, the browser doesn't think there's ever
        // any history stack to undo or redo, so we have to manage these
        // hotkeys ourselves. (2019/11/06)

        if (Hotkeys.isRedo(nativeEvent)) {
          event.preventDefault();

          if (typeof editor.redo === 'function') {
            editor.redo();
          }

          return;
        }

        if (Hotkeys.isUndo(nativeEvent)) {
          event.preventDefault();

          if (typeof editor.undo === 'function') {
            editor.undo();
          }

          return;
        } // COMPAT: Certain browsers don't handle the selection updates
        // properly. In Chrome, the selection isn't properly extended.
        // And in Firefox, the selection isn't properly collapsed.
        // (2017/10/17)


        if (Hotkeys.isMoveLineBackward(nativeEvent)) {
          event.preventDefault();
          slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].move(editor, {
            unit: 'line',
            reverse: true
          });
          return;
        }

        if (Hotkeys.isMoveLineForward(nativeEvent)) {
          event.preventDefault();
          slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].move(editor, {
            unit: 'line'
          });
          return;
        }

        if (Hotkeys.isExtendLineBackward(nativeEvent)) {
          event.preventDefault();
          slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].move(editor, {
            unit: 'line',
            edge: 'focus',
            reverse: true
          });
          return;
        }

        if (Hotkeys.isExtendLineForward(nativeEvent)) {
          event.preventDefault();
          slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].move(editor, {
            unit: 'line',
            edge: 'focus'
          });
          return;
        } // COMPAT: If a void node is selected, or a zero-width text node
        // adjacent to an inline is selected, we need to handle these
        // hotkeys manually because browsers won't be able to skip over
        // the void node with the zero-width space not being an empty
        // string.


        if (Hotkeys.isMoveBackward(nativeEvent)) {
          event.preventDefault();

          if (selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isCollapsed(selection)) {
            slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].move(editor, {
              reverse: true
            });
          } else {
            slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].collapse(editor, {
              edge: 'start'
            });
          }

          return;
        }

        if (Hotkeys.isMoveForward(nativeEvent)) {
          event.preventDefault();

          if (selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isCollapsed(selection)) {
            slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].move(editor);
          } else {
            slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].collapse(editor, {
              edge: 'end'
            });
          }

          return;
        }

        if (Hotkeys.isMoveWordBackward(nativeEvent)) {
          event.preventDefault();
          slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].move(editor, {
            unit: 'word',
            reverse: true
          });
          return;
        }

        if (Hotkeys.isMoveWordForward(nativeEvent)) {
          event.preventDefault();
          slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].move(editor, {
            unit: 'word'
          });
          return;
        } // COMPAT: Certain browsers don't support the `beforeinput` event, so we
        // fall back to guessing at the input intention for hotkeys.
        // COMPAT: In iOS, some of these hotkeys are handled in the


        if (!HAS_BEFORE_INPUT_SUPPORT) {
          // We don't have a core behavior for these, but they change the
          // DOM if we don't prevent them, so we have to.
          if (Hotkeys.isBold(nativeEvent) || Hotkeys.isItalic(nativeEvent) || Hotkeys.isTransposeCharacter(nativeEvent)) {
            event.preventDefault();
            return;
          }

          if (Hotkeys.isSplitBlock(nativeEvent)) {
            event.preventDefault();
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].insertBreak(editor);
            return;
          }

          if (Hotkeys.isDeleteBackward(nativeEvent)) {
            event.preventDefault();

            if (selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isExpanded(selection)) {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteFragment(editor);
            } else {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteBackward(editor);
            }

            return;
          }

          if (Hotkeys.isDeleteForward(nativeEvent)) {
            event.preventDefault();

            if (selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isExpanded(selection)) {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteFragment(editor);
            } else {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteForward(editor);
            }

            return;
          }

          if (Hotkeys.isDeleteLineBackward(nativeEvent)) {
            event.preventDefault();

            if (selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isExpanded(selection)) {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteFragment(editor);
            } else {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteBackward(editor, {
                unit: 'line'
              });
            }

            return;
          }

          if (Hotkeys.isDeleteLineForward(nativeEvent)) {
            event.preventDefault();

            if (selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isExpanded(selection)) {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteFragment(editor);
            } else {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteForward(editor, {
                unit: 'line'
              });
            }

            return;
          }

          if (Hotkeys.isDeleteWordBackward(nativeEvent)) {
            event.preventDefault();

            if (selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isExpanded(selection)) {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteFragment(editor);
            } else {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteBackward(editor, {
                unit: 'word'
              });
            }

            return;
          }

          if (Hotkeys.isDeleteWordForward(nativeEvent)) {
            event.preventDefault();

            if (selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isExpanded(selection)) {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteFragment(editor);
            } else {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteForward(editor, {
                unit: 'word'
              });
            }

            return;
          }
        }
      }
    }, [readOnly, attributes.onKeyDown]),
    onPaste: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      // COMPAT: Certain browsers don't support the `beforeinput` event, so we
      // fall back to React's `onPaste` here instead.
      // COMPAT: Firefox, Chrome and Safari are not emitting `beforeinput` events
      // when "paste without formatting" option is used.
      // This unfortunately needs to be handled with paste events instead.
      if (!isEventHandled(event, attributes.onPaste) && (!HAS_BEFORE_INPUT_SUPPORT || isPlainTextOnlyPaste(event.nativeEvent)) && !readOnly && hasEditableTarget(editor, event.target)) {
        event.preventDefault();
        ReactEditor.insertData(editor, event.clipboardData);
      }
    }, [readOnly, attributes.onPaste])
  }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Children, {
    decorate: decorate,
    decorations: decorations,
    node: editor,
    renderElement: renderElement,
    renderLeaf: renderLeaf,
    selection: editor.selection
  })));
};
/**
 * A default memoized decorate function.
 */

var defaultDecorate = () => [];
/**
 * Check if the target is in the editor.
 */


var hasTarget = (editor, target) => {
  return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target);
};
/**
 * Check if the target is editable and in the editor.
 */


var hasEditableTarget = (editor, target) => {
  return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target, {
    editable: true
  });
};
/**
 * Check if the target is inside void and in the editor.
 */


var isTargetInsideVoid = (editor, target) => {
  var slateNode = hasTarget(editor, target) && ReactEditor.toSlateNode(editor, target);
  return slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].isVoid(editor, slateNode);
};
/**
 * Check if an event is overrided by a handler.
 */


var isEventHandled = (event, handler) => {
  if (!handler) {
    return false;
  }

  handler(event);
  return event.isDefaultPrevented() || event.isPropagationStopped();
};
/**
 * Check if a DOM event is overrided by a handler.
 */


var isDOMEventHandled = (event, handler) => {
  if (!handler) {
    return false;
  }

  handler(event);
  return event.defaultPrevented;
};


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "../node_modules/slate/dist/index.es.js":
/*!**********************************************!*\
  !*** ../node_modules/slate/dist/index.es.js ***!
  \**********************************************/
/*! exports provided: Editor, Element, Location, Node, Operation, Path, PathRef, Point, PointRef, Range, RangeRef, Span, Text, Transforms, createEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Editor", function() { return Editor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Element", function() { return Element; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Location", function() { return Location; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Node", function() { return Node; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Operation", function() { return Operation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Path", function() { return Path; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PathRef", function() { return PathRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Point", function() { return Point; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointRef", function() { return PointRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Range", function() { return Range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RangeRef", function() { return RangeRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Span", function() { return Span; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Text", function() { return Text; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transforms", function() { return Transforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEditor", function() { return createEditor; });
/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-plain-object */ "../node_modules/slate/node_modules/is-plain-object/index.js");
/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! immer */ "../node_modules/immer/dist/immer.module.js");
/* harmony import */ var esrever__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! esrever */ "../node_modules/esrever/esrever.js");
/* harmony import */ var esrever__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(esrever__WEBPACK_IMPORTED_MODULE_2__);




function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var DIRTY_PATHS = new WeakMap();
var FLUSHING = new WeakMap();
var NORMALIZING = new WeakMap();
var PATH_REFS = new WeakMap();
var POINT_REFS = new WeakMap();
var RANGE_REFS = new WeakMap();

/**
 * Constants for string distance checking.
 */
var SPACE = /\s/;
var PUNCTUATION = /[\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
var CHAMELEON = /['\u2018\u2019]/;
var SURROGATE_START = 0xd800;
var SURROGATE_END = 0xdfff;
var ZERO_WIDTH_JOINER = 0x200d;
/**
 * Get the distance to the end of the first character in a string of text.
 */

var getCharacterDistance = text => {
  var offset = 0; // prev types:
  // SURR: surrogate pair
  // MOD: modifier (technically also surrogate pair)
  // ZWJ: zero width joiner
  // VAR: variation selector
  // BMP: sequenceable character from basic multilingual plane

  var prev = null;
  var charCode = text.charCodeAt(0);

  while (charCode) {
    if (isSurrogate(charCode)) {
      var modifier = isModifier(charCode, text, offset); // Early returns are the heart of this function, where we decide if previous and current
      // codepoints should form a single character (in terms of how many of them should selection
      // jump over).

      if (prev === 'SURR' || prev === 'BMP') {
        break;
      }

      offset += 2;
      prev = modifier ? 'MOD' : 'SURR';
      charCode = text.charCodeAt(offset); // Absolutely fine to `continue` without any checks because if `charCode` is NaN (which
      // is the case when out of `text` range), next `while` loop won"t execute and we"re done.

      continue;
    }

    if (charCode === ZERO_WIDTH_JOINER) {
      offset += 1;
      prev = 'ZWJ';
      charCode = text.charCodeAt(offset);
      continue;
    }

    if (isBMPEmoji(charCode)) {
      if (prev && prev !== 'ZWJ' && prev !== 'VAR') {
        break;
      }

      offset += 1;
      prev = 'BMP';
      charCode = text.charCodeAt(offset);
      continue;
    }

    if (isVariationSelector(charCode)) {
      if (prev && prev !== 'ZWJ') {
        break;
      }

      offset += 1;
      prev = 'VAR';
      charCode = text.charCodeAt(offset);
      continue;
    } // Modifier 'groups up' with what ever character is before that (even whitespace), need to
    // look ahead.


    if (prev === 'MOD') {
      offset += 1;
      break;
    } // If while loop ever gets here, we're done (e.g latin chars).


    break;
  }

  return offset || 1;
};
/**
 * Get the distance to the end of the first word in a string of text.
 */

var getWordDistance = text => {
  var length = 0;
  var i = 0;
  var started = false;
  var char;

  while (char = text.charAt(i)) {
    var l = getCharacterDistance(char);
    char = text.slice(i, i + l);
    var rest = text.slice(i + l);

    if (isWordCharacter(char, rest)) {
      started = true;
      length += l;
    } else if (!started) {
      length += l;
    } else {
      break;
    }

    i += l;
  }

  return length;
};
/**
 * Check if a character is a word character. The `remaining` argument is used
 * because sometimes you must read subsequent characters to truly determine it.
 */

var isWordCharacter = (char, remaining) => {
  if (SPACE.test(char)) {
    return false;
  } // Chameleons count as word characters as long as they're in a word, so
  // recurse to see if the next one is a word character or not.


  if (CHAMELEON.test(char)) {
    var next = remaining.charAt(0);
    var length = getCharacterDistance(next);
    next = remaining.slice(0, length);
    var rest = remaining.slice(length);

    if (isWordCharacter(next, rest)) {
      return true;
    }
  }

  if (PUNCTUATION.test(char)) {
    return false;
  }

  return true;
};
/**
 * Determines if `code` is a surrogate
 */


var isSurrogate = code => SURROGATE_START <= code && code <= SURROGATE_END;
/**
 * Does `code` form Modifier with next one.
 *
 * https://emojipedia.org/modifiers/
 */


var isModifier = (code, text, offset) => {
  if (code === 0xd83c) {
    var next = text.charCodeAt(offset + 1);
    return next <= 0xdfff && next >= 0xdffb;
  }

  return false;
};
/**
 * Is `code` a Variation Selector.
 *
 * https://codepoints.net/variation_selectors
 */


var isVariationSelector = code => {
  return code <= 0xfe0f && code >= 0xfe00;
};
/**
 * Is `code` one of the BMP codes used in emoji sequences.
 *
 * https://emojipedia.org/emoji-zwj-sequences/
 */


var isBMPEmoji = code => {
  // This requires tiny bit of maintanance, better ideas?
  // Fortunately it only happens if new Unicode Standard
  // is released. Fails gracefully if upkeep lags behind,
  // same way Slate previously behaved with all emojis.
  return code === 0x2764 || // heart (❤)
  code === 0x2642 || // male (♂)
  code === 0x2640 || // female (♀)
  code === 0x2620 || // scull (☠)
  code === 0x2695 || // medical (⚕)
  code === 0x2708 || // plane (✈️)
  code === 0x25ef // large circle (◯)
  ;
};

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var Editor = {
  /**
   * Get the ancestor above a location in the document.
   */
  above(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      voids = false,
      mode = 'lowest',
      at = editor.selection,
      match
    } = options;

    if (!at) {
      return;
    }

    var path = Editor.path(editor, at);
    var reverse = mode === 'lowest';

    for (var [n, p] of Editor.levels(editor, {
      at: path,
      voids,
      match,
      reverse
    })) {
      if (!Text.isText(n) && !Path.equals(path, p)) {
        return [n, p];
      }
    }
  },

  /**
   * Add a custom property to the leaf text nodes in the current selection.
   *
   * If the selection is currently collapsed, the marks will be added to the
   * `editor.marks` property instead, and applied when text is inserted next.
   */
  addMark(editor, key, value) {
    editor.addMark(key, value);
  },

  /**
   * Get the point after a location.
   */
  after(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var anchor = Editor.point(editor, at, {
      edge: 'end'
    });
    var focus = Editor.end(editor, []);
    var range = {
      anchor,
      focus
    };
    var {
      distance = 1
    } = options;
    var d = 0;
    var target;

    for (var p of Editor.positions(editor, _objectSpread({}, options, {
      at: range
    }))) {
      if (d > distance) {
        break;
      }

      if (d !== 0) {
        target = p;
      }

      d++;
    }

    return target;
  },

  /**
   * Get the point before a location.
   */
  before(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var anchor = Editor.start(editor, []);
    var focus = Editor.point(editor, at, {
      edge: 'start'
    });
    var range = {
      anchor,
      focus
    };
    var {
      distance = 1
    } = options;
    var d = 0;
    var target;

    for (var p of Editor.positions(editor, _objectSpread({}, options, {
      at: range,
      reverse: true
    }))) {
      if (d > distance) {
        break;
      }

      if (d !== 0) {
        target = p;
      }

      d++;
    }

    return target;
  },

  /**
   * Delete content in the editor backward from the current selection.
   */
  deleteBackward(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      unit = 'character'
    } = options;
    editor.deleteBackward(unit);
  },

  /**
   * Delete content in the editor forward from the current selection.
   */
  deleteForward(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      unit = 'character'
    } = options;
    editor.deleteForward(unit);
  },

  /**
   * Delete the content in the current selection.
   */
  deleteFragment(editor) {
    editor.deleteFragment();
  },

  /**
   * Get the start and end points of a location.
   */
  edges(editor, at) {
    return [Editor.start(editor, at), Editor.end(editor, at)];
  },

  /**
   * Get the end point of a location.
   */
  end(editor, at) {
    return Editor.point(editor, at, {
      edge: 'end'
    });
  },

  /**
   * Get the first node at a location.
   */
  first(editor, at) {
    var path = Editor.path(editor, at, {
      edge: 'start'
    });
    return Editor.node(editor, path);
  },

  /**
   * Get the fragment at a location.
   */
  fragment(editor, at) {
    var range = Editor.range(editor, at);
    var fragment = Node.fragment(editor, range);
    return fragment;
  },

  /**
   * Check if a node has block children.
   */
  hasBlocks(editor, element) {
    return element.children.some(n => Editor.isBlock(editor, n));
  },

  /**
   * Check if a node has inline and text children.
   */
  hasInlines(editor, element) {
    return element.children.some(n => Text.isText(n) || Editor.isInline(editor, n));
  },

  /**
   * Check if a node has text children.
   */
  hasTexts(editor, element) {
    return element.children.every(n => Text.isText(n));
  },

  /**
   * Insert a block break at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertBreak(editor) {
    editor.insertBreak();
  },

  /**
   * Insert a fragment at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertFragment(editor, fragment) {
    editor.insertFragment(fragment);
  },

  /**
   * Insert a node at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertNode(editor, node) {
    editor.insertNode(node);
  },

  /**
   * Insert text at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertText(editor, text) {
    editor.insertText(text);
  },

  /**
   * Check if a value is a block `Element` object.
   */
  isBlock(editor, value) {
    return Element.isElement(value) && !editor.isInline(value);
  },

  /**
   * Check if a value is an `Editor` object.
   */
  isEditor(value) {
    return Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && typeof value.addMark === 'function' && typeof value.apply === 'function' && typeof value.deleteBackward === 'function' && typeof value.deleteForward === 'function' && typeof value.deleteFragment === 'function' && typeof value.insertBreak === 'function' && typeof value.insertFragment === 'function' && typeof value.insertNode === 'function' && typeof value.insertText === 'function' && typeof value.isInline === 'function' && typeof value.isVoid === 'function' && typeof value.normalizeNode === 'function' && typeof value.onChange === 'function' && typeof value.removeMark === 'function' && (value.marks === null || Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);
  },

  /**
   * Check if a point is the end point of a location.
   */
  isEnd(editor, point, at) {
    var end = Editor.end(editor, at);
    return Point.equals(point, end);
  },

  /**
   * Check if a point is an edge of a location.
   */
  isEdge(editor, point, at) {
    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);
  },

  /**
   * Check if an element is empty, accounting for void nodes.
   */
  isEmpty(editor, element) {
    var {
      children
    } = element;
    var [first] = children;
    return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === '' && !editor.isVoid(element);
  },

  /**
   * Check if a value is an inline `Element` object.
   */
  isInline(editor, value) {
    return Element.isElement(value) && editor.isInline(value);
  },

  /**
   * Check if the editor is currently normalizing after each operation.
   */
  isNormalizing(editor) {
    var isNormalizing = NORMALIZING.get(editor);
    return isNormalizing === undefined ? true : isNormalizing;
  },

  /**
   * Check if a point is the start point of a location.
   */
  isStart(editor, point, at) {
    // PERF: If the offset isn't `0` we know it's not the start.
    if (point.offset !== 0) {
      return false;
    }

    var start = Editor.start(editor, at);
    return Point.equals(point, start);
  },

  /**
   * Check if a value is a void `Element` object.
   */
  isVoid(editor, value) {
    return Element.isElement(value) && editor.isVoid(value);
  },

  /**
   * Get the last node at a location.
   */
  last(editor, at) {
    var path = Editor.path(editor, at, {
      edge: 'end'
    });
    return Editor.node(editor, path);
  },

  /**
   * Get the leaf text node at a location.
   */
  leaf(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var path = Editor.path(editor, at, options);
    var node = Node.leaf(editor, path);
    return [node, path];
  },

  /**
   * Iterate through all of the levels at a location.
   */
  *levels(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      at = editor.selection,
      reverse = false,
      voids = false
    } = options;
    var {
      match
    } = options;

    if (match == null) {
      match = () => true;
    }

    if (!at) {
      return;
    }

    var levels = [];
    var path = Editor.path(editor, at);

    for (var [n, p] of Node.levels(editor, path)) {
      if (!match(n)) {
        continue;
      }

      levels.push([n, p]);

      if (!voids && Editor.isVoid(editor, n)) {
        break;
      }
    }

    if (reverse) {
      levels.reverse();
    }

    yield* levels;
  },

  /**
   * Get the marks that would be added to text at the current selection.
   */
  marks(editor) {
    var {
      marks,
      selection
    } = editor;

    if (!selection) {
      return null;
    }

    if (marks) {
      return marks;
    }

    if (Range.isExpanded(selection)) {
      var [match] = Editor.nodes(editor, {
        match: Text.isText
      });

      if (match) {
        var [_node] = match;

        var _rest = _objectWithoutProperties(_node, ["text"]);

        return _rest;
      } else {
        return {};
      }
    }

    var {
      anchor
    } = selection;
    var {
      path
    } = anchor;
    var [node] = Editor.leaf(editor, path);

    if (anchor.offset === 0) {
      var prev = Editor.previous(editor, {
        at: path,
        match: Text.isText
      });
      var block = Editor.above(editor, {
        match: n => Editor.isBlock(editor, n)
      });

      if (prev && block) {
        var [prevNode, prevPath] = prev;
        var [, blockPath] = block;

        if (Path.isAncestor(blockPath, prevPath)) {
          node = prevNode;
        }
      }
    }

    var rest = _objectWithoutProperties(node, ["text"]);

    return rest;
  },

  /**
   * Get the matching node in the branch of the document after a location.
   */
  next(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      mode = 'lowest',
      voids = false
    } = options;
    var {
      match,
      at = editor.selection
    } = options;

    if (!at) {
      return;
    }

    var [, from] = Editor.last(editor, at);
    var [, to] = Editor.last(editor, []);
    var span = [from, to];

    if (Path.isPath(at) && at.length === 0) {
      throw new Error("Cannot get the next node from the root node!");
    }

    if (match == null) {
      if (Path.isPath(at)) {
        var [parent] = Editor.parent(editor, at);

        match = n => parent.children.includes(n);
      } else {
        match = () => true;
      }
    }

    var [, next] = Editor.nodes(editor, {
      at: span,
      match,
      mode,
      voids
    });
    return next;
  },

  /**
   * Get the node at a location.
   */
  node(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var path = Editor.path(editor, at, options);
    var node = Node.get(editor, path);
    return [node, path];
  },

  /**
   * Iterate through all of the nodes in the Editor.
   */
  *nodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      at = editor.selection,
      mode = 'all',
      universal = false,
      reverse = false,
      voids = false
    } = options;
    var {
      match
    } = options;

    if (!match) {
      match = () => true;
    }

    if (!at) {
      return;
    }

    var from;
    var to;

    if (Span.isSpan(at)) {
      from = at[0];
      to = at[1];
    } else {
      var first = Editor.path(editor, at, {
        edge: 'start'
      });
      var last = Editor.path(editor, at, {
        edge: 'end'
      });
      from = reverse ? last : first;
      to = reverse ? first : last;
    }

    var iterable = Node.nodes(editor, {
      reverse,
      from,
      to,
      pass: (_ref) => {
        var [n] = _ref;
        return voids ? false : Editor.isVoid(editor, n);
      }
    });
    var matches = [];
    var hit;

    for (var [node, path] of iterable) {
      var isLower = hit && Path.compare(path, hit[1]) === 0; // In highest mode any node lower than the last hit is not a match.

      if (mode === 'highest' && isLower) {
        continue;
      }

      if (!match(node)) {
        // If we've arrived at a leaf text node that is not lower than the last
        // hit, then we've found a branch that doesn't include a match, which
        // means the match is not universal.
        if (universal && !isLower && Text.isText(node)) {
          return;
        } else {
          continue;
        }
      } // If there's a match and it's lower than the last, update the hit.


      if (mode === 'lowest' && isLower) {
        hit = [node, path];
        continue;
      } // In lowest mode we emit the last hit, once it's guaranteed lowest.


      var emit = mode === 'lowest' ? hit : [node, path];

      if (emit) {
        if (universal) {
          matches.push(emit);
        } else {
          yield emit;
        }
      }

      hit = [node, path];
    } // Since lowest is always emitting one behind, catch up at the end.


    if (mode === 'lowest' && hit) {
      if (universal) {
        matches.push(hit);
      } else {
        yield hit;
      }
    } // Universal defers to ensure that the match occurs in every branch, so we
    // yield all of the matches after iterating.


    if (universal) {
      yield* matches;
    }
  },

  /**
   * Normalize any dirty objects in the editor.
   */
  normalize(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      force = false
    } = options;

    var getDirtyPaths = editor => {
      return DIRTY_PATHS.get(editor) || [];
    };

    if (!Editor.isNormalizing(editor)) {
      return;
    }

    if (force) {
      var allPaths = Array.from(Node.nodes(editor), (_ref2) => {
        var [, p] = _ref2;
        return p;
      });
      DIRTY_PATHS.set(editor, allPaths);
    }

    if (getDirtyPaths(editor).length === 0) {
      return;
    }

    Editor.withoutNormalizing(editor, () => {
      var max = getDirtyPaths(editor).length * 42; // HACK: better way?

      var m = 0;

      while (getDirtyPaths(editor).length !== 0) {
        if (m > max) {
          throw new Error("\n            Could not completely normalize the editor after ".concat(max, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\n          "));
        }

        var path = getDirtyPaths(editor).pop();
        var entry = Editor.node(editor, path);
        editor.normalizeNode(entry);
        m++;
      }
    });
  },

  /**
   * Get the parent node of a location.
   */
  parent(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var path = Editor.path(editor, at, options);
    var parentPath = Path.parent(path);
    var entry = Editor.node(editor, parentPath);
    return entry;
  },

  /**
   * Get the path of a location.
   */
  path(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      depth,
      edge
    } = options;

    if (Path.isPath(at)) {
      if (edge === 'start') {
        var [, firstPath] = Node.first(editor, at);
        at = firstPath;
      } else if (edge === 'end') {
        var [, lastPath] = Node.last(editor, at);
        at = lastPath;
      }
    }

    if (Range.isRange(at)) {
      if (edge === 'start') {
        at = Range.start(at);
      } else if (edge === 'end') {
        at = Range.end(at);
      } else {
        at = Path.common(at.anchor.path, at.focus.path);
      }
    }

    if (Point.isPoint(at)) {
      at = at.path;
    }

    if (depth != null) {
      at = at.slice(0, depth);
    }

    return at;
  },

  /**
   * Create a mutable ref for a `Path` object, which will stay in sync as new
   * operations are applied to the editor.
   */
  pathRef(editor, path) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      affinity = 'forward'
    } = options;
    var ref = {
      current: path,
      affinity,

      unref() {
        var {
          current
        } = ref;
        var pathRefs = Editor.pathRefs(editor);
        pathRefs.delete(ref);
        ref.current = null;
        return current;
      }

    };
    var refs = Editor.pathRefs(editor);
    refs.add(ref);
    return ref;
  },

  /**
   * Get the set of currently tracked path refs of the editor.
   */
  pathRefs(editor) {
    var refs = PATH_REFS.get(editor);

    if (!refs) {
      refs = new Set();
      PATH_REFS.set(editor, refs);
    }

    return refs;
  },

  /**
   * Get the start or end point of a location.
   */
  point(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      edge = 'start'
    } = options;

    if (Path.isPath(at)) {
      var path;

      if (edge === 'end') {
        var [, lastPath] = Node.last(editor, at);
        path = lastPath;
      } else {
        var [, firstPath] = Node.first(editor, at);
        path = firstPath;
      }

      var node = Node.get(editor, path);

      if (!Text.isText(node)) {
        throw new Error("Cannot get the ".concat(edge, " point in the node at path [").concat(at, "] because it has no ").concat(edge, " text node."));
      }

      return {
        path,
        offset: edge === 'end' ? node.text.length : 0
      };
    }

    if (Range.isRange(at)) {
      var [start, end] = Range.edges(at);
      return edge === 'start' ? start : end;
    }

    return at;
  },

  /**
   * Create a mutable ref for a `Point` object, which will stay in sync as new
   * operations are applied to the editor.
   */
  pointRef(editor, point) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      affinity = 'forward'
    } = options;
    var ref = {
      current: point,
      affinity,

      unref() {
        var {
          current
        } = ref;
        var pointRefs = Editor.pointRefs(editor);
        pointRefs.delete(ref);
        ref.current = null;
        return current;
      }

    };
    var refs = Editor.pointRefs(editor);
    refs.add(ref);
    return ref;
  },

  /**
   * Get the set of currently tracked point refs of the editor.
   */
  pointRefs(editor) {
    var refs = POINT_REFS.get(editor);

    if (!refs) {
      refs = new Set();
      POINT_REFS.set(editor, refs);
    }

    return refs;
  },

  /**
   * Iterate through all of the positions in the document where a `Point` can be
   * placed.
   *
   * By default it will move forward by individual offsets at a time,  but you
   * can pass the `unit: 'character'` option to moved forward one character, word,
   * or line at at time.
   *
   * Note: void nodes are treated as a single point, and iteration will not
   * happen inside their content.
   */
  *positions(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      at = editor.selection,
      unit = 'offset',
      reverse: reverse$1 = false
    } = options;

    if (!at) {
      return;
    }

    var range = Editor.range(editor, at);
    var [start, end] = Range.edges(range);
    var first = reverse$1 ? end : start;
    var string = '';
    var available = 0;
    var offset = 0;
    var distance = null;
    var isNewBlock = false;

    var advance = () => {
      if (distance == null) {
        if (unit === 'character') {
          distance = getCharacterDistance(string);
        } else if (unit === 'word') {
          distance = getWordDistance(string);
        } else if (unit === 'line' || unit === 'block') {
          distance = string.length;
        } else {
          distance = 1;
        }

        string = string.slice(distance);
      } // Add or substract the offset.


      offset = reverse$1 ? offset - distance : offset + distance; // Subtract the distance traveled from the available text.

      available = available - distance; // If the available had room to spare, reset the distance so that it will
      // advance again next time. Otherwise, set it to the overflow amount.

      distance = available >= 0 ? null : 0 - available;
    };

    for (var [node, path] of Editor.nodes(editor, {
      at,
      reverse: reverse$1
    })) {
      if (Element.isElement(node)) {
        // Void nodes are a special case, since we don't want to iterate over
        // their content. We instead always just yield their first point.
        if (editor.isVoid(node)) {
          yield Editor.start(editor, path);
          continue;
        }

        if (editor.isInline(node)) {
          continue;
        }

        if (Editor.hasInlines(editor, node)) {
          var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);
          var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);
          var text = Editor.string(editor, {
            anchor: s,
            focus: e
          });
          string = reverse$1 ? Object(esrever__WEBPACK_IMPORTED_MODULE_2__["reverse"])(text) : text;
          isNewBlock = true;
        }
      }

      if (Text.isText(node)) {
        var isFirst = Path.equals(path, first.path);
        available = node.text.length;
        offset = reverse$1 ? available : 0;

        if (isFirst) {
          available = reverse$1 ? first.offset : available - first.offset;
          offset = first.offset;
        }

        if (isFirst || isNewBlock || unit === 'offset') {
          yield {
            path,
            offset
          };
        }

        while (true) {
          // If there's no more string, continue to the next block.
          if (string === '') {
            break;
          } else {
            advance();
          } // If the available space hasn't overflow, we have another point to
          // yield in the current text node.


          if (available >= 0) {
            yield {
              path,
              offset
            };
          } else {
            break;
          }
        }

        isNewBlock = false;
      }
    }
  },

  /**
   * Get the matching node in the branch of the document before a location.
   */
  previous(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      mode = 'lowest',
      voids = false
    } = options;
    var {
      match,
      at = editor.selection
    } = options;

    if (!at) {
      return;
    }

    var [, from] = Editor.first(editor, at);
    var [, to] = Editor.first(editor, []);
    var span = [from, to];

    if (Path.isPath(at) && at.length === 0) {
      throw new Error("Cannot get the previous node from the root node!");
    }

    if (match == null) {
      if (Path.isPath(at)) {
        var [parent] = Editor.parent(editor, at);

        match = n => parent.children.includes(n);
      } else {
        match = () => true;
      }
    }

    var [, previous] = Editor.nodes(editor, {
      reverse: true,
      at: span,
      match,
      mode,
      voids
    });
    return previous;
  },

  /**
   * Get a range of a location.
   */
  range(editor, at, to) {
    if (Range.isRange(at) && !to) {
      return at;
    }

    var start = Editor.start(editor, at);
    var end = Editor.end(editor, to || at);
    return {
      anchor: start,
      focus: end
    };
  },

  /**
   * Create a mutable ref for a `Range` object, which will stay in sync as new
   * operations are applied to the editor.
   */
  rangeRef(editor, range) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      affinity = 'forward'
    } = options;
    var ref = {
      current: range,
      affinity,

      unref() {
        var {
          current
        } = ref;
        var rangeRefs = Editor.rangeRefs(editor);
        rangeRefs.delete(ref);
        ref.current = null;
        return current;
      }

    };
    var refs = Editor.rangeRefs(editor);
    refs.add(ref);
    return ref;
  },

  /**
   * Get the set of currently tracked range refs of the editor.
   */
  rangeRefs(editor) {
    var refs = RANGE_REFS.get(editor);

    if (!refs) {
      refs = new Set();
      RANGE_REFS.set(editor, refs);
    }

    return refs;
  },

  /**
   * Remove a custom property from all of the leaf text nodes in the current
   * selection.
   *
   * If the selection is currently collapsed, the removal will be stored on
   * `editor.marks` and applied to the text inserted next.
   */
  removeMark(editor, key) {
    editor.removeMark(key);
  },

  /**
   * Get the start point of a location.
   */
  start(editor, at) {
    return Editor.point(editor, at, {
      edge: 'start'
    });
  },

  /**
   * Get the text string content of a location.
   *
   * Note: the text of void nodes is presumed to be an empty string, regardless
   * of what their actual content is.
   */
  string(editor, at) {
    var range = Editor.range(editor, at);
    var [start, end] = Range.edges(range);
    var text = '';

    for (var [node, path] of Editor.nodes(editor, {
      at: range,
      match: Text.isText
    })) {
      var t = node.text;

      if (Path.equals(path, end.path)) {
        t = t.slice(0, end.offset);
      }

      if (Path.equals(path, start.path)) {
        t = t.slice(start.offset);
      }

      text += t;
    }

    return text;
  },

  /**
   * Transform the editor by an operation.
   */
  transform(editor, op) {
    editor.children = Object(immer__WEBPACK_IMPORTED_MODULE_1__["createDraft"])(editor.children);
    var selection = editor.selection && Object(immer__WEBPACK_IMPORTED_MODULE_1__["createDraft"])(editor.selection);

    switch (op.type) {
      case 'insert_node':
        {
          var {
            path,
            node
          } = op;
          var parent = Node.parent(editor, path);
          var index = path[path.length - 1];
          parent.children.splice(index, 0, node);

          if (selection) {
            for (var [point, key] of Range.points(selection)) {
              selection[key] = Point.transform(point, op);
            }
          }

          break;
        }

      case 'insert_text':
        {
          var {
            path: _path,
            offset,
            text
          } = op;

          var _node2 = Node.leaf(editor, _path);

          var before = _node2.text.slice(0, offset);

          var after = _node2.text.slice(offset);

          _node2.text = before + text + after;

          if (selection) {
            for (var [_point, _key] of Range.points(selection)) {
              selection[_key] = Point.transform(_point, op);
            }
          }

          break;
        }

      case 'merge_node':
        {
          var {
            path: _path2
          } = op;

          var _node3 = Node.get(editor, _path2);

          var prevPath = Path.previous(_path2);
          var prev = Node.get(editor, prevPath);

          var _parent = Node.parent(editor, _path2);

          var _index = _path2[_path2.length - 1];

          if (Text.isText(_node3) && Text.isText(prev)) {
            prev.text += _node3.text;
          } else if (!Text.isText(_node3) && !Text.isText(prev)) {
            prev.children.push(..._node3.children);
          } else {
            throw new Error("Cannot apply a \"merge_node\" operation at path [".concat(_path2, "] to nodes of different interaces: ").concat(_node3, " ").concat(prev));
          }

          _parent.children.splice(_index, 1);

          if (selection) {
            for (var [_point2, _key2] of Range.points(selection)) {
              selection[_key2] = Point.transform(_point2, op);
            }
          }

          break;
        }

      case 'move_node':
        {
          var {
            path: _path3,
            newPath
          } = op;

          if (Path.isAncestor(_path3, newPath)) {
            throw new Error("Cannot move a path [".concat(_path3, "] to new path [").concat(newPath, "] because the destination is inside itself."));
          }

          var _node4 = Node.get(editor, _path3);

          var _parent2 = Node.parent(editor, _path3);

          var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to
          // the same snapshot in time, there's a mismatch. After either
          // removing the original position, the second step's path can be out
          // of date. So instead of using the `op.newPath` directly, we
          // transform `op.path` to ascertain what the `newPath` would be after
          // the operation was applied.

          _parent2.children.splice(_index2, 1);

          var truePath = Path.transform(_path3, op);
          var newParent = Node.get(editor, Path.parent(truePath));
          var newIndex = truePath[truePath.length - 1];
          newParent.children.splice(newIndex, 0, _node4);

          if (selection) {
            for (var [_point3, _key3] of Range.points(selection)) {
              selection[_key3] = Point.transform(_point3, op);
            }
          }

          break;
        }

      case 'remove_node':
        {
          var {
            path: _path4
          } = op;
          var _index3 = _path4[_path4.length - 1];

          var _parent3 = Node.parent(editor, _path4);

          _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the
          // node that was removed we need to update the range or remove it.


          if (selection) {
            for (var [_point4, _key4] of Range.points(selection)) {
              var result = Point.transform(_point4, op);

              if (selection != null && result != null) {
                selection[_key4] = result;
              } else {
                var _prev = void 0;

                var next = void 0;

                for (var [n, p] of Node.texts(editor)) {
                  if (Path.compare(p, _path4) === -1) {
                    _prev = [n, p];
                  } else {
                    next = [n, p];
                    break;
                  }
                }

                if (_prev) {
                  _point4.path = _prev[1];
                  _point4.offset = _prev[0].text.length;
                } else if (next) {
                  _point4.path = next[1];
                  _point4.offset = 0;
                } else {
                  selection = null;
                }
              }
            }
          }

          break;
        }

      case 'remove_text':
        {
          var {
            path: _path5,
            offset: _offset,
            text: _text2
          } = op;

          var _node5 = Node.leaf(editor, _path5);

          var _before = _node5.text.slice(0, _offset);

          var _after = _node5.text.slice(_offset + _text2.length);

          _node5.text = _before + _after;

          if (selection) {
            for (var [_point5, _key5] of Range.points(selection)) {
              selection[_key5] = Point.transform(_point5, op);
            }
          }

          break;
        }

      case 'set_node':
        {
          var {
            path: _path6,
            newProperties
          } = op;

          if (_path6.length === 0) {
            throw new Error("Cannot set properties on the root node!");
          }

          var _node6 = Node.get(editor, _path6);

          for (var _key6 in newProperties) {
            if (_key6 === 'children' || _key6 === 'text') {
              throw new Error("Cannot set the \"".concat(_key6, "\" property of nodes!"));
            }

            var value = newProperties[_key6];

            if (value == null) {
              delete _node6[_key6];
            } else {
              _node6[_key6] = value;
            }
          }

          break;
        }

      case 'set_selection':
        {
          var {
            newProperties: _newProperties
          } = op;

          if (_newProperties == null) {
            selection = _newProperties;
          } else if (selection == null) {
            if (!Range.isRange(_newProperties)) {
              throw new Error("Cannot apply an incomplete \"set_selection\" operation properties ".concat(JSON.stringify(_newProperties), " when there is no current selection."));
            }

            selection = _newProperties;
          } else {
            Object.assign(selection, _newProperties);
          }

          break;
        }

      case 'split_node':
        {
          var {
            path: _path7,
            position,
            properties
          } = op;

          if (_path7.length === 0) {
            throw new Error("Cannot apply a \"split_node\" operation at path [".concat(_path7, "] because the root node cannot be split."));
          }

          var _node7 = Node.get(editor, _path7);

          var _parent4 = Node.parent(editor, _path7);

          var _index4 = _path7[_path7.length - 1];
          var newNode;

          if (Text.isText(_node7)) {
            var _before2 = _node7.text.slice(0, position);

            var _after2 = _node7.text.slice(position);

            _node7.text = _before2;
            newNode = _objectSpread({}, _node7, {}, properties, {
              text: _after2
            });
          } else {
            var _before3 = _node7.children.slice(0, position);

            var _after3 = _node7.children.slice(position);

            _node7.children = _before3;
            newNode = _objectSpread({}, _node7, {}, properties, {
              children: _after3
            });
          }

          _parent4.children.splice(_index4 + 1, 0, newNode);

          if (selection) {
            for (var [_point6, _key7] of Range.points(selection)) {
              selection[_key7] = Point.transform(_point6, op);
            }
          }

          break;
        }
    }

    editor.children = Object(immer__WEBPACK_IMPORTED_MODULE_1__["finishDraft"])(editor.children);

    if (selection) {
      editor.selection = Object(immer__WEBPACK_IMPORTED_MODULE_1__["isDraft"])(selection) ? Object(immer__WEBPACK_IMPORTED_MODULE_1__["finishDraft"])(selection) : selection;
    } else {
      editor.selection = null;
    }
  },

  /**
   * Convert a range into a non-hanging one.
   */
  unhangRange(editor, range) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      voids = false
    } = options;
    var [start, end] = Range.edges(range); // PERF: exit early if we can guarantee that the range isn't hanging.

    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range)) {
      return range;
    }

    var endBlock = Editor.above(editor, {
      at: end,
      match: n => Editor.isBlock(editor, n)
    });
    var blockPath = endBlock ? endBlock[1] : [];
    var first = Editor.start(editor, []);
    var before = {
      anchor: first,
      focus: end
    };
    var skip = true;

    for (var [node, path] of Editor.nodes(editor, {
      at: before,
      match: Text.isText,
      reverse: true,
      voids
    })) {
      if (skip) {
        skip = false;
        continue;
      }

      if (node.text !== '' || Path.isBefore(path, blockPath)) {
        end = {
          path,
          offset: node.text.length
        };
        break;
      }
    }

    return {
      anchor: start,
      focus: end
    };
  },

  /**
   * Match a void node in the current branch of the editor.
   */
  void(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return Editor.above(editor, _objectSpread({}, options, {
      match: n => Editor.isVoid(editor, n)
    }));
  },

  /**
   * Call a function, deferring normalization until after it completes.
   */
  withoutNormalizing(editor, fn) {
    var value = Editor.isNormalizing(editor);
    NORMALIZING.set(editor, false);
    fn();
    NORMALIZING.set(editor, value);
    Editor.normalize(editor);
  }

};

var Element = {
  /**
   * Check if a value implements the `Element` interface.
   */
  isElement(value) {
    return Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);
  },

  /**
   * Check if a value is an array of `Element` objects.
   */
  isElementList(value) {
    return Array.isArray(value) && (value.length === 0 || Element.isElement(value[0]));
  },

  /**
   * Check if an element matches set of properties.
   *
   * Note: this checks custom properties, and it does not ensure that any
   * children are equivalent.
   */
  matches(element, props) {
    for (var key in props) {
      if (key === 'children') {
        continue;
      }

      if (element[key] !== props[key]) {
        return false;
      }
    }

    return true;
  }

};

var Location = {
  /**
   * Check if a value implements the `Location` interface.
   */
  isLocation(value) {
    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);
  }

};
var Span = {
  /**
   * Check if a value implements the `Span` interface.
   */
  isSpan(value) {
    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);
  }

};

var Node = {
  /**
   * Get the node at a specific path, asserting that it's an ancestor node.
   */
  ancestor(root, path) {
    var node = Node.get(root, path);

    if (Text.isText(node)) {
      throw new Error("Cannot get the ancestor node at path [".concat(path, "] because it refers to a text node instead: ").concat(node));
    }

    return node;
  },

  /**
   * Return an iterable of all the ancestor nodes above a specific path.
   *
   * By default the order is bottom-up, from lowest to highest ancestor in
   * the tree, but you can pass the `reverse: true` option to go top-down.
   */
  *ancestors(root, path) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    for (var p of Path.ancestors(path, options)) {
      var n = Node.ancestor(root, p);
      var entry = [n, p];
      yield entry;
    }
  },

  /**
   * Get the child of a node at a specific index.
   */
  child(root, index) {
    if (Text.isText(root)) {
      throw new Error("Cannot get the child of a text node: ".concat(JSON.stringify(root)));
    }

    var c = root.children[index];

    if (c == null) {
      throw new Error("Cannot get child at index `".concat(index, "` in node: ").concat(JSON.stringify(root)));
    }

    return c;
  },

  /**
   * Iterate over the children of a node at a specific path.
   */
  *children(root, path) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      reverse = false
    } = options;
    var ancestor = Node.ancestor(root, path);
    var {
      children
    } = ancestor;
    var index = reverse ? children.length - 1 : 0;

    while (reverse ? index >= 0 : index < children.length) {
      var child = Node.child(ancestor, index);
      var childPath = path.concat(index);
      yield [child, childPath];
      index = reverse ? index - 1 : index + 1;
    }
  },

  /**
   * Get an entry for the common ancesetor node of two paths.
   */
  common(root, path, another) {
    var p = Path.common(path, another);
    var n = Node.get(root, p);
    return [n, p];
  },

  /**
   * Get the node at a specific path, asserting that it's a descendant node.
   */
  descendant(root, path) {
    var node = Node.get(root, path);

    if (Editor.isEditor(node)) {
      throw new Error("Cannot get the descendant node at path [".concat(path, "] because it refers to the root editor node instead: ").concat(node));
    }

    return node;
  },

  /**
   * Return an iterable of all the descendant node entries inside a root node.
   */
  *descendants(root) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    for (var [node, path] of Node.nodes(root, options)) {
      if (path.length !== 0) {
        // NOTE: we have to coerce here because checking the path's length does
        // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.
        yield [node, path];
      }
    }
  },

  /**
   * Return an iterable of all the element nodes inside a root node. Each iteration
   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the
   * root node is an element it will be included in the iteration as well.
   */
  *elements(root) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    for (var [node, path] of Node.nodes(root, options)) {
      if (Element.isElement(node)) {
        yield [node, path];
      }
    }
  },

  /**
   * Get the first node entry in a root node from a path.
   */
  first(root, path) {
    var p = path.slice();
    var n = Node.get(root, p);

    while (n) {
      if (Text.isText(n) || n.children.length === 0) {
        break;
      } else {
        n = n.children[0];
        p.push(0);
      }
    }

    return [n, p];
  },

  /**
   * Get the sliced fragment represented by a range inside a root node.
   */
  fragment(root, range) {
    if (Text.isText(root)) {
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(JSON.stringify(root)));
    }

    var newRoot = Object(immer__WEBPACK_IMPORTED_MODULE_1__["produce"])(root, r => {
      var [start, end] = Range.edges(range);
      var iterable = Node.nodes(r, {
        reverse: true,
        pass: (_ref) => {
          var [, path] = _ref;
          return !Range.includes(range, path);
        }
      });

      for (var [, path] of iterable) {
        if (!Range.includes(range, path)) {
          var parent = Node.parent(r, path);
          var index = path[path.length - 1];
          parent.children.splice(index, 1);
        }

        if (Path.equals(path, end.path)) {
          var leaf = Node.leaf(r, path);
          leaf.text = leaf.text.slice(0, end.offset);
        }

        if (Path.equals(path, start.path)) {
          var _leaf = Node.leaf(r, path);

          _leaf.text = _leaf.text.slice(start.offset);
        }
      }

      delete r.selection;
    });
    return newRoot.children;
  },

  /**
   * Get the descendant node referred to by a specific path. If the path is an
   * empty array, it refers to the root node itself.
   */
  get(root, path) {
    var node = root;

    for (var i = 0; i < path.length; i++) {
      var p = path[i];

      if (Text.isText(node) || !node.children[p]) {
        throw new Error("Cannot find a descendant at path [".concat(path, "] in node: ").concat(JSON.stringify(root)));
      }

      node = node.children[p];
    }

    return node;
  },

  /**
   * Check if a descendant node exists at a specific path.
   */
  has(root, path) {
    var node = root;

    for (var i = 0; i < path.length; i++) {
      var p = path[i];

      if (Text.isText(node) || !node.children[p]) {
        return false;
      }

      node = node.children[p];
    }

    return true;
  },

  /**
   * Check if a value implements the `Node` interface.
   */
  isNode(value) {
    return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);
  },

  /**
   * Check if a value is a list of `Node` objects.
   */
  isNodeList(value) {
    return Array.isArray(value) && (value.length === 0 || Node.isNode(value[0]));
  },

  /**
   * Get the lash node entry in a root node from a path.
   */
  last(root, path) {
    var p = path.slice();
    var n = Node.get(root, p);

    while (n) {
      if (Text.isText(n) || n.children.length === 0) {
        break;
      } else {
        var i = n.children.length - 1;
        n = n.children[i];
        p.push(i);
      }
    }

    return [n, p];
  },

  /**
   * Get the node at a specific path, ensuring it's a leaf text node.
   */
  leaf(root, path) {
    var node = Node.get(root, path);

    if (!Text.isText(node)) {
      throw new Error("Cannot get the leaf node at path [".concat(path, "] because it refers to a non-leaf node: ").concat(node));
    }

    return node;
  },

  /**
   * Return an iterable of the in a branch of the tree, from a specific path.
   *
   * By default the order is top-down, from lowest to highest node in the tree,
   * but you can pass the `reverse: true` option to go bottom-up.
   */
  *levels(root, path) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    for (var p of Path.levels(path, options)) {
      var n = Node.get(root, p);
      yield [n, p];
    }
  },

  /**
   * Check if a node matches a set of props.
   */
  matches(node, props) {
    return Element.isElement(node) && Element.matches(node, props) || Text.isText(node) && Text.matches(node, props);
  },

  /**
   * Return an iterable of all the node entries of a root node. Each entry is
   * returned as a `[Node, Path]` tuple, with the path referring to the node's
   * position inside the root node.
   */
  *nodes(root) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      pass,
      reverse = false
    } = options;
    var {
      from = [],
      to
    } = options;
    var visited = new Set();
    var p = [];
    var n = root;

    while (true) {
      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {
        break;
      }

      if (!visited.has(n)) {
        yield [n, p];
      } // If we're allowed to go downward and we haven't decsended yet, do.


      if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([n, p]) === false)) {
        visited.add(n);
        var nextIndex = reverse ? n.children.length - 1 : 0;

        if (Path.isAncestor(p, from)) {
          nextIndex = from[p.length];
        }

        p = p.concat(nextIndex);
        n = Node.get(root, p);
        continue;
      } // If we're at the root and we can't go down, we're done.


      if (p.length === 0) {
        break;
      } // If we're going forward...


      if (!reverse) {
        var newPath = Path.next(p);

        if (Node.has(root, newPath)) {
          p = newPath;
          n = Node.get(root, p);
          continue;
        }
      } // If we're going backward...


      if (reverse && p[p.length - 1] !== 0) {
        var _newPath = Path.previous(p);

        p = _newPath;
        n = Node.get(root, p);
        continue;
      } // Otherwise we're going upward...


      p = Path.parent(p);
      n = Node.get(root, p);
      visited.add(n);
    }
  },

  /**
   * Get the parent of a node at a specific path.
   */
  parent(root, path) {
    var parentPath = Path.parent(path);
    var p = Node.get(root, parentPath);

    if (Text.isText(p)) {
      throw new Error("Cannot get the parent of path [".concat(path, "] because it does not exist in the root."));
    }

    return p;
  },

  /**
   * Get the concatenated text string of a node's content.
   *
   * Note that this will not include spaces or line breaks between block nodes.
   * It is not a user-facing string, but a string for performing offset-related
   * computations for a node.
   */
  string(node) {
    if (Text.isText(node)) {
      return node.text;
    } else {
      return node.children.map(Node.string).join('');
    }
  },

  /**
   * Return an iterable of all leaf text nodes in a root node.
   */
  *texts(root) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    for (var [node, path] of Node.nodes(root, options)) {
      if (Text.isText(node)) {
        yield [node, path];
      }
    }
  }

};

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var Operation = {
  /**
   * Check of a value is a `NodeOperation` object.
   */
  isNodeOperation(value) {
    return Operation.isOperation(value) && value.type.endsWith('_node');
  },

  /**
   * Check of a value is an `Operation` object.
   */
  isOperation(value) {
    if (!Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
      return false;
    }

    switch (value.type) {
      case 'insert_node':
        return Path.isPath(value.path) && Node.isNode(value.node);

      case 'insert_text':
        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);

      case 'merge_node':
        return typeof value.position === 'number' && (typeof value.target === 'number' || value.target === null) && Path.isPath(value.path) && Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value.properties);

      case 'move_node':
        return Path.isPath(value.path) && Path.isPath(value.newPath);

      case 'remove_node':
        return Path.isPath(value.path) && Node.isNode(value.node);

      case 'remove_text':
        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);

      case 'set_node':
        return Path.isPath(value.path) && Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value.properties) && Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value.newProperties);

      case 'set_selection':
        return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value.properties) && Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value.newProperties);

      case 'split_node':
        return Path.isPath(value.path) && typeof value.position === 'number' && (typeof value.target === 'number' || value.target === null) && Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value.properties);

      default:
        return false;
    }
  },

  /**
   * Check if a value is a list of `Operation` objects.
   */
  isOperationList(value) {
    return Array.isArray(value) && (value.length === 0 || Operation.isOperation(value[0]));
  },

  /**
   * Check of a value is a `SelectionOperation` object.
   */
  isSelectionOperation(value) {
    return Operation.isOperation(value) && value.type.endsWith('_selection');
  },

  /**
   * Check of a value is a `TextOperation` object.
   */
  isTextOperation(value) {
    return Operation.isOperation(value) && value.type.endsWith('_text');
  },

  /**
   * Invert an operation, returning a new operation that will exactly undo the
   * original when applied.
   */
  inverse(op) {
    switch (op.type) {
      case 'insert_node':
        {
          return _objectSpread$1({}, op, {
            type: 'remove_node'
          });
        }

      case 'insert_text':
        {
          return _objectSpread$1({}, op, {
            type: 'remove_text'
          });
        }

      case 'merge_node':
        {
          return _objectSpread$1({}, op, {
            type: 'split_node',
            path: Path.previous(op.path)
          });
        }

      case 'move_node':
        {
          var {
            newPath,
            path
          } = op; // PERF: in this case the move operation is a no-op anyways.

          if (Path.equals(newPath, path)) {
            return op;
          } // If the move happens completely within a single parent the path and
          // newPath are stable with respect to each other.


          if (Path.isSibling(path, newPath)) {
            return _objectSpread$1({}, op, {
              path: newPath,
              newPath: path
            });
          } // If the move does not happen within a single parent it is possible
          // for the move to impact the true path to the location where the node
          // was removed from and where it was inserted. We have to adjust for this
          // and find the original path. We can accomplish this (only in non-sibling)
          // moves by looking at the impact of the move operation on the node
          // after the original move path.


          var inversePath = Path.transform(path, op);
          var inverseNewPath = Path.transform(Path.next(path), op);
          return _objectSpread$1({}, op, {
            path: inversePath,
            newPath: inverseNewPath
          });
        }

      case 'remove_node':
        {
          return _objectSpread$1({}, op, {
            type: 'insert_node'
          });
        }

      case 'remove_text':
        {
          return _objectSpread$1({}, op, {
            type: 'insert_text'
          });
        }

      case 'set_node':
        {
          var {
            properties,
            newProperties
          } = op;
          return _objectSpread$1({}, op, {
            properties: newProperties,
            newProperties: properties
          });
        }

      case 'set_selection':
        {
          var {
            properties: _properties,
            newProperties: _newProperties
          } = op;

          if (_properties == null) {
            return _objectSpread$1({}, op, {
              properties: _newProperties,
              newProperties: null
            });
          } else if (_newProperties == null) {
            return _objectSpread$1({}, op, {
              properties: null,
              newProperties: _properties
            });
          } else {
            return _objectSpread$1({}, op, {
              properties: _newProperties,
              newProperties: _properties
            });
          }
        }

      case 'split_node':
        {
          return _objectSpread$1({}, op, {
            type: 'merge_node',
            path: Path.next(op.path)
          });
        }
    }
  }

};

var Path = {
  /**
   * Get a list of ancestor paths for a given path.
   *
   * The paths are sorted from deepest to shallowest ancestor. However, if the
   * `reverse: true` option is passed, they are reversed.
   */
  ancestors(path) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      reverse = false
    } = options;
    var paths = Path.levels(path, options);

    if (reverse) {
      paths = paths.slice(1);
    } else {
      paths = paths.slice(0, -1);
    }

    return paths;
  },

  /**
   * Get the common ancestor path of two paths.
   */
  common(path, another) {
    var common = [];

    for (var i = 0; i < path.length && i < another.length; i++) {
      var av = path[i];
      var bv = another[i];

      if (av !== bv) {
        break;
      }

      common.push(av);
    }

    return common;
  },

  /**
   * Compare a path to another, returning an integer indicating whether the path
   * was before, at, or after the other.
   *
   * Note: Two paths of unequal length can still receive a `0` result if one is
   * directly above or below the other. If you want exact matching, use
   * [[Path.equals]] instead.
   */
  compare(path, another) {
    var min = Math.min(path.length, another.length);

    for (var i = 0; i < min; i++) {
      if (path[i] < another[i]) return -1;
      if (path[i] > another[i]) return 1;
    }

    return 0;
  },

  /**
   * Check if a path ends after one of the indexes in another.
   */
  endsAfter(path, another) {
    var i = path.length - 1;
    var as = path.slice(0, i);
    var bs = another.slice(0, i);
    var av = path[i];
    var bv = another[i];
    return Path.equals(as, bs) && av > bv;
  },

  /**
   * Check if a path ends at one of the indexes in another.
   */
  endsAt(path, another) {
    var i = path.length;
    var as = path.slice(0, i);
    var bs = another.slice(0, i);
    return Path.equals(as, bs);
  },

  /**
   * Check if a path ends before one of the indexes in another.
   */
  endsBefore(path, another) {
    var i = path.length - 1;
    var as = path.slice(0, i);
    var bs = another.slice(0, i);
    var av = path[i];
    var bv = another[i];
    return Path.equals(as, bs) && av < bv;
  },

  /**
   * Check if a path is exactly equal to another.
   */
  equals(path, another) {
    return path.length === another.length && path.every((n, i) => n === another[i]);
  },

  /**
   * Check if a path is after another.
   */
  isAfter(path, another) {
    return Path.compare(path, another) === 1;
  },

  /**
   * Check if a path is an ancestor of another.
   */
  isAncestor(path, another) {
    return path.length < another.length && Path.compare(path, another) === 0;
  },

  /**
   * Check if a path is before another.
   */
  isBefore(path, another) {
    return Path.compare(path, another) === -1;
  },

  /**
   * Check if a path is a child of another.
   */
  isChild(path, another) {
    return path.length === another.length + 1 && Path.compare(path, another) === 0;
  },

  /**
   * Check if a path is equal to or an ancestor of another.
   */
  isCommon(path, another) {
    return path.length <= another.length && Path.compare(path, another) === 0;
  },

  /**
   * Check if a path is a descendant of another.
   */
  isDescendant(path, another) {
    return path.length > another.length && Path.compare(path, another) === 0;
  },

  /**
   * Check if a path is the parent of another.
   */
  isParent(path, another) {
    return path.length + 1 === another.length && Path.compare(path, another) === 0;
  },

  /**
   * Check is a value implements the `Path` interface.
   */
  isPath(value) {
    return Array.isArray(value) && (value.length === 0 || typeof value[0] === 'number');
  },

  /**
   * Check if a path is a sibling of another.
   */
  isSibling(path, another) {
    if (path.length !== another.length) {
      return false;
    }

    var as = path.slice(0, -1);
    var bs = another.slice(0, -1);
    var al = path[path.length - 1];
    var bl = another[another.length - 1];
    return al !== bl && Path.equals(as, bs);
  },

  /**
   * Get a list of paths at every level down to a path. Note: this is the same
   * as `Path.ancestors`, but including the path itself.
   *
   * The paths are sorted from shallowest to deepest. However, if the `reverse:
   * true` option is passed, they are reversed.
   */
  levels(path) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      reverse = false
    } = options;
    var list = [];

    for (var i = 0; i <= path.length; i++) {
      list.push(path.slice(0, i));
    }

    if (reverse) {
      list.reverse();
    }

    return list;
  },

  /**
   * Given a path, get the path to the next sibling node.
   */
  next(path) {
    if (path.length === 0) {
      throw new Error("Cannot get the next path of a root path [".concat(path, "], because it has no next index."));
    }

    var last = path[path.length - 1];
    return path.slice(0, -1).concat(last + 1);
  },

  /**
   * Given a path, return a new path referring to the parent node above it.
   */
  parent(path) {
    if (path.length === 0) {
      throw new Error("Cannot get the parent path of the root path [".concat(path, "]."));
    }

    return path.slice(0, -1);
  },

  /**
   * Given a path, get the path to the previous sibling node.
   */
  previous(path) {
    if (path.length === 0) {
      throw new Error("Cannot get the previous path of a root path [".concat(path, "], because it has no previous index."));
    }

    var last = path[path.length - 1];

    if (last <= 0) {
      throw new Error("Cannot get the previous path of a first child path [".concat(path, "] because it would result in a negative index."));
    }

    return path.slice(0, -1).concat(last - 1);
  },

  /**
   * Get a path relative to an ancestor.
   */
  relative(path, ancestor) {
    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {
      throw new Error("Cannot get the relative path of [".concat(path, "] inside ancestor [").concat(ancestor, "], because it is not above or equal to the path."));
    }

    return path.slice(ancestor.length);
  },

  /**
   * Transform a path by an operation.
   */
  transform(path, operation) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return Object(immer__WEBPACK_IMPORTED_MODULE_1__["produce"])(path, p => {
      var {
        affinity = 'forward'
      } = options; // PERF: Exit early if the operation is guaranteed not to have an effect.

      if (path.length === 0) {
        return;
      }

      switch (operation.type) {
        case 'insert_node':
          {
            var {
              path: op
            } = operation;

            if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {
              p[op.length - 1] += 1;
            }

            break;
          }

        case 'remove_node':
          {
            var {
              path: _op
            } = operation;

            if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {
              return null;
            } else if (Path.endsBefore(_op, p)) {
              p[_op.length - 1] -= 1;
            }

            break;
          }

        case 'merge_node':
          {
            var {
              path: _op2,
              position
            } = operation;

            if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {
              p[_op2.length - 1] -= 1;
            } else if (Path.isAncestor(_op2, p)) {
              p[_op2.length - 1] -= 1;
              p[_op2.length] += position;
            }

            break;
          }

        case 'split_node':
          {
            var {
              path: _op3,
              position: _position
            } = operation;

            if (Path.equals(_op3, p)) {
              if (affinity === 'forward') {
                p[p.length - 1] += 1;
              } else if (affinity === 'backward') ; else {
                return null;
              }
            } else if (Path.endsBefore(_op3, p)) {
              p[_op3.length - 1] += 1;
            } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {
              p[_op3.length - 1] += 1;
              p[_op3.length] -= _position;
            }

            break;
          }

        case 'move_node':
          {
            var {
              path: _op4,
              newPath: onp
            } = operation; // If the old and new path are the same, it's a no-op.

            if (Path.equals(_op4, onp)) {
              return;
            }

            if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {
              var copy = onp.slice();

              if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {
                copy[_op4.length - 1] -= 1;
              }

              return copy.concat(p.slice(_op4.length));
            } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {
              if (Path.endsBefore(_op4, p)) {
                p[_op4.length - 1] -= 1;
              } else {
                p[_op4.length - 1] += 1;
              }
            } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {
              if (Path.endsBefore(_op4, p)) {
                p[_op4.length - 1] -= 1;
              }

              p[onp.length - 1] += 1;
            } else if (Path.endsBefore(_op4, p)) {
              if (Path.equals(onp, p)) {
                p[onp.length - 1] += 1;
              }

              p[_op4.length - 1] -= 1;
            }

            break;
          }
      }
    });
  }

};

var PathRef = {
  /**
   * Transform the path ref's current value by an operation.
   */
  transform(ref, op) {
    var {
      current,
      affinity
    } = ref;

    if (current == null) {
      return;
    }

    var path = Path.transform(current, op, {
      affinity
    });
    ref.current = path;

    if (path == null) {
      ref.unref();
    }
  }

};

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var Point = {
  /**
   * Compare a point to another, returning an integer indicating whether the
   * point was before, at, or after the other.
   */
  compare(point, another) {
    var result = Path.compare(point.path, another.path);

    if (result === 0) {
      if (point.offset < another.offset) return -1;
      if (point.offset > another.offset) return 1;
      return 0;
    }

    return result;
  },

  /**
   * Check if a point is after another.
   */
  isAfter(point, another) {
    return Point.compare(point, another) === 1;
  },

  /**
   * Check if a point is before another.
   */
  isBefore(point, another) {
    return Point.compare(point, another) === -1;
  },

  /**
   * Check if a point is exactly equal to another.
   */
  equals(point, another) {
    // PERF: ensure the offsets are equal first since they are cheaper to check.
    return point.offset === another.offset && Path.equals(point.path, another.path);
  },

  /**
   * Check if a value implements the `Point` interface.
   */
  isPoint(value) {
    return Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && typeof value.offset === 'number' && Path.isPath(value.path);
  },

  /**
   * Transform a point by an operation.
   */
  transform(point, op) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return Object(immer__WEBPACK_IMPORTED_MODULE_1__["produce"])(point, p => {
      var {
        affinity = 'forward'
      } = options;
      var {
        path,
        offset
      } = p;

      switch (op.type) {
        case 'insert_node':
        case 'move_node':
          {
            p.path = Path.transform(path, op, options);
            break;
          }

        case 'insert_text':
          {
            if (Path.equals(op.path, path) && op.offset <= offset) {
              p.offset += op.text.length;
            }

            break;
          }

        case 'merge_node':
          {
            if (Path.equals(op.path, path)) {
              p.offset += op.position;
            }

            p.path = Path.transform(path, op, options);
            break;
          }

        case 'remove_text':
          {
            if (Path.equals(op.path, path) && op.offset <= offset) {
              p.offset -= Math.min(offset - op.offset, op.text.length);
            }

            break;
          }

        case 'remove_node':
          {
            if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {
              return null;
            }

            p.path = Path.transform(path, op, options);
            break;
          }

        case 'split_node':
          {
            if (Path.equals(op.path, path)) {
              if (op.position === offset && affinity == null) {
                return null;
              } else if (op.position < offset || op.position === offset && affinity === 'forward') {
                p.offset -= op.position;
                p.path = Path.transform(path, op, _objectSpread$2({}, options, {
                  affinity: 'forward'
                }));
              }
            } else {
              p.path = Path.transform(path, op, options);
            }

            break;
          }
      }
    });
  }

};

var PointRef = {
  /**
   * Transform the point ref's current value by an operation.
   */
  transform(ref, op) {
    var {
      current,
      affinity
    } = ref;

    if (current == null) {
      return;
    }

    var point = Point.transform(current, op, {
      affinity
    });
    ref.current = point;

    if (point == null) {
      ref.unref();
    }
  }

};

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var Range = {
  /**
   * Get the start and end points of a range, in the order in which they appear
   * in the document.
   */
  edges(range) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      reverse = false
    } = options;
    var {
      anchor,
      focus
    } = range;
    return Range.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];
  },

  /**
   * Get the end point of a range.
   */
  end(range) {
    var [, end] = Range.edges(range);
    return end;
  },

  /**
   * Check if a range is exactly equal to another.
   */
  equals(range, another) {
    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);
  },

  /**
   * Check if a range includes a path, a point or part of another range.
   */
  includes(range, target) {
    if (Range.isRange(target)) {
      if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {
        return true;
      }

      var [rs, re] = Range.edges(range);
      var [ts, te] = Range.edges(target);
      return Point.isBefore(rs, ts) && Point.isAfter(re, te);
    }

    var [start, end] = Range.edges(range);
    var isAfterStart = false;
    var isBeforeEnd = false;

    if (Point.isPoint(target)) {
      isAfterStart = Point.compare(target, start) >= 0;
      isBeforeEnd = Point.compare(target, end) <= 0;
    } else {
      isAfterStart = Path.compare(target, start.path) >= 0;
      isBeforeEnd = Path.compare(target, end.path) <= 0;
    }

    return isAfterStart && isBeforeEnd;
  },

  /**
   * Get the intersection of a range with another.
   */
  intersection(range, another) {
    var rest = _objectWithoutProperties(range, ["anchor", "focus"]);

    var [s1, e1] = Range.edges(range);
    var [s2, e2] = Range.edges(another);
    var start = Point.isBefore(s1, s2) ? s2 : s1;
    var end = Point.isBefore(e1, e2) ? e1 : e2;

    if (Point.isBefore(end, start)) {
      return null;
    } else {
      return _objectSpread$3({
        anchor: start,
        focus: end
      }, rest);
    }
  },

  /**
   * Check if a range is backward, meaning that its anchor point appears in the
   * document _after_ its focus point.
   */
  isBackward(range) {
    var {
      anchor,
      focus
    } = range;
    return Point.isAfter(anchor, focus);
  },

  /**
   * Check if a range is collapsed, meaning that both its anchor and focus
   * points refer to the exact same position in the document.
   */
  isCollapsed(range) {
    var {
      anchor,
      focus
    } = range;
    return Point.equals(anchor, focus);
  },

  /**
   * Check if a range is expanded.
   *
   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.
   */
  isExpanded(range) {
    return !Range.isCollapsed(range);
  },

  /**
   * Check if a range is forward.
   *
   * This is the opposite of [[Range.isBackward]] and is provided for legibility.
   */
  isForward(range) {
    return !Range.isBackward(range);
  },

  /**
   * Check if a value implements the [[Range]] interface.
   */
  isRange(value) {
    return Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);
  },

  /**
   * Iterate through all of the point entries in a range.
   */
  *points(range) {
    yield [range.anchor, 'anchor'];
    yield [range.focus, 'focus'];
  },

  /**
   * Get the start point of a range.
   */
  start(range) {
    var [start] = Range.edges(range);
    return start;
  },

  /**
   * Transform a range by an operation.
   */
  transform(range, op, options) {
    var {
      affinity = 'inward'
    } = options;
    var affinityAnchor;
    var affinityFocus;

    if (affinity === 'inward') {
      if (Range.isForward(range)) {
        affinityAnchor = 'forward';
        affinityFocus = 'backward';
      } else {
        affinityAnchor = 'backward';
        affinityFocus = 'forward';
      }
    } else if (affinity === 'outward') {
      if (Range.isForward(range)) {
        affinityAnchor = 'backward';
        affinityFocus = 'forward';
      } else {
        affinityAnchor = 'forward';
        affinityFocus = 'backward';
      }
    } else {
      affinityAnchor = affinity;
      affinityFocus = affinity;
    }

    return Object(immer__WEBPACK_IMPORTED_MODULE_1__["produce"])(range, r => {
      var anchor = Point.transform(r.anchor, op, {
        affinity: affinityAnchor
      });
      var focus = Point.transform(r.focus, op, {
        affinity: affinityFocus
      });

      if (!anchor || !focus) {
        return null;
      }

      r.anchor = anchor;
      r.focus = focus;
    });
  }

};

var RangeRef = {
  /**
   * Transform the range ref's current value by an operation.
   */
  transform(ref, op) {
    var {
      current,
      affinity
    } = ref;

    if (current == null) {
      return;
    }

    var path = Range.transform(current, op, {
      affinity
    });
    ref.current = path;

    if (path == null) {
      ref.unref();
    }
  }

};

function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var Text = {
  /**
   * Check if two text nodes are equal.
   */
  equals(text, another) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      loose = false
    } = options;

    for (var key in text) {
      if (loose && key === 'text') {
        continue;
      }

      if (text[key] !== another[key]) {
        return false;
      }
    }

    for (var _key in another) {
      if (loose && _key === 'text') {
        continue;
      }

      if (text[_key] !== another[_key]) {
        return false;
      }
    }

    return true;
  },

  /**
   * Check if a value implements the `Text` interface.
   */
  isText(value) {
    return Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && typeof value.text === 'string';
  },

  /**
   * Check if a value is a list of `Text` objects.
   */
  isTextList(value) {
    return Array.isArray(value) && (value.length === 0 || Text.isText(value[0]));
  },

  /**
   * Check if an text matches set of properties.
   *
   * Note: this is for matching custom properties, and it does not ensure that
   * the `text` property are two nodes equal.
   */
  matches(text, props) {
    for (var key in props) {
      if (key === 'text') {
        continue;
      }

      if (text[key] !== props[key]) {
        return false;
      }
    }

    return true;
  },

  /**
   * Get the leaves for a text node given decorations.
   */
  decorations(node, decorations) {
    var leaves = [_objectSpread$4({}, node)];

    for (var dec of decorations) {
      var rest = _objectWithoutProperties(dec, ["anchor", "focus"]);

      var [start, end] = Range.edges(dec);
      var next = [];
      var o = 0;

      for (var leaf of leaves) {
        var {
          length
        } = leaf.text;
        var offset = o;
        o += length; // If the range encompases the entire leaf, add the range.

        if (start.offset <= offset && end.offset >= offset + length) {
          Object.assign(leaf, rest);
          next.push(leaf);
          continue;
        } // If the range starts after the leaf, or ends before it, continue.


        if (start.offset > offset + length || end.offset < offset || end.offset === offset && offset !== 0) {
          next.push(leaf);
          continue;
        } // Otherwise we need to split the leaf, at the start, end, or both,
        // and add the range to the middle intersecting section. Do the end
        // split first since we don't need to update the offset that way.


        var middle = leaf;
        var before = void 0;
        var after = void 0;

        if (end.offset < offset + length) {
          var off = end.offset - offset;
          after = _objectSpread$4({}, middle, {
            text: middle.text.slice(off)
          });
          middle = _objectSpread$4({}, middle, {
            text: middle.text.slice(0, off)
          });
        }

        if (start.offset > offset) {
          var _off = start.offset - offset;

          before = _objectSpread$4({}, middle, {
            text: middle.text.slice(0, _off)
          });
          middle = _objectSpread$4({}, middle, {
            text: middle.text.slice(_off)
          });
        }

        Object.assign(middle, rest);

        if (before) {
          next.push(before);
        }

        next.push(middle);

        if (after) {
          next.push(after);
        }
      }

      leaves = next;
    }

    return leaves;
  }

};

function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var GeneralTransforms = {
  /**
   * Transform the editor by an operation.
   */
  transform(editor, op) {
    editor.children = Object(immer__WEBPACK_IMPORTED_MODULE_1__["createDraft"])(editor.children);
    var selection = editor.selection && Object(immer__WEBPACK_IMPORTED_MODULE_1__["createDraft"])(editor.selection);

    switch (op.type) {
      case 'insert_node':
        {
          var {
            path,
            node
          } = op;
          var parent = Node.parent(editor, path);
          var index = path[path.length - 1];
          parent.children.splice(index, 0, node);

          if (selection) {
            for (var [point, key] of Range.points(selection)) {
              selection[key] = Point.transform(point, op);
            }
          }

          break;
        }

      case 'insert_text':
        {
          var {
            path: _path,
            offset,
            text
          } = op;

          var _node = Node.leaf(editor, _path);

          var before = _node.text.slice(0, offset);

          var after = _node.text.slice(offset);

          _node.text = before + text + after;

          if (selection) {
            for (var [_point, _key] of Range.points(selection)) {
              selection[_key] = Point.transform(_point, op);
            }
          }

          break;
        }

      case 'merge_node':
        {
          var {
            path: _path2
          } = op;

          var _node2 = Node.get(editor, _path2);

          var prevPath = Path.previous(_path2);
          var prev = Node.get(editor, prevPath);

          var _parent = Node.parent(editor, _path2);

          var _index = _path2[_path2.length - 1];

          if (Text.isText(_node2) && Text.isText(prev)) {
            prev.text += _node2.text;
          } else if (!Text.isText(_node2) && !Text.isText(prev)) {
            prev.children.push(..._node2.children);
          } else {
            throw new Error("Cannot apply a \"merge_node\" operation at path [".concat(_path2, "] to nodes of different interaces: ").concat(_node2, " ").concat(prev));
          }

          _parent.children.splice(_index, 1);

          if (selection) {
            for (var [_point2, _key2] of Range.points(selection)) {
              selection[_key2] = Point.transform(_point2, op);
            }
          }

          break;
        }

      case 'move_node':
        {
          var {
            path: _path3,
            newPath
          } = op;

          if (Path.isAncestor(_path3, newPath)) {
            throw new Error("Cannot move a path [".concat(_path3, "] to new path [").concat(newPath, "] because the destination is inside itself."));
          }

          var _node3 = Node.get(editor, _path3);

          var _parent2 = Node.parent(editor, _path3);

          var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to
          // the same snapshot in time, there's a mismatch. After either
          // removing the original position, the second step's path can be out
          // of date. So instead of using the `op.newPath` directly, we
          // transform `op.path` to ascertain what the `newPath` would be after
          // the operation was applied.

          _parent2.children.splice(_index2, 1);

          var truePath = Path.transform(_path3, op);
          var newParent = Node.get(editor, Path.parent(truePath));
          var newIndex = truePath[truePath.length - 1];
          newParent.children.splice(newIndex, 0, _node3);

          if (selection) {
            for (var [_point3, _key3] of Range.points(selection)) {
              selection[_key3] = Point.transform(_point3, op);
            }
          }

          break;
        }

      case 'remove_node':
        {
          var {
            path: _path4
          } = op;
          var _index3 = _path4[_path4.length - 1];

          var _parent3 = Node.parent(editor, _path4);

          _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the
          // node that was removed we need to update the range or remove it.


          if (selection) {
            for (var [_point4, _key4] of Range.points(selection)) {
              var result = Point.transform(_point4, op);

              if (selection != null && result != null) {
                selection[_key4] = result;
              } else {
                var _prev = void 0;

                var next = void 0;

                for (var [n, p] of Node.texts(editor)) {
                  if (Path.compare(p, _path4) === -1) {
                    _prev = [n, p];
                  } else {
                    next = [n, p];
                    break;
                  }
                }

                if (_prev) {
                  _point4.path = _prev[1];
                  _point4.offset = _prev[0].text.length;
                } else if (next) {
                  _point4.path = next[1];
                  _point4.offset = 0;
                } else {
                  selection = null;
                }
              }
            }
          }

          break;
        }

      case 'remove_text':
        {
          var {
            path: _path5,
            offset: _offset,
            text: _text
          } = op;

          var _node4 = Node.leaf(editor, _path5);

          var _before = _node4.text.slice(0, _offset);

          var _after = _node4.text.slice(_offset + _text.length);

          _node4.text = _before + _after;

          if (selection) {
            for (var [_point5, _key5] of Range.points(selection)) {
              selection[_key5] = Point.transform(_point5, op);
            }
          }

          break;
        }

      case 'set_node':
        {
          var {
            path: _path6,
            newProperties
          } = op;

          if (_path6.length === 0) {
            throw new Error("Cannot set properties on the root node!");
          }

          var _node5 = Node.get(editor, _path6);

          for (var _key6 in newProperties) {
            if (_key6 === 'children' || _key6 === 'text') {
              throw new Error("Cannot set the \"".concat(_key6, "\" property of nodes!"));
            }

            var value = newProperties[_key6];

            if (value == null) {
              delete _node5[_key6];
            } else {
              _node5[_key6] = value;
            }
          }

          break;
        }

      case 'set_selection':
        {
          var {
            newProperties: _newProperties
          } = op;

          if (_newProperties == null) {
            selection = _newProperties;
          } else if (selection == null) {
            if (!Range.isRange(_newProperties)) {
              throw new Error("Cannot apply an incomplete \"set_selection\" operation properties ".concat(JSON.stringify(_newProperties), " when there is no current selection."));
            }

            selection = _newProperties;
          } else {
            Object.assign(selection, _newProperties);
          }

          break;
        }

      case 'split_node':
        {
          var {
            path: _path7,
            position,
            properties
          } = op;

          if (_path7.length === 0) {
            throw new Error("Cannot apply a \"split_node\" operation at path [".concat(_path7, "] because the root node cannot be split."));
          }

          var _node6 = Node.get(editor, _path7);

          var _parent4 = Node.parent(editor, _path7);

          var _index4 = _path7[_path7.length - 1];
          var newNode;

          if (Text.isText(_node6)) {
            var _before2 = _node6.text.slice(0, position);

            var _after2 = _node6.text.slice(position);

            _node6.text = _before2;
            newNode = _objectSpread$5({}, _node6, {}, properties, {
              text: _after2
            });
          } else {
            var _before3 = _node6.children.slice(0, position);

            var _after3 = _node6.children.slice(position);

            _node6.children = _before3;
            newNode = _objectSpread$5({}, _node6, {}, properties, {
              children: _after3
            });
          }

          _parent4.children.splice(_index4 + 1, 0, newNode);

          if (selection) {
            for (var [_point6, _key7] of Range.points(selection)) {
              selection[_key7] = Point.transform(_point6, op);
            }
          }

          break;
        }
    }

    editor.children = Object(immer__WEBPACK_IMPORTED_MODULE_1__["finishDraft"])(editor.children);

    if (selection) {
      editor.selection = Object(immer__WEBPACK_IMPORTED_MODULE_1__["isDraft"])(selection) ? Object(immer__WEBPACK_IMPORTED_MODULE_1__["finishDraft"])(selection) : selection;
    } else {
      editor.selection = null;
    }
  }

};

function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var NodeTransforms = {
  /**
   * Insert nodes at a specific location in the Editor.
   */
  insertNodes(editor, nodes) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false,
        mode = 'lowest'
      } = options;
      var {
        at,
        match,
        select
      } = options;

      if (Node.isNode(nodes)) {
        nodes = [nodes];
      }

      if (nodes.length === 0) {
        return;
      }

      var [node] = nodes; // By default, use the selection as the target location. But if there is
      // no selection, insert at the end of the document since that is such a
      // common use case when inserting from a non-selected state.

      if (!at) {
        if (editor.selection) {
          at = editor.selection;
        } else if (editor.children.length > 0) {
          at = Editor.end(editor, []);
        } else {
          at = [0];
        }

        select = true;
      }

      if (select == null) {
        select = false;
      }

      if (Range.isRange(at)) {
        if (!hanging) {
          at = Editor.unhangRange(editor, at);
        }

        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var [, end] = Range.edges(at);
          var pointRef = Editor.pointRef(editor, end);
          Transforms.delete(editor, {
            at
          });
          at = pointRef.unref();
        }
      }

      if (Point.isPoint(at)) {
        if (match == null) {
          if (Text.isText(node)) {
            match = n => Text.isText(n);
          } else if (editor.isInline(node)) {
            match = n => Text.isText(n) || Editor.isInline(editor, n);
          } else {
            match = n => Editor.isBlock(editor, n);
          }
        }

        var [entry] = Editor.nodes(editor, {
          at: at.path,
          match,
          mode,
          voids
        });

        if (entry) {
          var [, _matchPath] = entry;
          var pathRef = Editor.pathRef(editor, _matchPath);
          var isAtEnd = Editor.isEnd(editor, at, _matchPath);
          Transforms.splitNodes(editor, {
            at,
            match,
            mode,
            voids
          });
          var path = pathRef.unref();
          at = isAtEnd ? Path.next(path) : path;
        } else {
          return;
        }
      }

      var parentPath = Path.parent(at);
      var index = at[at.length - 1];

      if (!voids && Editor.void(editor, {
        at: parentPath
      })) {
        return;
      }

      for (var _node of nodes) {
        var _path = parentPath.concat(index);

        index++;
        editor.apply({
          type: 'insert_node',
          path: _path,
          node: _node
        });
      }

      if (select) {
        var point = Editor.end(editor, at);

        if (point) {
          Transforms.select(editor, point);
        }
      }
    });
  },

  /**
   * Lift nodes at a specific location upwards in the document tree, splitting
   * their parent in two if necessary.
   */
  liftNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        at = editor.selection,
        mode = 'lowest',
        voids = false
      } = options;
      var {
        match
      } = options;

      if (match == null) {
        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);
      }

      if (!at) {
        return;
      }

      var matches = Editor.nodes(editor, {
        at,
        match,
        mode,
        voids
      });
      var pathRefs = Array.from(matches, (_ref) => {
        var [, p] = _ref;
        return Editor.pathRef(editor, p);
      });

      for (var pathRef of pathRefs) {
        var path = pathRef.unref();

        if (path.length < 2) {
          throw new Error("Cannot lift node at a path [".concat(path, "] because it has a depth of less than `2`."));
        }

        var parentNodeEntry = Editor.node(editor, Path.parent(path));
        var [parent, parentPath] = parentNodeEntry;
        var index = path[path.length - 1];
        var {
          length
        } = parent.children;

        if (length === 1) {
          var toPath = Path.next(parentPath);
          Transforms.moveNodes(editor, {
            at: path,
            to: toPath,
            voids
          });
          Transforms.removeNodes(editor, {
            at: parentPath,
            voids
          });
        } else if (index === 0) {
          Transforms.moveNodes(editor, {
            at: path,
            to: parentPath,
            voids
          });
        } else if (index === length - 1) {
          var _toPath = Path.next(parentPath);

          Transforms.moveNodes(editor, {
            at: path,
            to: _toPath,
            voids
          });
        } else {
          var splitPath = Path.next(path);

          var _toPath2 = Path.next(parentPath);

          Transforms.splitNodes(editor, {
            at: splitPath,
            voids
          });
          Transforms.moveNodes(editor, {
            at: path,
            to: _toPath2,
            voids
          });
        }
      }
    });
  },

  /**
   * Merge a node at a location with the previous node of the same depth,
   * removing any empty containing nodes after the merge if necessary.
   */
  mergeNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        match,
        at = editor.selection
      } = options;
      var {
        hanging = false,
        voids = false,
        mode = 'lowest'
      } = options;

      if (!at) {
        return;
      }

      if (match == null) {
        if (Path.isPath(at)) {
          var [parent] = Editor.parent(editor, at);

          match = n => parent.children.includes(n);
        } else {
          match = n => Editor.isBlock(editor, n);
        }
      }

      if (!hanging && Range.isRange(at)) {
        at = Editor.unhangRange(editor, at);
      }

      if (Range.isRange(at)) {
        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var [, end] = Range.edges(at);
          var pointRef = Editor.pointRef(editor, end);
          Transforms.delete(editor, {
            at
          });
          at = pointRef.unref();

          if (options.at == null) {
            Transforms.select(editor, at);
          }
        }
      }

      var [current] = Editor.nodes(editor, {
        at,
        match,
        voids,
        mode
      });
      var prev = Editor.previous(editor, {
        at,
        match,
        voids,
        mode
      });

      if (!current || !prev) {
        return;
      }

      var [node, path] = current;
      var [prevNode, prevPath] = prev;

      if (path.length === 0 || prevPath.length === 0) {
        return;
      }

      var newPath = Path.next(prevPath);
      var commonPath = Path.common(path, prevPath);
      var isPreviousSibling = Path.isSibling(path, prevPath);
      var levels = Array.from(Editor.levels(editor, {
        at: path
      }), (_ref2) => {
        var [n] = _ref2;
        return n;
      }).slice(commonPath.length).slice(0, -1); // Determine if the merge will leave an ancestor of the path empty as a
      // result, in which case we'll want to remove it after merging.

      var emptyAncestor = Editor.above(editor, {
        at: path,
        mode: 'highest',
        match: n => levels.includes(n) && Element.isElement(n) && n.children.length === 1
      });
      var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);
      var properties;
      var position; // Ensure that the nodes are equivalent, and figure out what the position
      // and extra properties of the merge will be.

      if (Text.isText(node) && Text.isText(prevNode)) {
        var rest = _objectWithoutProperties(node, ["text"]);

        position = prevNode.text.length;
        properties = rest;
      } else if (Element.isElement(node) && Element.isElement(prevNode)) {
        var rest = _objectWithoutProperties(node, ["children"]);

        position = prevNode.children.length;
        properties = rest;
      } else {
        throw new Error("Cannot merge the node at path [".concat(path, "] with the previous sibling because it is not the same kind: ").concat(JSON.stringify(node), " ").concat(JSON.stringify(prevNode)));
      } // If the node isn't already the next sibling of the previous node, move
      // it so that it is before merging.


      if (!isPreviousSibling) {
        Transforms.moveNodes(editor, {
          at: path,
          to: newPath,
          voids
        });
      } // If there was going to be an empty ancestor of the node that was merged,
      // we remove it from the tree.


      if (emptyRef) {
        Transforms.removeNodes(editor, {
          at: emptyRef.current,
          voids
        });
      } // If the target node that we're merging with is empty, remove it instead
      // of merging the two. This is a common rich text editor behavior to
      // prevent losing formatting when deleting entire nodes when you have a
      // hanging selection.


      if (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === '') {
        Transforms.removeNodes(editor, {
          at: prevPath,
          voids
        });
      } else {
        editor.apply({
          type: 'merge_node',
          path: newPath,
          position,
          target: null,
          properties
        });
      }

      if (emptyRef) {
        emptyRef.unref();
      }
    });
  },

  /**
   * Move the nodes at a location to a new location.
   */
  moveNodes(editor, options) {
    Editor.withoutNormalizing(editor, () => {
      var {
        to,
        at = editor.selection,
        mode = 'lowest',
        voids = false
      } = options;
      var {
        match
      } = options;

      if (!at) {
        return;
      }

      if (match == null) {
        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);
      }

      var toRef = Editor.pathRef(editor, to);
      var targets = Editor.nodes(editor, {
        at,
        match,
        mode,
        voids
      });
      var pathRefs = Array.from(targets, (_ref3) => {
        var [, p] = _ref3;
        return Editor.pathRef(editor, p);
      });

      for (var pathRef of pathRefs) {
        var path = pathRef.unref();
        var newPath = toRef.current;

        if (path.length !== 0) {
          editor.apply({
            type: 'move_node',
            path,
            newPath
          });
        }
      }

      toRef.unref();
    });
  },

  /**
   * Remove the nodes at a specific location in the document.
   */
  removeNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false,
        mode = 'lowest'
      } = options;
      var {
        at = editor.selection,
        match
      } = options;

      if (!at) {
        return;
      }

      if (match == null) {
        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);
      }

      if (!hanging && Range.isRange(at)) {
        at = Editor.unhangRange(editor, at);
      }

      var depths = Editor.nodes(editor, {
        at,
        match,
        mode,
        voids
      });
      var pathRefs = Array.from(depths, (_ref4) => {
        var [, p] = _ref4;
        return Editor.pathRef(editor, p);
      });

      for (var pathRef of pathRefs) {
        var path = pathRef.unref();

        if (path) {
          var [node] = Editor.node(editor, path);
          editor.apply({
            type: 'remove_node',
            path,
            node
          });
        }
      }
    });
  },

  /**
   * Set new properties on the nodes at a location.
   */
  setNodes(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        match,
        at = editor.selection
      } = options;
      var {
        hanging = false,
        mode = 'lowest',
        split = false,
        voids = false
      } = options;

      if (!at) {
        return;
      }

      if (match == null) {
        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);
      }

      if (!hanging && Range.isRange(at)) {
        at = Editor.unhangRange(editor, at);
      }

      if (split && Range.isRange(at)) {
        var rangeRef = Editor.rangeRef(editor, at, {
          affinity: 'inward'
        });
        var [start, end] = Range.edges(at);
        var splitMode = mode === 'lowest' ? 'lowest' : 'highest';
        Transforms.splitNodes(editor, {
          at: end,
          match,
          mode: splitMode,
          voids
        });
        Transforms.splitNodes(editor, {
          at: start,
          match,
          mode: splitMode,
          voids
        });
        at = rangeRef.unref();

        if (options.at == null) {
          Transforms.select(editor, at);
        }
      }

      for (var [node, path] of Editor.nodes(editor, {
        at,
        match,
        mode,
        voids
      })) {
        var properties = {};
        var newProperties = {}; // You can't set properties on the editor node.

        if (path.length === 0) {
          continue;
        }

        for (var k in props) {
          if (k === 'children' || k === 'text') {
            continue;
          }

          if (props[k] !== node[k]) {
            properties[k] = node[k];
            newProperties[k] = props[k];
          }
        }

        if (Object.keys(newProperties).length !== 0) {
          editor.apply({
            type: 'set_node',
            path,
            properties,
            newProperties
          });
        }
      }
    });
  },

  /**
   * Split the nodes at a specific location.
   */
  splitNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        mode = 'lowest',
        voids = false
      } = options;
      var {
        match,
        at = editor.selection,
        height = 0,
        always = false
      } = options;

      if (match == null) {
        match = n => Editor.isBlock(editor, n);
      }

      if (Range.isRange(at)) {
        at = deleteRange(editor, at);
      } // If the target is a path, the default height-skipping and position
      // counters need to account for us potentially splitting at a non-leaf.


      if (Path.isPath(at)) {
        var path = at;
        var point = Editor.point(editor, path);
        var [parent] = Editor.parent(editor, path);

        match = n => n === parent;

        height = point.path.length - path.length + 1;
        at = point;
        always = true;
      }

      if (!at) {
        return;
      }

      var beforeRef = Editor.pointRef(editor, at, {
        affinity: 'backward'
      });
      var [highest] = Editor.nodes(editor, {
        at,
        match,
        mode,
        voids
      });

      if (!highest) {
        return;
      }

      var voidMatch = Editor.void(editor, {
        at,
        mode: 'highest'
      });
      var nudge = 0;

      if (!voids && voidMatch) {
        var [voidNode, voidPath] = voidMatch;

        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {
          var after = Editor.after(editor, voidPath);

          if (!after) {
            var text = {
              text: ''
            };
            var afterPath = Path.next(voidPath);
            Transforms.insertNodes(editor, text, {
              at: afterPath,
              voids
            });
            after = Editor.point(editor, afterPath);
          }

          at = after;
          always = true;
        }

        var siblingHeight = at.path.length - voidPath.length;
        height = siblingHeight + 1;
        always = true;
      }

      var afterRef = Editor.pointRef(editor, at);
      var depth = at.path.length - height;
      var [, highestPath] = highest;
      var lowestPath = at.path.slice(0, depth);
      var position = height === 0 ? at.offset : at.path[depth] + nudge;
      var target = null;

      for (var [node, _path2] of Editor.levels(editor, {
        at: lowestPath,
        reverse: true,
        voids
      })) {
        var split = false;

        if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Editor.isVoid(editor, node)) {
          break;
        }

        var _point = beforeRef.current;
        var isEnd = Editor.isEnd(editor, _point, _path2);

        if (always || !beforeRef || !Editor.isEdge(editor, _point, _path2)) {
          split = true;

          var properties = _objectWithoutProperties(node, ["text", "children"]);

          editor.apply({
            type: 'split_node',
            path: _path2,
            position,
            target,
            properties
          });
        }

        target = position;
        position = _path2[_path2.length - 1] + (split || isEnd ? 1 : 0);
      }

      if (options.at == null) {
        var _point2 = afterRef.current || Editor.end(editor, []);

        Transforms.select(editor, _point2);
      }

      beforeRef.unref();
      afterRef.unref();
    });
  },

  /**
   * Unset properties on the nodes at a location.
   */
  unsetNodes(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (!Array.isArray(props)) {
      props = [props];
    }

    var obj = {};

    for (var key of props) {
      obj[key] = null;
    }

    Transforms.setNodes(editor, obj, options);
  },

  /**
   * Unwrap the nodes at a location from a parent node, splitting the parent if
   * necessary to ensure that only the content in the range is unwrapped.
   */
  unwrapNodes(editor, options) {
    Editor.withoutNormalizing(editor, () => {
      var {
        mode = 'lowest',
        split = false,
        voids = false
      } = options;
      var {
        at = editor.selection,
        match
      } = options;

      if (!at) {
        return;
      }

      if (match == null) {
        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);
      }

      if (Path.isPath(at)) {
        at = Editor.range(editor, at);
      }

      var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;
      var matches = Editor.nodes(editor, {
        at,
        match,
        mode,
        voids
      });
      var pathRefs = Array.from(matches, (_ref5) => {
        var [, p] = _ref5;
        return Editor.pathRef(editor, p);
      });

      var _loop = function _loop(pathRef) {
        var path = pathRef.unref();
        var [node] = Editor.node(editor, path);
        var range = Editor.range(editor, path);

        if (split && rangeRef) {
          range = Range.intersection(rangeRef.current, range);
        }

        Transforms.liftNodes(editor, {
          at: range,
          match: n => node.children.includes(n),
          voids
        });
      };

      for (var pathRef of pathRefs) {
        _loop(pathRef);
      }

      if (rangeRef) {
        rangeRef.unref();
      }
    });
  },

  /**
   * Wrap the nodes at a location in a new container node, splitting the edges
   * of the range first to ensure that only the content in the range is wrapped.
   */
  wrapNodes(editor, element) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        mode = 'lowest',
        split = false,
        voids = false
      } = options;
      var {
        match,
        at = editor.selection
      } = options;

      if (!at) {
        return;
      }

      if (match == null) {
        if (Path.isPath(at)) {
          match = matchPath(editor, at);
        } else if (editor.isInline(element)) {
          match = n => Editor.isInline(editor, n) || Text.isText(n);
        } else {
          match = n => Editor.isBlock(editor, n);
        }
      }

      if (split && Range.isRange(at)) {
        var [start, end] = Range.edges(at);
        var rangeRef = Editor.rangeRef(editor, at, {
          affinity: 'inward'
        });
        Transforms.splitNodes(editor, {
          at: end,
          match,
          voids
        });
        Transforms.splitNodes(editor, {
          at: start,
          match,
          voids
        });
        at = rangeRef.unref();

        if (options.at == null) {
          Transforms.select(editor, at);
        }
      }

      var roots = Array.from(Editor.nodes(editor, {
        at,
        match: editor.isInline(element) ? n => Editor.isBlock(editor, n) : n => Editor.isEditor(n),
        mode: 'lowest',
        voids
      }));

      for (var [, rootPath] of roots) {
        var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;

        if (!a) {
          continue;
        }

        var matches = Array.from(Editor.nodes(editor, {
          at: a,
          match,
          mode,
          voids
        }));

        if (matches.length > 0) {
          (function () {
            var [first] = matches;
            var last = matches[matches.length - 1];
            var [, firstPath] = first;
            var [, lastPath] = last;
            var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);
            var range = Editor.range(editor, firstPath, lastPath);
            var commonNodeEntry = Editor.node(editor, commonPath);
            var [commonNode] = commonNodeEntry;
            var depth = commonPath.length + 1;
            var wrapperPath = Path.next(lastPath.slice(0, depth));

            var wrapper = _objectSpread$6({}, element, {
              children: []
            });

            Transforms.insertNodes(editor, wrapper, {
              at: wrapperPath,
              voids
            });
            Transforms.moveNodes(editor, {
              at: range,
              match: n => commonNode.children.includes(n),
              to: wrapperPath.concat(0),
              voids
            });
          })();
        }
      }
    });
  }

};
/**
 * Convert a range into a point by deleting it's content.
 */

var deleteRange = (editor, range) => {
  if (Range.isCollapsed(range)) {
    return range.anchor;
  } else {
    var [, end] = Range.edges(range);
    var pointRef = Editor.pointRef(editor, end);
    Transforms.delete(editor, {
      at: range
    });
    return pointRef.unref();
  }
};

var matchPath = (editor, path) => {
  var [node] = Editor.node(editor, path);
  return n => n === node;
};

function ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var SelectionTransforms = {
  /**
   * Collapse the selection.
   */
  collapse(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      edge = 'anchor'
    } = options;
    var {
      selection
    } = editor;

    if (!selection) {
      return;
    } else if (edge === 'anchor') {
      Transforms.select(editor, selection.anchor);
    } else if (edge === 'focus') {
      Transforms.select(editor, selection.focus);
    } else if (edge === 'start') {
      var [start] = Range.edges(selection);
      Transforms.select(editor, start);
    } else if (edge === 'end') {
      var [, end] = Range.edges(selection);
      Transforms.select(editor, end);
    }
  },

  /**
   * Unset the selection.
   */
  deselect(editor) {
    var {
      selection
    } = editor;

    if (selection) {
      editor.apply({
        type: 'set_selection',
        properties: selection,
        newProperties: null
      });
    }
  },

  /**
   * Move the selection's point forward or backward.
   */
  move(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      selection
    } = editor;
    var {
      distance = 1,
      unit = 'character',
      reverse = false
    } = options;
    var {
      edge = null
    } = options;

    if (!selection) {
      return;
    }

    if (edge === 'start') {
      edge = Range.isBackward(selection) ? 'focus' : 'anchor';
    }

    if (edge === 'end') {
      edge = Range.isBackward(selection) ? 'anchor' : 'focus';
    }

    var {
      anchor,
      focus
    } = selection;
    var opts = {
      distance,
      unit
    };
    var props = {};

    if (edge == null || edge === 'anchor') {
      var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);

      if (point) {
        props.anchor = point;
      }
    }

    if (edge == null || edge === 'focus') {
      var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);

      if (_point) {
        props.focus = _point;
      }
    }

    Transforms.setSelection(editor, props);
  },

  /**
   * Set the selection to a new value.
   */
  select(editor, target) {
    var {
      selection
    } = editor;
    target = Editor.range(editor, target);

    if (selection) {
      Transforms.setSelection(editor, target);
      return;
    }

    if (!Range.isRange(target)) {
      throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(JSON.stringify(target)));
    }

    editor.apply({
      type: 'set_selection',
      properties: selection,
      newProperties: target
    });
  },

  /**
   * Set new properties on one of the selection's points.
   */
  setPoint(editor, props, options) {
    var {
      selection
    } = editor;
    var {
      edge = 'both'
    } = options;

    if (!selection) {
      return;
    }

    if (edge === 'start') {
      edge = Range.isBackward(selection) ? 'focus' : 'anchor';
    }

    if (edge === 'end') {
      edge = Range.isBackward(selection) ? 'anchor' : 'focus';
    }

    var {
      anchor,
      focus
    } = selection;
    var point = edge === 'anchor' ? anchor : focus;
    Transforms.setSelection(editor, {
      [edge === 'anchor' ? 'anchor' : 'focus']: _objectSpread$7({}, point, {}, props)
    });
  },

  /**
   * Set new properties on the selection.
   */
  setSelection(editor, props) {
    var {
      selection
    } = editor;
    var oldProps = {};
    var newProps = {};

    if (!selection) {
      return;
    }

    for (var k in props) {
      if (k === 'anchor' && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === 'focus' && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== 'anchor' && k !== 'focus' && props[k] !== selection[k]) {
        oldProps[k] = selection[k];
        newProps[k] = props[k];
      }
    }

    if (Object.keys(oldProps).length > 0) {
      editor.apply({
        type: 'set_selection',
        properties: oldProps,
        newProperties: newProps
      });
    }
  }

};

var TextTransforms = {
  /**
   * Delete content in the editor.
   */
  delete(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        reverse = false,
        unit = 'character',
        distance = 1,
        voids = false
      } = options;
      var {
        at = editor.selection,
        hanging = false
      } = options;

      if (!at) {
        return;
      }

      if (Range.isRange(at) && Range.isCollapsed(at)) {
        at = at.anchor;
      }

      if (Point.isPoint(at)) {
        var furthestVoid = Editor.void(editor, {
          at,
          mode: 'highest'
        });

        if (!voids && furthestVoid) {
          var [, voidPath] = furthestVoid;
          at = voidPath;
        } else {
          var opts = {
            unit,
            distance
          };
          var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);
          at = {
            anchor: at,
            focus: target
          };
          hanging = true;
        }
      }

      if (Path.isPath(at)) {
        Transforms.removeNodes(editor, {
          at,
          voids
        });
        return;
      }

      if (Range.isCollapsed(at)) {
        return;
      }

      if (!hanging) {
        at = Editor.unhangRange(editor, at, {
          voids
        });
      }

      var [start, end] = Range.edges(at);
      var startBlock = Editor.above(editor, {
        match: n => Editor.isBlock(editor, n),
        at: start,
        voids
      });
      var endBlock = Editor.above(editor, {
        match: n => Editor.isBlock(editor, n),
        at: end,
        voids
      });
      var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);
      var isSingleText = Path.equals(start.path, end.path);
      var startVoid = voids ? null : Editor.void(editor, {
        at: start,
        mode: 'highest'
      });
      var endVoid = voids ? null : Editor.void(editor, {
        at: end,
        mode: 'highest'
      }); // If the start or end points are inside an inline void, nudge them out.

      if (startVoid) {
        var before = Editor.before(editor, start);

        if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {
          start = before;
        }
      }

      if (endVoid) {
        var after = Editor.after(editor, end);

        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {
          end = after;
        }
      } // Get the highest nodes that are completely inside the range, as well as
      // the start and end nodes.


      var matches = [];
      var lastPath;

      for (var entry of Editor.nodes(editor, {
        at,
        voids
      })) {
        var [node, path] = entry;

        if (lastPath && Path.compare(path, lastPath) === 0) {
          continue;
        }

        if (!voids && Editor.isVoid(editor, node) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) {
          matches.push(entry);
          lastPath = path;
        }
      }

      var pathRefs = Array.from(matches, (_ref) => {
        var [, p] = _ref;
        return Editor.pathRef(editor, p);
      });
      var startRef = Editor.pointRef(editor, start);
      var endRef = Editor.pointRef(editor, end);

      if (!isSingleText && !startVoid) {
        var _point = startRef.current;
        var [_node] = Editor.leaf(editor, _point);
        var {
          path: _path
        } = _point;
        var {
          offset
        } = start;

        var text = _node.text.slice(offset);

        editor.apply({
          type: 'remove_text',
          path: _path,
          offset,
          text
        });
      }

      for (var pathRef of pathRefs) {
        var _path2 = pathRef.unref();

        Transforms.removeNodes(editor, {
          at: _path2,
          voids
        });
      }

      if (!endVoid) {
        var _point2 = endRef.current;
        var [_node2] = Editor.leaf(editor, _point2);
        var {
          path: _path3
        } = _point2;

        var _offset = isSingleText ? start.offset : 0;

        var _text = _node2.text.slice(_offset, end.offset);

        editor.apply({
          type: 'remove_text',
          path: _path3,
          offset: _offset,
          text: _text
        });
      }

      if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {
        Transforms.mergeNodes(editor, {
          at: endRef.current,
          hanging: true,
          voids
        });
      }

      var point = endRef.unref() || startRef.unref();

      if (options.at == null && point) {
        Transforms.select(editor, point);
      }
    });
  },

  /**
   * Insert a fragment at a specific location in the editor.
   */
  insertFragment(editor, fragment) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false
      } = options;
      var {
        at = editor.selection
      } = options;

      if (!fragment.length) {
        return;
      }

      if (!at) {
        return;
      } else if (Range.isRange(at)) {
        if (!hanging) {
          at = Editor.unhangRange(editor, at);
        }

        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var [, end] = Range.edges(at);

          if (!voids && Editor.void(editor, {
            at: end
          })) {
            return;
          }

          var pointRef = Editor.pointRef(editor, end);
          Transforms.delete(editor, {
            at
          });
          at = pointRef.unref();
        }
      } else if (Path.isPath(at)) {
        at = Editor.start(editor, at);
      }

      if (!voids && Editor.void(editor, {
        at
      })) {
        return;
      } // If the insert point is at the edge of an inline node, move it outside
      // instead since it will need to be split otherwise.


      var inlineElementMatch = Editor.above(editor, {
        at,
        match: n => Editor.isInline(editor, n),
        mode: 'highest',
        voids
      });

      if (inlineElementMatch) {
        var [, _inlinePath] = inlineElementMatch;

        if (Editor.isEnd(editor, at, _inlinePath)) {
          var after = Editor.after(editor, _inlinePath);
          at = after;
        } else if (Editor.isStart(editor, at, _inlinePath)) {
          var before = Editor.before(editor, _inlinePath);
          at = before;
        }
      }

      var blockMatch = Editor.above(editor, {
        match: n => Editor.isBlock(editor, n),
        at,
        voids
      });
      var [, blockPath] = blockMatch;
      var isBlockStart = Editor.isStart(editor, at, blockPath);
      var isBlockEnd = Editor.isEnd(editor, at, blockPath);
      var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;
      var mergeEnd = !isBlockEnd;
      var [, firstPath] = Node.first({
        children: fragment
      }, []);
      var [, lastPath] = Node.last({
        children: fragment
      }, []);
      var matches = [];

      var matcher = (_ref2) => {
        var [n, p] = _ref2;

        if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {
          return false;
        }

        if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {
          return false;
        }

        return true;
      };

      for (var entry of Node.nodes({
        children: fragment
      }, {
        pass: matcher
      })) {
        if (entry[1].length > 0 && matcher(entry)) {
          matches.push(entry);
        }
      }

      var starts = [];
      var middles = [];
      var ends = [];
      var starting = true;
      var hasBlocks = false;

      for (var [node] of matches) {
        if (Element.isElement(node) && !editor.isInline(node)) {
          starting = false;
          hasBlocks = true;
          middles.push(node);
        } else if (starting) {
          starts.push(node);
        } else {
          ends.push(node);
        }
      }

      var [inlineMatch] = Editor.nodes(editor, {
        at,
        match: n => Text.isText(n) || Editor.isInline(editor, n),
        mode: 'highest',
        voids
      });
      var [, inlinePath] = inlineMatch;
      var isInlineStart = Editor.isStart(editor, at, inlinePath);
      var isInlineEnd = Editor.isEnd(editor, at, inlinePath);
      var middleRef = Editor.pathRef(editor, isBlockEnd ? Path.next(blockPath) : blockPath);
      var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);
      Transforms.splitNodes(editor, {
        at,
        match: n => hasBlocks ? Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n),
        mode: hasBlocks ? 'lowest' : 'highest',
        voids
      });
      var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);
      Transforms.insertNodes(editor, starts, {
        at: startRef.current,
        match: n => Text.isText(n) || Editor.isInline(editor, n),
        mode: 'highest',
        voids
      });
      Transforms.insertNodes(editor, middles, {
        at: middleRef.current,
        match: n => Editor.isBlock(editor, n),
        mode: 'lowest',
        voids
      });
      Transforms.insertNodes(editor, ends, {
        at: endRef.current,
        match: n => Text.isText(n) || Editor.isInline(editor, n),
        mode: 'highest',
        voids
      });

      if (!options.at) {
        var path;

        if (ends.length > 0) {
          path = Path.previous(endRef.current);
        } else if (middles.length > 0) {
          path = Path.previous(middleRef.current);
        } else {
          path = Path.previous(startRef.current);
        }

        var _end = Editor.end(editor, path);

        Transforms.select(editor, _end);
      }

      startRef.unref();
      middleRef.unref();
      endRef.unref();
    });
  },

  /**
   * Insert a string of text in the Editor.
   */
  insertText(editor, text) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        voids = false
      } = options;
      var {
        at = editor.selection
      } = options;

      if (!at) {
        return;
      }

      if (Path.isPath(at)) {
        at = Editor.range(editor, at);
      }

      if (Range.isRange(at)) {
        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var end = Range.end(at);

          if (!voids && Editor.void(editor, {
            at: end
          })) {
            return;
          }

          var pointRef = Editor.pointRef(editor, end);
          Transforms.delete(editor, {
            at,
            voids
          });
          at = pointRef.unref();
          Transforms.setSelection(editor, {
            anchor: at,
            focus: at
          });
        }
      }

      if (!voids && Editor.void(editor, {
        at
      })) {
        return;
      }

      var {
        path,
        offset
      } = at;
      editor.apply({
        type: 'insert_text',
        path,
        offset,
        text
      });
    });
  }

};

function ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var Transforms = _objectSpread$8({}, GeneralTransforms, {}, NodeTransforms, {}, SelectionTransforms, {}, TextTransforms);

function ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$9(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$9(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * Create a new Slate `Editor` object.
 */

var createEditor = () => {
  var editor = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isInline: () => false,
    isVoid: () => false,
    onChange: () => {},
    apply: op => {
      for (var ref of Editor.pathRefs(editor)) {
        PathRef.transform(ref, op);
      }

      for (var _ref of Editor.pointRefs(editor)) {
        PointRef.transform(_ref, op);
      }

      for (var _ref2 of Editor.rangeRefs(editor)) {
        RangeRef.transform(_ref2, op);
      }

      var set = new Set();
      var dirtyPaths = [];

      var add = path => {
        if (path) {
          var key = path.join(',');

          if (!set.has(key)) {
            set.add(key);
            dirtyPaths.push(path);
          }
        }
      };

      var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];
      var newDirtyPaths = getDirtyPaths(op);

      for (var path of oldDirtyPaths) {
        var newPath = Path.transform(path, op);
        add(newPath);
      }

      for (var _path of newDirtyPaths) {
        add(_path);
      }

      DIRTY_PATHS.set(editor, dirtyPaths);
      Editor.transform(editor, op);
      editor.operations.push(op);
      Editor.normalize(editor); // Clear any formats applied to the cursor if the selection changes.

      if (op.type === 'set_selection') {
        editor.marks = null;
      }

      if (!FLUSHING.get(editor)) {
        FLUSHING.set(editor, true);
        Promise.resolve().then(() => {
          FLUSHING.set(editor, false);
          editor.onChange();
          editor.operations = [];
        });
      }
    },
    addMark: (key, value) => {
      var {
        selection
      } = editor;

      if (selection) {
        if (Range.isExpanded(selection)) {
          Transforms.setNodes(editor, {
            [key]: value
          }, {
            match: Text.isText,
            split: true
          });
        } else {
          var marks = _objectSpread$9({}, Editor.marks(editor) || {}, {
            [key]: value
          });

          editor.marks = marks;
          editor.onChange();
        }
      }
    },
    deleteBackward: unit => {
      var {
        selection
      } = editor;

      if (selection && Range.isCollapsed(selection)) {
        Transforms.delete(editor, {
          unit,
          reverse: true
        });
      }
    },
    deleteForward: unit => {
      var {
        selection
      } = editor;

      if (selection && Range.isCollapsed(selection)) {
        Transforms.delete(editor, {
          unit
        });
      }
    },
    deleteFragment: () => {
      var {
        selection
      } = editor;

      if (selection && Range.isExpanded(selection)) {
        Transforms.delete(editor);
      }
    },
    getFragment: () => {
      var {
        selection
      } = editor;

      if (selection) {
        return Node.fragment(editor, selection);
      }

      return [];
    },
    insertBreak: () => {
      Transforms.splitNodes(editor, {
        always: true
      });
    },
    insertFragment: fragment => {
      Transforms.insertFragment(editor, fragment);
    },
    insertNode: node => {
      Transforms.insertNodes(editor, node);
    },
    insertText: text => {
      var {
        selection,
        marks
      } = editor;

      if (selection) {
        // If the cursor is at the end of an inline, move it outside of
        // the inline before inserting
        if (Range.isCollapsed(selection)) {
          var inline = Editor.above(editor, {
            match: n => Editor.isInline(editor, n),
            mode: 'highest'
          });

          if (inline) {
            var [, inlinePath] = inline;

            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {
              var point = Editor.after(editor, inlinePath);
              Transforms.setSelection(editor, {
                anchor: point,
                focus: point
              });
            }
          }
        }

        if (marks) {
          var node = _objectSpread$9({
            text
          }, marks);

          Transforms.insertNodes(editor, node);
        } else {
          Transforms.insertText(editor, text);
        }

        editor.marks = null;
      }
    },
    normalizeNode: entry => {
      var [node, path] = entry; // There are no core normalizations for text nodes.

      if (Text.isText(node)) {
        return;
      } // Ensure that block and inline nodes have at least one text child.


      if (Element.isElement(node) && node.children.length === 0) {
        var child = {
          text: ''
        };
        Transforms.insertNodes(editor, child, {
          at: path.concat(0),
          voids: true
        });
        return;
      } // Determine whether the node should have block or inline children.


      var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0])); // Since we'll be applying operations while iterating, keep track of an
      // index that accounts for any added/removed nodes.

      var n = 0;

      for (var i = 0; i < node.children.length; i++, n++) {
        var _child = node.children[i];
        var prev = node.children[i - 1];
        var isLast = i === node.children.length - 1;
        var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child); // Only allow block nodes in the top-level children and parent blocks
        // that only contain block nodes. Similarly, only allow inline nodes in
        // other inline nodes, or parent blocks that only contain inlines and
        // text.

        if (isInlineOrText !== shouldHaveInlines) {
          Transforms.removeNodes(editor, {
            at: path.concat(n),
            voids: true
          });
          n--;
        } else if (Element.isElement(_child)) {
          // Ensure that inline nodes are surrounded by text nodes.
          if (editor.isInline(_child)) {
            if (prev == null || !Text.isText(prev)) {
              var newChild = {
                text: ''
              };
              Transforms.insertNodes(editor, newChild, {
                at: path.concat(n),
                voids: true
              });
              n++;
            } else if (isLast) {
              var _newChild = {
                text: ''
              };
              Transforms.insertNodes(editor, _newChild, {
                at: path.concat(n + 1),
                voids: true
              });
              n++;
            }
          }
        } else {
          // Merge adjacent text nodes that are empty or match.
          if (prev != null && Text.isText(prev)) {
            if (Text.equals(_child, prev, {
              loose: true
            })) {
              Transforms.mergeNodes(editor, {
                at: path.concat(n),
                voids: true
              });
              n--;
            } else if (prev.text === '') {
              Transforms.removeNodes(editor, {
                at: path.concat(n - 1),
                voids: true
              });
              n--;
            } else if (isLast && _child.text === '') {
              Transforms.removeNodes(editor, {
                at: path.concat(n),
                voids: true
              });
              n--;
            }
          }
        }
      }
    },
    removeMark: key => {
      var {
        selection
      } = editor;

      if (selection) {
        if (Range.isExpanded(selection)) {
          Transforms.unsetNodes(editor, key, {
            match: Text.isText,
            split: true
          });
        } else {
          var marks = _objectSpread$9({}, Editor.marks(editor) || {});

          delete marks[key];
          editor.marks = marks;
          editor.onChange();
        }
      }
    }
  };
  return editor;
};
/**
 * Get the "dirty" paths generated from an operation.
 */

var getDirtyPaths = op => {
  switch (op.type) {
    case 'insert_text':
    case 'remove_text':
    case 'set_node':
      {
        var {
          path
        } = op;
        return Path.levels(path);
      }

    case 'insert_node':
      {
        var {
          node,
          path: _path2
        } = op;
        var levels = Path.levels(_path2);
        var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), (_ref3) => {
          var [, p] = _ref3;
          return _path2.concat(p);
        });
        return [...levels, ...descendants];
      }

    case 'merge_node':
      {
        var {
          path: _path3
        } = op;
        var ancestors = Path.ancestors(_path3);
        var previousPath = Path.previous(_path3);
        return [...ancestors, previousPath];
      }

    case 'move_node':
      {
        var {
          path: _path4,
          newPath
        } = op;

        if (Path.equals(_path4, newPath)) {
          return [];
        }

        var oldAncestors = [];
        var newAncestors = [];

        for (var ancestor of Path.ancestors(_path4)) {
          var p = Path.transform(ancestor, op);
          oldAncestors.push(p);
        }

        for (var _ancestor of Path.ancestors(newPath)) {
          var _p = Path.transform(_ancestor, op);

          newAncestors.push(_p);
        }

        return [...oldAncestors, ...newAncestors];
      }

    case 'remove_node':
      {
        var {
          path: _path5
        } = op;

        var _ancestors = Path.ancestors(_path5);

        return [..._ancestors];
      }

    case 'split_node':
      {
        var {
          path: _path6
        } = op;

        var _levels = Path.levels(_path6);

        var nextPath = Path.next(_path6);
        return [..._levels, nextPath];
      }

    default:
      {
        return [];
      }
  }
};


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "../node_modules/slate/node_modules/is-plain-object/index.js":
/*!*******************************************************************!*\
  !*** ../node_modules/slate/node_modules/is-plain-object/index.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isPlainObject; });
/* harmony import */ var isobject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! isobject */ "../node_modules/slate/node_modules/isobject/index.js");
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */



function isObjectObject(o) {
  return Object(isobject__WEBPACK_IMPORTED_MODULE_0__["default"])(o) === true
    && Object.prototype.toString.call(o) === '[object Object]';
}

function isPlainObject(o) {
  var ctor,prot;

  if (isObjectObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (typeof ctor !== 'function') return false;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObjectObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
};


/***/ }),

/***/ "../node_modules/slate/node_modules/isobject/index.js":
/*!************************************************************!*\
  !*** ../node_modules/slate/node_modules/isobject/index.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isObject; });
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

function isObject(val) {
  return val != null && typeof val === 'object' && Array.isArray(val) === false;
};


/***/ }),

/***/ "../node_modules/webpack/buildin/global.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../node_modules/webpack/buildin/module.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/module.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./src/components/Icon.js":
/*!********************************!*\
  !*** ./src/components/Icon.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);

var svgIcons = {
  format_bold: '<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path d="M0 0h24v24H0z" fill="none"/><path d="M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H7v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42zM10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z"/></svg>',
  format_italic: '<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path d="M0 0h24v24H0z" fill="none"/><path d="M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z"/></svg>',
  format_underlined: '<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path d="M0 0h24v24H0z" fill="none"/><path d="M12 17c3.31 0 6-2.69 6-6V3h-2.5v8c0 1.93-1.57 3.5-3.5 3.5S8.5 12.93 8.5 11V3H6v8c0 3.31 2.69 6 6 6zm-7 2v2h14v-2H5z"/></svg>',
  format_list_bulleted: '<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M4 10.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0-6c-.83 0-1.5.67-1.5 1.5S3.17 7.5 4 7.5 5.5 6.83 5.5 6 4.83 4.5 4 4.5zm0 12c-.83 0-1.5.68-1.5 1.5s.68 1.5 1.5 1.5 1.5-.68 1.5-1.5-.67-1.5-1.5-1.5zM7 19h14v-2H7v2zm0-6h14v-2H7v2zm0-8v2h14V5H7z"/></svg>',
  format_list_numbered: '<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path d="M0 0h24v24H0z" fill="none"/><path d="M2 17h2v.5H3v1h1v.5H2v1h3v-4H2v1zm1-9h1V4H2v1h1v3zm-1 3h1.8L2 13.1v.9h3v-1H3.2L5 10.9V10H2v1zm5-6v2h14V5H7zm0 14h14v-2H7v2zm0-6h14v-2H7v2z"/></svg>'
};
var styles = {
  icon: {
    opacity: 0.7
  }
};

var Icon = function Icon(_ref) {
  var children = _ref.children;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("img", {
    height: 20,
    src: "data:image/svg+xml;utf8,".concat(svgIcons[children]),
    style: styles.icon
  });
};

/* harmony default export */ __webpack_exports__["default"] = (Icon);

/***/ }),

/***/ "./src/components/JsonViewer.js":
/*!**************************************!*\
  !*** ./src/components/JsonViewer.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);

var styles = {
  jsonViewer: {
    padding: 16,
    borderRadius: 4,
    background: 'linen'
  }
};

var JsonViewer = function JsonViewer(_ref) {
  var value = _ref.value;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("pre", {
    style: styles.jsonViewer
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("code", null, JSON.stringify(value, null, 2)));
};

/* harmony default export */ __webpack_exports__["default"] = (JsonViewer);

/***/ }),

/***/ "./src/components/Toolbar.js":
/*!***********************************!*\
  !*** ./src/components/Toolbar.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }


var styles = {
  toolbar: {
    display: 'flex',
    flexDirection: 'row'
  },
  button: {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    height: 30,
    minWidth: 30,
    margin: 5,
    padding: 0,
    border: 'none',
    background: 'transparent',
    borderRadius: 4,
    cursor: 'pointer'
  },
  buttonActive: {
    background: '#f5f5f5'
  },
  separator: {
    margin: '10px 5px',
    borderRight: 'solid thin #eaeaea'
  }
};

var Toolbar = function Toolbar(_ref) {
  var children = _ref.children;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
    style: styles.toolbar
  }, children);
};

Toolbar.Button = function (_ref2) {
  var active = _ref2.active,
      props = _objectWithoutProperties(_ref2, ["active"]);

  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", _extends({}, props, {
    style: _objectSpread(_objectSpread({}, styles.button), active ? styles.buttonActive : undefined)
  }));
};

Toolbar.Separator = function () {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
    style: styles.separator
  });
};

/* harmony default export */ __webpack_exports__["default"] = (Toolbar);

/***/ }),

/***/ "./src/constants.js":
/*!**************************!*\
  !*** ./src/constants.js ***!
  \**************************/
/*! exports provided: BULLETED_LIST, NUMBERED_LIST, LIST_ITEM, MENTION, BOLD, ITALIC, UNDERLINE, EDITOR_CHANGE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BULLETED_LIST", function() { return BULLETED_LIST; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NUMBERED_LIST", function() { return NUMBERED_LIST; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LIST_ITEM", function() { return LIST_ITEM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MENTION", function() { return MENTION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BOLD", function() { return BOLD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ITALIC", function() { return ITALIC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNDERLINE", function() { return UNDERLINE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EDITOR_CHANGE", function() { return EDITOR_CHANGE; });
// Blocks
var BULLETED_LIST = 'bulleted-list';
var NUMBERED_LIST = 'numbered-list';
var LIST_ITEM = 'list-item';
var MENTION = 'mention'; // Marks

var BOLD = 'bold';
var ITALIC = 'italic';
var UNDERLINE = 'underline'; // Other events

var EDITOR_CHANGE = 'editor-change';


/***/ }),

/***/ "./src/helpers/apply.js":
/*!******************************!*\
  !*** ./src/helpers/apply.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var apply = function apply() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return function (func) {
    return func.apply(void 0, _toConsumableArray(args));
  };
};

/* harmony default export */ __webpack_exports__["default"] = (apply);

/***/ }),

/***/ "./src/helpers/compose.js":
/*!********************************!*\
  !*** ./src/helpers/compose.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var compose = function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  return function (arg) {
    return funcs.reduceRight(function (composed, f) {
      return f ? f(composed) : composed;
    }, arg);
  };
};

/* harmony default export */ __webpack_exports__["default"] = (compose);

/***/ }),

/***/ "./src/helpers/createPlugin.js":
/*!*************************************!*\
  !*** ./src/helpers/createPlugin.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var createPlugin = function createPlugin(configs) {
  var defaultPlugin = {
    name: '',
    renderLeaf: function renderLeaf(next) {
      return function (props) {
        return next(props);
      };
    },
    renderElement: function renderElement(next) {
      return function (props) {
        return next(props);
      };
    },
    ToolbarButton: function ToolbarButton() {
      return null;
    },
    renderCustom: function renderCustom() {
      return null;
    },
    handleMessage: function handleMessage() {
      return function () {};
    },
    enhanceEditor: function enhanceEditor(editor) {
      return editor;
    }
  };
  return _objectSpread(_objectSpread({}, defaultPlugin), configs);
};

/* harmony default export */ __webpack_exports__["default"] = (createPlugin);

/***/ }),

/***/ "./src/helpers/elementHelpers.js":
/*!***************************************!*\
  !*** ./src/helpers/elementHelpers.js ***!
  \***************************************/
/*! exports provided: isBlockActive, isList, renderDefaultElement, makeRenderElement, composeRenderElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBlockActive", function() { return isBlockActive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isList", function() { return isList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderDefaultElement", function() { return renderDefaultElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeRenderElement", function() { return makeRenderElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "composeRenderElement", function() { return composeRenderElement; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ "../node_modules/slate/dist/index.es.js");
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./compose */ "./src/helpers/compose.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants */ "./src/constants.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }






var isBlockActive = function isBlockActive(editor, format) {
  var _Editor$nodes = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].nodes(editor, {
    match: function match(n) {
      return n.type === format;
    }
  }),
      _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),
      match = _Editor$nodes2[0];

  return !!match;
};

var isList = function isList(node) {
  return [_constants__WEBPACK_IMPORTED_MODULE_3__["BULLETED_LIST"], _constants__WEBPACK_IMPORTED_MODULE_3__["NUMBERED_LIST"]].includes(node.type);
};

var DefaultElement = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.forwardRef(function (props, ref) {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("p", _extends({
    ref: ref,
    style: {
      margin: 0,
      lineHeight: 1.5
    }
  }, props));
});

var renderDefaultElement = function renderDefaultElement(_ref) {
  var attributes = _ref.attributes,
      children = _ref.children;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(DefaultElement, attributes, children);
};

var makeRenderElement = function makeRenderElement(block, CustomElement) {
  return function (next) {
    return function (props) {
      if (props.element.type === block) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(CustomElement, props);
      }

      return next(props);
    };
  };
};

var composeRenderElement = function composeRenderElement(plugins) {
  return _compose__WEBPACK_IMPORTED_MODULE_2__["default"].apply(void 0, _toConsumableArray(plugins.map(function (plugin) {
    return plugin.renderElement;
  })))(renderDefaultElement);
};



/***/ }),

/***/ "./src/helpers/flow.js":
/*!*****************************!*\
  !*** ./src/helpers/flow.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var flow = function flow() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  return function (arg) {
    return funcs.reduce(function (composed, f) {
      return f ? f(composed) : composed;
    }, arg);
  };
};

/* harmony default export */ __webpack_exports__["default"] = (flow);

/***/ }),

/***/ "./src/helpers/get.js":
/*!****************************!*\
  !*** ./src/helpers/get.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var get = function get(path) {
  return function (object) {
    return object[path];
  };
};

/* harmony default export */ __webpack_exports__["default"] = (get);

/***/ }),

/***/ "./src/helpers/index.js":
/*!******************************!*\
  !*** ./src/helpers/index.js ***!
  \******************************/
/*! exports provided: compose, flow, map, get, apply, createPlugin, withId, useForceUpdate, isMarkActive, toggleMark, renderDefaultLeaf, makeRenderLeaf, composeRenderLeaf, isBlockActive, isList, renderDefaultElement, makeRenderElement, composeRenderElement, addMessageListener, postMessage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compose */ "./src/helpers/compose.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return _compose__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _flow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./flow */ "./src/helpers/flow.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flow", function() { return _flow__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map */ "./src/helpers/map.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "map", function() { return _map__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get */ "./src/helpers/get.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "get", function() { return _get__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _apply__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./apply */ "./src/helpers/apply.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "apply", function() { return _apply__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _createPlugin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./createPlugin */ "./src/helpers/createPlugin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createPlugin", function() { return _createPlugin__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _withId__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./withId */ "./src/helpers/withId.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withId", function() { return _withId__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _useForceUpdate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./useForceUpdate */ "./src/helpers/useForceUpdate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useForceUpdate", function() { return _useForceUpdate__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _leafHelpers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./leafHelpers */ "./src/helpers/leafHelpers.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMarkActive", function() { return _leafHelpers__WEBPACK_IMPORTED_MODULE_8__["isMarkActive"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toggleMark", function() { return _leafHelpers__WEBPACK_IMPORTED_MODULE_8__["toggleMark"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "renderDefaultLeaf", function() { return _leafHelpers__WEBPACK_IMPORTED_MODULE_8__["renderDefaultLeaf"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "makeRenderLeaf", function() { return _leafHelpers__WEBPACK_IMPORTED_MODULE_8__["makeRenderLeaf"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "composeRenderLeaf", function() { return _leafHelpers__WEBPACK_IMPORTED_MODULE_8__["composeRenderLeaf"]; });

/* harmony import */ var _elementHelpers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./elementHelpers */ "./src/helpers/elementHelpers.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBlockActive", function() { return _elementHelpers__WEBPACK_IMPORTED_MODULE_9__["isBlockActive"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isList", function() { return _elementHelpers__WEBPACK_IMPORTED_MODULE_9__["isList"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "renderDefaultElement", function() { return _elementHelpers__WEBPACK_IMPORTED_MODULE_9__["renderDefaultElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "makeRenderElement", function() { return _elementHelpers__WEBPACK_IMPORTED_MODULE_9__["makeRenderElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "composeRenderElement", function() { return _elementHelpers__WEBPACK_IMPORTED_MODULE_9__["composeRenderElement"]; });

/* harmony import */ var _messageHelpers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./messageHelpers */ "./src/helpers/messageHelpers.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addMessageListener", function() { return _messageHelpers__WEBPACK_IMPORTED_MODULE_10__["addMessageListener"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "postMessage", function() { return _messageHelpers__WEBPACK_IMPORTED_MODULE_10__["postMessage"]; });













/***/ }),

/***/ "./src/helpers/leafHelpers.js":
/*!************************************!*\
  !*** ./src/helpers/leafHelpers.js ***!
  \************************************/
/*! exports provided: isMarkActive, toggleMark, renderDefaultLeaf, makeRenderLeaf, composeRenderLeaf */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMarkActive", function() { return isMarkActive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toggleMark", function() { return toggleMark; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderDefaultLeaf", function() { return renderDefaultLeaf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeRenderLeaf", function() { return makeRenderLeaf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "composeRenderLeaf", function() { return composeRenderLeaf; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ "../node_modules/slate/dist/index.es.js");
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./compose */ "./src/helpers/compose.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var isMarkActive = function isMarkActive(editor, format) {
  var marks = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].marks(editor);
  return marks ? marks[format] === true : false;
};

var toggleMark = function toggleMark(editor, format) {
  var isActive = isMarkActive(editor, format);

  if (isActive) {
    slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].removeMark(editor, format);
  } else {
    slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].addMark(editor, format, true);
  }
};

var DefaultLeaf = 'span';

var renderDefaultLeaf = function renderDefaultLeaf(_ref) {
  var attributes = _ref.attributes,
      children = _ref.children;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(DefaultLeaf, attributes, children);
};

var makeRenderLeaf = function makeRenderLeaf(mark, CustomLeaf) {
  return function (next) {
    return function (props) {
      if (props.leaf[mark]) {
        var children = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(CustomLeaf, props);
        return next(_objectSpread(_objectSpread({}, props), {}, {
          children: children
        }));
      }

      return next(props);
    };
  };
};

var composeRenderLeaf = function composeRenderLeaf(plugins) {
  return _compose__WEBPACK_IMPORTED_MODULE_2__["default"].apply(void 0, _toConsumableArray(plugins.map(function (plugin) {
    return plugin.renderLeaf;
  })))(renderDefaultLeaf);
};



/***/ }),

/***/ "./src/helpers/map.js":
/*!****************************!*\
  !*** ./src/helpers/map.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var map = function map(iteratee) {
  return function (collection) {
    return collection.map(iteratee);
  };
};

/* harmony default export */ __webpack_exports__["default"] = (map);

/***/ }),

/***/ "./src/helpers/messageHelpers.js":
/*!***************************************!*\
  !*** ./src/helpers/messageHelpers.js ***!
  \***************************************/
/*! exports provided: addMessageListener, postMessage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addMessageListener", function() { return addMessageListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "postMessage", function() { return postMessage; });
var messagePrefix = '@hero-editor';

var addMessageListener = function addMessageListener(type, callback) {
  return function (editor) {
    var listener = function listener(event) {
      if (event.data.type === "".concat(messagePrefix, "/").concat(editor.id, "/").concat(type)) {
        callback({
          editor: editor,
          data: event.data.data
        });
      }
    };

    window.addEventListener('message', listener);
    return function () {
      return window.removeEventListener('message', listener);
    };
  };
};

var postMessage = function postMessage(type, data, editor) {
  var _window$ReactNativeWe;

  var message = {
    type: "".concat(messagePrefix, "/").concat(editor.id, "/").concat(type),
    data: data
  };
  window.postMessage(message, '*');
  (_window$ReactNativeWe = window.ReactNativeWebView) === null || _window$ReactNativeWe === void 0 ? void 0 : _window$ReactNativeWe.postMessage(JSON.stringify(message));
};



/***/ }),

/***/ "./src/helpers/useForceUpdate.js":
/*!***************************************!*\
  !*** ./src/helpers/useForceUpdate.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }



var useForceUpdate = function useForceUpdate() {
  var prev = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(0);

  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(0),
      _useState2 = _slicedToArray(_useState, 2),
      curr = _useState2[0],
      setCurr = _useState2[1];

  var isForceUpdated = prev.current !== curr;
  prev.current = curr;
  return {
    isForceUpdated: isForceUpdated,
    forceUpdate: function forceUpdate() {
      return setCurr(curr + 1);
    }
  };
};

/* harmony default export */ __webpack_exports__["default"] = (useForceUpdate);

/***/ }),

/***/ "./src/helpers/withId.js":
/*!*******************************!*\
  !*** ./src/helpers/withId.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var withId = function withId(id) {
  return function (editor) {
    editor.id = id;
    return editor;
  };
};

/* harmony default export */ __webpack_exports__["default"] = (withId);

/***/ }),

/***/ "./src/lib.js":
/*!********************!*\
  !*** ./src/lib.js ***!
  \********************/
/*! exports provided: bold, italic, underline, logger, bulletedList, numberedList, listItem, mention, editorPlaceholder, JsonViewer, Toolbar, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ "../node_modules/slate/dist/index.es.js");
/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! slate-react */ "../node_modules/slate-react/dist/index.es.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers */ "./src/helpers/index.js");
/* harmony import */ var _components_Toolbar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/Toolbar */ "./src/components/Toolbar.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants */ "./src/constants.js");
/* harmony import */ var _plugins__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./plugins */ "./src/plugins/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bold", function() { return _plugins__WEBPACK_IMPORTED_MODULE_6__["bold"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "italic", function() { return _plugins__WEBPACK_IMPORTED_MODULE_6__["italic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "underline", function() { return _plugins__WEBPACK_IMPORTED_MODULE_6__["underline"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logger", function() { return _plugins__WEBPACK_IMPORTED_MODULE_6__["logger"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bulletedList", function() { return _plugins__WEBPACK_IMPORTED_MODULE_6__["bulletedList"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "numberedList", function() { return _plugins__WEBPACK_IMPORTED_MODULE_6__["numberedList"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "listItem", function() { return _plugins__WEBPACK_IMPORTED_MODULE_6__["listItem"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mention", function() { return _plugins__WEBPACK_IMPORTED_MODULE_6__["mention"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "editorPlaceholder", function() { return _plugins__WEBPACK_IMPORTED_MODULE_6__["editorPlaceholder"]; });

/* harmony import */ var _components_JsonViewer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/JsonViewer */ "./src/components/JsonViewer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "JsonViewer", function() { return _components_JsonViewer__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Toolbar", function() { return _components_Toolbar__WEBPACK_IMPORTED_MODULE_4__["default"]; });

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }







var styles = {
  editorWrapper: {
    fontFamily: 'sans-serif',
    border: 'solid thin #eaeaea',
    borderRadius: 4
  },
  editableWrapper: {
    position: 'relative'
  },
  editable: {
    padding: 16
  }
};

var getCustomElements = function getCustomElements(editor) {
  return Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["map"])(Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["flow"])(Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["get"])('renderCustom'), Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["apply"])([editor])));
};

var addMessageListeners = function addMessageListeners(editor) {
  return Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["map"])(Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["flow"])(Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["get"])('handleMessage'), Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["apply"])([editor])));
};

var getToolbarButtons = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["map"])(function (_ref) {
  var name = _ref.name,
      ToolbarButton = _ref.ToolbarButton;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ToolbarButton, {
    key: name
  });
});

var HeroEditor = function HeroEditor(_ref2) {
  var id = _ref2.id,
      _ref2$showToolbar = _ref2.showToolbar,
      showToolbar = _ref2$showToolbar === void 0 ? true : _ref2$showToolbar,
      _ref2$plugins = _ref2.plugins,
      plugins = _ref2$plugins === void 0 ? [] : _ref2$plugins,
      placeholder = _ref2.placeholder,
      value = _ref2.value,
      _onChange = _ref2.onChange,
      wrapperStyle = _ref2.wrapperStyle;
  var editor = Object(react__WEBPACK_IMPORTED_MODULE_0__["useMemo"])(function () {
    return _helpers__WEBPACK_IMPORTED_MODULE_3__["flow"].apply(void 0, [slate__WEBPACK_IMPORTED_MODULE_1__["createEditor"], slate_react__WEBPACK_IMPORTED_MODULE_2__["withReact"], Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["withId"])(id)].concat(_toConsumableArray(Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["map"])(Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["get"])('enhanceEditor'))(plugins))))();
  }, []);
  var renderLeaf = Object(react__WEBPACK_IMPORTED_MODULE_0__["useMemo"])(function () {
    return Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["composeRenderLeaf"])(plugins);
  }, [plugins]);
  var renderElement = Object(react__WEBPACK_IMPORTED_MODULE_0__["useMemo"])(function () {
    return Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["composeRenderElement"])(plugins);
  }, [plugins]);
  var renderCustom = Object(react__WEBPACK_IMPORTED_MODULE_0__["useMemo"])(function () {
    return function () {
      return getCustomElements(editor)(plugins);
    };
  }, [plugins, value]);
  var toolBarButtons = Object(react__WEBPACK_IMPORTED_MODULE_0__["useMemo"])(function () {
    return getToolbarButtons(plugins);
  }, [plugins]);
  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    var removeHandlers = addMessageListeners(editor)(plugins);
    return function () {
      return removeHandlers.forEach(function (removeHandler) {
        return removeHandler();
      });
    };
  }, [plugins]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
    style: _objectSpread(_objectSpread({}, styles.editorWrapper), wrapperStyle)
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(slate_react__WEBPACK_IMPORTED_MODULE_2__["Slate"], {
    editor: editor,
    value: value,
    onChange: function onChange(value) {
      _onChange(value);

      Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["postMessage"])(_constants__WEBPACK_IMPORTED_MODULE_5__["EDITOR_CHANGE"], {}, editor);
    }
  }, showToolbar ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Toolbar__WEBPACK_IMPORTED_MODULE_4__["default"], null, toolBarButtons) : null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
    style: styles.editableWrapper
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(slate_react__WEBPACK_IMPORTED_MODULE_2__["Editable"], {
    placeholder: placeholder,
    renderLeaf: renderLeaf,
    renderElement: renderElement,
    style: styles.editable
  }), renderCustom())));
};




/* harmony default export */ __webpack_exports__["default"] = (HeroEditor);

/***/ }),

/***/ "./src/plugins/bold.js":
/*!*****************************!*\
  !*** ./src/plugins/bold.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate-react */ "../node_modules/slate-react/dist/index.es.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers */ "./src/helpers/index.js");
/* harmony import */ var _components_Toolbar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/Toolbar */ "./src/components/Toolbar.js");
/* harmony import */ var _components_Icon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/Icon */ "./src/components/Icon.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants */ "./src/constants.js");






var renderLeaf = Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["makeRenderLeaf"])(_constants__WEBPACK_IMPORTED_MODULE_5__["BOLD"], function (_ref) {
  var children = _ref.children;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("strong", null, children);
});
var handleMessage = Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["addMessageListener"])(_constants__WEBPACK_IMPORTED_MODULE_5__["BOLD"], function (_ref2) {
  var editor = _ref2.editor;
  Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["toggleMark"])(editor, _constants__WEBPACK_IMPORTED_MODULE_5__["BOLD"]);
});

var ToolbarButton = function ToolbarButton() {
  var editor = Object(slate_react__WEBPACK_IMPORTED_MODULE_1__["useSlate"])();
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Toolbar__WEBPACK_IMPORTED_MODULE_3__["default"].Button, {
    active: Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["isMarkActive"])(editor, _constants__WEBPACK_IMPORTED_MODULE_5__["BOLD"]),
    onMouseDown: function onMouseDown(event) {
      event.preventDefault();
      Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["postMessage"])(_constants__WEBPACK_IMPORTED_MODULE_5__["BOLD"], {}, editor);
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_4__["default"], null, "format_bold"));
};

/* harmony default export */ __webpack_exports__["default"] = (Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["createPlugin"])({
  name: _constants__WEBPACK_IMPORTED_MODULE_5__["BOLD"],
  renderLeaf: renderLeaf,
  handleMessage: handleMessage,
  ToolbarButton: ToolbarButton
}));

/***/ }),

/***/ "./src/plugins/bulletedList.js":
/*!*************************************!*\
  !*** ./src/plugins/bulletedList.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ "../node_modules/slate/dist/index.es.js");
/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! slate-react */ "../node_modules/slate-react/dist/index.es.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers */ "./src/helpers/index.js");
/* harmony import */ var _components_Toolbar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/Toolbar */ "./src/components/Toolbar.js");
/* harmony import */ var _components_Icon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/Icon */ "./src/components/Icon.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../constants */ "./src/constants.js");







var renderElement = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["makeRenderElement"])(_constants__WEBPACK_IMPORTED_MODULE_6__["BULLETED_LIST"], function (_ref) {
  var attributes = _ref.attributes,
      children = _ref.children;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("ul", attributes, children);
});
var handleMessage = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["addMessageListener"])(_constants__WEBPACK_IMPORTED_MODULE_6__["BULLETED_LIST"], function (_ref2) {
  var editor = _ref2.editor;
  var isActive = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["isBlockActive"])(editor, _constants__WEBPACK_IMPORTED_MODULE_6__["BULLETED_LIST"]); // Unwrap all the items of any list

  slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].unwrapNodes(editor, {
    match: _helpers__WEBPACK_IMPORTED_MODULE_3__["isList"],
    split: true
  });

  if (isActive) {
    slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].setNodes(editor, {
      type: 'paragraph'
    });
  } else {
    slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].setNodes(editor, {
      type: _constants__WEBPACK_IMPORTED_MODULE_6__["LIST_ITEM"]
    });
    slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].wrapNodes(editor, {
      type: _constants__WEBPACK_IMPORTED_MODULE_6__["BULLETED_LIST"],
      children: []
    });
  }
});

var ToolbarButton = function ToolbarButton() {
  var editor = Object(slate_react__WEBPACK_IMPORTED_MODULE_2__["useSlate"])();
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Toolbar__WEBPACK_IMPORTED_MODULE_4__["default"].Button, {
    active: Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["isBlockActive"])(editor, _constants__WEBPACK_IMPORTED_MODULE_6__["BULLETED_LIST"]),
    onMouseDown: function onMouseDown(event) {
      event.preventDefault();
      Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["postMessage"])(_constants__WEBPACK_IMPORTED_MODULE_6__["BULLETED_LIST"], {}, editor);
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_5__["default"], null, "format_list_bulleted"));
};

/* harmony default export */ __webpack_exports__["default"] = (Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["createPlugin"])({
  name: _constants__WEBPACK_IMPORTED_MODULE_6__["BULLETED_LIST"],
  renderElement: renderElement,
  handleMessage: handleMessage,
  ToolbarButton: ToolbarButton
}));

/***/ }),

/***/ "./src/plugins/editorPlaceholder.js":
/*!******************************************!*\
  !*** ./src/plugins/editorPlaceholder.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers */ "./src/helpers/index.js");


var styles = {
  placeholder: {
    boxSizing: 'border-box',
    position: 'absolute',
    top: 0,
    left: 0,
    width: '100%',
    padding: 16,
    lineHeight: 1.5,
    color: 'lightgrey',
    zIndex: -1
  }
};
var CACHE_TTL = 500;

var isDefined = function isDefined(ref) {
  return typeof ref.current !== 'undefined';
};

var checkEmptyOptimistically = function checkEmptyOptimistically(content) {
  return content.length === 1 && content[0].type === 'paragraph' && content[0].children.length === 1 && content[0].children[0].text === '';
};

var EditorPlaceholder = function EditorPlaceholder(_ref) {
  var value = _ref.value,
      editor = _ref.editor;
  var cache = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(undefined);

  var _useForceUpdate = Object(_helpers__WEBPACK_IMPORTED_MODULE_1__["useForceUpdate"])(),
      isForceUpdated = _useForceUpdate.isForceUpdated,
      forceUpdate = _useForceUpdate.forceUpdate;

  var createPlaceholder = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(function () {
    var isEmpty = checkEmptyOptimistically(editor.children);
    return isEmpty ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      style: styles.placeholder
    }, value) : null;
  }, []);
  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    if (isDefined(cache)) {
      var timerId = setTimeout(function () {
        cache.current = undefined;
        if (!isForceUpdated) forceUpdate();
      }, CACHE_TTL);
      return function () {
        return clearTimeout(timerId);
      };
    }
  });
  if (isDefined(cache)) return cache.current;
  cache.current = createPlaceholder();
  return cache.current;
};

/* harmony default export */ __webpack_exports__["default"] = (function (_ref2) {
  var value = _ref2.value;
  return Object(_helpers__WEBPACK_IMPORTED_MODULE_1__["createPlugin"])({
    name: 'editor-placeholder',
    renderCustom: function renderCustom(editor) {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(EditorPlaceholder, {
        key: "editor-placeholder",
        value: value,
        editor: editor
      });
    }
  });
});

/***/ }),

/***/ "./src/plugins/index.js":
/*!******************************!*\
  !*** ./src/plugins/index.js ***!
  \******************************/
/*! exports provided: bold, italic, underline, logger, bulletedList, numberedList, listItem, mention, editorPlaceholder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _bold__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bold */ "./src/plugins/bold.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bold", function() { return _bold__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _italic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./italic */ "./src/plugins/italic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "italic", function() { return _italic__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _underline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./underline */ "./src/plugins/underline.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "underline", function() { return _underline__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./logger */ "./src/plugins/logger.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logger", function() { return _logger__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _bulletedList__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bulletedList */ "./src/plugins/bulletedList.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bulletedList", function() { return _bulletedList__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _numberedList__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./numberedList */ "./src/plugins/numberedList.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "numberedList", function() { return _numberedList__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _listItem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./listItem */ "./src/plugins/listItem.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "listItem", function() { return _listItem__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _mention__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mention */ "./src/plugins/mention.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mention", function() { return _mention__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _editorPlaceholder__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./editorPlaceholder */ "./src/plugins/editorPlaceholder.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "editorPlaceholder", function() { return _editorPlaceholder__WEBPACK_IMPORTED_MODULE_8__["default"]; });











/***/ }),

/***/ "./src/plugins/italic.js":
/*!*******************************!*\
  !*** ./src/plugins/italic.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate-react */ "../node_modules/slate-react/dist/index.es.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers */ "./src/helpers/index.js");
/* harmony import */ var _components_Toolbar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/Toolbar */ "./src/components/Toolbar.js");
/* harmony import */ var _components_Icon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/Icon */ "./src/components/Icon.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants */ "./src/constants.js");






var renderLeaf = Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["makeRenderLeaf"])(_constants__WEBPACK_IMPORTED_MODULE_5__["ITALIC"], function (_ref) {
  var children = _ref.children;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("em", null, children);
});
var handleMessage = Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["addMessageListener"])(_constants__WEBPACK_IMPORTED_MODULE_5__["ITALIC"], function (_ref2) {
  var editor = _ref2.editor;
  Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["toggleMark"])(editor, _constants__WEBPACK_IMPORTED_MODULE_5__["ITALIC"]);
});

var ToolbarButton = function ToolbarButton() {
  var editor = Object(slate_react__WEBPACK_IMPORTED_MODULE_1__["useSlate"])();
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Toolbar__WEBPACK_IMPORTED_MODULE_3__["default"].Button, {
    active: Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["isMarkActive"])(editor, _constants__WEBPACK_IMPORTED_MODULE_5__["ITALIC"]),
    onMouseDown: function onMouseDown(event) {
      event.preventDefault();
      Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["postMessage"])(_constants__WEBPACK_IMPORTED_MODULE_5__["ITALIC"], {}, editor);
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_4__["default"], null, "format_italic"));
};

/* harmony default export */ __webpack_exports__["default"] = (Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["createPlugin"])({
  name: _constants__WEBPACK_IMPORTED_MODULE_5__["ITALIC"],
  renderLeaf: renderLeaf,
  handleMessage: handleMessage,
  ToolbarButton: ToolbarButton
}));

/***/ }),

/***/ "./src/plugins/listItem.js":
/*!*********************************!*\
  !*** ./src/plugins/listItem.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers */ "./src/helpers/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants */ "./src/constants.js");



var renderElement = Object(_helpers__WEBPACK_IMPORTED_MODULE_1__["makeRenderElement"])(_constants__WEBPACK_IMPORTED_MODULE_2__["LIST_ITEM"], function (_ref) {
  var attributes = _ref.attributes,
      children = _ref.children;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", attributes, children);
});
/* harmony default export */ __webpack_exports__["default"] = (Object(_helpers__WEBPACK_IMPORTED_MODULE_1__["createPlugin"])({
  name: _constants__WEBPACK_IMPORTED_MODULE_2__["LIST_ITEM"],
  renderElement: renderElement
}));

/***/ }),

/***/ "./src/plugins/logger.js":
/*!*******************************!*\
  !*** ./src/plugins/logger.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers */ "./src/helpers/index.js");

var name = 'logger';

var isEmpty = function isEmpty(object) {
  return Object.keys(object).length < 1;
};

var handleMessage = function handleMessage() {
  var listener = function listener(event) {
    var _event$data$type;

    if ((_event$data$type = event.data.type) === null || _event$data$type === void 0 ? void 0 : _event$data$type.startsWith('@hero-editor')) {
      var groupMethod = isEmpty(event.data.data) ? 'groupCollapsed' : 'group';
      console[groupMethod]("%c ".concat(event.data.type, " "), 'color: limegreen;');
      console.log({
        data: event.data.data,
        event: event
      });
      console.groupEnd();
    }
  };

  window.addEventListener('message', listener);
  return function () {
    return window.removeEventListener('message', listener);
  };
};

/* harmony default export */ __webpack_exports__["default"] = (Object(_helpers__WEBPACK_IMPORTED_MODULE_0__["createPlugin"])({
  name: name,
  handleMessage: handleMessage
}));

/***/ }),

/***/ "./src/plugins/mention.js":
/*!********************************!*\
  !*** ./src/plugins/mention.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ "../node_modules/slate/dist/index.es.js");
/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! slate-react */ "../node_modules/slate-react/dist/index.es.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers */ "./src/helpers/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants */ "./src/constants.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }







var MentionElement = function MentionElement(_ref) {
  var attributes = _ref.attributes,
      children = _ref.children,
      element = _ref.element;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", _extends({}, attributes, {
    contentEditable: false,
    style: {
      padding: '2px 4px',
      background: 'lavender',
      borderRadius: 4
    }
  }), "@", element.data.name, children);
};

var renderElement = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["makeRenderElement"])(_constants__WEBPACK_IMPORTED_MODULE_4__["MENTION"], MentionElement);

var handleMessage = function handleMessage(editor) {
  var removeEditorChangeListener = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["addMessageListener"])(_constants__WEBPACK_IMPORTED_MODULE_4__["EDITOR_CHANGE"], function (_ref2) {
    var editor = _ref2.editor;
    var selection = editor.selection;

    if (selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isCollapsed(selection)) {
      var _Range$edges = slate__WEBPACK_IMPORTED_MODULE_1__["Range"].edges(selection),
          _Range$edges2 = _slicedToArray(_Range$edges, 1),
          start = _Range$edges2[0];

      var wordBefore = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].before(editor, start, {
        unit: 'word'
      });
      var before = wordBefore && slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].before(editor, wordBefore);
      var beforeRange = before && slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].range(editor, before, start);
      var beforeText = beforeRange && slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].string(editor, beforeRange);
      var beforeMatch = beforeText && beforeText.match(/^@(\w+)$/);
      var after = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].after(editor, start);
      var afterRange = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].range(editor, start, after);
      var afterText = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].string(editor, afterRange);
      var afterMatch = afterText.match(/^(\s|$)/);

      if (beforeMatch && afterMatch) {
        Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["postMessage"])('mention-search', {
          target: beforeRange,
          search: beforeMatch[1]
        }, editor);
      } else {
        Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["postMessage"])('mention-search', {
          target: null,
          search: ''
        }, editor);
      }
    }
  })(editor);
  var removeMentionApplyListener = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["addMessageListener"])('mention-apply', function (_ref3) {
    var editor = _ref3.editor,
        data = _ref3.data;
    var id = data.id,
        name = data.name,
        meta = data.meta;
    slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].select(editor, meta.target);
    var mention = {
      type: _constants__WEBPACK_IMPORTED_MODULE_4__["MENTION"],
      data: {
        id: id,
        name: name
      },
      children: [{
        text: ''
      }]
    };
    slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].insertNodes(editor, mention);
    slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].move(editor);
  })(editor);
  return function () {
    removeEditorChangeListener();
    removeMentionApplyListener();
  };
};

var MentionListWrapper = function MentionListWrapper(_ref4) {
  var renderMentionList = _ref4.renderMentionList;

  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(''),
      _useState2 = _slicedToArray(_useState, 2),
      search = _useState2[0],
      setSearch = _useState2[1];

  var _useState3 = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(null),
      _useState4 = _slicedToArray(_useState3, 2),
      target = _useState4[0],
      setTarget = _useState4[1];

  var wrapper = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(null);
  var editor = Object(slate_react__WEBPACK_IMPORTED_MODULE_2__["useSlate"])();
  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    var removeMentionSearchListener = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["addMessageListener"])('mention-search', function (_ref5) {
      var data = _ref5.data;
      var wrapperEl = wrapper.current;

      if (data.target) {
        var domRange = slate_react__WEBPACK_IMPORTED_MODULE_2__["ReactEditor"].toDOMRange(editor, data.target);
        var rangeRect = domRange.getBoundingClientRect();
        var editorRect = wrapperEl.parentElement.getBoundingClientRect();
        wrapperEl.style.display = 'block';
        wrapperEl.style.top = "".concat(rangeRect.top - editorRect.top + 20, "px");
        wrapperEl.style.left = "".concat(rangeRect.left - editorRect.left, "px");
      } else {
        wrapperEl.style.display = 'none';
      }

      setSearch(data.search);
      setTarget(data.target);
    })(editor);
    return function () {
      return removeMentionSearchListener();
    };
  }, []);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
    ref: wrapper,
    style: {
      position: 'absolute',
      display: 'none'
    }
  }, renderMentionList(search, function (_ref6) {
    var id = _ref6.id,
        name = _ref6.name;
    Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["postMessage"])('mention-apply', {
      id: id,
      name: name,
      meta: {
        target: target
      }
    }, editor);
  }));
};

var enhanceEditor = function enhanceEditor(editor) {
  var isInline = editor.isInline,
      isVoid = editor.isVoid;

  editor.isInline = function (element) {
    return element.type === _constants__WEBPACK_IMPORTED_MODULE_4__["MENTION"] ? true : isInline(element);
  };

  editor.isVoid = function (element) {
    return element.type === _constants__WEBPACK_IMPORTED_MODULE_4__["MENTION"] ? true : isVoid(element);
  };

  return editor;
};

/* harmony default export */ __webpack_exports__["default"] = (function (_ref7) {
  var renderMentionList = _ref7.renderMentionList;
  return Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["createPlugin"])({
    name: _constants__WEBPACK_IMPORTED_MODULE_4__["MENTION"],
    renderElement: renderElement,
    renderCustom: function renderCustom() {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(MentionListWrapper, {
        key: _constants__WEBPACK_IMPORTED_MODULE_4__["MENTION"],
        renderMentionList: renderMentionList
      });
    },
    handleMessage: handleMessage,
    enhanceEditor: enhanceEditor
  });
});

/***/ }),

/***/ "./src/plugins/numberedList.js":
/*!*************************************!*\
  !*** ./src/plugins/numberedList.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ "../node_modules/slate/dist/index.es.js");
/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! slate-react */ "../node_modules/slate-react/dist/index.es.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers */ "./src/helpers/index.js");
/* harmony import */ var _components_Toolbar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/Toolbar */ "./src/components/Toolbar.js");
/* harmony import */ var _components_Icon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/Icon */ "./src/components/Icon.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../constants */ "./src/constants.js");







var renderElement = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["makeRenderElement"])(_constants__WEBPACK_IMPORTED_MODULE_6__["NUMBERED_LIST"], function (_ref) {
  var attributes = _ref.attributes,
      children = _ref.children;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("ol", attributes, children);
});
var handleMessage = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["addMessageListener"])(_constants__WEBPACK_IMPORTED_MODULE_6__["NUMBERED_LIST"], function (_ref2) {
  var editor = _ref2.editor;
  var isActive = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["isBlockActive"])(editor, _constants__WEBPACK_IMPORTED_MODULE_6__["NUMBERED_LIST"]); // Unwrap all the items of any list

  slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].unwrapNodes(editor, {
    match: _helpers__WEBPACK_IMPORTED_MODULE_3__["isList"],
    split: true
  });

  if (isActive) {
    slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].setNodes(editor, {
      type: 'paragraph'
    });
  } else {
    slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].setNodes(editor, {
      type: _constants__WEBPACK_IMPORTED_MODULE_6__["LIST_ITEM"]
    });
    slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].wrapNodes(editor, {
      type: _constants__WEBPACK_IMPORTED_MODULE_6__["NUMBERED_LIST"],
      children: []
    });
  }
});

var ToolbarButton = function ToolbarButton() {
  var editor = Object(slate_react__WEBPACK_IMPORTED_MODULE_2__["useSlate"])();
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Toolbar__WEBPACK_IMPORTED_MODULE_4__["default"].Button, {
    active: Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["isBlockActive"])(editor, _constants__WEBPACK_IMPORTED_MODULE_6__["NUMBERED_LIST"]),
    onMouseDown: function onMouseDown(event) {
      event.preventDefault();
      Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["postMessage"])(_constants__WEBPACK_IMPORTED_MODULE_6__["NUMBERED_LIST"], {}, editor);
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_5__["default"], null, "format_list_numbered"));
};

/* harmony default export */ __webpack_exports__["default"] = (Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["createPlugin"])({
  name: _constants__WEBPACK_IMPORTED_MODULE_6__["NUMBERED_LIST"],
  renderElement: renderElement,
  handleMessage: handleMessage,
  ToolbarButton: ToolbarButton
}));

/***/ }),

/***/ "./src/plugins/underline.js":
/*!**********************************!*\
  !*** ./src/plugins/underline.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate-react */ "../node_modules/slate-react/dist/index.es.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers */ "./src/helpers/index.js");
/* harmony import */ var _components_Toolbar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/Toolbar */ "./src/components/Toolbar.js");
/* harmony import */ var _components_Icon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/Icon */ "./src/components/Icon.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants */ "./src/constants.js");






var renderLeaf = Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["makeRenderLeaf"])(_constants__WEBPACK_IMPORTED_MODULE_5__["UNDERLINE"], function (_ref) {
  var children = _ref.children;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("u", null, children);
});
var handleMessage = Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["addMessageListener"])(_constants__WEBPACK_IMPORTED_MODULE_5__["UNDERLINE"], function (_ref2) {
  var editor = _ref2.editor;
  Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["toggleMark"])(editor, _constants__WEBPACK_IMPORTED_MODULE_5__["UNDERLINE"]);
});

var ToolbarButton = function ToolbarButton() {
  var editor = Object(slate_react__WEBPACK_IMPORTED_MODULE_1__["useSlate"])();
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Toolbar__WEBPACK_IMPORTED_MODULE_3__["default"].Button, {
    active: Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["isMarkActive"])(editor, _constants__WEBPACK_IMPORTED_MODULE_5__["UNDERLINE"]),
    onMouseDown: function onMouseDown(event) {
      event.preventDefault();
      Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["postMessage"])(_constants__WEBPACK_IMPORTED_MODULE_5__["UNDERLINE"], {}, editor);
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_4__["default"], null, "format_underlined")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Toolbar__WEBPACK_IMPORTED_MODULE_3__["default"].Separator, null));
};

/* harmony default export */ __webpack_exports__["default"] = (Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["createPlugin"])({
  name: _constants__WEBPACK_IMPORTED_MODULE_5__["UNDERLINE"],
  renderLeaf: renderLeaf,
  handleMessage: handleMessage,
  ToolbarButton: ToolbarButton
}));

/***/ }),

/***/ "react":
/*!**************************************************************************************!*\
  !*** external {"root":"React","commonjs2":"react","commonjs":"react","amd":"react"} ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_react__;

/***/ }),

/***/ "react-dom":
/*!*****************************************************************************************************!*\
  !*** external {"root":"ReactDOM","commonjs2":"react-dom","commonjs":"react-dom","amd":"react-dom"} ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_react_dom__;

/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvbXB1dGUtc2Nyb2xsLWludG8tdmlldy9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2RpcmVjdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzcmV2ZXIvZXNyZXZlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2ltbWVyL2Rpc3QvaW1tZXIubW9kdWxlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaXMtaG90a2V5L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL2RlYm91bmNlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9ub3cuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdGhyb3R0bGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9OdW1iZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9zY3JvbGwtaW50by12aWV3LWlmLW5lZWRlZC9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3NsYXRlLXJlYWN0L2Rpc3QvaW5kZXguZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9zbGF0ZS9kaXN0L2luZGV4LmVzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvc2xhdGUvbm9kZV9tb2R1bGVzL2lzLXBsYWluLW9iamVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3NsYXRlL25vZGVfbW9kdWxlcy9pc29iamVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0ljb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvSnNvblZpZXdlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Ub29sYmFyLmpzIiwid2VicGFjazovLy8uL3NyYy9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlbHBlcnMvYXBwbHkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlbHBlcnMvY29tcG9zZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaGVscGVycy9jcmVhdGVQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlbHBlcnMvZWxlbWVudEhlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlbHBlcnMvZmxvdy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaGVscGVycy9nZXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlbHBlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlbHBlcnMvbGVhZkhlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlbHBlcnMvbWFwLmpzIiwid2VicGFjazovLy8uL3NyYy9oZWxwZXJzL21lc3NhZ2VIZWxwZXJzLmpzIiwid2VicGFjazovLy8uL3NyYy9oZWxwZXJzL3VzZUZvcmNlVXBkYXRlLmpzIiwid2VicGFjazovLy8uL3NyYy9oZWxwZXJzL3dpdGhJZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliLmpzIiwid2VicGFjazovLy8uL3NyYy9wbHVnaW5zL2JvbGQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BsdWdpbnMvYnVsbGV0ZWRMaXN0LmpzIiwid2VicGFjazovLy8uL3NyYy9wbHVnaW5zL2VkaXRvclBsYWNlaG9sZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9wbHVnaW5zL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9wbHVnaW5zL2l0YWxpYy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGx1Z2lucy9saXN0SXRlbS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGx1Z2lucy9sb2dnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BsdWdpbnMvbWVudGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGx1Z2lucy9udW1iZXJlZExpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BsdWdpbnMvdW5kZXJsaW5lLmpzIiwid2VicGFjazovLy9leHRlcm5hbCB7XCJyb290XCI6XCJSZWFjdFwiLFwiY29tbW9uanMyXCI6XCJyZWFjdFwiLFwiY29tbW9uanNcIjpcInJlYWN0XCIsXCJhbWRcIjpcInJlYWN0XCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJyb290XCI6XCJSZWFjdERPTVwiLFwiY29tbW9uanMyXCI6XCJyZWFjdC1kb21cIixcImNvbW1vbmpzXCI6XCJyZWFjdC1kb21cIixcImFtZFwiOlwicmVhY3QtZG9tXCJ9Il0sIm5hbWVzIjpbInN2Z0ljb25zIiwiZm9ybWF0X2JvbGQiLCJmb3JtYXRfaXRhbGljIiwiZm9ybWF0X3VuZGVybGluZWQiLCJmb3JtYXRfbGlzdF9idWxsZXRlZCIsImZvcm1hdF9saXN0X251bWJlcmVkIiwic3R5bGVzIiwiaWNvbiIsIm9wYWNpdHkiLCJJY29uIiwiY2hpbGRyZW4iLCJqc29uVmlld2VyIiwicGFkZGluZyIsImJvcmRlclJhZGl1cyIsImJhY2tncm91bmQiLCJKc29uVmlld2VyIiwidmFsdWUiLCJKU09OIiwic3RyaW5naWZ5IiwidG9vbGJhciIsImRpc3BsYXkiLCJmbGV4RGlyZWN0aW9uIiwiYnV0dG9uIiwiYWxpZ25JdGVtcyIsImp1c3RpZnlDb250ZW50IiwiaGVpZ2h0IiwibWluV2lkdGgiLCJtYXJnaW4iLCJib3JkZXIiLCJjdXJzb3IiLCJidXR0b25BY3RpdmUiLCJzZXBhcmF0b3IiLCJib3JkZXJSaWdodCIsIlRvb2xiYXIiLCJCdXR0b24iLCJhY3RpdmUiLCJwcm9wcyIsInVuZGVmaW5lZCIsIlNlcGFyYXRvciIsIkJVTExFVEVEX0xJU1QiLCJOVU1CRVJFRF9MSVNUIiwiTElTVF9JVEVNIiwiTUVOVElPTiIsIkJPTEQiLCJJVEFMSUMiLCJVTkRFUkxJTkUiLCJFRElUT1JfQ0hBTkdFIiwiYXBwbHkiLCJhcmdzIiwiZnVuYyIsImNvbXBvc2UiLCJmdW5jcyIsImFyZyIsInJlZHVjZVJpZ2h0IiwiY29tcG9zZWQiLCJmIiwiY3JlYXRlUGx1Z2luIiwiY29uZmlncyIsImRlZmF1bHRQbHVnaW4iLCJuYW1lIiwicmVuZGVyTGVhZiIsIm5leHQiLCJyZW5kZXJFbGVtZW50IiwiVG9vbGJhckJ1dHRvbiIsInJlbmRlckN1c3RvbSIsImhhbmRsZU1lc3NhZ2UiLCJlbmhhbmNlRWRpdG9yIiwiZWRpdG9yIiwiaXNCbG9ja0FjdGl2ZSIsImZvcm1hdCIsIkVkaXRvciIsIm5vZGVzIiwibWF0Y2giLCJuIiwidHlwZSIsImlzTGlzdCIsIm5vZGUiLCJpbmNsdWRlcyIsIkRlZmF1bHRFbGVtZW50IiwiUmVhY3QiLCJmb3J3YXJkUmVmIiwicmVmIiwibGluZUhlaWdodCIsInJlbmRlckRlZmF1bHRFbGVtZW50IiwiYXR0cmlidXRlcyIsIm1ha2VSZW5kZXJFbGVtZW50IiwiYmxvY2siLCJDdXN0b21FbGVtZW50IiwiZWxlbWVudCIsImNvbXBvc2VSZW5kZXJFbGVtZW50IiwicGx1Z2lucyIsIm1hcCIsInBsdWdpbiIsImZsb3ciLCJyZWR1Y2UiLCJnZXQiLCJwYXRoIiwib2JqZWN0IiwiaXNNYXJrQWN0aXZlIiwibWFya3MiLCJ0b2dnbGVNYXJrIiwiaXNBY3RpdmUiLCJyZW1vdmVNYXJrIiwiYWRkTWFyayIsIkRlZmF1bHRMZWFmIiwicmVuZGVyRGVmYXVsdExlYWYiLCJtYWtlUmVuZGVyTGVhZiIsIm1hcmsiLCJDdXN0b21MZWFmIiwibGVhZiIsImNvbXBvc2VSZW5kZXJMZWFmIiwiaXRlcmF0ZWUiLCJjb2xsZWN0aW9uIiwibWVzc2FnZVByZWZpeCIsImFkZE1lc3NhZ2VMaXN0ZW5lciIsImNhbGxiYWNrIiwibGlzdGVuZXIiLCJldmVudCIsImRhdGEiLCJpZCIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicG9zdE1lc3NhZ2UiLCJtZXNzYWdlIiwiUmVhY3ROYXRpdmVXZWJWaWV3IiwidXNlRm9yY2VVcGRhdGUiLCJwcmV2IiwidXNlUmVmIiwidXNlU3RhdGUiLCJjdXJyIiwic2V0Q3VyciIsImlzRm9yY2VVcGRhdGVkIiwiY3VycmVudCIsImZvcmNlVXBkYXRlIiwid2l0aElkIiwiZWRpdG9yV3JhcHBlciIsImZvbnRGYW1pbHkiLCJlZGl0YWJsZVdyYXBwZXIiLCJwb3NpdGlvbiIsImVkaXRhYmxlIiwiZ2V0Q3VzdG9tRWxlbWVudHMiLCJhZGRNZXNzYWdlTGlzdGVuZXJzIiwiZ2V0VG9vbGJhckJ1dHRvbnMiLCJIZXJvRWRpdG9yIiwic2hvd1Rvb2xiYXIiLCJwbGFjZWhvbGRlciIsIm9uQ2hhbmdlIiwid3JhcHBlclN0eWxlIiwidXNlTWVtbyIsImNyZWF0ZUVkaXRvciIsIndpdGhSZWFjdCIsInRvb2xCYXJCdXR0b25zIiwidXNlRWZmZWN0IiwicmVtb3ZlSGFuZGxlcnMiLCJmb3JFYWNoIiwicmVtb3ZlSGFuZGxlciIsInVzZVNsYXRlIiwicHJldmVudERlZmF1bHQiLCJUcmFuc2Zvcm1zIiwidW53cmFwTm9kZXMiLCJzcGxpdCIsInNldE5vZGVzIiwid3JhcE5vZGVzIiwiYm94U2l6aW5nIiwidG9wIiwibGVmdCIsIndpZHRoIiwiY29sb3IiLCJ6SW5kZXgiLCJDQUNIRV9UVEwiLCJpc0RlZmluZWQiLCJjaGVja0VtcHR5T3B0aW1pc3RpY2FsbHkiLCJjb250ZW50IiwibGVuZ3RoIiwidGV4dCIsIkVkaXRvclBsYWNlaG9sZGVyIiwiY2FjaGUiLCJjcmVhdGVQbGFjZWhvbGRlciIsInVzZUNhbGxiYWNrIiwiaXNFbXB0eSIsInRpbWVySWQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiT2JqZWN0Iiwia2V5cyIsInN0YXJ0c1dpdGgiLCJncm91cE1ldGhvZCIsImNvbnNvbGUiLCJsb2ciLCJncm91cEVuZCIsIk1lbnRpb25FbGVtZW50IiwicmVtb3ZlRWRpdG9yQ2hhbmdlTGlzdGVuZXIiLCJzZWxlY3Rpb24iLCJSYW5nZSIsImlzQ29sbGFwc2VkIiwiZWRnZXMiLCJzdGFydCIsIndvcmRCZWZvcmUiLCJiZWZvcmUiLCJ1bml0IiwiYmVmb3JlUmFuZ2UiLCJyYW5nZSIsImJlZm9yZVRleHQiLCJzdHJpbmciLCJiZWZvcmVNYXRjaCIsImFmdGVyIiwiYWZ0ZXJSYW5nZSIsImFmdGVyVGV4dCIsImFmdGVyTWF0Y2giLCJ0YXJnZXQiLCJzZWFyY2giLCJyZW1vdmVNZW50aW9uQXBwbHlMaXN0ZW5lciIsIm1ldGEiLCJzZWxlY3QiLCJtZW50aW9uIiwiaW5zZXJ0Tm9kZXMiLCJtb3ZlIiwiTWVudGlvbkxpc3RXcmFwcGVyIiwicmVuZGVyTWVudGlvbkxpc3QiLCJzZXRTZWFyY2giLCJzZXRUYXJnZXQiLCJ3cmFwcGVyIiwicmVtb3ZlTWVudGlvblNlYXJjaExpc3RlbmVyIiwid3JhcHBlckVsIiwiZG9tUmFuZ2UiLCJSZWFjdEVkaXRvciIsInRvRE9NUmFuZ2UiLCJyYW5nZVJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJlZGl0b3JSZWN0IiwicGFyZW50RWxlbWVudCIsInN0eWxlIiwiaXNJbmxpbmUiLCJpc1ZvaWQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO1FDVkE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQix1QkFBdUI7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQyxFOzs7Ozs7Ozs7Ozs7QUNwTVc7O0FBRVo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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O0FBQ0w7QUFDQTs7QUFFQSxtQkFBbUIsVUFBVTs7QUFFN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7OztBQUc5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLGFBQWE7QUFDN0MsNkVBQTZFLGFBQWE7QUFDMUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBELGdFQUFnRTtBQUMxSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEI7Ozs7Ozs7Ozs7O0FDcFBBLFdBQVcsbUJBQU8sQ0FBQyxnREFBUzs7QUFF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Q0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7Ozs7Ozs7Ozs7Ozs7QUN2THRDO0FBQUE7QUFBK0M7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW9ELHdFQUFPO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qix3RUFBTztBQUNoQzs7QUFFZSw2RUFBYyxFOzs7Ozs7Ozs7Ozs7QUMvRDdCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUE2SDtBQUNmO0FBQ3ZFO0FBQ2lCO0FBQ25CO0FBQ0o7QUFDTzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLDZCQUE2QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSw0Q0FBTTtBQUNsQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7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QSwyREFBMkQ7QUFDM0Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtEQUFhLG1uQkFBbW5CLCtEQUFhO0FBQ3hwQixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7O0FBRWxEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7O0FBR1AsaUVBQWlFOztBQUVqRSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQkFBK0IsdURBQU87QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseURBQVc7QUFDakMsd0NBQXdDLHlEQUFXOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHVDQUF1QztBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFF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O0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTyx3Q0FBd0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELDhEQUE4RCxnRUFBZ0UsRUFBRSxFQUFFLGdDQUFnQyxFQUFFLGFBQWE7O0FBRXJWLGtDQUFrQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEseURBQXlELDJDQUEyQyxFQUFFLEVBQUUsRUFBRSw2Q0FBNkMsMkVBQTJFLEVBQUUsT0FBTyxtREFBbUQsa0ZBQWtGLEVBQUUsRUFBRSxFQUFFLEVBQUUsZUFBZTtBQUMxaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtFQUFrRSxXQUFXO0FBQzdFLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPLEVBQUU7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCx3Q0FBd0MsNEJBQTRCOztBQUVwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FB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QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBRUEsSUFBTUgsVUFBVSxHQUFHOEMsK0RBQWMsQ0FBQzdELG9EQUFELEVBQVk7QUFBQSxNQUFHbkMsUUFBSCxRQUFHQSxRQUFIO0FBQUEsc0JBQzNDLHNFQUFJQSxRQUFKLENBRDJDO0FBQUEsQ0FBWixDQUFqQztBQUlBLElBQU11RCxhQUFhLEdBQUdpRCxtRUFBa0IsQ0FBQ3JFLG9EQUFELEVBQVksaUJBQWdCO0FBQUEsTUFBYnNCLE1BQWEsU0FBYkEsTUFBYTtBQUNsRWlDLDZEQUFVLENBQUNqQyxNQUFELEVBQVN0QixvREFBVCxDQUFWO0FBQ0QsQ0FGdUMsQ0FBeEM7O0FBSUEsSUFBTWtCLGFBQWEsR0FBRyxTQUFoQkEsYUFBZ0IsR0FBTTtBQUMxQixNQUFNSSxNQUFNLEdBQUcwRiw0REFBUSxFQUF2QjtBQUVBLHNCQUNFLHFJQUNFLDJEQUFDLDJEQUFELENBQVMsTUFBVDtBQUNFLFVBQU0sRUFBRTNELDZEQUFZLENBQUMvQixNQUFELEVBQVN0QixvREFBVCxDQUR0QjtBQUVFLGVBQVcsRUFBRSxxQkFBQ3dFLEtBQUQsRUFBVztBQUN0QkEsV0FBSyxDQUFDeUMsY0FBTjtBQUNBbkMsa0VBQVcsQ0FBQzlFLG9EQUFELEVBQVksRUFBWixFQUFnQnNCLE1BQWhCLENBQVg7QUFDRDtBQUxILGtCQU9FLDJEQUFDLHdEQUFELDRCQVBGLENBREYsZUFVRSwyREFBQywyREFBRCxDQUFTLFNBQVQsT0FWRixDQURGO0FBY0QsQ0FqQkQ7O0FBbUJlWCw0SEFBWSxDQUFDO0FBQzFCRyxNQUFJLEVBQUVkLG9EQURvQjtBQUUxQmUsWUFBVSxFQUFWQSxVQUYwQjtBQUcxQkssZUFBYSxFQUFiQSxhQUgwQjtBQUkxQkYsZUFBYSxFQUFiQTtBQUowQixDQUFELENBQTNCLEU7Ozs7Ozs7Ozs7O0FDekNBLG1EOzs7Ozs7Ozs7OztBQ0FBLHVEIiwiZmlsZSI6ImxpYi5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpLCByZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcInJlYWN0XCIsIFwicmVhY3QtZG9tXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBmYWN0b3J5KHJlcXVpcmUoXCJyZWFjdFwiKSwgcmVxdWlyZShcInJlYWN0LWRvbVwiKSkgOiBmYWN0b3J5KHJvb3RbXCJSZWFjdFwiXSwgcm9vdFtcIlJlYWN0RE9NXCJdKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHdpbmRvdywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9yZWFjdF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX3JlYWN0X2RvbV9fKSB7XG5yZXR1cm4gIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvbGliLmpzXCIpO1xuIiwiZnVuY3Rpb24gaXNFbGVtZW50KGVsKSB7XG4gIHJldHVybiBlbCAhPSBudWxsICYmIHR5cGVvZiBlbCA9PT0gJ29iamVjdCcgJiYgZWwubm9kZVR5cGUgPT09IDE7XG59XG5cbmZ1bmN0aW9uIGNhbk92ZXJmbG93KG92ZXJmbG93LCBza2lwT3ZlcmZsb3dIaWRkZW5FbGVtZW50cykge1xuICBpZiAoc2tpcE92ZXJmbG93SGlkZGVuRWxlbWVudHMgJiYgb3ZlcmZsb3cgPT09ICdoaWRkZW4nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG92ZXJmbG93ICE9PSAndmlzaWJsZScgJiYgb3ZlcmZsb3cgIT09ICdjbGlwJztcbn1cblxuZnVuY3Rpb24gZ2V0RnJhbWVFbGVtZW50KGVsKSB7XG4gIGlmICghZWwub3duZXJEb2N1bWVudCB8fCAhZWwub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZWwub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5mcmFtZUVsZW1lbnQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0hpZGRlbkJ5RnJhbWUoZWwpIHtcbiAgdmFyIGZyYW1lID0gZ2V0RnJhbWVFbGVtZW50KGVsKTtcblxuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGZyYW1lLmNsaWVudEhlaWdodCA8IGVsLnNjcm9sbEhlaWdodCB8fCBmcmFtZS5jbGllbnRXaWR0aCA8IGVsLnNjcm9sbFdpZHRoO1xufVxuXG5mdW5jdGlvbiBpc1Njcm9sbGFibGUoZWwsIHNraXBPdmVyZmxvd0hpZGRlbkVsZW1lbnRzKSB7XG4gIGlmIChlbC5jbGllbnRIZWlnaHQgPCBlbC5zY3JvbGxIZWlnaHQgfHwgZWwuY2xpZW50V2lkdGggPCBlbC5zY3JvbGxXaWR0aCkge1xuICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpO1xuICAgIHJldHVybiBjYW5PdmVyZmxvdyhzdHlsZS5vdmVyZmxvd1ksIHNraXBPdmVyZmxvd0hpZGRlbkVsZW1lbnRzKSB8fCBjYW5PdmVyZmxvdyhzdHlsZS5vdmVyZmxvd1gsIHNraXBPdmVyZmxvd0hpZGRlbkVsZW1lbnRzKSB8fCBpc0hpZGRlbkJ5RnJhbWUoZWwpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhbGlnbk5lYXJlc3Qoc2Nyb2xsaW5nRWRnZVN0YXJ0LCBzY3JvbGxpbmdFZGdlRW5kLCBzY3JvbGxpbmdTaXplLCBzY3JvbGxpbmdCb3JkZXJTdGFydCwgc2Nyb2xsaW5nQm9yZGVyRW5kLCBlbGVtZW50RWRnZVN0YXJ0LCBlbGVtZW50RWRnZUVuZCwgZWxlbWVudFNpemUpIHtcbiAgaWYgKGVsZW1lbnRFZGdlU3RhcnQgPCBzY3JvbGxpbmdFZGdlU3RhcnQgJiYgZWxlbWVudEVkZ2VFbmQgPiBzY3JvbGxpbmdFZGdlRW5kIHx8IGVsZW1lbnRFZGdlU3RhcnQgPiBzY3JvbGxpbmdFZGdlU3RhcnQgJiYgZWxlbWVudEVkZ2VFbmQgPCBzY3JvbGxpbmdFZGdlRW5kKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoZWxlbWVudEVkZ2VTdGFydCA8PSBzY3JvbGxpbmdFZGdlU3RhcnQgJiYgZWxlbWVudFNpemUgPD0gc2Nyb2xsaW5nU2l6ZSB8fCBlbGVtZW50RWRnZUVuZCA+PSBzY3JvbGxpbmdFZGdlRW5kICYmIGVsZW1lbnRTaXplID49IHNjcm9sbGluZ1NpemUpIHtcbiAgICByZXR1cm4gZWxlbWVudEVkZ2VTdGFydCAtIHNjcm9sbGluZ0VkZ2VTdGFydCAtIHNjcm9sbGluZ0JvcmRlclN0YXJ0O1xuICB9XG5cbiAgaWYgKGVsZW1lbnRFZGdlRW5kID4gc2Nyb2xsaW5nRWRnZUVuZCAmJiBlbGVtZW50U2l6ZSA8IHNjcm9sbGluZ1NpemUgfHwgZWxlbWVudEVkZ2VTdGFydCA8IHNjcm9sbGluZ0VkZ2VTdGFydCAmJiBlbGVtZW50U2l6ZSA+IHNjcm9sbGluZ1NpemUpIHtcbiAgICByZXR1cm4gZWxlbWVudEVkZ2VFbmQgLSBzY3JvbGxpbmdFZGdlRW5kICsgc2Nyb2xsaW5nQm9yZGVyRW5kO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zKSB7XG4gIHZhciBzY3JvbGxNb2RlID0gb3B0aW9ucy5zY3JvbGxNb2RlLFxuICAgICAgYmxvY2sgPSBvcHRpb25zLmJsb2NrLFxuICAgICAgaW5saW5lID0gb3B0aW9ucy5pbmxpbmUsXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICBza2lwT3ZlcmZsb3dIaWRkZW5FbGVtZW50cyA9IG9wdGlvbnMuc2tpcE92ZXJmbG93SGlkZGVuRWxlbWVudHM7XG4gIHZhciBjaGVja0JvdW5kYXJ5ID0gdHlwZW9mIGJvdW5kYXJ5ID09PSAnZnVuY3Rpb24nID8gYm91bmRhcnkgOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBub2RlICE9PSBib3VuZGFyeTtcbiAgfTtcblxuICBpZiAoIWlzRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0YXJnZXQnKTtcbiAgfVxuXG4gIHZhciBzY3JvbGxpbmdFbGVtZW50ID0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBmcmFtZXMgPSBbXTtcbiAgdmFyIGN1cnNvciA9IHRhcmdldDtcblxuICB3aGlsZSAoaXNFbGVtZW50KGN1cnNvcikgJiYgY2hlY2tCb3VuZGFyeShjdXJzb3IpKSB7XG4gICAgY3Vyc29yID0gY3Vyc29yLnBhcmVudE5vZGU7XG5cbiAgICBpZiAoY3Vyc29yID09PSBzY3JvbGxpbmdFbGVtZW50KSB7XG4gICAgICBmcmFtZXMucHVzaChjdXJzb3IpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGN1cnNvciA9PT0gZG9jdW1lbnQuYm9keSAmJiBpc1Njcm9sbGFibGUoY3Vyc29yKSAmJiAhaXNTY3JvbGxhYmxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChpc1Njcm9sbGFibGUoY3Vyc29yLCBza2lwT3ZlcmZsb3dIaWRkZW5FbGVtZW50cykpIHtcbiAgICAgIGZyYW1lcy5wdXNoKGN1cnNvcik7XG4gICAgfVxuICB9XG5cbiAgdmFyIHZpZXdwb3J0V2lkdGggPSB3aW5kb3cudmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC53aWR0aCA6IGlubmVyV2lkdGg7XG4gIHZhciB2aWV3cG9ydEhlaWdodCA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCA/IHZpc3VhbFZpZXdwb3J0LmhlaWdodCA6IGlubmVySGVpZ2h0O1xuICB2YXIgdmlld3BvcnRYID0gd2luZG93LnNjcm9sbFggfHwgcGFnZVhPZmZzZXQ7XG4gIHZhciB2aWV3cG9ydFkgPSB3aW5kb3cuc2Nyb2xsWSB8fCBwYWdlWU9mZnNldDtcblxuICB2YXIgX3RhcmdldCRnZXRCb3VuZGluZ0NsID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgdGFyZ2V0SGVpZ2h0ID0gX3RhcmdldCRnZXRCb3VuZGluZ0NsLmhlaWdodCxcbiAgICAgIHRhcmdldFdpZHRoID0gX3RhcmdldCRnZXRCb3VuZGluZ0NsLndpZHRoLFxuICAgICAgdGFyZ2V0VG9wID0gX3RhcmdldCRnZXRCb3VuZGluZ0NsLnRvcCxcbiAgICAgIHRhcmdldFJpZ2h0ID0gX3RhcmdldCRnZXRCb3VuZGluZ0NsLnJpZ2h0LFxuICAgICAgdGFyZ2V0Qm90dG9tID0gX3RhcmdldCRnZXRCb3VuZGluZ0NsLmJvdHRvbSxcbiAgICAgIHRhcmdldExlZnQgPSBfdGFyZ2V0JGdldEJvdW5kaW5nQ2wubGVmdDtcblxuICB2YXIgdGFyZ2V0QmxvY2sgPSBibG9jayA9PT0gJ3N0YXJ0JyB8fCBibG9jayA9PT0gJ25lYXJlc3QnID8gdGFyZ2V0VG9wIDogYmxvY2sgPT09ICdlbmQnID8gdGFyZ2V0Qm90dG9tIDogdGFyZ2V0VG9wICsgdGFyZ2V0SGVpZ2h0IC8gMjtcbiAgdmFyIHRhcmdldElubGluZSA9IGlubGluZSA9PT0gJ2NlbnRlcicgPyB0YXJnZXRMZWZ0ICsgdGFyZ2V0V2lkdGggLyAyIDogaW5saW5lID09PSAnZW5kJyA/IHRhcmdldFJpZ2h0IDogdGFyZ2V0TGVmdDtcbiAgdmFyIGNvbXB1dGF0aW9ucyA9IFtdO1xuXG4gIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBmcmFtZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgdmFyIGZyYW1lID0gZnJhbWVzW2luZGV4XTtcblxuICAgIHZhciBfZnJhbWUkZ2V0Qm91bmRpbmdDbGkgPSBmcmFtZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgaGVpZ2h0ID0gX2ZyYW1lJGdldEJvdW5kaW5nQ2xpLmhlaWdodCxcbiAgICAgICAgd2lkdGggPSBfZnJhbWUkZ2V0Qm91bmRpbmdDbGkud2lkdGgsXG4gICAgICAgIHRvcCA9IF9mcmFtZSRnZXRCb3VuZGluZ0NsaS50b3AsXG4gICAgICAgIHJpZ2h0ID0gX2ZyYW1lJGdldEJvdW5kaW5nQ2xpLnJpZ2h0LFxuICAgICAgICBib3R0b20gPSBfZnJhbWUkZ2V0Qm91bmRpbmdDbGkuYm90dG9tLFxuICAgICAgICBsZWZ0ID0gX2ZyYW1lJGdldEJvdW5kaW5nQ2xpLmxlZnQ7XG5cbiAgICBpZiAoc2Nyb2xsTW9kZSA9PT0gJ2lmLW5lZWRlZCcgJiYgdGFyZ2V0VG9wID49IDAgJiYgdGFyZ2V0TGVmdCA+PSAwICYmIHRhcmdldEJvdHRvbSA8PSB2aWV3cG9ydEhlaWdodCAmJiB0YXJnZXRSaWdodCA8PSB2aWV3cG9ydFdpZHRoICYmIHRhcmdldFRvcCA+PSB0b3AgJiYgdGFyZ2V0Qm90dG9tIDw9IGJvdHRvbSAmJiB0YXJnZXRMZWZ0ID49IGxlZnQgJiYgdGFyZ2V0UmlnaHQgPD0gcmlnaHQpIHtcbiAgICAgIHJldHVybiBjb21wdXRhdGlvbnM7XG4gICAgfVxuXG4gICAgdmFyIGZyYW1lU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGZyYW1lKTtcbiAgICB2YXIgYm9yZGVyTGVmdCA9IHBhcnNlSW50KGZyYW1lU3R5bGUuYm9yZGVyTGVmdFdpZHRoLCAxMCk7XG4gICAgdmFyIGJvcmRlclRvcCA9IHBhcnNlSW50KGZyYW1lU3R5bGUuYm9yZGVyVG9wV2lkdGgsIDEwKTtcbiAgICB2YXIgYm9yZGVyUmlnaHQgPSBwYXJzZUludChmcmFtZVN0eWxlLmJvcmRlclJpZ2h0V2lkdGgsIDEwKTtcbiAgICB2YXIgYm9yZGVyQm90dG9tID0gcGFyc2VJbnQoZnJhbWVTdHlsZS5ib3JkZXJCb3R0b21XaWR0aCwgMTApO1xuICAgIHZhciBibG9ja1Njcm9sbCA9IDA7XG4gICAgdmFyIGlubGluZVNjcm9sbCA9IDA7XG4gICAgdmFyIHNjcm9sbGJhcldpZHRoID0gJ29mZnNldFdpZHRoJyBpbiBmcmFtZSA/IGZyYW1lLm9mZnNldFdpZHRoIC0gZnJhbWUuY2xpZW50V2lkdGggLSBib3JkZXJMZWZ0IC0gYm9yZGVyUmlnaHQgOiAwO1xuICAgIHZhciBzY3JvbGxiYXJIZWlnaHQgPSAnb2Zmc2V0SGVpZ2h0JyBpbiBmcmFtZSA/IGZyYW1lLm9mZnNldEhlaWdodCAtIGZyYW1lLmNsaWVudEhlaWdodCAtIGJvcmRlclRvcCAtIGJvcmRlckJvdHRvbSA6IDA7XG5cbiAgICBpZiAoc2Nyb2xsaW5nRWxlbWVudCA9PT0gZnJhbWUpIHtcbiAgICAgIGlmIChibG9jayA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBibG9ja1Njcm9sbCA9IHRhcmdldEJsb2NrO1xuICAgICAgfSBlbHNlIGlmIChibG9jayA9PT0gJ2VuZCcpIHtcbiAgICAgICAgYmxvY2tTY3JvbGwgPSB0YXJnZXRCbG9jayAtIHZpZXdwb3J0SGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChibG9jayA9PT0gJ25lYXJlc3QnKSB7XG4gICAgICAgIGJsb2NrU2Nyb2xsID0gYWxpZ25OZWFyZXN0KHZpZXdwb3J0WSwgdmlld3BvcnRZICsgdmlld3BvcnRIZWlnaHQsIHZpZXdwb3J0SGVpZ2h0LCBib3JkZXJUb3AsIGJvcmRlckJvdHRvbSwgdmlld3BvcnRZICsgdGFyZ2V0QmxvY2ssIHZpZXdwb3J0WSArIHRhcmdldEJsb2NrICsgdGFyZ2V0SGVpZ2h0LCB0YXJnZXRIZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmxvY2tTY3JvbGwgPSB0YXJnZXRCbG9jayAtIHZpZXdwb3J0SGVpZ2h0IC8gMjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlubGluZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBpbmxpbmVTY3JvbGwgPSB0YXJnZXRJbmxpbmU7XG4gICAgICB9IGVsc2UgaWYgKGlubGluZSA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgaW5saW5lU2Nyb2xsID0gdGFyZ2V0SW5saW5lIC0gdmlld3BvcnRXaWR0aCAvIDI7XG4gICAgICB9IGVsc2UgaWYgKGlubGluZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgaW5saW5lU2Nyb2xsID0gdGFyZ2V0SW5saW5lIC0gdmlld3BvcnRXaWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlubGluZVNjcm9sbCA9IGFsaWduTmVhcmVzdCh2aWV3cG9ydFgsIHZpZXdwb3J0WCArIHZpZXdwb3J0V2lkdGgsIHZpZXdwb3J0V2lkdGgsIGJvcmRlckxlZnQsIGJvcmRlclJpZ2h0LCB2aWV3cG9ydFggKyB0YXJnZXRJbmxpbmUsIHZpZXdwb3J0WCArIHRhcmdldElubGluZSArIHRhcmdldFdpZHRoLCB0YXJnZXRXaWR0aCk7XG4gICAgICB9XG5cbiAgICAgIGJsb2NrU2Nyb2xsID0gTWF0aC5tYXgoMCwgYmxvY2tTY3JvbGwgKyB2aWV3cG9ydFkpO1xuICAgICAgaW5saW5lU2Nyb2xsID0gTWF0aC5tYXgoMCwgaW5saW5lU2Nyb2xsICsgdmlld3BvcnRYKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGJsb2NrID09PSAnc3RhcnQnKSB7XG4gICAgICAgIGJsb2NrU2Nyb2xsID0gdGFyZ2V0QmxvY2sgLSB0b3AgLSBib3JkZXJUb3A7XG4gICAgICB9IGVsc2UgaWYgKGJsb2NrID09PSAnZW5kJykge1xuICAgICAgICBibG9ja1Njcm9sbCA9IHRhcmdldEJsb2NrIC0gYm90dG9tICsgYm9yZGVyQm90dG9tICsgc2Nyb2xsYmFySGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChibG9jayA9PT0gJ25lYXJlc3QnKSB7XG4gICAgICAgIGJsb2NrU2Nyb2xsID0gYWxpZ25OZWFyZXN0KHRvcCwgYm90dG9tLCBoZWlnaHQsIGJvcmRlclRvcCwgYm9yZGVyQm90dG9tICsgc2Nyb2xsYmFySGVpZ2h0LCB0YXJnZXRCbG9jaywgdGFyZ2V0QmxvY2sgKyB0YXJnZXRIZWlnaHQsIHRhcmdldEhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBibG9ja1Njcm9sbCA9IHRhcmdldEJsb2NrIC0gKHRvcCArIGhlaWdodCAvIDIpICsgc2Nyb2xsYmFySGVpZ2h0IC8gMjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlubGluZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBpbmxpbmVTY3JvbGwgPSB0YXJnZXRJbmxpbmUgLSBsZWZ0IC0gYm9yZGVyTGVmdDtcbiAgICAgIH0gZWxzZSBpZiAoaW5saW5lID09PSAnY2VudGVyJykge1xuICAgICAgICBpbmxpbmVTY3JvbGwgPSB0YXJnZXRJbmxpbmUgLSAobGVmdCArIHdpZHRoIC8gMikgKyBzY3JvbGxiYXJXaWR0aCAvIDI7XG4gICAgICB9IGVsc2UgaWYgKGlubGluZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgaW5saW5lU2Nyb2xsID0gdGFyZ2V0SW5saW5lIC0gcmlnaHQgKyBib3JkZXJSaWdodCArIHNjcm9sbGJhcldpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5saW5lU2Nyb2xsID0gYWxpZ25OZWFyZXN0KGxlZnQsIHJpZ2h0LCB3aWR0aCwgYm9yZGVyTGVmdCwgYm9yZGVyUmlnaHQgKyBzY3JvbGxiYXJXaWR0aCwgdGFyZ2V0SW5saW5lLCB0YXJnZXRJbmxpbmUgKyB0YXJnZXRXaWR0aCwgdGFyZ2V0V2lkdGgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2Nyb2xsTGVmdCA9IGZyYW1lLnNjcm9sbExlZnQsXG4gICAgICAgICAgc2Nyb2xsVG9wID0gZnJhbWUuc2Nyb2xsVG9wO1xuICAgICAgYmxvY2tTY3JvbGwgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzY3JvbGxUb3AgKyBibG9ja1Njcm9sbCwgZnJhbWUuc2Nyb2xsSGVpZ2h0IC0gaGVpZ2h0ICsgc2Nyb2xsYmFySGVpZ2h0KSk7XG4gICAgICBpbmxpbmVTY3JvbGwgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzY3JvbGxMZWZ0ICsgaW5saW5lU2Nyb2xsLCBmcmFtZS5zY3JvbGxXaWR0aCAtIHdpZHRoICsgc2Nyb2xsYmFyV2lkdGgpKTtcbiAgICAgIHRhcmdldEJsb2NrICs9IHNjcm9sbFRvcCAtIGJsb2NrU2Nyb2xsO1xuICAgICAgdGFyZ2V0SW5saW5lICs9IHNjcm9sbExlZnQgLSBpbmxpbmVTY3JvbGw7XG4gICAgfVxuXG4gICAgY29tcHV0YXRpb25zLnB1c2goe1xuICAgICAgZWw6IGZyYW1lLFxuICAgICAgdG9wOiBibG9ja1Njcm9sbCxcbiAgICAgIGxlZnQ6IGlubGluZVNjcm9sbFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGNvbXB1dGF0aW9ucztcbn0pOyIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRpcmVjdGlvblxuXG52YXIgUlRMID0gJ1xcdTA1OTEtXFx1MDdGRlxcdUZCMUQtXFx1RkRGRFxcdUZFNzAtXFx1RkVGQydcbnZhciBMVFIgPVxuICAnQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2JyArXG4gICdcXHUwMEY4LVxcdTAyQjhcXHUwMzAwLVxcdTA1OTBcXHUwODAwLVxcdTFGRkZcXHUyMDBFXFx1MkMwMC1cXHVGQjFDJyArXG4gICdcXHVGRTAwLVxcdUZFNkZcXHVGRUZELVxcdUZGRkYnXG5cbnZhciBydGwgPSBuZXcgUmVnRXhwKCdeW14nICsgTFRSICsgJ10qWycgKyBSVEwgKyAnXScpXG52YXIgbHRyID0gbmV3IFJlZ0V4cCgnXlteJyArIFJUTCArICddKlsnICsgTFRSICsgJ10nKVxuXG5mdW5jdGlvbiBkaXJlY3Rpb24odmFsdWUpIHtcbiAgdmFsdWUgPSBTdHJpbmcodmFsdWUgfHwgJycpXG5cbiAgaWYgKHJ0bC50ZXN0KHZhbHVlKSkge1xuICAgIHJldHVybiAncnRsJ1xuICB9XG5cbiAgaWYgKGx0ci50ZXN0KHZhbHVlKSkge1xuICAgIHJldHVybiAnbHRyJ1xuICB9XG5cbiAgcmV0dXJuICduZXV0cmFsJ1xufVxuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9lc3JldmVyIHYwLjIuMCBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGVzIGBleHBvcnRzYFxuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgXG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHRtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAsIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSxcblx0Ly8gYW5kIHVzZSBpdCBhcyBgcm9vdGBcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgcmVnZXhTeW1ib2xXaXRoQ29tYmluaW5nTWFya3MgPSAvKFtcXDAtXFx1MDJGRlxcdTAzNzAtXFx1MUFBRlxcdTFCMDAtXFx1MURCRlxcdTFFMDAtXFx1MjBDRlxcdTIxMDAtXFx1RDdGRlxcdUUwMDAtXFx1RkUxRlxcdUZFMzAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXSkoW1xcdTAzMDAtXFx1MDM2RlxcdTFBQjAtXFx1MUFGRlxcdTFEQzAtXFx1MURGRlxcdTIwRDAtXFx1MjBGRlxcdUZFMjAtXFx1RkUyRl0rKS9nO1xuXHR2YXIgcmVnZXhTdXJyb2dhdGVQYWlyID0gLyhbXFx1RDgwMC1cXHVEQkZGXSkoW1xcdURDMDAtXFx1REZGRl0pL2c7XG5cblx0dmFyIHJldmVyc2UgPSBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHQvLyBTdGVwIDE6IGRlYWwgd2l0aCBjb21iaW5pbmcgbWFya3MgYW5kIGFzdHJhbCBzeW1ib2xzIChzdXJyb2dhdGUgcGFpcnMpXG5cdFx0c3RyaW5nID0gc3RyaW5nXG5cdFx0XHQvLyBTd2FwIHN5bWJvbHMgd2l0aCB0aGVpciBjb21iaW5pbmcgbWFya3Mgc28gdGhlIGNvbWJpbmluZyBtYXJrcyBnbyBmaXJzdFxuXHRcdFx0LnJlcGxhY2UocmVnZXhTeW1ib2xXaXRoQ29tYmluaW5nTWFya3MsIGZ1bmN0aW9uKCQwLCAkMSwgJDIpIHtcblx0XHRcdFx0Ly8gUmV2ZXJzZSB0aGUgY29tYmluaW5nIG1hcmtzIHNvIHRoZXkgd2lsbCBlbmQgdXAgaW4gdGhlIHNhbWUgb3JkZXJcblx0XHRcdFx0Ly8gbGF0ZXIgb24gKGFmdGVyIGFub3RoZXIgcm91bmQgb2YgcmV2ZXJzaW5nKVxuXHRcdFx0XHRyZXR1cm4gcmV2ZXJzZSgkMikgKyAkMTtcblx0XHRcdH0pXG5cdFx0XHQvLyBTd2FwIGhpZ2ggYW5kIGxvdyBzdXJyb2dhdGVzIHNvIHRoZSBsb3cgc3Vycm9nYXRlcyBnbyBmaXJzdFxuXHRcdFx0LnJlcGxhY2UocmVnZXhTdXJyb2dhdGVQYWlyLCAnJDIkMScpO1xuXHRcdC8vIFN0ZXAgMjogcmV2ZXJzZSB0aGUgY29kZSB1bml0cyBpbiB0aGUgc3RyaW5nXG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdHZhciBpbmRleCA9IHN0cmluZy5sZW5ndGg7XG5cdFx0d2hpbGUgKGluZGV4LS0pIHtcblx0XHRcdHJlc3VsdCArPSBzdHJpbmcuY2hhckF0KGluZGV4KTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgZXNyZXZlciA9IHtcblx0XHQndmVyc2lvbic6ICcwLjIuMCcsXG5cdFx0J3JldmVyc2UnOiByZXZlcnNlXG5cdH07XG5cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZXNyZXZlcjtcblx0XHR9KTtcblx0fVx0ZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlKSB7XG5cdFx0aWYgKGZyZWVNb2R1bGUpIHsgLy8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gZXNyZXZlcjtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yICh2YXIga2V5IGluIGVzcmV2ZXIpIHtcblx0XHRcdFx0ZXNyZXZlci5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gZXNyZXZlcltrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LmVzcmV2ZXIgPSBlc3JldmVyO1xuXHR9XG5cbn0odGhpcykpO1xuIiwiLy8gU2hvdWxkIGJlIG5vIGltcG9ydHMgaGVyZSFcbnZhciBfYTsgLy8gU09tZSB0aGluZ3MgdGhhdCBzaG91bGQgYmUgZXZhbHVhdGVkIGJlZm9yZSBhbGwgZWxzZS4uLlxuXG5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiO1xudmFyIGhhc01hcCA9IHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCI7XG52YXIgaGFzU2V0ID0gdHlwZW9mIFNldCAhPT0gXCJ1bmRlZmluZWRcIjtcbi8qKlxyXG4gKiBUaGUgc2VudGluZWwgdmFsdWUgcmV0dXJuZWQgYnkgcHJvZHVjZXJzIHRvIHJlcGxhY2UgdGhlIGRyYWZ0IHdpdGggdW5kZWZpbmVkLlxyXG4gKi9cblxudmFyIE5PVEhJTkcgPSBoYXNTeW1ib2wgPyBTeW1ib2woXCJpbW1lci1ub3RoaW5nXCIpIDogKF9hID0ge30sIF9hW1wiaW1tZXItbm90aGluZ1wiXSA9IHRydWUsIF9hKTtcbi8qKlxyXG4gKiBUbyBsZXQgSW1tZXIgdHJlYXQgeW91ciBjbGFzcyBpbnN0YW5jZXMgYXMgcGxhaW4gaW1tdXRhYmxlIG9iamVjdHNcclxuICogKGFsYmVpdCB3aXRoIGEgY3VzdG9tIHByb3RvdHlwZSksIHlvdSBtdXN0IGRlZmluZSBlaXRoZXIgYW4gaW5zdGFuY2UgcHJvcGVydHlcclxuICogb3IgYSBzdGF0aWMgcHJvcGVydHkgb24gZWFjaCBvZiB5b3VyIGN1c3RvbSBjbGFzc2VzLlxyXG4gKlxyXG4gKiBPdGhlcndpc2UsIHlvdXIgY2xhc3MgaW5zdGFuY2Ugd2lsbCBuZXZlciBiZSBkcmFmdGVkLCB3aGljaCBtZWFucyBpdCB3b24ndCBiZVxyXG4gKiBzYWZlIHRvIG11dGF0ZSBpbiBhIHByb2R1Y2UgY2FsbGJhY2suXHJcbiAqL1xuXG52YXIgRFJBRlRBQkxFID0gaGFzU3ltYm9sID8gU3ltYm9sKFwiaW1tZXItZHJhZnRhYmxlXCIpIDogXCJfXyRpbW1lcl9kcmFmdGFibGVcIjtcbnZhciBEUkFGVF9TVEFURSA9IGhhc1N5bWJvbCA/IFN5bWJvbChcImltbWVyLXN0YXRlXCIpIDogXCJfXyRpbW1lcl9zdGF0ZVwiO1xudmFyIGl0ZXJhdG9yU3ltYm9sID0gaGFzU3ltYm9sID8gU3ltYm9sLml0ZXJhdG9yIDogXCJAQGl0ZXJhdG9yXCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwge1xuICAgIF9fcHJvdG9fXzogW11cbiAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZC5fX3Byb3RvX18gPSBiO1xuICB9IHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSB7IGlmIChiLmhhc093blByb3BlcnR5KHApKSB7IGRbcF0gPSBiW3BdOyB9IH1cbiAgfTtcblxuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07IC8vIFVnbHkgaGFjayB0byByZXNvbHZlICM1MDIgYW5kIGluaGVyaXQgYnVpbHQgaW4gTWFwIC8gU2V0XG5cblxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblxuICBmdW5jdGlvbiBfXygpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgfVxuXG4gIGQucHJvdG90eXBlID0gKCAvLyBAdHMtaWdub3JlXG4gIF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG5cbnZhciBBcmNodHlwZTtcblxuKGZ1bmN0aW9uIChBcmNodHlwZSkge1xuICBBcmNodHlwZVtBcmNodHlwZVtcIk9iamVjdFwiXSA9IDBdID0gXCJPYmplY3RcIjtcbiAgQXJjaHR5cGVbQXJjaHR5cGVbXCJBcnJheVwiXSA9IDFdID0gXCJBcnJheVwiO1xuICBBcmNodHlwZVtBcmNodHlwZVtcIk1hcFwiXSA9IDJdID0gXCJNYXBcIjtcbiAgQXJjaHR5cGVbQXJjaHR5cGVbXCJTZXRcIl0gPSAzXSA9IFwiU2V0XCI7XG59KShBcmNodHlwZSB8fCAoQXJjaHR5cGUgPSB7fSkpO1xuXG52YXIgUHJveHlUeXBlO1xuXG4oZnVuY3Rpb24gKFByb3h5VHlwZSkge1xuICBQcm94eVR5cGVbUHJveHlUeXBlW1wiUHJveHlPYmplY3RcIl0gPSAwXSA9IFwiUHJveHlPYmplY3RcIjtcbiAgUHJveHlUeXBlW1Byb3h5VHlwZVtcIlByb3h5QXJyYXlcIl0gPSAxXSA9IFwiUHJveHlBcnJheVwiO1xuICBQcm94eVR5cGVbUHJveHlUeXBlW1wiRVM1T2JqZWN0XCJdID0gMl0gPSBcIkVTNU9iamVjdFwiO1xuICBQcm94eVR5cGVbUHJveHlUeXBlW1wiRVM1QXJyYXlcIl0gPSAzXSA9IFwiRVM1QXJyYXlcIjtcbiAgUHJveHlUeXBlW1Byb3h5VHlwZVtcIk1hcFwiXSA9IDRdID0gXCJNYXBcIjtcbiAgUHJveHlUeXBlW1Byb3h5VHlwZVtcIlNldFwiXSA9IDVdID0gXCJTZXRcIjtcbn0pKFByb3h5VHlwZSB8fCAoUHJveHlUeXBlID0ge30pKTtcblxuLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gSW1tZXIgZHJhZnQgKi9cblxuZnVuY3Rpb24gaXNEcmFmdCh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiAhIXZhbHVlW0RSQUZUX1NUQVRFXTtcbn1cbi8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGNhbiBiZSBkcmFmdGVkIGJ5IEltbWVyICovXG5cbmZ1bmN0aW9uIGlzRHJhZnRhYmxlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCAhIXZhbHVlW0RSQUZUQUJMRV0gfHwgISF2YWx1ZS5jb25zdHJ1Y3RvcltEUkFGVEFCTEVdIHx8IGlzTWFwKHZhbHVlKSB8fCBpc1NldCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB7IHJldHVybiBmYWxzZTsgfVxuICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICByZXR1cm4gIXByb3RvIHx8IHByb3RvID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuZnVuY3Rpb24gb3JpZ2luYWwodmFsdWUpIHtcbiAgaWYgKHZhbHVlICYmIHZhbHVlW0RSQUZUX1NUQVRFXSkge1xuICAgIHJldHVybiB2YWx1ZVtEUkFGVF9TVEFURV0uYmFzZTtcbiAgfSAvLyBvdGhlcndpc2UgcmV0dXJuIHVuZGVmaW5lZFxuXG59XG52YXIgb3duS2V5cyA9IHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3Qub3duS2V5cyA/IFJlZmxlY3Qub3duS2V5cyA6IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSBcInVuZGVmaW5lZFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopKTtcbn0gOlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xuZnVuY3Rpb24gZWFjaChvYmosIGl0ZXIpIHtcbiAgaWYgKGdldEFyY2h0eXBlKG9iaikgPT09IEFyY2h0eXBlLk9iamVjdCkge1xuICAgIG93bktleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBpdGVyKGtleSwgb2JqW2tleV0sIG9iaik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xuICAgICAgcmV0dXJuIGl0ZXIoaW5kZXgsIGVudHJ5LCBvYmopO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBpc0VudW1lcmFibGUoYmFzZSwgcHJvcCkge1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcCk7XG4gIHJldHVybiBkZXNjICYmIGRlc2MuZW51bWVyYWJsZSA/IHRydWUgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldEFyY2h0eXBlKHRoaW5nKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICghdGhpbmcpIHsgZGllKCk7IH1cblxuICBpZiAodGhpbmdbRFJBRlRfU1RBVEVdKSB7XG4gICAgc3dpdGNoICh0aGluZ1tEUkFGVF9TVEFURV0udHlwZSkge1xuICAgICAgY2FzZSBQcm94eVR5cGUuRVM1T2JqZWN0OlxuICAgICAgY2FzZSBQcm94eVR5cGUuUHJveHlPYmplY3Q6XG4gICAgICAgIHJldHVybiBBcmNodHlwZS5PYmplY3Q7XG5cbiAgICAgIGNhc2UgUHJveHlUeXBlLkVTNUFycmF5OlxuICAgICAgY2FzZSBQcm94eVR5cGUuUHJveHlBcnJheTpcbiAgICAgICAgcmV0dXJuIEFyY2h0eXBlLkFycmF5O1xuXG4gICAgICBjYXNlIFByb3h5VHlwZS5NYXA6XG4gICAgICAgIHJldHVybiBBcmNodHlwZS5NYXA7XG5cbiAgICAgIGNhc2UgUHJveHlUeXBlLlNldDpcbiAgICAgICAgcmV0dXJuIEFyY2h0eXBlLlNldDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGluZykgPyBBcmNodHlwZS5BcnJheSA6IGlzTWFwKHRoaW5nKSA/IEFyY2h0eXBlLk1hcCA6IGlzU2V0KHRoaW5nKSA/IEFyY2h0eXBlLlNldCA6IEFyY2h0eXBlLk9iamVjdDtcbn1cbmZ1bmN0aW9uIGhhcyh0aGluZywgcHJvcCkge1xuICByZXR1cm4gZ2V0QXJjaHR5cGUodGhpbmcpID09PSBBcmNodHlwZS5NYXAgPyB0aGluZy5oYXMocHJvcCkgOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpbmcsIHByb3ApO1xufVxuZnVuY3Rpb24gZ2V0KHRoaW5nLCBwcm9wKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIGdldEFyY2h0eXBlKHRoaW5nKSA9PT0gQXJjaHR5cGUuTWFwID8gdGhpbmcuZ2V0KHByb3ApIDogdGhpbmdbcHJvcF07XG59XG5mdW5jdGlvbiBzZXQodGhpbmcsIHByb3BPck9sZFZhbHVlLCB2YWx1ZSkge1xuICBzd2l0Y2ggKGdldEFyY2h0eXBlKHRoaW5nKSkge1xuICAgIGNhc2UgQXJjaHR5cGUuTWFwOlxuICAgICAgdGhpbmcuc2V0KHByb3BPck9sZFZhbHVlLCB2YWx1ZSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQXJjaHR5cGUuU2V0OlxuICAgICAgdGhpbmcuZGVsZXRlKHByb3BPck9sZFZhbHVlKTtcbiAgICAgIHRoaW5nLmFkZCh2YWx1ZSk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGluZ1twcm9wT3JPbGRWYWx1ZV0gPSB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBGcm9tOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2M2OTkwNGE1MTFiOTAwMjY2OTM1MTY4MjIzMDYzZGQ4NzcyZGZjNDAvcGFja2FnZXMvZmJqcy9zcmMvY29yZS9zaGFsbG93RXF1YWwuanNcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuZnVuY3Rpb24gaXNNYXAodGFyZ2V0KSB7XG4gIHJldHVybiBoYXNNYXAgJiYgdGFyZ2V0IGluc3RhbmNlb2YgTWFwO1xufVxuZnVuY3Rpb24gaXNTZXQodGFyZ2V0KSB7XG4gIHJldHVybiBoYXNTZXQgJiYgdGFyZ2V0IGluc3RhbmNlb2YgU2V0O1xufVxuZnVuY3Rpb24gbGF0ZXN0KHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5jb3B5IHx8IHN0YXRlLmJhc2U7XG59XG5mdW5jdGlvbiBzaGFsbG93Q29weShiYXNlLCBpbnZva2VHZXR0ZXJzKSB7XG4gIGlmIChpbnZva2VHZXR0ZXJzID09PSB2b2lkIDApIHtcbiAgICBpbnZva2VHZXR0ZXJzID0gZmFsc2U7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShiYXNlKSkgeyByZXR1cm4gYmFzZS5zbGljZSgpOyB9XG4gIHZhciBjbG9uZSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2UpKTtcbiAgb3duS2V5cyhiYXNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoa2V5ID09PSBEUkFGVF9TVEFURSkge1xuICAgICAgcmV0dXJuOyAvLyBOZXZlciBjb3B5IG92ZXIgZHJhZnQgc3RhdGUuXG4gICAgfVxuXG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIGtleSk7XG4gICAgdmFyIHZhbHVlID0gZGVzYy52YWx1ZTtcblxuICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgaWYgKCFpbnZva2VHZXR0ZXJzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkltbWVyIGRyYWZ0cyBjYW5ub3QgaGF2ZSBjb21wdXRlZCBwcm9wZXJ0aWVzXCIpO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IGRlc2MuZ2V0LmNhbGwoYmFzZSk7XG4gICAgfVxuXG4gICAgaWYgKGRlc2MuZW51bWVyYWJsZSkge1xuICAgICAgY2xvbmVba2V5XSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xvbmUsIGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjbG9uZTtcbn1cbmZ1bmN0aW9uIGZyZWV6ZShvYmosIGRlZXApIHtcbiAgaWYgKCFpc0RyYWZ0YWJsZShvYmopIHx8IGlzRHJhZnQob2JqKSB8fCBPYmplY3QuaXNGcm96ZW4ob2JqKSkgeyByZXR1cm47IH1cbiAgdmFyIHR5cGUgPSBnZXRBcmNodHlwZShvYmopO1xuXG4gIGlmICh0eXBlID09PSBBcmNodHlwZS5TZXQpIHtcbiAgICBvYmouYWRkID0gb2JqLmNsZWFyID0gb2JqLmRlbGV0ZSA9IGRvbnRNdXRhdGVGcm96ZW5Db2xsZWN0aW9ucztcbiAgfSBlbHNlIGlmICh0eXBlID09PSBBcmNodHlwZS5NYXApIHtcbiAgICBvYmouc2V0ID0gb2JqLmNsZWFyID0gb2JqLmRlbGV0ZSA9IGRvbnRNdXRhdGVGcm96ZW5Db2xsZWN0aW9ucztcbiAgfVxuXG4gIE9iamVjdC5mcmVlemUob2JqKTtcbiAgaWYgKGRlZXApIHsgZWFjaChvYmosIGZ1bmN0aW9uIChfLCB2YWx1ZSkge1xuICAgIHJldHVybiBmcmVlemUodmFsdWUsIHRydWUpO1xuICB9KTsgfVxufVxuXG5mdW5jdGlvbiBkb250TXV0YXRlRnJvemVuQ29sbGVjdGlvbnMoKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIlRoaXMgb2JqZWN0IGhhcyBiZWVuIGZyb3plbiBhbmQgc2hvdWxkIG5vdCBiZSBtdXRhdGVkXCIpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIaWRkZW5Qcm9wZXJ0eSh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3AsIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG5mdW5jdGlvbiBkaWUoKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGUsIHBsZWFzZSBmaWxlIGEgYnVnXCIpO1xufVxuXG4vKiogRWFjaCBzY29wZSByZXByZXNlbnRzIGEgYHByb2R1Y2VgIGNhbGwuICovXG5cbnZhciBJbW1lclNjb3BlID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW1tZXJTY29wZShwYXJlbnQsIGltbWVyKSB7XG4gICAgdGhpcy5kcmFmdHMgPSBbXTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLmltbWVyID0gaW1tZXI7IC8vIFdoZW5ldmVyIHRoZSBtb2RpZmllZCBkcmFmdCBjb250YWlucyBhIGRyYWZ0IGZyb20gYW5vdGhlciBzY29wZSwgd2VcbiAgICAvLyBuZWVkIHRvIHByZXZlbnQgYXV0by1mcmVlemluZyBzbyB0aGUgdW5vd25lZCBkcmFmdCBjYW4gYmUgZmluYWxpemVkLlxuXG4gICAgdGhpcy5jYW5BdXRvRnJlZXplID0gdHJ1ZTtcbiAgfVxuXG4gIEltbWVyU2NvcGUucHJvdG90eXBlLnVzZVBhdGNoZXMgPSBmdW5jdGlvbiAocGF0Y2hMaXN0ZW5lcikge1xuICAgIGlmIChwYXRjaExpc3RlbmVyKSB7XG4gICAgICB0aGlzLnBhdGNoZXMgPSBbXTtcbiAgICAgIHRoaXMuaW52ZXJzZVBhdGNoZXMgPSBbXTtcbiAgICAgIHRoaXMucGF0Y2hMaXN0ZW5lciA9IHBhdGNoTGlzdGVuZXI7XG4gICAgfVxuICB9O1xuXG4gIEltbWVyU2NvcGUucHJvdG90eXBlLnJldm9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmxlYXZlKCk7XG4gICAgdGhpcy5kcmFmdHMuZm9yRWFjaChyZXZva2UpOyAvLyBAdHMtaWdub3JlXG5cbiAgICB0aGlzLmRyYWZ0cyA9IG51bGw7XG4gIH07XG5cbiAgSW1tZXJTY29wZS5wcm90b3R5cGUubGVhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMgPT09IEltbWVyU2NvcGUuY3VycmVudCkge1xuICAgICAgSW1tZXJTY29wZS5jdXJyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgfVxuICB9O1xuXG4gIEltbWVyU2NvcGUuZW50ZXIgPSBmdW5jdGlvbiAoaW1tZXIpIHtcbiAgICB2YXIgc2NvcGUgPSBuZXcgSW1tZXJTY29wZShJbW1lclNjb3BlLmN1cnJlbnQsIGltbWVyKTtcbiAgICBJbW1lclNjb3BlLmN1cnJlbnQgPSBzY29wZTtcbiAgICByZXR1cm4gc2NvcGU7XG4gIH07XG5cbiAgcmV0dXJuIEltbWVyU2NvcGU7XG59KCk7XG5cbmZ1bmN0aW9uIHJldm9rZShkcmFmdCkge1xuICB2YXIgc3RhdGUgPSBkcmFmdFtEUkFGVF9TVEFURV07XG4gIGlmIChzdGF0ZS50eXBlID09PSBQcm94eVR5cGUuUHJveHlPYmplY3QgfHwgc3RhdGUudHlwZSA9PT0gUHJveHlUeXBlLlByb3h5QXJyYXkpIHsgc3RhdGUucmV2b2tlKCk7IH1lbHNlIHsgc3RhdGUucmV2b2tlZCA9IHRydWU7IH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jlc3VsdChpbW1lciwgcmVzdWx0LCBzY29wZSkge1xuICB2YXIgYmFzZURyYWZ0ID0gc2NvcGUuZHJhZnRzWzBdO1xuICB2YXIgaXNSZXBsYWNlZCA9IHJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIHJlc3VsdCAhPT0gYmFzZURyYWZ0O1xuICBpbW1lci53aWxsRmluYWxpemUoc2NvcGUsIHJlc3VsdCwgaXNSZXBsYWNlZCk7XG5cbiAgaWYgKGlzUmVwbGFjZWQpIHtcbiAgICBpZiAoYmFzZURyYWZ0W0RSQUZUX1NUQVRFXS5tb2RpZmllZCkge1xuICAgICAgc2NvcGUucmV2b2tlKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbiBpbW1lciBwcm9kdWNlciByZXR1cm5lZCBhIG5ldyB2YWx1ZSAqYW5kKiBtb2RpZmllZCBpdHMgZHJhZnQuIEVpdGhlciByZXR1cm4gYSBuZXcgdmFsdWUgKm9yKiBtb2RpZnkgdGhlIGRyYWZ0LlwiKTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgfVxuXG4gICAgaWYgKGlzRHJhZnRhYmxlKHJlc3VsdCkpIHtcbiAgICAgIC8vIEZpbmFsaXplIHRoZSByZXN1bHQgaW4gY2FzZSBpdCBjb250YWlucyAob3IgaXMpIGEgc3Vic2V0IG9mIHRoZSBkcmFmdC5cbiAgICAgIHJlc3VsdCA9IGZpbmFsaXplKGltbWVyLCByZXN1bHQsIHNjb3BlKTtcbiAgICAgIGlmICghc2NvcGUucGFyZW50KSB7IG1heWJlRnJlZXplKGltbWVyLCByZXN1bHQpOyB9XG4gICAgfVxuXG4gICAgaWYgKHNjb3BlLnBhdGNoZXMpIHtcbiAgICAgIHNjb3BlLnBhdGNoZXMucHVzaCh7XG4gICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgcGF0aDogW10sXG4gICAgICAgIHZhbHVlOiByZXN1bHRcbiAgICAgIH0pO1xuICAgICAgc2NvcGUuaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgcGF0aDogW10sXG4gICAgICAgIHZhbHVlOiBiYXNlRHJhZnRbRFJBRlRfU1RBVEVdLmJhc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5hbGl6ZSB0aGUgYmFzZSBkcmFmdC5cbiAgICByZXN1bHQgPSBmaW5hbGl6ZShpbW1lciwgYmFzZURyYWZ0LCBzY29wZSwgW10pO1xuICB9XG5cbiAgc2NvcGUucmV2b2tlKCk7XG5cbiAgaWYgKHNjb3BlLnBhdGNoZXMpIHtcbiAgICBzY29wZS5wYXRjaExpc3RlbmVyKHNjb3BlLnBhdGNoZXMsIHNjb3BlLmludmVyc2VQYXRjaGVzKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQgIT09IE5PVEhJTkcgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGZpbmFsaXplKGltbWVyLCBkcmFmdCwgc2NvcGUsIHBhdGgpIHtcbiAgdmFyIHN0YXRlID0gZHJhZnRbRFJBRlRfU1RBVEVdO1xuXG4gIGlmICghc3RhdGUpIHtcbiAgICBpZiAoT2JqZWN0LmlzRnJvemVuKGRyYWZ0KSkgeyByZXR1cm4gZHJhZnQ7IH1cbiAgICByZXR1cm4gZmluYWxpemVUcmVlKGltbWVyLCBkcmFmdCwgc2NvcGUpO1xuICB9IC8vIE5ldmVyIGZpbmFsaXplIGRyYWZ0cyBvd25lZCBieSBhbm90aGVyIHNjb3BlLlxuXG5cbiAgaWYgKHN0YXRlLnNjb3BlICE9PSBzY29wZSkge1xuICAgIHJldHVybiBkcmFmdDtcbiAgfVxuXG4gIGlmICghc3RhdGUubW9kaWZpZWQpIHtcbiAgICBtYXliZUZyZWV6ZShpbW1lciwgc3RhdGUuYmFzZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHN0YXRlLmJhc2U7XG4gIH1cblxuICBpZiAoIXN0YXRlLmZpbmFsaXplZCkge1xuICAgIHN0YXRlLmZpbmFsaXplZCA9IHRydWU7XG4gICAgZmluYWxpemVUcmVlKGltbWVyLCBzdGF0ZS5kcmFmdCwgc2NvcGUsIHBhdGgpOyAvLyBXZSBjYW5ub3QgcmVhbGx5IGRlbGV0ZSBhbnl0aGluZyBpbnNpZGUgb2YgYSBTZXQuIFdlIGNhbiBvbmx5IHJlcGxhY2UgdGhlIHdob2xlIFNldC5cblxuICAgIGlmIChpbW1lci5vbkRlbGV0ZSAmJiBzdGF0ZS50eXBlICE9PSBQcm94eVR5cGUuU2V0KSB7XG4gICAgICAvLyBUaGUgYGFzc2lnbmVkYCBvYmplY3QgaXMgdW5yZWxpYWJsZSB3aXRoIEVTNSBkcmFmdHMuXG4gICAgICBpZiAoaW1tZXIudXNlUHJveGllcykge1xuICAgICAgICB2YXIgYXNzaWduZWQgPSBzdGF0ZS5hc3NpZ25lZDtcbiAgICAgICAgZWFjaChhc3NpZ25lZCwgZnVuY3Rpb24gKHByb3AsIGV4aXN0cykge1xuICAgICAgICAgIGlmICghZXhpc3RzKSB7IGltbWVyLm9uRGVsZXRlKHN0YXRlLCBwcm9wKTsgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBiYXNlID0gc3RhdGUuYmFzZSxcbiAgICAgICAgICAgIGNvcHlfMSA9IHN0YXRlLmNvcHk7XG4gICAgICAgIGVhY2goYmFzZSwgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICBpZiAoIWhhcyhjb3B5XzEsIHByb3ApKSB7IGltbWVyLm9uRGVsZXRlKHN0YXRlLCBwcm9wKTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW1tZXIub25Db3B5KSB7XG4gICAgICBpbW1lci5vbkNvcHkoc3RhdGUpO1xuICAgIH0gLy8gQXQgdGhpcyBwb2ludCwgYWxsIGRlc2NlbmRhbnRzIG9mIGBzdGF0ZS5jb3B5YCBoYXZlIGJlZW4gZmluYWxpemVkLFxuICAgIC8vIHNvIHdlIGNhbiBiZSBzdXJlIHRoYXQgYHNjb3BlLmNhbkF1dG9GcmVlemVgIGlzIGFjY3VyYXRlLlxuXG5cbiAgICBpZiAoaW1tZXIuYXV0b0ZyZWV6ZSAmJiBzY29wZS5jYW5BdXRvRnJlZXplKSB7XG4gICAgICBmcmVlemUoc3RhdGUuY29weSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChwYXRoICYmIHNjb3BlLnBhdGNoZXMpIHtcbiAgICAgIGdlbmVyYXRlUGF0Y2hlcyhzdGF0ZSwgcGF0aCwgc2NvcGUucGF0Y2hlcywgc2NvcGUuaW52ZXJzZVBhdGNoZXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5jb3B5O1xufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZVRyZWUoaW1tZXIsIHJvb3QsIHNjb3BlLCByb290UGF0aCkge1xuICB2YXIgc3RhdGUgPSByb290W0RSQUZUX1NUQVRFXTtcblxuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUudHlwZSA9PT0gUHJveHlUeXBlLkVTNU9iamVjdCB8fCBzdGF0ZS50eXBlID09PSBQcm94eVR5cGUuRVM1QXJyYXkpIHtcbiAgICAgIC8vIENyZWF0ZSB0aGUgZmluYWwgY29weSwgd2l0aCBhZGRlZCBrZXlzIGFuZCB3aXRob3V0IGRlbGV0ZWQga2V5cy5cbiAgICAgIHN0YXRlLmNvcHkgPSBzaGFsbG93Q29weShzdGF0ZS5kcmFmdCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcm9vdCA9IHN0YXRlLmNvcHk7XG4gIH1cblxuICBlYWNoKHJvb3QsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIGZpbmFsaXplUHJvcGVydHkoaW1tZXIsIHNjb3BlLCByb290LCBzdGF0ZSwgcm9vdCwga2V5LCB2YWx1ZSwgcm9vdFBhdGgpO1xuICB9KTtcbiAgcmV0dXJuIHJvb3Q7XG59XG5cbmZ1bmN0aW9uIGZpbmFsaXplUHJvcGVydHkoaW1tZXIsIHNjb3BlLCByb290LCByb290U3RhdGUsIHBhcmVudFZhbHVlLCBwcm9wLCBjaGlsZFZhbHVlLCByb290UGF0aCkge1xuICBpZiAoY2hpbGRWYWx1ZSA9PT0gcGFyZW50VmFsdWUpIHtcbiAgICB0aHJvdyBFcnJvcihcIkltbWVyIGZvcmJpZHMgY2lyY3VsYXIgcmVmZXJlbmNlc1wiKTtcbiAgfSAvLyBJbiB0aGUgYGZpbmFsaXplVHJlZWAgbWV0aG9kLCBvbmx5IHRoZSBgcm9vdGAgb2JqZWN0IG1heSBiZSBhIGRyYWZ0LlxuXG5cbiAgdmFyIGlzRHJhZnRQcm9wID0gISFyb290U3RhdGUgJiYgcGFyZW50VmFsdWUgPT09IHJvb3Q7XG4gIHZhciBpc1NldE1lbWJlciA9IGlzU2V0KHBhcmVudFZhbHVlKTtcblxuICBpZiAoaXNEcmFmdChjaGlsZFZhbHVlKSkge1xuICAgIHZhciBwYXRoID0gcm9vdFBhdGggJiYgaXNEcmFmdFByb3AgJiYgIWlzU2V0TWVtYmVyICYmIC8vIFNldCBvYmplY3RzIGFyZSBhdG9taWMgc2luY2UgdGhleSBoYXZlIG5vIGtleXMuXG4gICAgIWhhcyhyb290U3RhdGUuYXNzaWduZWQsIHByb3ApIC8vIFNraXAgZGVlcCBwYXRjaGVzIGZvciBhc3NpZ25lZCBrZXlzLlxuICAgID8gcm9vdFBhdGguY29uY2F0KHByb3ApIDogdW5kZWZpbmVkOyAvLyBEcmFmdHMgb3duZWQgYnkgYHNjb3BlYCBhcmUgZmluYWxpemVkIGhlcmUuXG5cbiAgICBjaGlsZFZhbHVlID0gZmluYWxpemUoaW1tZXIsIGNoaWxkVmFsdWUsIHNjb3BlLCBwYXRoKTtcbiAgICBzZXQocGFyZW50VmFsdWUsIHByb3AsIGNoaWxkVmFsdWUpOyAvLyBEcmFmdHMgZnJvbSBhbm90aGVyIHNjb3BlIG11c3QgcHJldmVudCBhdXRvLWZyZWV6aW5nLlxuXG4gICAgaWYgKGlzRHJhZnQoY2hpbGRWYWx1ZSkpIHtcbiAgICAgIHNjb3BlLmNhbkF1dG9GcmVlemUgPSBmYWxzZTtcbiAgICB9XG4gIH0gLy8gVW5jaGFuZ2VkIGRyYWZ0IHByb3BlcnRpZXMgYXJlIGlnbm9yZWQuXG4gIGVsc2UgaWYgKGlzRHJhZnRQcm9wICYmIGlzKGNoaWxkVmFsdWUsIGdldChyb290U3RhdGUuYmFzZSwgcHJvcCkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBTZWFyY2ggbmV3IG9iamVjdHMgZm9yIHVuZmluYWxpemVkIGRyYWZ0cy4gRnJvemVuIG9iamVjdHMgc2hvdWxkIG5ldmVyIGNvbnRhaW4gZHJhZnRzLlxuICAgIC8vIFRPRE86IHRoZSByZWN1cnNpb24gb3ZlciBoZXJlIGxvb2tzIHdlaXJkLCBzaG91bGRuJ3Qgbm9uLWRyYWZ0IHN0dWZmIGhhdmUgaXQncyBvd24gcmVjdXJzaW9uP1xuICAgIC8vIGVzcGVjaWFsbHkgdGhlIHBhc3Npbmcgb24gb2Ygcm9vdCBhbmQgcm9vdFN0YXRlIGRvZXNuJ3QgbWFrZSBzZW5zZS4uLlxuICAgIGVsc2UgaWYgKGlzRHJhZnRhYmxlKGNoaWxkVmFsdWUpKSB7XG4gICAgICAgIGVhY2goY2hpbGRWYWx1ZSwgZnVuY3Rpb24gKGtleSwgZ3JhbmRDaGlsZCkge1xuICAgICAgICAgIHJldHVybiBmaW5hbGl6ZVByb3BlcnR5KGltbWVyLCBzY29wZSwgcm9vdCwgcm9vdFN0YXRlLCBjaGlsZFZhbHVlLCBrZXksIGdyYW5kQ2hpbGQsIHJvb3RQYXRoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc2NvcGUucGFyZW50KSB7IG1heWJlRnJlZXplKGltbWVyLCBjaGlsZFZhbHVlKTsgfVxuICAgICAgfVxuXG4gIGlmIChpc0RyYWZ0UHJvcCAmJiBpbW1lci5vbkFzc2lnbiAmJiAhaXNTZXRNZW1iZXIpIHtcbiAgICBpbW1lci5vbkFzc2lnbihyb290U3RhdGUsIHByb3AsIGNoaWxkVmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlRnJlZXplKGltbWVyLCB2YWx1ZSwgZGVlcCkge1xuICBpZiAoZGVlcCA9PT0gdm9pZCAwKSB7XG4gICAgZGVlcCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKGltbWVyLmF1dG9GcmVlemUgJiYgIWlzRHJhZnQodmFsdWUpKSB7XG4gICAgZnJlZXplKHZhbHVlLCBkZWVwKTtcbiAgfVxufVxuXG4vKipcclxuICogUmV0dXJucyBhIG5ldyBkcmFmdCBvZiB0aGUgYGJhc2VgIG9iamVjdC5cclxuICpcclxuICogVGhlIHNlY29uZCBhcmd1bWVudCBpcyB0aGUgcGFyZW50IGRyYWZ0LXN0YXRlICh1c2VkIGludGVybmFsbHkpLlxyXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlUHJveHkoYmFzZSwgcGFyZW50KSB7XG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShiYXNlKTtcbiAgdmFyIHN0YXRlID0ge1xuICAgIHR5cGU6IGlzQXJyYXkgPyBQcm94eVR5cGUuUHJveHlBcnJheSA6IFByb3h5VHlwZS5Qcm94eU9iamVjdCxcbiAgICAvLyBUcmFjayB3aGljaCBwcm9kdWNlIGNhbGwgdGhpcyBpcyBhc3NvY2lhdGVkIHdpdGguXG4gICAgc2NvcGU6IHBhcmVudCA/IHBhcmVudC5zY29wZSA6IEltbWVyU2NvcGUuY3VycmVudCxcbiAgICAvLyBUcnVlIGZvciBib3RoIHNoYWxsb3cgYW5kIGRlZXAgY2hhbmdlcy5cbiAgICBtb2RpZmllZDogZmFsc2UsXG4gICAgLy8gVXNlZCBkdXJpbmcgZmluYWxpemF0aW9uLlxuICAgIGZpbmFsaXplZDogZmFsc2UsXG4gICAgLy8gVHJhY2sgd2hpY2ggcHJvcGVydGllcyBoYXZlIGJlZW4gYXNzaWduZWQgKHRydWUpIG9yIGRlbGV0ZWQgKGZhbHNlKS5cbiAgICBhc3NpZ25lZDoge30sXG4gICAgLy8gVGhlIHBhcmVudCBkcmFmdCBzdGF0ZS5cbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAvLyBUaGUgYmFzZSBzdGF0ZS5cbiAgICBiYXNlOiBiYXNlLFxuICAgIC8vIFRoZSBiYXNlIHByb3h5LlxuICAgIGRyYWZ0OiBudWxsLFxuICAgIC8vIEFueSBwcm9wZXJ0eSBwcm94aWVzLlxuICAgIGRyYWZ0czoge30sXG4gICAgLy8gVGhlIGJhc2UgY29weSB3aXRoIGFueSB1cGRhdGVkIHZhbHVlcy5cbiAgICBjb3B5OiBudWxsLFxuICAgIC8vIENhbGxlZCBieSB0aGUgYHByb2R1Y2VgIGZ1bmN0aW9uLlxuICAgIHJldm9rZTogbnVsbCxcbiAgICBpc01hbnVhbDogZmFsc2VcbiAgfTsgLy8gdGhlIHRyYXBzIG11c3QgdGFyZ2V0IHNvbWV0aGluZywgYSBiaXQgbGlrZSB0aGUgJ3JlYWwnIGJhc2UuXG4gIC8vIGJ1dCBhbHNvLCB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gZGV0ZXJtaW5lIGZyb20gdGhlIHRhcmdldCB3aGF0IHRoZSByZWxldmFudCBzdGF0ZSBpc1xuICAvLyAodG8gYXZvaWQgY3JlYXRpbmcgdHJhcHMgcGVyIGluc3RhbmNlIHRvIGNhcHR1cmUgdGhlIHN0YXRlIGluIGNsb3N1cmUsXG4gIC8vIGFuZCB0byBhdm9pZCBjcmVhdGluZyB3ZWlyZCBoaWRkZW4gcHJvcGVydGllcyBhcyB3ZWxsKVxuICAvLyBTbyB0aGUgdHJpY2sgaXMgdG8gdXNlICdzdGF0ZScgYXMgdGhlIGFjdHVhbCAndGFyZ2V0JyEgKGFuZCBtYWtlIHN1cmUgd2UgaW50ZXJjZXB0IGV2ZXJ5dGhpbmcpXG4gIC8vIE5vdGUgdGhhdCBpbiB0aGUgY2FzZSBvZiBhbiBhcnJheSwgd2UgcHV0IHRoZSBzdGF0ZSBpbiBhbiBhcnJheSB0byBoYXZlIGJldHRlciBSZWZsZWN0IGRlZmF1bHRzIG9vdGJcblxuICB2YXIgdGFyZ2V0ID0gc3RhdGU7XG4gIHZhciB0cmFwcyA9IG9iamVjdFRyYXBzO1xuXG4gIGlmIChpc0FycmF5KSB7XG4gICAgdGFyZ2V0ID0gW3N0YXRlXTtcbiAgICB0cmFwcyA9IGFycmF5VHJhcHM7XG4gIH0gLy8gVE9ETzogb3B0aW1pemF0aW9uOiBtaWdodCBiZSBmYXN0ZXIsIGNoZWFwZXIgaWYgd2UgY3JlYXRlZCBhIG5vbi1yZXZvY2FibGUgcHJveHlcbiAgLy8gYW5kIGFkbWluaXN0cmF0ZSByZXZva2luZyBvdXJzZWx2ZXNcblxuXG4gIHZhciBfYSA9IFByb3h5LnJldm9jYWJsZSh0YXJnZXQsIHRyYXBzKSxcbiAgICAgIHJldm9rZSA9IF9hLnJldm9rZSxcbiAgICAgIHByb3h5ID0gX2EucHJveHk7XG5cbiAgc3RhdGUuZHJhZnQgPSBwcm94eTtcbiAgc3RhdGUucmV2b2tlID0gcmV2b2tlO1xuICByZXR1cm4gcHJveHk7XG59XG4vKipcclxuICogT2JqZWN0IGRyYWZ0c1xyXG4gKi9cblxudmFyIG9iamVjdFRyYXBzID0ge1xuICBnZXQ6IGZ1bmN0aW9uIChzdGF0ZSwgcHJvcCkge1xuICAgIGlmIChwcm9wID09PSBEUkFGVF9TVEFURSkgeyByZXR1cm4gc3RhdGU7IH1cbiAgICB2YXIgZHJhZnRzID0gc3RhdGUuZHJhZnRzOyAvLyBDaGVjayBmb3IgZXhpc3RpbmcgZHJhZnQgaW4gdW5tb2RpZmllZCBzdGF0ZS5cblxuICAgIGlmICghc3RhdGUubW9kaWZpZWQgJiYgaGFzKGRyYWZ0cywgcHJvcCkpIHtcbiAgICAgIHJldHVybiBkcmFmdHNbcHJvcF07XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gbGF0ZXN0KHN0YXRlKVtwcm9wXTtcblxuICAgIGlmIChzdGF0ZS5maW5hbGl6ZWQgfHwgIWlzRHJhZnRhYmxlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gLy8gQ2hlY2sgZm9yIGV4aXN0aW5nIGRyYWZ0IGluIG1vZGlmaWVkIHN0YXRlLlxuXG5cbiAgICBpZiAoc3RhdGUubW9kaWZpZWQpIHtcbiAgICAgIC8vIEFzc2lnbmVkIHZhbHVlcyBhcmUgbmV2ZXIgZHJhZnRlZC4gVGhpcyBjYXRjaGVzIGFueSBkcmFmdHMgd2UgY3JlYXRlZCwgdG9vLlxuICAgICAgaWYgKHZhbHVlICE9PSBwZWVrKHN0YXRlLmJhc2UsIHByb3ApKSB7IHJldHVybiB2YWx1ZTsgfSAvLyBTdG9yZSBkcmFmdHMgb24gdGhlIGNvcHkgKHdoZW4gb25lIGV4aXN0cykuXG4gICAgICAvLyBAdHMtaWdub3JlXG5cbiAgICAgIGRyYWZ0cyA9IHN0YXRlLmNvcHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRyYWZ0c1twcm9wXSA9IHN0YXRlLnNjb3BlLmltbWVyLmNyZWF0ZVByb3h5KHZhbHVlLCBzdGF0ZSk7XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gKHN0YXRlLCBwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AgaW4gbGF0ZXN0KHN0YXRlKTtcbiAgfSxcbiAgb3duS2V5czogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyhsYXRlc3Qoc3RhdGUpKTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAoc3RhdGUsIHByb3BcbiAgLyogc3RyaWN0bHkgbm90LCBidXQgaGVscHMgVFMgKi9cbiAgLCB2YWx1ZSkge1xuICAgIGlmICghc3RhdGUubW9kaWZpZWQpIHtcbiAgICAgIHZhciBiYXNlVmFsdWUgPSBwZWVrKHN0YXRlLmJhc2UsIHByb3ApOyAvLyBPcHRpbWl6ZSBiYXNlZCBvbiB2YWx1ZSdzIHRydXRoaW5lc3MuIFRydXRoeSB2YWx1ZXMgYXJlIGd1YXJhbnRlZWQgdG9cbiAgICAgIC8vIG5ldmVyIGJlIHVuZGVmaW5lZCwgc28gd2UgY2FuIGF2b2lkIHRoZSBgaW5gIG9wZXJhdG9yLiBMYXN0bHksIHRydXRoeVxuICAgICAgLy8gdmFsdWVzIG1heSBiZSBkcmFmdHMsIGJ1dCBmYWxzeSB2YWx1ZXMgYXJlIG5ldmVyIGRyYWZ0cy5cblxuICAgICAgdmFyIGlzVW5jaGFuZ2VkID0gdmFsdWUgPyBpcyhiYXNlVmFsdWUsIHZhbHVlKSB8fCB2YWx1ZSA9PT0gc3RhdGUuZHJhZnRzW3Byb3BdIDogaXMoYmFzZVZhbHVlLCB2YWx1ZSkgJiYgcHJvcCBpbiBzdGF0ZS5iYXNlO1xuICAgICAgaWYgKGlzVW5jaGFuZ2VkKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICBwcmVwYXJlQ29weShzdGF0ZSk7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgfVxuXG4gICAgc3RhdGUuYXNzaWduZWRbcHJvcF0gPSB0cnVlOyAvLyBAdHMtaWdub3JlXG5cbiAgICBzdGF0ZS5jb3B5W3Byb3BdID0gdmFsdWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbiAoc3RhdGUsIHByb3ApIHtcbiAgICAvLyBUaGUgYHVuZGVmaW5lZGAgY2hlY2sgaXMgYSBmYXN0IHBhdGggZm9yIHByZS1leGlzdGluZyBrZXlzLlxuICAgIGlmIChwZWVrKHN0YXRlLmJhc2UsIHByb3ApICE9PSB1bmRlZmluZWQgfHwgcHJvcCBpbiBzdGF0ZS5iYXNlKSB7XG4gICAgICBzdGF0ZS5hc3NpZ25lZFtwcm9wXSA9IGZhbHNlO1xuICAgICAgcHJlcGFyZUNvcHkoc3RhdGUpO1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuYXNzaWduZWRbcHJvcF0pIHtcbiAgICAgIC8vIGlmIGFuIG9yaWdpbmFsbHkgbm90IGFzc2lnbmVkIHByb3BlcnR5IHdhcyBkZWxldGVkXG4gICAgICBkZWxldGUgc3RhdGUuYXNzaWduZWRbcHJvcF07XG4gICAgfSAvLyBAdHMtaWdub3JlXG5cblxuICAgIGlmIChzdGF0ZS5jb3B5KSB7IGRlbGV0ZSBzdGF0ZS5jb3B5W3Byb3BdOyB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIE5vdGU6IFdlIG5ldmVyIGNvZXJjZSBgZGVzYy52YWx1ZWAgaW50byBhbiBJbW1lciBkcmFmdCwgYmVjYXVzZSB3ZSBjYW4ndCBtYWtlXG4gIC8vIHRoZSBzYW1lIGd1YXJhbnRlZSBpbiBFUzUgbW9kZS5cbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiAoc3RhdGUsIHByb3ApIHtcbiAgICB2YXIgb3duZXIgPSBsYXRlc3Qoc3RhdGUpO1xuICAgIHZhciBkZXNjID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob3duZXIsIHByb3ApO1xuXG4gICAgaWYgKGRlc2MpIHtcbiAgICAgIGRlc2Mud3JpdGFibGUgPSB0cnVlO1xuICAgICAgZGVzYy5jb25maWd1cmFibGUgPSBzdGF0ZS50eXBlICE9PSBQcm94eVR5cGUuUHJveHlBcnJheSB8fCBwcm9wICE9PSBcImxlbmd0aFwiO1xuICAgIH1cblxuICAgIHJldHVybiBkZXNjO1xuICB9LFxuICBkZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpIGNhbm5vdCBiZSB1c2VkIG9uIGFuIEltbWVyIGRyYWZ0XCIpOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgfSxcbiAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc3RhdGUuYmFzZSk7XG4gIH0sXG4gIHNldFByb3RvdHlwZU9mOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0LnNldFByb3RvdHlwZU9mKCkgY2Fubm90IGJlIHVzZWQgb24gYW4gSW1tZXIgZHJhZnRcIik7IC8vIHByZXR0aWVyLWlnbm9yZVxuICB9XG59O1xuLyoqXHJcbiAqIEFycmF5IGRyYWZ0c1xyXG4gKi9cblxudmFyIGFycmF5VHJhcHMgPSB7fTtcbmVhY2gob2JqZWN0VHJhcHMsIGZ1bmN0aW9uIChrZXksIGZuKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgYXJyYXlUcmFwc1trZXldID0gZnVuY3Rpb24gKCkge1xuICAgIGFyZ3VtZW50c1swXSA9IGFyZ3VtZW50c1swXVswXTtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn0pO1xuXG5hcnJheVRyYXBzLmRlbGV0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKHN0YXRlLCBwcm9wKSB7XG4gIGlmIChpc05hTihwYXJzZUludChwcm9wKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbW1lciBvbmx5IHN1cHBvcnRzIGRlbGV0aW5nIGFycmF5IGluZGljZXNcIik7IC8vIHByZXR0aWVyLWlnbm9yZVxuICB9XG5cbiAgcmV0dXJuIG9iamVjdFRyYXBzLmRlbGV0ZVByb3BlcnR5LmNhbGwodGhpcywgc3RhdGVbMF0sIHByb3ApO1xufTtcblxuYXJyYXlUcmFwcy5zZXQgPSBmdW5jdGlvbiAoc3RhdGUsIHByb3AsIHZhbHVlKSB7XG4gIGlmIChwcm9wICE9PSBcImxlbmd0aFwiICYmIGlzTmFOKHBhcnNlSW50KHByb3ApKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkltbWVyIG9ubHkgc3VwcG9ydHMgc2V0dGluZyBhcnJheSBpbmRpY2VzIGFuZCB0aGUgJ2xlbmd0aCcgcHJvcGVydHlcIik7IC8vIHByZXR0aWVyLWlnbm9yZVxuICB9XG5cbiAgcmV0dXJuIG9iamVjdFRyYXBzLnNldC5jYWxsKHRoaXMsIHN0YXRlWzBdLCBwcm9wLCB2YWx1ZSwgc3RhdGVbMF0pO1xufTtcbi8qKlxyXG4gKiBNYXAgZHJhZnRzXHJcbiAqL1xuLy8gQWNjZXNzIGEgcHJvcGVydHkgd2l0aG91dCBjcmVhdGluZyBhbiBJbW1lciBkcmFmdC5cblxuXG5mdW5jdGlvbiBwZWVrKGRyYWZ0LCBwcm9wKSB7XG4gIHZhciBzdGF0ZSA9IGRyYWZ0W0RSQUZUX1NUQVRFXTtcbiAgdmFyIGRlc2MgPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzdGF0ZSA/IGxhdGVzdChzdGF0ZSkgOiBkcmFmdCwgcHJvcCk7XG4gIHJldHVybiBkZXNjICYmIGRlc2MudmFsdWU7XG59XG5cbmZ1bmN0aW9uIG1hcmtDaGFuZ2VkKHN0YXRlKSB7XG4gIGlmICghc3RhdGUubW9kaWZpZWQpIHtcbiAgICBzdGF0ZS5tb2RpZmllZCA9IHRydWU7XG5cbiAgICBpZiAoc3RhdGUudHlwZSA9PT0gUHJveHlUeXBlLlByb3h5T2JqZWN0IHx8IHN0YXRlLnR5cGUgPT09IFByb3h5VHlwZS5Qcm94eUFycmF5KSB7XG4gICAgICB2YXIgY29weV8xID0gc3RhdGUuY29weSA9IHNoYWxsb3dDb3B5KHN0YXRlLmJhc2UpO1xuICAgICAgZWFjaChzdGF0ZS5kcmFmdHMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29weV8xW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgc3RhdGUuZHJhZnRzID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5wYXJlbnQpIHtcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlLnBhcmVudCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVDb3B5KHN0YXRlKSB7XG4gIGlmICghc3RhdGUuY29weSkge1xuICAgIHN0YXRlLmNvcHkgPSBzaGFsbG93Q29weShzdGF0ZS5iYXNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3aWxsRmluYWxpemVFUzUoc2NvcGUsIHJlc3VsdCwgaXNSZXBsYWNlZCkge1xuICBzY29wZS5kcmFmdHMuZm9yRWFjaChmdW5jdGlvbiAoZHJhZnQpIHtcbiAgICBkcmFmdFtEUkFGVF9TVEFURV0uZmluYWxpemluZyA9IHRydWU7XG4gIH0pO1xuXG4gIGlmICghaXNSZXBsYWNlZCkge1xuICAgIGlmIChzY29wZS5wYXRjaGVzKSB7XG4gICAgICBtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5KHNjb3BlLmRyYWZ0c1swXSk7XG4gICAgfSAvLyBUaGlzIGlzIGZhc3RlciB3aGVuIHdlIGRvbid0IGNhcmUgYWJvdXQgd2hpY2ggYXR0cmlidXRlcyBjaGFuZ2VkLlxuXG5cbiAgICBtYXJrQ2hhbmdlc1N3ZWVwKHNjb3BlLmRyYWZ0cyk7XG4gIH0gLy8gV2hlbiBhIGNoaWxkIGRyYWZ0IGlzIHJldHVybmVkLCBsb29rIGZvciBjaGFuZ2VzLlxuICBlbHNlIGlmIChpc0RyYWZ0KHJlc3VsdCkgJiYgcmVzdWx0W0RSQUZUX1NUQVRFXS5zY29wZSA9PT0gc2NvcGUpIHtcbiAgICAgIG1hcmtDaGFuZ2VzU3dlZXAoc2NvcGUuZHJhZnRzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFUzVQcm94eShiYXNlLCBwYXJlbnQpIHtcbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGJhc2UpO1xuICB2YXIgZHJhZnQgPSBjbG9uZVBvdGVudGlhbERyYWZ0KGJhc2UpO1xuICBlYWNoKGRyYWZ0LCBmdW5jdGlvbiAocHJvcCkge1xuICAgIHByb3h5UHJvcGVydHkoZHJhZnQsIHByb3AsIGlzQXJyYXkgfHwgaXNFbnVtZXJhYmxlKGJhc2UsIHByb3ApKTtcbiAgfSk7XG4gIHZhciBzdGF0ZSA9IHtcbiAgICB0eXBlOiBpc0FycmF5ID8gUHJveHlUeXBlLkVTNUFycmF5IDogUHJveHlUeXBlLkVTNU9iamVjdCxcbiAgICBzY29wZTogcGFyZW50ID8gcGFyZW50LnNjb3BlIDogSW1tZXJTY29wZS5jdXJyZW50LFxuICAgIG1vZGlmaWVkOiBmYWxzZSxcbiAgICBmaW5hbGl6aW5nOiBmYWxzZSxcbiAgICBmaW5hbGl6ZWQ6IGZhbHNlLFxuICAgIGFzc2lnbmVkOiB7fSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBiYXNlOiBiYXNlLFxuICAgIGRyYWZ0OiBkcmFmdCxcbiAgICBjb3B5OiBudWxsLFxuICAgIHJldm9rZWQ6IGZhbHNlLFxuICAgIGlzTWFudWFsOiBmYWxzZVxuICB9O1xuICBjcmVhdGVIaWRkZW5Qcm9wZXJ0eShkcmFmdCwgRFJBRlRfU1RBVEUsIHN0YXRlKTtcbiAgcmV0dXJuIGRyYWZ0O1xufSAvLyBBY2Nlc3MgYSBwcm9wZXJ0eSB3aXRob3V0IGNyZWF0aW5nIGFuIEltbWVyIGRyYWZ0LlxuXG5mdW5jdGlvbiBwZWVrJDEoZHJhZnQsIHByb3ApIHtcbiAgdmFyIHN0YXRlID0gZHJhZnRbRFJBRlRfU1RBVEVdO1xuXG4gIGlmIChzdGF0ZSAmJiAhc3RhdGUuZmluYWxpemluZykge1xuICAgIHN0YXRlLmZpbmFsaXppbmcgPSB0cnVlO1xuICAgIHZhciB2YWx1ZSA9IGRyYWZ0W3Byb3BdO1xuICAgIHN0YXRlLmZpbmFsaXppbmcgPSBmYWxzZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gZHJhZnRbcHJvcF07XG59XG5cbmZ1bmN0aW9uIGdldCQxKHN0YXRlLCBwcm9wKSB7XG4gIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gIHZhciB2YWx1ZSA9IHBlZWskMShsYXRlc3Qoc3RhdGUpLCBwcm9wKTtcbiAgaWYgKHN0YXRlLmZpbmFsaXppbmcpIHsgcmV0dXJuIHZhbHVlOyB9IC8vIENyZWF0ZSBhIGRyYWZ0IGlmIHRoZSB2YWx1ZSBpcyB1bm1vZGlmaWVkLlxuXG4gIGlmICh2YWx1ZSA9PT0gcGVlayQxKHN0YXRlLmJhc2UsIHByb3ApICYmIGlzRHJhZnRhYmxlKHZhbHVlKSkge1xuICAgIHByZXBhcmVDb3B5JDEoc3RhdGUpOyAvLyBAdHMtaWdub3JlXG5cbiAgICByZXR1cm4gc3RhdGUuY29weVtwcm9wXSA9IHN0YXRlLnNjb3BlLmltbWVyLmNyZWF0ZVByb3h5KHZhbHVlLCBzdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHNldCQxKHN0YXRlLCBwcm9wLCB2YWx1ZSkge1xuICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICBzdGF0ZS5hc3NpZ25lZFtwcm9wXSA9IHRydWU7XG5cbiAgaWYgKCFzdGF0ZS5tb2RpZmllZCkge1xuICAgIGlmIChpcyh2YWx1ZSwgcGVlayQxKGxhdGVzdChzdGF0ZSksIHByb3ApKSkgeyByZXR1cm47IH1cbiAgICBtYXJrQ2hhbmdlZEVTNShzdGF0ZSk7XG4gICAgcHJlcGFyZUNvcHkkMShzdGF0ZSk7XG4gIH0gLy8gQHRzLWlnbm9yZVxuXG5cbiAgc3RhdGUuY29weVtwcm9wXSA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBtYXJrQ2hhbmdlZEVTNShzdGF0ZSkge1xuICBpZiAoIXN0YXRlLm1vZGlmaWVkKSB7XG4gICAgc3RhdGUubW9kaWZpZWQgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5wYXJlbnQpIHsgbWFya0NoYW5nZWRFUzUoc3RhdGUucGFyZW50KTsgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVDb3B5JDEoc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5jb3B5KSB7IHN0YXRlLmNvcHkgPSBjbG9uZVBvdGVudGlhbERyYWZ0KHN0YXRlLmJhc2UpOyB9XG59XG5cbmZ1bmN0aW9uIGNsb25lUG90ZW50aWFsRHJhZnQoYmFzZSkge1xuICB2YXIgc3RhdGUgPSBiYXNlICYmIGJhc2VbRFJBRlRfU1RBVEVdO1xuXG4gIGlmIChzdGF0ZSkge1xuICAgIHN0YXRlLmZpbmFsaXppbmcgPSB0cnVlO1xuICAgIHZhciBkcmFmdCA9IHNoYWxsb3dDb3B5KHN0YXRlLmRyYWZ0LCB0cnVlKTtcbiAgICBzdGF0ZS5maW5hbGl6aW5nID0gZmFsc2U7XG4gICAgcmV0dXJuIGRyYWZ0O1xuICB9XG5cbiAgcmV0dXJuIHNoYWxsb3dDb3B5KGJhc2UpO1xufSAvLyBwcm9wZXJ0eSBkZXNjcmlwdG9ycyBhcmUgcmVjeWNsZWQgdG8gbWFrZSBzdXJlIHdlIGRvbid0IGNyZWF0ZSBhIGdldCBhbmQgc2V0IGNsb3N1cmUgcGVyIHByb3BlcnR5LFxuLy8gYnV0IHNoYXJlIHRoZW0gYWxsIGluc3RlYWRcblxuXG52YXIgZGVzY3JpcHRvcnMgPSB7fTtcblxuZnVuY3Rpb24gcHJveHlQcm9wZXJ0eShkcmFmdCwgcHJvcCwgZW51bWVyYWJsZSkge1xuICB2YXIgZGVzYyA9IGRlc2NyaXB0b3JzW3Byb3BdO1xuXG4gIGlmIChkZXNjKSB7XG4gICAgZGVzYy5lbnVtZXJhYmxlID0gZW51bWVyYWJsZTtcbiAgfSBlbHNlIHtcbiAgICBkZXNjcmlwdG9yc1twcm9wXSA9IGRlc2MgPSB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBlbnVtZXJhYmxlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBnZXQkMSh0aGlzW0RSQUZUX1NUQVRFXSwgcHJvcCk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgc2V0JDEodGhpc1tEUkFGVF9TVEFURV0sIHByb3AsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRyYWZ0LCBwcm9wLCBkZXNjKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VW5yZXZva2VkKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5yZXZva2VkID09PSB0cnVlKSB7IHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgYSBwcm94eSB0aGF0IGhhcyBiZWVuIHJldm9rZWQuIERpZCB5b3UgcGFzcyBhbiBvYmplY3QgZnJvbSBpbnNpZGUgYW4gaW1tZXIgZnVuY3Rpb24gdG8gYW4gYXN5bmMgcHJvY2Vzcz8gXCIgKyBKU09OLnN0cmluZ2lmeShsYXRlc3Qoc3RhdGUpKSk7IH1cbn0gLy8gVGhpcyBsb29rcyBleHBlbnNpdmUsIGJ1dCBvbmx5IHByb3hpZXMgYXJlIHZpc2l0ZWQsIGFuZCBvbmx5IG9iamVjdHMgd2l0aG91dCBrbm93biBjaGFuZ2VzIGFyZSBzY2FubmVkLlxuXG5mdW5jdGlvbiBtYXJrQ2hhbmdlc1N3ZWVwKGRyYWZ0cykge1xuICAvLyBUaGUgbmF0dXJhbCBvcmRlciBvZiBkcmFmdHMgaW4gdGhlIGBzY29wZWAgYXJyYXkgaXMgYmFzZWQgb24gd2hlbiB0aGV5XG4gIC8vIHdlcmUgYWNjZXNzZWQuIEJ5IHByb2Nlc3NpbmcgZHJhZnRzIGluIHJldmVyc2UgbmF0dXJhbCBvcmRlciwgd2UgaGF2ZSBhXG4gIC8vIGJldHRlciBjaGFuY2Ugb2YgcHJvY2Vzc2luZyBsZWFmIG5vZGVzIGZpcnN0LiBXaGVuIGEgbGVhZiBub2RlIGlzIGtub3duIHRvXG4gIC8vIGhhdmUgY2hhbmdlZCwgd2UgY2FuIGF2b2lkIGFueSB0cmF2ZXJzYWwgb2YgaXRzIGFuY2VzdG9yIG5vZGVzLlxuICBmb3IgKHZhciBpID0gZHJhZnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHN0YXRlID0gZHJhZnRzW2ldW0RSQUZUX1NUQVRFXTtcblxuICAgIGlmICghc3RhdGUubW9kaWZpZWQpIHtcbiAgICAgIHN3aXRjaCAoc3RhdGUudHlwZSkge1xuICAgICAgICBjYXNlIFByb3h5VHlwZS5FUzVBcnJheTpcbiAgICAgICAgICBpZiAoaGFzQXJyYXlDaGFuZ2VzKHN0YXRlKSkgeyBtYXJrQ2hhbmdlZEVTNShzdGF0ZSk7IH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFByb3h5VHlwZS5FUzVPYmplY3Q6XG4gICAgICAgICAgaWYgKGhhc09iamVjdENoYW5nZXMoc3RhdGUpKSB7IG1hcmtDaGFuZ2VkRVM1KHN0YXRlKTsgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5KG9iamVjdCkge1xuICBpZiAoIW9iamVjdCB8fCB0eXBlb2Ygb2JqZWN0ICE9PSBcIm9iamVjdFwiKSB7IHJldHVybjsgfVxuICB2YXIgc3RhdGUgPSBvYmplY3RbRFJBRlRfU1RBVEVdO1xuICBpZiAoIXN0YXRlKSB7IHJldHVybjsgfVxuICB2YXIgYmFzZSA9IHN0YXRlLmJhc2UsXG4gICAgICBkcmFmdCA9IHN0YXRlLmRyYWZ0LFxuICAgICAgYXNzaWduZWQgPSBzdGF0ZS5hc3NpZ25lZCxcbiAgICAgIHR5cGUgPSBzdGF0ZS50eXBlO1xuXG4gIGlmICh0eXBlID09PSBQcm94eVR5cGUuRVM1T2JqZWN0KSB7XG4gICAgLy8gTG9vayBmb3IgYWRkZWQga2V5cy5cbiAgICAvLyBUT0RPOiBsb29rcyBxdWl0ZSBkdXBsaWNhdGUgdG8gaGFzT2JqZWN0Q2hhbmdlcyxcbiAgICAvLyBwcm9iYWJseSB0aGVyZSBpcyBhIGZhc3RlciB3YXkgdG8gZGV0ZWN0IGNoYW5nZXMsIGFzIHN3ZWVwICsgcmVjdXJzZSBzZWVtcyB0byBkbyBzb21lXG4gICAgLy8gdW5uZWNlc3Nhcnkgd29yay5cbiAgICAvLyBhbHNvOiBwcm9iYWJseSB3ZSBjYW4gc3RvcmUgdGhlIGluZm9ybWF0aW9uIHdlIGRldGVjdCBoZXJlLCB0byBzcGVlZCB1cCB0cmVlIGZpbmFsaXphdGlvbiFcbiAgICBlYWNoKGRyYWZ0LCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoa2V5ID09PSBEUkFGVF9TVEFURSkgeyByZXR1cm47IH0gLy8gVGhlIGB1bmRlZmluZWRgIGNoZWNrIGlzIGEgZmFzdCBwYXRoIGZvciBwcmUtZXhpc3Rpbmcga2V5cy5cblxuICAgICAgaWYgKGJhc2Vba2V5XSA9PT0gdW5kZWZpbmVkICYmICFoYXMoYmFzZSwga2V5KSkge1xuICAgICAgICBhc3NpZ25lZFtrZXldID0gdHJ1ZTtcbiAgICAgICAgbWFya0NoYW5nZWRFUzUoc3RhdGUpO1xuICAgICAgfSBlbHNlIGlmICghYXNzaWduZWRba2V5XSkge1xuICAgICAgICAvLyBPbmx5IHVudG91Y2hlZCBwcm9wZXJ0aWVzIHRyaWdnZXIgcmVjdXJzaW9uLlxuICAgICAgICBtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5KGRyYWZ0W2tleV0pO1xuICAgICAgfVxuICAgIH0pOyAvLyBMb29rIGZvciByZW1vdmVkIGtleXMuXG5cbiAgICBlYWNoKGJhc2UsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8vIFRoZSBgdW5kZWZpbmVkYCBjaGVjayBpcyBhIGZhc3QgcGF0aCBmb3IgcHJlLWV4aXN0aW5nIGtleXMuXG4gICAgICBpZiAoZHJhZnRba2V5XSA9PT0gdW5kZWZpbmVkICYmICFoYXMoZHJhZnQsIGtleSkpIHtcbiAgICAgICAgYXNzaWduZWRba2V5XSA9IGZhbHNlO1xuICAgICAgICBtYXJrQ2hhbmdlZEVTNShzdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gUHJveHlUeXBlLkVTNUFycmF5KSB7XG4gICAgaWYgKGhhc0FycmF5Q2hhbmdlcyhzdGF0ZSkpIHtcbiAgICAgIG1hcmtDaGFuZ2VkRVM1KHN0YXRlKTtcbiAgICAgIGFzc2lnbmVkLmxlbmd0aCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGRyYWZ0Lmxlbmd0aCA8IGJhc2UubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gZHJhZnQubGVuZ3RoOyBpIDwgYmFzZS5sZW5ndGg7IGkrKykgeyBhc3NpZ25lZFtpXSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSBiYXNlLmxlbmd0aDsgaSA8IGRyYWZ0Lmxlbmd0aDsgaSsrKSB7IGFzc2lnbmVkW2ldID0gdHJ1ZTsgfVxuICAgIH0gLy8gTWluaW11bSBjb3VudCBpcyBlbm91Z2gsIHRoZSBvdGhlciBwYXJ0cyBoYXMgYmVlbiBwcm9jZXNzZWQuXG5cblxuICAgIHZhciBtaW4gPSBNYXRoLm1pbihkcmFmdC5sZW5ndGgsIGJhc2UubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWluOyBpKyspIHtcbiAgICAgIC8vIE9ubHkgdW50b3VjaGVkIGluZGljZXMgdHJpZ2dlciByZWN1cnNpb24uXG4gICAgICBpZiAoYXNzaWduZWRbaV0gPT09IHVuZGVmaW5lZCkgeyBtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5KGRyYWZ0W2ldKTsgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNPYmplY3RDaGFuZ2VzKHN0YXRlKSB7XG4gIHZhciBiYXNlID0gc3RhdGUuYmFzZSxcbiAgICAgIGRyYWZ0ID0gc3RhdGUuZHJhZnQ7IC8vIFNlYXJjaCBmb3IgYWRkZWQga2V5cyBhbmQgY2hhbmdlZCBrZXlzLiBTdGFydCBhdCB0aGUgYmFjaywgYmVjYXVzZVxuICAvLyBub24tbnVtZXJpYyBrZXlzIGFyZSBvcmRlcmVkIGJ5IHRpbWUgb2YgZGVmaW5pdGlvbiBvbiB0aGUgb2JqZWN0LlxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZHJhZnQpO1xuXG4gIGZvciAodmFyIGkgPSBrZXlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgdmFyIGJhc2VWYWx1ZSA9IGJhc2Vba2V5XTsgLy8gVGhlIGB1bmRlZmluZWRgIGNoZWNrIGlzIGEgZmFzdCBwYXRoIGZvciBwcmUtZXhpc3Rpbmcga2V5cy5cblxuICAgIGlmIChiYXNlVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhaGFzKGJhc2UsIGtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gT25jZSBhIGJhc2Uga2V5IGlzIGRlbGV0ZWQsIGZ1dHVyZSBjaGFuZ2VzIGdvIHVuZGV0ZWN0ZWQsIGJlY2F1c2UgaXRzXG4gICAgLy8gZGVzY3JpcHRvciBpcyBlcmFzZWQuIFRoaXMgYnJhbmNoIGRldGVjdHMgYW55IG1pc3NlZCBjaGFuZ2VzLlxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUgPSBkcmFmdFtrZXldO1xuICAgICAgICB2YXIgc3RhdGVfMSA9IHZhbHVlICYmIHZhbHVlW0RSQUZUX1NUQVRFXTtcblxuICAgICAgICBpZiAoc3RhdGVfMSA/IHN0YXRlXzEuYmFzZSAhPT0gYmFzZVZhbHVlIDogIWlzKHZhbHVlLCBiYXNlVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfSAvLyBBdCB0aGlzIHBvaW50LCBubyBrZXlzIHdlcmUgYWRkZWQgb3IgY2hhbmdlZC5cbiAgLy8gQ29tcGFyZSBrZXkgY291bnQgdG8gZGV0ZXJtaW5lIGlmIGtleXMgd2VyZSBkZWxldGVkLlxuXG5cbiAgcmV0dXJuIGtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiYXNlKS5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGhhc0FycmF5Q2hhbmdlcyhzdGF0ZSkge1xuICB2YXIgZHJhZnQgPSBzdGF0ZS5kcmFmdDtcbiAgaWYgKGRyYWZ0Lmxlbmd0aCAhPT0gc3RhdGUuYmFzZS5sZW5ndGgpIHsgcmV0dXJuIHRydWU7IH0gLy8gU2VlICMxMTZcbiAgLy8gSWYgd2UgZmlyc3Qgc2hvcnRlbiB0aGUgbGVuZ3RoLCBvdXIgYXJyYXkgaW50ZXJjZXB0b3JzIHdpbGwgYmUgcmVtb3ZlZC5cbiAgLy8gSWYgYWZ0ZXIgdGhhdCBuZXcgaXRlbXMgYXJlIGFkZGVkLCByZXN1bHQgaW4gdGhlIHNhbWUgb3JpZ2luYWwgbGVuZ3RoLFxuICAvLyB0aG9zZSBsYXN0IGl0ZW1zIHdpbGwgaGF2ZSBubyBpbnRlcmNlcHRpbmcgcHJvcGVydHkuXG4gIC8vIFNvIGlmIHRoZXJlIGlzIG5vIG93biBkZXNjcmlwdG9yIG9uIHRoZSBsYXN0IHBvc2l0aW9uLCB3ZSBrbm93IHRoYXQgaXRlbXMgd2VyZSByZW1vdmVkIGFuZCBhZGRlZFxuICAvLyBOLkIuOiBzcGxpY2UsIHVuc2hpZnQsIGV0YyBvbmx5IHNoaWZ0IHZhbHVlcyBhcm91bmQsIGJ1dCBub3QgcHJvcCBkZXNjcmlwdG9ycywgc28gd2Ugb25seSBoYXZlIHRvIGNoZWNrXG4gIC8vIHRoZSBsYXN0IG9uZVxuXG4gIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkcmFmdCwgZHJhZnQubGVuZ3RoIC0gMSk7IC8vIGRlc2NyaXB0b3IgY2FuIGJlIG51bGwsIGJ1dCBvbmx5IGZvciBuZXdseSBjcmVhdGVkIHNwYXJzZSBhcnJheXMsIGVnLiBuZXcgQXJyYXkoMTApXG5cbiAgaWYgKGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3IuZ2V0KSB7IHJldHVybiB0cnVlOyB9IC8vIEZvciBhbGwgb3RoZXIgY2FzZXMsIHdlIGRvbid0IGhhdmUgdG8gY29tcGFyZSwgYXMgdGhleSB3b3VsZCBoYXZlIGJlZW4gcGlja2VkIHVwIGJ5IHRoZSBpbmRleCBzZXR0ZXJzXG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgRHJhZnRNYXAgPSBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gIGlmICghX3N1cGVyKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYXAgaXMgbm90IHBvbHlmaWxsZWRcIik7XG4gIH1cblxuICBfX2V4dGVuZHMoRHJhZnRNYXAsIF9zdXBlcik7IC8vIENyZWF0ZSBjbGFzcyBtYW51YWxseSwgY2F1c2UgIzUwMlxuXG5cbiAgZnVuY3Rpb24gRHJhZnRNYXAodGFyZ2V0LCBwYXJlbnQpIHtcbiAgICB0aGlzW0RSQUZUX1NUQVRFXSA9IHtcbiAgICAgIHR5cGU6IFByb3h5VHlwZS5NYXAsXG4gICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgIHNjb3BlOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGUgOiBJbW1lclNjb3BlLmN1cnJlbnQsXG4gICAgICBtb2RpZmllZDogZmFsc2UsXG4gICAgICBmaW5hbGl6ZWQ6IGZhbHNlLFxuICAgICAgY29weTogdW5kZWZpbmVkLFxuICAgICAgYXNzaWduZWQ6IHVuZGVmaW5lZCxcbiAgICAgIGJhc2U6IHRhcmdldCxcbiAgICAgIGRyYWZ0OiB0aGlzLFxuICAgICAgaXNNYW51YWw6IGZhbHNlLFxuICAgICAgcmV2b2tlZDogZmFsc2VcbiAgICB9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIHAgPSBEcmFmdE1hcC5wcm90b3R5cGU7IC8vIFRPRE86IHNtYWxsZXIgYnVpbGQgc2l6ZSBpZiB3ZSBjcmVhdGUgYSB1dGlsIGZvciBPYmplY3QuZGVmaW5lUHJvcGVydHlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocCwgXCJzaXplXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLnNpemU7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcblxuICBwLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5oYXMoa2V5KTtcbiAgfTtcblxuICBwLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcblxuICAgIGlmIChsYXRlc3Qoc3RhdGUpLmdldChrZXkpICE9PSB2YWx1ZSkge1xuICAgICAgcHJlcGFyZUNvcHkkMihzdGF0ZSk7XG4gICAgICBzdGF0ZS5zY29wZS5pbW1lci5tYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICBzdGF0ZS5hc3NpZ25lZC5zZXQoa2V5LCB0cnVlKTtcbiAgICAgIHN0YXRlLmNvcHkuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgc3RhdGUuYXNzaWduZWQuc2V0KGtleSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcC5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCF0aGlzLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICBwcmVwYXJlQ29weSQyKHN0YXRlKTtcbiAgICBzdGF0ZS5zY29wZS5pbW1lci5tYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgc3RhdGUuYXNzaWduZWQuc2V0KGtleSwgZmFsc2UpO1xuICAgIHN0YXRlLmNvcHkuZGVsZXRlKGtleSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcC5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgIHByZXBhcmVDb3B5JDIoc3RhdGUpO1xuICAgIHN0YXRlLnNjb3BlLmltbWVyLm1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICBzdGF0ZS5hc3NpZ25lZCA9IG5ldyBNYXAoKTtcbiAgICByZXR1cm4gc3RhdGUuY29weS5jbGVhcigpO1xuICB9O1xuXG4gIHAuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYiwgdGhpc0FyZykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICBsYXRlc3Qoc3RhdGUpLmZvckVhY2goZnVuY3Rpb24gKF92YWx1ZSwga2V5LCBfbWFwKSB7XG4gICAgICBjYi5jYWxsKHRoaXNBcmcsIF90aGlzLmdldChrZXkpLCBrZXksIF90aGlzKTtcbiAgICB9KTtcbiAgfTtcblxuICBwLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgIHZhciB2YWx1ZSA9IGxhdGVzdChzdGF0ZSkuZ2V0KGtleSk7XG5cbiAgICBpZiAoc3RhdGUuZmluYWxpemVkIHx8ICFpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgIT09IHN0YXRlLmJhc2UuZ2V0KGtleSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTsgLy8gZWl0aGVyIGFscmVhZHkgZHJhZnRlZCBvciByZWFzc2lnbmVkXG4gICAgfSAvLyBkZXNwaXRlIHdoYXQgaXQgbG9va3MsIHRoaXMgY3JlYXRlcyBhIGRyYWZ0IG9ubHkgb25jZSwgc2VlIGFib3ZlIGNvbmRpdGlvblxuXG5cbiAgICB2YXIgZHJhZnQgPSBzdGF0ZS5zY29wZS5pbW1lci5jcmVhdGVQcm94eSh2YWx1ZSwgc3RhdGUpO1xuICAgIHByZXBhcmVDb3B5JDIoc3RhdGUpO1xuICAgIHN0YXRlLmNvcHkuc2V0KGtleSwgZHJhZnQpO1xuICAgIHJldHVybiBkcmFmdDtcbiAgfTtcblxuICBwLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkua2V5cygpO1xuICB9O1xuXG4gIHAudmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLmtleXMoKTtcbiAgICByZXR1cm4gX2EgPSB7fSwgX2FbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnZhbHVlcygpO1xuICAgIH0sIF9hLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgciA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICAgIGlmIChyLmRvbmUpIHsgcmV0dXJuIHI7IH1cblxuICAgICAgdmFyIHZhbHVlID0gX3RoaXMuZ2V0KHIudmFsdWUpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9O1xuICAgIH0sIF9hO1xuICB9O1xuXG4gIHAuZW50cmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2E7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5rZXlzKCk7XG4gICAgcmV0dXJuIF9hID0ge30sIF9hW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5lbnRyaWVzKCk7XG4gICAgfSwgX2EubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICAgICAgaWYgKHIuZG9uZSkgeyByZXR1cm4gcjsgfVxuXG4gICAgICB2YXIgdmFsdWUgPSBfdGhpcy5nZXQoci52YWx1ZSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogW3IudmFsdWUsIHZhbHVlXVxuICAgICAgfTtcbiAgICB9LCBfYTtcbiAgfTtcblxuICBwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gIH07XG5cbiAgcmV0dXJuIERyYWZ0TWFwO1xufShNYXApO1xuXG5mdW5jdGlvbiBwcm94eU1hcCh0YXJnZXQsIHBhcmVudCkge1xuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiBuZXcgRHJhZnRNYXAodGFyZ2V0LCBwYXJlbnQpO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlQ29weSQyKHN0YXRlKSB7XG4gIGlmICghc3RhdGUuY29weSkge1xuICAgIHN0YXRlLmFzc2lnbmVkID0gbmV3IE1hcCgpO1xuICAgIHN0YXRlLmNvcHkgPSBuZXcgTWFwKHN0YXRlLmJhc2UpO1xuICB9XG59XG5cbnZhciBEcmFmdFNldCA9IGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgaWYgKCFfc3VwZXIpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNldCBpcyBub3QgcG9seWZpbGxlZFwiKTtcbiAgfVxuXG4gIF9fZXh0ZW5kcyhEcmFmdFNldCwgX3N1cGVyKTsgLy8gQ3JlYXRlIGNsYXNzIG1hbnVhbGx5LCBjYXVzZSAjNTAyXG5cblxuICBmdW5jdGlvbiBEcmFmdFNldCh0YXJnZXQsIHBhcmVudCkge1xuICAgIHRoaXNbRFJBRlRfU1RBVEVdID0ge1xuICAgICAgdHlwZTogUHJveHlUeXBlLlNldCxcbiAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgc2NvcGU6IHBhcmVudCA/IHBhcmVudC5zY29wZSA6IEltbWVyU2NvcGUuY3VycmVudCxcbiAgICAgIG1vZGlmaWVkOiBmYWxzZSxcbiAgICAgIGZpbmFsaXplZDogZmFsc2UsXG4gICAgICBjb3B5OiB1bmRlZmluZWQsXG4gICAgICBiYXNlOiB0YXJnZXQsXG4gICAgICBkcmFmdDogdGhpcyxcbiAgICAgIGRyYWZ0czogbmV3IE1hcCgpLFxuICAgICAgcmV2b2tlZDogZmFsc2UsXG4gICAgICBpc01hbnVhbDogZmFsc2VcbiAgICB9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIHAgPSBEcmFmdFNldC5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcInNpemVcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkuc2l6ZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuXG4gIHAuaGFzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTsgLy8gYml0IG9mIHRyaWNrZXJ5IGhlcmUsIHRvIGJlIGFibGUgdG8gcmVjb2duaXplIGJvdGggdGhlIHZhbHVlLCBhbmQgdGhlIGRyYWZ0IG9mIGl0cyB2YWx1ZVxuXG4gICAgaWYgKCFzdGF0ZS5jb3B5KSB7XG4gICAgICByZXR1cm4gc3RhdGUuYmFzZS5oYXModmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5jb3B5Lmhhcyh2YWx1ZSkpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBpZiAoc3RhdGUuZHJhZnRzLmhhcyh2YWx1ZSkgJiYgc3RhdGUuY29weS5oYXMoc3RhdGUuZHJhZnRzLmdldCh2YWx1ZSkpKSB7IHJldHVybiB0cnVlOyB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHAuYWRkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcblxuICAgIGlmIChzdGF0ZS5jb3B5KSB7XG4gICAgICBzdGF0ZS5jb3B5LmFkZCh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICghc3RhdGUuYmFzZS5oYXModmFsdWUpKSB7XG4gICAgICBwcmVwYXJlQ29weSQzKHN0YXRlKTtcbiAgICAgIHN0YXRlLnNjb3BlLmltbWVyLm1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgIHN0YXRlLmNvcHkuYWRkKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBwLmRlbGV0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICBwcmVwYXJlQ29weSQzKHN0YXRlKTtcbiAgICBzdGF0ZS5zY29wZS5pbW1lci5tYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgcmV0dXJuIHN0YXRlLmNvcHkuZGVsZXRlKHZhbHVlKSB8fCAoc3RhdGUuZHJhZnRzLmhhcyh2YWx1ZSkgPyBzdGF0ZS5jb3B5LmRlbGV0ZShzdGF0ZS5kcmFmdHMuZ2V0KHZhbHVlKSkgOlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZmFsc2UpO1xuICB9O1xuXG4gIHAuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICBwcmVwYXJlQ29weSQzKHN0YXRlKTtcbiAgICBzdGF0ZS5zY29wZS5pbW1lci5tYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgcmV0dXJuIHN0YXRlLmNvcHkuY2xlYXIoKTtcbiAgfTtcblxuICBwLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgIHByZXBhcmVDb3B5JDMoc3RhdGUpO1xuICAgIHJldHVybiBzdGF0ZS5jb3B5LnZhbHVlcygpO1xuICB9O1xuXG4gIHAuZW50cmllcyA9IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICBwcmVwYXJlQ29weSQzKHN0YXRlKTtcbiAgICByZXR1cm4gc3RhdGUuY29weS5lbnRyaWVzKCk7XG4gIH07XG5cbiAgcC5rZXlzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xuICB9O1xuXG4gIHBbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xuICB9O1xuXG4gIHAuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goY2IsIHRoaXNBcmcpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLnZhbHVlcygpO1xuICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG5cbiAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICBjYi5jYWxsKHRoaXNBcmcsIHJlc3VsdC52YWx1ZSwgcmVzdWx0LnZhbHVlLCB0aGlzKTtcbiAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIERyYWZ0U2V0O1xufShTZXQpO1xuXG5mdW5jdGlvbiBwcm94eVNldCh0YXJnZXQsIHBhcmVudCkge1xuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiBuZXcgRHJhZnRTZXQodGFyZ2V0LCBwYXJlbnQpO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlQ29weSQzKHN0YXRlKSB7XG4gIGlmICghc3RhdGUuY29weSkge1xuICAgIC8vIGNyZWF0ZSBkcmFmdHMgZm9yIGFsbCBlbnRyaWVzIHRvIHByZXNlcnZlIGluc2VydGlvbiBvcmRlclxuICAgIHN0YXRlLmNvcHkgPSBuZXcgU2V0KCk7XG4gICAgc3RhdGUuYmFzZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKGlzRHJhZnRhYmxlKHZhbHVlKSkge1xuICAgICAgICB2YXIgZHJhZnQgPSBzdGF0ZS5zY29wZS5pbW1lci5jcmVhdGVQcm94eSh2YWx1ZSwgc3RhdGUpO1xuICAgICAgICBzdGF0ZS5kcmFmdHMuc2V0KHZhbHVlLCBkcmFmdCk7XG4gICAgICAgIHN0YXRlLmNvcHkuYWRkKGRyYWZ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmNvcHkuYWRkKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVBhdGNoZXMoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICBzd2l0Y2ggKHN0YXRlLnR5cGUpIHtcbiAgICBjYXNlIFByb3h5VHlwZS5Qcm94eU9iamVjdDpcbiAgICBjYXNlIFByb3h5VHlwZS5FUzVPYmplY3Q6XG4gICAgY2FzZSBQcm94eVR5cGUuTWFwOlxuICAgICAgcmV0dXJuIGdlbmVyYXRlUGF0Y2hlc0Zyb21Bc3NpZ25lZChzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKTtcblxuICAgIGNhc2UgUHJveHlUeXBlLkVTNUFycmF5OlxuICAgIGNhc2UgUHJveHlUeXBlLlByb3h5QXJyYXk6XG4gICAgICByZXR1cm4gZ2VuZXJhdGVBcnJheVBhdGNoZXMoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcyk7XG5cbiAgICBjYXNlIFByb3h5VHlwZS5TZXQ6XG4gICAgICByZXR1cm4gZ2VuZXJhdGVTZXRQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQXJyYXlQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgdmFyIF9hLCBfYjtcblxuICB2YXIgYmFzZSA9IHN0YXRlLmJhc2UsXG4gICAgICBhc3NpZ25lZCA9IHN0YXRlLmFzc2lnbmVkLFxuICAgICAgY29weSA9IHN0YXRlLmNvcHk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgaWYgKCFjb3B5KSB7IGRpZSgpOyB9IC8vIFJlZHVjZSBjb21wbGV4aXR5IGJ5IGVuc3VyaW5nIGBiYXNlYCBpcyBuZXZlciBsb25nZXIuXG5cbiAgaWYgKGNvcHkubGVuZ3RoIDwgYmFzZS5sZW5ndGgpIHtcbiAgICBfYSA9IFtjb3B5LCBiYXNlXSwgYmFzZSA9IF9hWzBdLCBjb3B5ID0gX2FbMV07XG4gICAgX2IgPSBbaW52ZXJzZVBhdGNoZXMsIHBhdGNoZXNdLCBwYXRjaGVzID0gX2JbMF0sIGludmVyc2VQYXRjaGVzID0gX2JbMV07XG4gIH1cblxuICB2YXIgZGVsdGEgPSBjb3B5Lmxlbmd0aCAtIGJhc2UubGVuZ3RoOyAvLyBGaW5kIHRoZSBmaXJzdCByZXBsYWNlZCBpbmRleC5cblxuICB2YXIgc3RhcnQgPSAwO1xuXG4gIHdoaWxlIChiYXNlW3N0YXJ0XSA9PT0gY29weVtzdGFydF0gJiYgc3RhcnQgPCBiYXNlLmxlbmd0aCkge1xuICAgICsrc3RhcnQ7XG4gIH0gLy8gRmluZCB0aGUgbGFzdCByZXBsYWNlZCBpbmRleC4gU2VhcmNoIGZyb20gdGhlIGVuZCB0byBvcHRpbWl6ZSBzcGxpY2UgcGF0Y2hlcy5cblxuXG4gIHZhciBlbmQgPSBiYXNlLmxlbmd0aDtcblxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgYmFzZVtlbmQgLSAxXSA9PT0gY29weVtlbmQgKyBkZWx0YSAtIDFdKSB7XG4gICAgLS1lbmQ7XG4gIH0gLy8gUHJvY2VzcyByZXBsYWNlZCBpbmRpY2VzLlxuXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBpZiAoYXNzaWduZWRbaV0gJiYgY29weVtpXSAhPT0gYmFzZVtpXSkge1xuICAgICAgdmFyIHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgdmFsdWU6IGNvcHlbaV1cbiAgICAgIH0pO1xuICAgICAgaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgdmFsdWU6IGJhc2VbaV1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZXBsYWNlQ291bnQgPSBwYXRjaGVzLmxlbmd0aDsgLy8gUHJvY2VzcyBhZGRlZCBpbmRpY2VzLlxuXG4gIGZvciAodmFyIGkgPSBlbmQgKyBkZWx0YSAtIDE7IGkgPj0gZW5kOyAtLWkpIHtcbiAgICB2YXIgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xuICAgIHBhdGNoZXNbcmVwbGFjZUNvdW50ICsgaSAtIGVuZF0gPSB7XG4gICAgICBvcDogXCJhZGRcIixcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICB2YWx1ZTogY29weVtpXVxuICAgIH07XG4gICAgaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICBvcDogXCJyZW1vdmVcIixcbiAgICAgIHBhdGg6IHBhdGhcbiAgICB9KTtcbiAgfVxufSAvLyBUaGlzIGlzIHVzZWQgZm9yIGJvdGggTWFwIG9iamVjdHMgYW5kIG5vcm1hbCBvYmplY3RzLlxuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlUGF0Y2hlc0Zyb21Bc3NpZ25lZChzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XG4gIHZhciBiYXNlID0gc3RhdGUuYmFzZSxcbiAgICAgIGNvcHkgPSBzdGF0ZS5jb3B5O1xuICBlYWNoKHN0YXRlLmFzc2lnbmVkLCBmdW5jdGlvbiAoa2V5LCBhc3NpZ25lZFZhbHVlKSB7XG4gICAgdmFyIG9yaWdWYWx1ZSA9IGdldChiYXNlLCBrZXkpO1xuICAgIHZhciB2YWx1ZSA9IGdldChjb3B5LCBrZXkpO1xuICAgIHZhciBvcCA9ICFhc3NpZ25lZFZhbHVlID8gXCJyZW1vdmVcIiA6IGhhcyhiYXNlLCBrZXkpID8gXCJyZXBsYWNlXCIgOiBcImFkZFwiO1xuICAgIGlmIChvcmlnVmFsdWUgPT09IHZhbHVlICYmIG9wID09PSBcInJlcGxhY2VcIikgeyByZXR1cm47IH1cbiAgICB2YXIgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChrZXkpO1xuICAgIHBhdGNoZXMucHVzaChvcCA9PT0gXCJyZW1vdmVcIiA/IHtcbiAgICAgIG9wOiBvcCxcbiAgICAgIHBhdGg6IHBhdGhcbiAgICB9IDoge1xuICAgICAgb3A6IG9wLFxuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xuICAgIGludmVyc2VQYXRjaGVzLnB1c2gob3AgPT09IFwiYWRkXCIgPyB7XG4gICAgICBvcDogXCJyZW1vdmVcIixcbiAgICAgIHBhdGg6IHBhdGhcbiAgICB9IDogb3AgPT09IFwicmVtb3ZlXCIgPyB7XG4gICAgICBvcDogXCJhZGRcIixcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICB2YWx1ZTogb3JpZ1ZhbHVlXG4gICAgfSA6IHtcbiAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICB2YWx1ZTogb3JpZ1ZhbHVlXG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVNldFBhdGNoZXMoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICB2YXIgYmFzZSA9IHN0YXRlLmJhc2UsXG4gICAgICBjb3B5ID0gc3RhdGUuY29weTtcbiAgdmFyIGkgPSAwO1xuICBiYXNlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKCFjb3B5Lmhhcyh2YWx1ZSkpIHtcbiAgICAgIHZhciBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSk7XG4gICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICBvcDogXCJyZW1vdmVcIixcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICAgIGludmVyc2VQYXRjaGVzLnVuc2hpZnQoe1xuICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpKys7XG4gIH0pO1xuICBpID0gMDtcbiAgY29weS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICghYmFzZS5oYXModmFsdWUpKSB7XG4gICAgICB2YXIgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xuICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgICBpbnZlcnNlUGF0Y2hlcy51bnNoaWZ0KHtcbiAgICAgICAgb3A6IFwicmVtb3ZlXCIsXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaSsrO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYXBwbHlQYXRjaGVzKGRyYWZ0LCBwYXRjaGVzKSB7XG4gIHBhdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAocGF0Y2gpIHtcbiAgICB2YXIgcGF0aCA9IHBhdGNoLnBhdGgsXG4gICAgICAgIG9wID0gcGF0Y2gub3A7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICAgIGlmICghcGF0aC5sZW5ndGgpIHsgZGllKCk7IH1cbiAgICB2YXIgYmFzZSA9IGRyYWZ0O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgYmFzZSA9IGdldChiYXNlLCBwYXRoW2ldKTtcbiAgICAgIGlmICghYmFzZSB8fCB0eXBlb2YgYmFzZSAhPT0gXCJvYmplY3RcIikgeyB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgcGF0Y2gsIHBhdGggZG9lc24ndCByZXNvbHZlOiBcIiArIHBhdGguam9pbihcIi9cIikpOyB9IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIH1cblxuICAgIHZhciB0eXBlID0gZ2V0QXJjaHR5cGUoYmFzZSk7XG4gICAgdmFyIHZhbHVlID0gZGVlcENsb25lUGF0Y2hWYWx1ZShwYXRjaC52YWx1ZSk7IC8vIHVzZWQgdG8gY2xvbmUgcGF0Y2ggdG8gZW5zdXJlIG9yaWdpbmFsIHBhdGNoIGlzIG5vdCBtb2RpZmllZCwgc2VlICM0MTFcblxuICAgIHZhciBrZXkgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG5cbiAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlIFwicmVwbGFjZVwiOlxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIEFyY2h0eXBlLk1hcDpcbiAgICAgICAgICAgIHJldHVybiBiYXNlLnNldChrZXksIHZhbHVlKTtcblxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICAgICAgICBjYXNlIEFyY2h0eXBlLlNldDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2V0cyBjYW5ub3QgaGF2ZSBcInJlcGxhY2VcIiBwYXRjaGVzLicpO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIGlmIHZhbHVlIGlzIGFuIG9iamVjdCwgdGhlbiBpdCdzIGFzc2lnbmVkIGJ5IHJlZmVyZW5jZVxuICAgICAgICAgICAgLy8gaW4gdGhlIGZvbGxvd2luZyBhZGQgb3IgcmVtb3ZlIG9wcywgdGhlIHZhbHVlIGZpZWxkIGluc2lkZSB0aGUgcGF0Y2ggd2lsbCBhbHNvIGJlIG1vZGlmeWVkXG4gICAgICAgICAgICAvLyBzbyB3ZSB1c2UgdmFsdWUgZnJvbSB0aGUgY2xvbmVkIHBhdGNoXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICByZXR1cm4gYmFzZVtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIEFyY2h0eXBlLkFycmF5OlxuICAgICAgICAgICAgcmV0dXJuIGJhc2Uuc3BsaWNlKGtleSwgMCwgdmFsdWUpO1xuXG4gICAgICAgICAgY2FzZSBBcmNodHlwZS5NYXA6XG4gICAgICAgICAgICByZXR1cm4gYmFzZS5zZXQoa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgICBjYXNlIEFyY2h0eXBlLlNldDpcbiAgICAgICAgICAgIHJldHVybiBiYXNlLmFkZCh2YWx1ZSk7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGJhc2Vba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJyZW1vdmVcIjpcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBBcmNodHlwZS5BcnJheTpcbiAgICAgICAgICAgIHJldHVybiBiYXNlLnNwbGljZShrZXksIDEpO1xuXG4gICAgICAgICAgY2FzZSBBcmNodHlwZS5NYXA6XG4gICAgICAgICAgICByZXR1cm4gYmFzZS5kZWxldGUoa2V5KTtcblxuICAgICAgICAgIGNhc2UgQXJjaHR5cGUuU2V0OlxuICAgICAgICAgICAgcmV0dXJuIGJhc2UuZGVsZXRlKHBhdGNoLnZhbHVlKTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlIGJhc2Vba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBwYXRjaCBvcGVyYXRpb246IFwiICsgb3ApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkcmFmdDtcbn1cblxuZnVuY3Rpb24gZGVlcENsb25lUGF0Y2hWYWx1ZShvYmopIHtcbiAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikgeyByZXR1cm4gb2JqOyB9XG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHsgcmV0dXJuIG9iai5tYXAoZGVlcENsb25lUGF0Y2hWYWx1ZSk7IH1cbiAgaWYgKGlzTWFwKG9iaikpIHsgcmV0dXJuIG5ldyBNYXAoQXJyYXkuZnJvbShvYmouZW50cmllcygpKS5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGsgPSBfYVswXSxcbiAgICAgICAgdiA9IF9hWzFdO1xuICAgIHJldHVybiBbaywgZGVlcENsb25lUGF0Y2hWYWx1ZSh2KV07XG4gIH0pKTsgfVxuICBpZiAoaXNTZXQob2JqKSkgeyByZXR1cm4gbmV3IFNldChBcnJheS5mcm9tKG9iaikubWFwKGRlZXBDbG9uZVBhdGNoVmFsdWUpKTsgfVxuICB2YXIgY2xvbmVkID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSk7XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikgeyBjbG9uZWRba2V5XSA9IGRlZXBDbG9uZVBhdGNoVmFsdWUob2JqW2tleV0pOyB9XG5cbiAgcmV0dXJuIGNsb25lZDtcbn1cblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuZnVuY3Rpb24gdmVyaWZ5TWluaWZpZWQoKSB7fVxuXG52YXIgY29uZmlnRGVmYXVsdHMgPSB7XG4gIHVzZVByb3hpZXM6IHR5cGVvZiBQcm94eSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgUHJveHkucmV2b2NhYmxlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiLFxuICBhdXRvRnJlZXplOiB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA6XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHZlcmlmeU1pbmlmaWVkLm5hbWUgPT09IFwidmVyaWZ5TWluaWZpZWRcIixcbiAgb25Bc3NpZ246IG51bGwsXG4gIG9uRGVsZXRlOiBudWxsLFxuICBvbkNvcHk6IG51bGxcbn07XG5cbnZhciBJbW1lciA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEltbWVyKGNvbmZpZykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLnVzZVByb3hpZXMgPSBmYWxzZTtcbiAgICB0aGlzLmF1dG9GcmVlemUgPSBmYWxzZTtcbiAgICBlYWNoKGNvbmZpZ0RlZmF1bHRzLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIF9hLCBfYjsgLy8gQHRzLWlnbm9yZVxuXG5cbiAgICAgIF90aGlzW2tleV0gPSAoX2IgPSAoX2EgPSBjb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtrZXldLCBfYiAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB2YWx1ZSk7XG4gICAgfSk7XG4gICAgdGhpcy5zZXRVc2VQcm94aWVzKHRoaXMudXNlUHJveGllcyk7XG4gICAgdGhpcy5wcm9kdWNlID0gdGhpcy5wcm9kdWNlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5wcm9kdWNlV2l0aFBhdGNoZXMgPSB0aGlzLnByb2R1Y2VXaXRoUGF0Y2hlcy5iaW5kKHRoaXMpO1xuICB9XG4gIC8qKlxyXG4gICAqIFRoZSBgcHJvZHVjZWAgZnVuY3Rpb24gdGFrZXMgYSB2YWx1ZSBhbmQgYSBcInJlY2lwZSBmdW5jdGlvblwiICh3aG9zZVxyXG4gICAqIHJldHVybiB2YWx1ZSBvZnRlbiBkZXBlbmRzIG9uIHRoZSBiYXNlIHN0YXRlKS4gVGhlIHJlY2lwZSBmdW5jdGlvbiBpc1xyXG4gICAqIGZyZWUgdG8gbXV0YXRlIGl0cyBmaXJzdCBhcmd1bWVudCBob3dldmVyIGl0IHdhbnRzLiBBbGwgbXV0YXRpb25zIGFyZVxyXG4gICAqIG9ubHkgZXZlciBhcHBsaWVkIHRvIGEgX19jb3B5X18gb2YgdGhlIGJhc2Ugc3RhdGUuXHJcbiAgICpcclxuICAgKiBQYXNzIG9ubHkgYSBmdW5jdGlvbiB0byBjcmVhdGUgYSBcImN1cnJpZWQgcHJvZHVjZXJcIiB3aGljaCByZWxpZXZlcyB5b3VcclxuICAgKiBmcm9tIHBhc3NpbmcgdGhlIHJlY2lwZSBmdW5jdGlvbiBldmVyeSB0aW1lLlxyXG4gICAqXHJcbiAgICogT25seSBwbGFpbiBvYmplY3RzIGFuZCBhcnJheXMgYXJlIG1hZGUgbXV0YWJsZS4gQWxsIG90aGVyIG9iamVjdHMgYXJlXHJcbiAgICogY29uc2lkZXJlZCB1bmNvcHlhYmxlLlxyXG4gICAqXHJcbiAgICogTm90ZTogVGhpcyBmdW5jdGlvbiBpcyBfX2JvdW5kX18gdG8gaXRzIGBJbW1lcmAgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2FueX0gYmFzZSAtIHRoZSBpbml0aWFsIHN0YXRlXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvZHVjZXIgLSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEgcHJveHkgb2YgdGhlIGJhc2Ugc3RhdGUgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHdoaWNoIGNhbiBiZSBmcmVlbHkgbW9kaWZpZWRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXRjaExpc3RlbmVyIC0gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFsbCB0aGUgcGF0Y2hlcyBwcm9kdWNlZCBoZXJlXHJcbiAgICogQHJldHVybnMge2FueX0gYSBuZXcgc3RhdGUsIG9yIHRoZSBpbml0aWFsIHN0YXRlIGlmIG5vdGhpbmcgd2FzIG1vZGlmaWVkXHJcbiAgICovXG5cblxuICBJbW1lci5wcm90b3R5cGUucHJvZHVjZSA9IGZ1bmN0aW9uIChiYXNlLCByZWNpcGUsIHBhdGNoTGlzdGVuZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzOyAvLyBjdXJyaWVkIGludm9jYXRpb25cblxuXG4gICAgaWYgKHR5cGVvZiBiYXNlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHJlY2lwZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB2YXIgZGVmYXVsdEJhc2VfMSA9IHJlY2lwZTtcbiAgICAgIHJlY2lwZSA9IGJhc2U7XG4gICAgICB2YXIgc2VsZl8xID0gdGhpcztcbiAgICAgIHJldHVybiBmdW5jdGlvbiBjdXJyaWVkUHJvZHVjZShiYXNlKSB7XG4gICAgICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIGlmIChiYXNlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBiYXNlID0gZGVmYXVsdEJhc2VfMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhcmdzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHMkMVtfaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZl8xLnByb2R1Y2UoYmFzZSwgZnVuY3Rpb24gKGRyYWZ0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlY2lwZS5jYWxsLmFwcGx5KHJlY2lwZSwgX19zcHJlYWRBcnJheXMoW190aGlzLCBkcmFmdF0sIGFyZ3MpKTtcbiAgICAgICAgfSk7IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgfTtcbiAgICB9IC8vIHByZXR0aWVyLWlnbm9yZVxuXG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHJlY2lwZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBmaXJzdCBvciBzZWNvbmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhdGNoTGlzdGVuZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcGF0Y2hMaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSB0aGlyZCBhcmd1bWVudCB0byBgcHJvZHVjZWAgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIHVuZGVmaW5lZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlc3VsdDsgLy8gT25seSBwbGFpbiBvYmplY3RzLCBhcnJheXMsIGFuZCBcImltbWVyYWJsZSBjbGFzc2VzXCIgYXJlIGRyYWZ0ZWQuXG5cbiAgICBpZiAoaXNEcmFmdGFibGUoYmFzZSkpIHtcbiAgICAgIHZhciBzY29wZV8xID0gSW1tZXJTY29wZS5lbnRlcih0aGlzKTtcbiAgICAgIHZhciBwcm94eSA9IHRoaXMuY3JlYXRlUHJveHkoYmFzZSwgdW5kZWZpbmVkKTtcbiAgICAgIHZhciBoYXNFcnJvciA9IHRydWU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IHJlY2lwZShwcm94eSk7XG4gICAgICAgIGhhc0Vycm9yID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAvLyBmaW5hbGx5IGluc3RlYWQgb2YgY2F0Y2ggKyByZXRocm93IGJldHRlciBwcmVzZXJ2ZXMgb3JpZ2luYWwgc3RhY2tcbiAgICAgICAgaWYgKGhhc0Vycm9yKSB7IHNjb3BlXzEucmV2b2tlKCk7IH1lbHNlIHsgc2NvcGVfMS5sZWF2ZSgpOyB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiByZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgc2NvcGVfMS51c2VQYXRjaGVzKHBhdGNoTGlzdGVuZXIpO1xuICAgICAgICAgIHJldHVybiBwcm9jZXNzUmVzdWx0KF90aGlzLCByZXN1bHQsIHNjb3BlXzEpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBzY29wZV8xLnJldm9rZSgpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc2NvcGVfMS51c2VQYXRjaGVzKHBhdGNoTGlzdGVuZXIpO1xuICAgICAgcmV0dXJuIHByb2Nlc3NSZXN1bHQodGhpcywgcmVzdWx0LCBzY29wZV8xKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gcmVjaXBlKGJhc2UpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gTk9USElORykgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHsgcmVzdWx0ID0gYmFzZTsgfVxuICAgICAgbWF5YmVGcmVlemUodGhpcywgcmVzdWx0LCB0cnVlKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xuXG4gIEltbWVyLnByb3RvdHlwZS5wcm9kdWNlV2l0aFBhdGNoZXMgPSBmdW5jdGlvbiAoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIGFyZzEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50cyQxW19pXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfdGhpcy5wcm9kdWNlV2l0aFBhdGNoZXMoc3RhdGUsIGZ1bmN0aW9uIChkcmFmdCkge1xuICAgICAgICAgIHJldHVybiBhcmcxLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheXMoW2RyYWZ0XSwgYXJncykpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSAvLyBub24tY3VycmllZCBmb3JtXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG5cbiAgICBpZiAoYXJnMykgeyBkaWUoKTsgfVxuICAgIHZhciBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcztcbiAgICB2YXIgbmV4dFN0YXRlID0gdGhpcy5wcm9kdWNlKGFyZzEsIGFyZzIsIGZ1bmN0aW9uIChwLCBpcCkge1xuICAgICAgcGF0Y2hlcyA9IHA7XG4gICAgICBpbnZlcnNlUGF0Y2hlcyA9IGlwO1xuICAgIH0pO1xuICAgIHJldHVybiBbbmV4dFN0YXRlLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlc107XG4gIH07XG5cbiAgSW1tZXIucHJvdG90eXBlLmNyZWF0ZURyYWZ0ID0gZnVuY3Rpb24gKGJhc2UpIHtcbiAgICBpZiAoIWlzRHJhZnRhYmxlKGJhc2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaXJzdCBhcmd1bWVudCB0byBgY3JlYXRlRHJhZnRgIG11c3QgYmUgYSBwbGFpbiBvYmplY3QsIGFuIGFycmF5LCBvciBhbiBpbW1lcmFibGUgb2JqZWN0XCIpOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICB9XG5cbiAgICB2YXIgc2NvcGUgPSBJbW1lclNjb3BlLmVudGVyKHRoaXMpO1xuICAgIHZhciBwcm94eSA9IHRoaXMuY3JlYXRlUHJveHkoYmFzZSwgdW5kZWZpbmVkKTtcbiAgICBwcm94eVtEUkFGVF9TVEFURV0uaXNNYW51YWwgPSB0cnVlO1xuICAgIHNjb3BlLmxlYXZlKCk7XG4gICAgcmV0dXJuIHByb3h5O1xuICB9O1xuXG4gIEltbWVyLnByb3RvdHlwZS5maW5pc2hEcmFmdCA9IGZ1bmN0aW9uIChkcmFmdCwgcGF0Y2hMaXN0ZW5lcikge1xuICAgIHZhciBzdGF0ZSA9IGRyYWZ0ICYmIGRyYWZ0W0RSQUZUX1NUQVRFXTtcblxuICAgIGlmICghc3RhdGUgfHwgIXN0YXRlLmlzTWFudWFsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaXJzdCBhcmd1bWVudCB0byBgZmluaXNoRHJhZnRgIG11c3QgYmUgYSBkcmFmdCByZXR1cm5lZCBieSBgY3JlYXRlRHJhZnRgXCIpOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuZmluYWxpemVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZ2l2ZW4gZHJhZnQgaXMgYWxyZWFkeSBmaW5hbGl6ZWRcIik7IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIH1cblxuICAgIHZhciBzY29wZSA9IHN0YXRlLnNjb3BlO1xuICAgIHNjb3BlLnVzZVBhdGNoZXMocGF0Y2hMaXN0ZW5lcik7XG4gICAgcmV0dXJuIHByb2Nlc3NSZXN1bHQodGhpcywgdW5kZWZpbmVkLCBzY29wZSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFBhc3MgdHJ1ZSB0byBhdXRvbWF0aWNhbGx5IGZyZWV6ZSBhbGwgY29waWVzIGNyZWF0ZWQgYnkgSW1tZXIuXHJcbiAgICpcclxuICAgKiBCeSBkZWZhdWx0LCBhdXRvLWZyZWV6aW5nIGlzIGRpc2FibGVkIGluIHByb2R1Y3Rpb24uXHJcbiAgICovXG5cblxuICBJbW1lci5wcm90b3R5cGUuc2V0QXV0b0ZyZWV6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuYXV0b0ZyZWV6ZSA9IHZhbHVlO1xuICB9O1xuICAvKipcclxuICAgKiBQYXNzIHRydWUgdG8gdXNlIHRoZSBFUzIwMTUgYFByb3h5YCBjbGFzcyB3aGVuIGNyZWF0aW5nIGRyYWZ0cywgd2hpY2ggaXNcclxuICAgKiBhbHdheXMgZmFzdGVyIHRoYW4gdXNpbmcgRVM1IHByb3hpZXMuXHJcbiAgICpcclxuICAgKiBCeSBkZWZhdWx0LCBmZWF0dXJlIGRldGVjdGlvbiBpcyB1c2VkLCBzbyBjYWxsaW5nIHRoaXMgaXMgcmFyZWx5IG5lY2Vzc2FyeS5cclxuICAgKi9cblxuXG4gIEltbWVyLnByb3RvdHlwZS5zZXRVc2VQcm94aWVzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy51c2VQcm94aWVzID0gdmFsdWU7XG4gIH07XG5cbiAgSW1tZXIucHJvdG90eXBlLmFwcGx5UGF0Y2hlcyA9IGZ1bmN0aW9uIChiYXNlLCBwYXRjaGVzKSB7XG4gICAgLy8gSWYgYSBwYXRjaCByZXBsYWNlcyB0aGUgZW50aXJlIHN0YXRlLCB0YWtlIHRoYXQgcmVwbGFjZW1lbnQgYXMgYmFzZVxuICAgIC8vIGJlZm9yZSBhcHBseWluZyBwYXRjaGVzXG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSBwYXRjaGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuXG4gICAgICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDAgJiYgcGF0Y2gub3AgPT09IFwicmVwbGFjZVwiKSB7XG4gICAgICAgIGJhc2UgPSBwYXRjaC52YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzRHJhZnQoYmFzZSkpIHtcbiAgICAgIC8vIE4uQjogbmV2ZXIgaGl0cyBpZiBzb21lIHBhdGNoIGEgcmVwbGFjZW1lbnQsIHBhdGNoZXMgYXJlIG5ldmVyIGRyYWZ0c1xuICAgICAgcmV0dXJuIGFwcGx5UGF0Y2hlcyhiYXNlLCBwYXRjaGVzKTtcbiAgICB9IC8vIE90aGVyd2lzZSwgcHJvZHVjZSBhIGNvcHkgb2YgdGhlIGJhc2Ugc3RhdGUuXG5cblxuICAgIHJldHVybiB0aGlzLnByb2R1Y2UoYmFzZSwgZnVuY3Rpb24gKGRyYWZ0KSB7XG4gICAgICByZXR1cm4gYXBwbHlQYXRjaGVzKGRyYWZ0LCBwYXRjaGVzLnNsaWNlKGkgKyAxKSk7XG4gICAgfSk7XG4gIH07XG5cbiAgSW1tZXIucHJvdG90eXBlLmNyZWF0ZVByb3h5ID0gZnVuY3Rpb24gKHZhbHVlLCBwYXJlbnQpIHtcbiAgICAvLyBwcmVjb25kaXRpb246IGNyZWF0ZVByb3h5IHNob3VsZCBiZSBndWFyZGVkIGJ5IGlzRHJhZnRhYmxlLCBzbyB3ZSBrbm93IHdlIGNhbiBzYWZlbHkgZHJhZnRcbiAgICB2YXIgZHJhZnQgPSBpc01hcCh2YWx1ZSkgPyBwcm94eU1hcCh2YWx1ZSwgcGFyZW50KSA6IGlzU2V0KHZhbHVlKSA/IHByb3h5U2V0KHZhbHVlLCBwYXJlbnQpIDogdGhpcy51c2VQcm94aWVzID8gY3JlYXRlUHJveHkodmFsdWUsIHBhcmVudCkgOiBjcmVhdGVFUzVQcm94eSh2YWx1ZSwgcGFyZW50KTtcbiAgICB2YXIgc2NvcGUgPSBwYXJlbnQgPyBwYXJlbnQuc2NvcGUgOiBJbW1lclNjb3BlLmN1cnJlbnQ7XG4gICAgc2NvcGUuZHJhZnRzLnB1c2goZHJhZnQpO1xuICAgIHJldHVybiBkcmFmdDtcbiAgfTtcblxuICBJbW1lci5wcm90b3R5cGUud2lsbEZpbmFsaXplID0gZnVuY3Rpb24gKHNjb3BlLCB0aGluZywgaXNSZXBsYWNlZCkge1xuICAgIGlmICghdGhpcy51c2VQcm94aWVzKSB7IHdpbGxGaW5hbGl6ZUVTNShzY29wZSwgdGhpbmcsIGlzUmVwbGFjZWQpOyB9XG4gIH07XG5cbiAgSW1tZXIucHJvdG90eXBlLm1hcmtDaGFuZ2VkID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMudXNlUHJveGllcykge1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXJrQ2hhbmdlZEVTNShzdGF0ZSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBJbW1lcjtcbn0oKTtcblxudmFyIGltbWVyID0gbmV3IEltbWVyKCk7XG4vKipcclxuICogVGhlIGBwcm9kdWNlYCBmdW5jdGlvbiB0YWtlcyBhIHZhbHVlIGFuZCBhIFwicmVjaXBlIGZ1bmN0aW9uXCIgKHdob3NlXHJcbiAqIHJldHVybiB2YWx1ZSBvZnRlbiBkZXBlbmRzIG9uIHRoZSBiYXNlIHN0YXRlKS4gVGhlIHJlY2lwZSBmdW5jdGlvbiBpc1xyXG4gKiBmcmVlIHRvIG11dGF0ZSBpdHMgZmlyc3QgYXJndW1lbnQgaG93ZXZlciBpdCB3YW50cy4gQWxsIG11dGF0aW9ucyBhcmVcclxuICogb25seSBldmVyIGFwcGxpZWQgdG8gYSBfX2NvcHlfXyBvZiB0aGUgYmFzZSBzdGF0ZS5cclxuICpcclxuICogUGFzcyBvbmx5IGEgZnVuY3Rpb24gdG8gY3JlYXRlIGEgXCJjdXJyaWVkIHByb2R1Y2VyXCIgd2hpY2ggcmVsaWV2ZXMgeW91XHJcbiAqIGZyb20gcGFzc2luZyB0aGUgcmVjaXBlIGZ1bmN0aW9uIGV2ZXJ5IHRpbWUuXHJcbiAqXHJcbiAqIE9ubHkgcGxhaW4gb2JqZWN0cyBhbmQgYXJyYXlzIGFyZSBtYWRlIG11dGFibGUuIEFsbCBvdGhlciBvYmplY3RzIGFyZVxyXG4gKiBjb25zaWRlcmVkIHVuY29weWFibGUuXHJcbiAqXHJcbiAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgX19ib3VuZF9fIHRvIGl0cyBgSW1tZXJgIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge2FueX0gYmFzZSAtIHRoZSBpbml0aWFsIHN0YXRlXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByb2R1Y2VyIC0gZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhIHByb3h5IG9mIHRoZSBiYXNlIHN0YXRlIGFzIGZpcnN0IGFyZ3VtZW50IGFuZCB3aGljaCBjYW4gYmUgZnJlZWx5IG1vZGlmaWVkXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBhdGNoTGlzdGVuZXIgLSBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggYWxsIHRoZSBwYXRjaGVzIHByb2R1Y2VkIGhlcmVcclxuICogQHJldHVybnMge2FueX0gYSBuZXcgc3RhdGUsIG9yIHRoZSBpbml0aWFsIHN0YXRlIGlmIG5vdGhpbmcgd2FzIG1vZGlmaWVkXHJcbiAqL1xuXG52YXIgcHJvZHVjZSA9IGltbWVyLnByb2R1Y2U7XG4vKipcclxuICogTGlrZSBgcHJvZHVjZWAsIGJ1dCBgcHJvZHVjZVdpdGhQYXRjaGVzYCBhbHdheXMgcmV0dXJucyBhIHR1cGxlXHJcbiAqIFtuZXh0U3RhdGUsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzXSAoaW5zdGVhZCBvZiBqdXN0IHRoZSBuZXh0IHN0YXRlKVxyXG4gKi9cblxudmFyIHByb2R1Y2VXaXRoUGF0Y2hlcyA9IGltbWVyLnByb2R1Y2VXaXRoUGF0Y2hlcy5iaW5kKGltbWVyKTtcbi8qKlxyXG4gKiBQYXNzIHRydWUgdG8gYXV0b21hdGljYWxseSBmcmVlemUgYWxsIGNvcGllcyBjcmVhdGVkIGJ5IEltbWVyLlxyXG4gKlxyXG4gKiBCeSBkZWZhdWx0LCBhdXRvLWZyZWV6aW5nIGlzIGRpc2FibGVkIGluIHByb2R1Y3Rpb24uXHJcbiAqL1xuXG52YXIgc2V0QXV0b0ZyZWV6ZSA9IGltbWVyLnNldEF1dG9GcmVlemUuYmluZChpbW1lcik7XG4vKipcclxuICogUGFzcyB0cnVlIHRvIHVzZSB0aGUgRVMyMDE1IGBQcm94eWAgY2xhc3Mgd2hlbiBjcmVhdGluZyBkcmFmdHMsIHdoaWNoIGlzXHJcbiAqIGFsd2F5cyBmYXN0ZXIgdGhhbiB1c2luZyBFUzUgcHJveGllcy5cclxuICpcclxuICogQnkgZGVmYXVsdCwgZmVhdHVyZSBkZXRlY3Rpb24gaXMgdXNlZCwgc28gY2FsbGluZyB0aGlzIGlzIHJhcmVseSBuZWNlc3NhcnkuXHJcbiAqL1xuXG52YXIgc2V0VXNlUHJveGllcyA9IGltbWVyLnNldFVzZVByb3hpZXMuYmluZChpbW1lcik7XG4vKipcclxuICogQXBwbHkgYW4gYXJyYXkgb2YgSW1tZXIgcGF0Y2hlcyB0byB0aGUgZmlyc3QgYXJndW1lbnQuXHJcbiAqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSBwcm9kdWNlciwgd2hpY2ggbWVhbnMgY29weS1vbi13cml0ZSBpcyBpbiBlZmZlY3QuXHJcbiAqL1xuXG52YXIgYXBwbHlQYXRjaGVzJDEgPSBpbW1lci5hcHBseVBhdGNoZXMuYmluZChpbW1lcik7XG4vKipcclxuICogQ3JlYXRlIGFuIEltbWVyIGRyYWZ0IGZyb20gdGhlIGdpdmVuIGJhc2Ugc3RhdGUsIHdoaWNoIG1heSBiZSBhIGRyYWZ0IGl0c2VsZi5cclxuICogVGhlIGRyYWZ0IGNhbiBiZSBtb2RpZmllZCB1bnRpbCB5b3UgZmluYWxpemUgaXQgd2l0aCB0aGUgYGZpbmlzaERyYWZ0YCBmdW5jdGlvbi5cclxuICovXG5cbnZhciBjcmVhdGVEcmFmdCA9IGltbWVyLmNyZWF0ZURyYWZ0LmJpbmQoaW1tZXIpO1xuLyoqXHJcbiAqIEZpbmFsaXplIGFuIEltbWVyIGRyYWZ0IGZyb20gYSBgY3JlYXRlRHJhZnRgIGNhbGwsIHJldHVybmluZyB0aGUgYmFzZSBzdGF0ZVxyXG4gKiAoaWYgbm8gY2hhbmdlcyB3ZXJlIG1hZGUpIG9yIGEgbW9kaWZpZWQgY29weS4gVGhlIGRyYWZ0IG11c3QgKm5vdCogYmVcclxuICogbXV0YXRlZCBhZnRlcndhcmRzLlxyXG4gKlxyXG4gKiBQYXNzIGEgZnVuY3Rpb24gYXMgdGhlIDJuZCBhcmd1bWVudCB0byBnZW5lcmF0ZSBJbW1lciBwYXRjaGVzIGJhc2VkIG9uIHRoZVxyXG4gKiBjaGFuZ2VzIHRoYXQgd2VyZSBtYWRlLlxyXG4gKi9cblxudmFyIGZpbmlzaERyYWZ0ID0gaW1tZXIuZmluaXNoRHJhZnQuYmluZChpbW1lcik7XG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBpcyBhY3R1YWxseSBhIG5vLW9wLCBidXQgY2FuIGJlIHVzZWQgdG8gY2FzdCBhbiBpbW11dGFibGUgdHlwZVxyXG4gKiB0byBhbiBkcmFmdCB0eXBlIGFuZCBtYWtlIFR5cGVTY3JpcHQgaGFwcHlcclxuICpcclxuICogQHBhcmFtIHZhbHVlXHJcbiAqL1xuXG5mdW5jdGlvbiBjYXN0RHJhZnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYWN0dWFsbHkgYSBuby1vcCwgYnV0IGNhbiBiZSB1c2VkIHRvIGNhc3QgYSBtdXRhYmxlIHR5cGVcclxuICogdG8gYW4gaW1tdXRhYmxlIHR5cGUgYW5kIG1ha2UgVHlwZVNjcmlwdCBoYXBweVxyXG4gKiBAcGFyYW0gdmFsdWVcclxuICovXG5cbmZ1bmN0aW9uIGNhc3RJbW11dGFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcm9kdWNlO1xuZXhwb3J0IHsgSW1tZXIsIGFwcGx5UGF0Y2hlcyQxIGFzIGFwcGx5UGF0Y2hlcywgY2FzdERyYWZ0LCBjYXN0SW1tdXRhYmxlLCBjcmVhdGVEcmFmdCwgZmluaXNoRHJhZnQsIERSQUZUQUJMRSBhcyBpbW1lcmFibGUsIGlzRHJhZnQsIGlzRHJhZnRhYmxlLCBOT1RISU5HIGFzIG5vdGhpbmcsIG9yaWdpbmFsLCBwcm9kdWNlLCBwcm9kdWNlV2l0aFBhdGNoZXMsIHNldEF1dG9GcmVlemUsIHNldFVzZVByb3hpZXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltbWVyLm1vZHVsZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBDb25zdGFudHMuXG4gKi9cblxudmFyIElTX01BQyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgL01hY3xpUG9kfGlQaG9uZXxpUGFkLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0pO1xuXG52YXIgTU9ESUZJRVJTID0ge1xuICBhbHQ6ICdhbHRLZXknLFxuICBjb250cm9sOiAnY3RybEtleScsXG4gIG1ldGE6ICdtZXRhS2V5JyxcbiAgc2hpZnQ6ICdzaGlmdEtleSdcbn07XG5cbnZhciBBTElBU0VTID0ge1xuICBhZGQ6ICcrJyxcbiAgYnJlYWs6ICdwYXVzZScsXG4gIGNtZDogJ21ldGEnLFxuICBjb21tYW5kOiAnbWV0YScsXG4gIGN0bDogJ2NvbnRyb2wnLFxuICBjdHJsOiAnY29udHJvbCcsXG4gIGRlbDogJ2RlbGV0ZScsXG4gIGRvd246ICdhcnJvd2Rvd24nLFxuICBlc2M6ICdlc2NhcGUnLFxuICBpbnM6ICdpbnNlcnQnLFxuICBsZWZ0OiAnYXJyb3dsZWZ0JyxcbiAgbW9kOiBJU19NQUMgPyAnbWV0YScgOiAnY29udHJvbCcsXG4gIG9wdDogJ2FsdCcsXG4gIG9wdGlvbjogJ2FsdCcsXG4gIHJldHVybjogJ2VudGVyJyxcbiAgcmlnaHQ6ICdhcnJvd3JpZ2h0JyxcbiAgc3BhY2U6ICcgJyxcbiAgc3BhY2ViYXI6ICcgJyxcbiAgdXA6ICdhcnJvd3VwJyxcbiAgd2luOiAnbWV0YScsXG4gIHdpbmRvd3M6ICdtZXRhJ1xufTtcblxudmFyIENPREVTID0ge1xuICBiYWNrc3BhY2U6IDgsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzaGlmdDogMTYsXG4gIGNvbnRyb2w6IDE3LFxuICBhbHQ6IDE4LFxuICBwYXVzZTogMTksXG4gIGNhcHNsb2NrOiAyMCxcbiAgZXNjYXBlOiAyNyxcbiAgJyAnOiAzMixcbiAgcGFnZXVwOiAzMyxcbiAgcGFnZWRvd246IDM0LFxuICBlbmQ6IDM1LFxuICBob21lOiAzNixcbiAgYXJyb3dsZWZ0OiAzNyxcbiAgYXJyb3d1cDogMzgsXG4gIGFycm93cmlnaHQ6IDM5LFxuICBhcnJvd2Rvd246IDQwLFxuICBpbnNlcnQ6IDQ1LFxuICBkZWxldGU6IDQ2LFxuICBtZXRhOiA5MSxcbiAgbnVtbG9jazogMTQ0LFxuICBzY3JvbGxsb2NrOiAxNDUsXG4gICc7JzogMTg2LFxuICAnPSc6IDE4NyxcbiAgJywnOiAxODgsXG4gICctJzogMTg5LFxuICAnLic6IDE5MCxcbiAgJy8nOiAxOTEsXG4gICdgJzogMTkyLFxuICAnWyc6IDIxOSxcbiAgJ1xcXFwnOiAyMjAsXG4gICddJzogMjIxLFxuICAnXFwnJzogMjIyXG59O1xuXG5mb3IgKHZhciBmID0gMTsgZiA8IDIwOyBmKyspIHtcbiAgQ09ERVNbJ2YnICsgZl0gPSAxMTEgKyBmO1xufVxuXG4vKipcbiAqIElzIGhvdGtleT9cbiAqL1xuXG5mdW5jdGlvbiBpc0hvdGtleShob3RrZXksIG9wdGlvbnMsIGV2ZW50KSB7XG4gIGlmIChvcHRpb25zICYmICEoJ2J5S2V5JyBpbiBvcHRpb25zKSkge1xuICAgIGV2ZW50ID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShob3RrZXkpKSB7XG4gICAgaG90a2V5ID0gW2hvdGtleV07XG4gIH1cblxuICB2YXIgYXJyYXkgPSBob3RrZXkubWFwKGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICByZXR1cm4gcGFyc2VIb3RrZXkoc3RyaW5nLCBvcHRpb25zKTtcbiAgfSk7XG4gIHZhciBjaGVjayA9IGZ1bmN0aW9uIGNoZWNrKGUpIHtcbiAgICByZXR1cm4gYXJyYXkuc29tZShmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICByZXR1cm4gY29tcGFyZUhvdGtleShvYmplY3QsIGUpO1xuICAgIH0pO1xuICB9O1xuICB2YXIgcmV0ID0gZXZlbnQgPT0gbnVsbCA/IGNoZWNrIDogY2hlY2soZXZlbnQpO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpc0NvZGVIb3RrZXkoaG90a2V5LCBldmVudCkge1xuICByZXR1cm4gaXNIb3RrZXkoaG90a2V5LCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIGlzS2V5SG90a2V5KGhvdGtleSwgZXZlbnQpIHtcbiAgcmV0dXJuIGlzSG90a2V5KGhvdGtleSwgeyBieUtleTogdHJ1ZSB9LCBldmVudCk7XG59XG5cbi8qKlxuICogUGFyc2UuXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VIb3RrZXkoaG90a2V5LCBvcHRpb25zKSB7XG4gIHZhciBieUtleSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5ieUtleTtcbiAgdmFyIHJldCA9IHt9O1xuXG4gIC8vIFNwZWNpYWwgY2FzZSB0byBoYW5kbGUgdGhlIGArYCBrZXkgc2luY2Ugd2UgdXNlIGl0IGFzIGEgc2VwYXJhdG9yLlxuICBob3RrZXkgPSBob3RrZXkucmVwbGFjZSgnKysnLCAnK2FkZCcpO1xuICB2YXIgdmFsdWVzID0gaG90a2V5LnNwbGl0KCcrJyk7XG4gIHZhciBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIC8vIEVuc3VyZSB0aGF0IGFsbCB0aGUgbW9kaWZpZXJzIGFyZSBzZXQgdG8gZmFsc2UgdW5sZXNzIHRoZSBob3RrZXkgaGFzIHRoZW0uXG5cbiAgZm9yICh2YXIgayBpbiBNT0RJRklFUlMpIHtcbiAgICByZXRbTU9ESUZJRVJTW2tdXSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdmFsdWVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgdmFyIHZhbHVlID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIHZhciBvcHRpb25hbCA9IHZhbHVlLmVuZHNXaXRoKCc/JykgJiYgdmFsdWUubGVuZ3RoID4gMTtcblxuICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IHRvS2V5TmFtZSh2YWx1ZSk7XG4gICAgICB2YXIgbW9kaWZpZXIgPSBNT0RJRklFUlNbbmFtZV07XG5cbiAgICAgIGlmIChsZW5ndGggPT09IDEgfHwgIW1vZGlmaWVyKSB7XG4gICAgICAgIGlmIChieUtleSkge1xuICAgICAgICAgIHJldC5rZXkgPSBuYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldC53aGljaCA9IHRvS2V5Q29kZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGlmaWVyKSB7XG4gICAgICAgIHJldFttb2RpZmllcl0gPSBvcHRpb25hbCA/IG51bGwgOiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIENvbXBhcmUuXG4gKi9cblxuZnVuY3Rpb24gY29tcGFyZUhvdGtleShvYmplY3QsIGV2ZW50KSB7XG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICB2YXIgZXhwZWN0ZWQgPSBvYmplY3Rba2V5XTtcbiAgICB2YXIgYWN0dWFsID0gdm9pZCAwO1xuXG4gICAgaWYgKGV4cGVjdGVkID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICdrZXknICYmIGV2ZW50LmtleSAhPSBudWxsKSB7XG4gICAgICBhY3R1YWwgPSBldmVudC5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3doaWNoJykge1xuICAgICAgYWN0dWFsID0gZXhwZWN0ZWQgPT09IDkxICYmIGV2ZW50LndoaWNoID09PSA5MyA/IDkxIDogZXZlbnQud2hpY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjdHVhbCA9IGV2ZW50W2tleV07XG4gICAgfVxuXG4gICAgaWYgKGFjdHVhbCA9PSBudWxsICYmIGV4cGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBVdGlscy5cbiAqL1xuXG5mdW5jdGlvbiB0b0tleUNvZGUobmFtZSkge1xuICBuYW1lID0gdG9LZXlOYW1lKG5hbWUpO1xuICB2YXIgY29kZSA9IENPREVTW25hbWVdIHx8IG5hbWUudG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gY29kZTtcbn1cblxuZnVuY3Rpb24gdG9LZXlOYW1lKG5hbWUpIHtcbiAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgbmFtZSA9IEFMSUFTRVNbbmFtZV0gfHwgbmFtZTtcbiAgcmV0dXJuIG5hbWU7XG59XG5cbi8qKlxuICogRXhwb3J0LlxuICovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IGlzSG90a2V5O1xuZXhwb3J0cy5pc0hvdGtleSA9IGlzSG90a2V5O1xuZXhwb3J0cy5pc0NvZGVIb3RrZXkgPSBpc0NvZGVIb3RrZXk7XG5leHBvcnRzLmlzS2V5SG90a2V5ID0gaXNLZXlIb3RrZXk7XG5leHBvcnRzLnBhcnNlSG90a2V5ID0gcGFyc2VIb3RrZXk7XG5leHBvcnRzLmNvbXBhcmVIb3RrZXkgPSBjb21wYXJlSG90a2V5O1xuZXhwb3J0cy50b0tleUNvZGUgPSB0b0tleUNvZGU7XG5leHBvcnRzLnRvS2V5TmFtZSA9IHRvS2V5TmFtZTsiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIG5vdyA9IHJlcXVpcmUoJy4vbm93JyksXG4gICAgdG9OdW1iZXIgPSByZXF1aXJlKCcuL3RvTnVtYmVyJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gKiBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxuICogfSkpO1xuICpcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxhc3RBcmdzLFxuICAgICAgbGFzdFRoaXMsXG4gICAgICBtYXhXYWl0LFxuICAgICAgcmVzdWx0LFxuICAgICAgdGltZXJJZCxcbiAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICB0aW1lV2FpdGluZyA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmdcbiAgICAgID8gbmF0aXZlTWluKHRpbWVXYWl0aW5nLCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSlcbiAgICAgIDogdGltZVdhaXRpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYm91bmNlO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBEYXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAqIH0sIF8ubm93KCkpO1xuICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAqL1xudmFyIG5vdyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBub3c7XG4iLCJ2YXIgZGVib3VuY2UgPSByZXF1aXJlKCcuL2RlYm91bmNlJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxuICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICpcbiAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxuICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICdsZWFkaW5nJzogbGVhZGluZyxcbiAgICAnbWF4V2FpdCc6IHdhaXQsXG4gICAgJ3RyYWlsaW5nJzogdHJhaWxpbmdcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGhyb3R0bGU7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlcjtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJpbXBvcnQgY29tcHV0ZSBmcm9tICdjb21wdXRlLXNjcm9sbC1pbnRvLXZpZXcnO1xuXG5mdW5jdGlvbiBpc09wdGlvbnNPYmplY3Qob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucyA9PT0gT2JqZWN0KG9wdGlvbnMpICYmIE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCAhPT0gMDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEJlaGF2aW9yKGFjdGlvbnMsIGJlaGF2aW9yKSB7XG4gIGlmIChiZWhhdmlvciA9PT0gdm9pZCAwKSB7XG4gICAgYmVoYXZpb3IgPSAnYXV0byc7XG4gIH1cblxuICB2YXIgY2FuU21vb3RoU2Nyb2xsID0gKCdzY3JvbGxCZWhhdmlvcicgaW4gZG9jdW1lbnQuYm9keS5zdHlsZSk7XG4gIGFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBlbCA9IF9yZWYuZWwsXG4gICAgICAgIHRvcCA9IF9yZWYudG9wLFxuICAgICAgICBsZWZ0ID0gX3JlZi5sZWZ0O1xuXG4gICAgaWYgKGVsLnNjcm9sbCAmJiBjYW5TbW9vdGhTY3JvbGwpIHtcbiAgICAgIGVsLnNjcm9sbCh7XG4gICAgICAgIHRvcDogdG9wLFxuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICBiZWhhdmlvcjogYmVoYXZpb3JcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zY3JvbGxUb3AgPSB0b3A7XG4gICAgICBlbC5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJsb2NrOiAnZW5kJyxcbiAgICAgIGlubGluZTogJ25lYXJlc3QnXG4gICAgfTtcbiAgfVxuXG4gIGlmIChpc09wdGlvbnNPYmplY3Qob3B0aW9ucykpIHtcbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmxvY2s6ICdzdGFydCcsXG4gICAgaW5saW5lOiAnbmVhcmVzdCdcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcodGFyZ2V0LCBvcHRpb25zKSB7XG4gIHZhciB0YXJnZXRJc0RldGFjaGVkID0gIXRhcmdldC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyh0YXJnZXQpO1xuXG4gIGlmIChpc09wdGlvbnNPYmplY3Qob3B0aW9ucykgJiYgdHlwZW9mIG9wdGlvbnMuYmVoYXZpb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5iZWhhdmlvcih0YXJnZXRJc0RldGFjaGVkID8gW10gOiBjb21wdXRlKHRhcmdldCwgb3B0aW9ucykpO1xuICB9XG5cbiAgaWYgKHRhcmdldElzRGV0YWNoZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29tcHV0ZU9wdGlvbnMgPSBnZXRPcHRpb25zKG9wdGlvbnMpO1xuICByZXR1cm4gZGVmYXVsdEJlaGF2aW9yKGNvbXB1dGUodGFyZ2V0LCBjb21wdXRlT3B0aW9ucyksIGNvbXB1dGVPcHRpb25zLmJlaGF2aW9yKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2Nyb2xsSW50b1ZpZXc7IiwiaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VNZW1vLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEVkaXRvciwgVHJhbnNmb3JtcywgUmFuZ2UsIFBhdGgsIE5vZGUgYXMgTm9kZSQxLCBUZXh0IGFzIFRleHQkMSwgRWxlbWVudCBhcyBFbGVtZW50JDEgfSBmcm9tICdzbGF0ZSc7XG5pbXBvcnQgdGhyb3R0bGUgZnJvbSAnbG9kYXNoL3Rocm90dGxlJztcbmltcG9ydCBzY3JvbGxJbnRvVmlldyBmcm9tICdzY3JvbGwtaW50by12aWV3LWlmLW5lZWRlZCc7XG5pbXBvcnQgZ2V0RGlyZWN0aW9uIGZyb20gJ2RpcmVjdGlvbic7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IGlzS2V5SG90a2V5IH0gZnJvbSAnaXMtaG90a2V5JztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcclxuICogQW4gYXV0by1pbmNyZW1lbnRpbmcgaWRlbnRpZmllciBmb3Iga2V5cy5cclxuICovXG52YXIgbiA9IDA7XG4vKipcclxuICogQSBjbGFzcyB0aGF0IGtlZXBzIHRyYWNrIG9mIGEga2V5IHN0cmluZy4gV2UgdXNlIGEgZnVsbCBjbGFzcyBoZXJlIGJlY2F1c2Ugd2VcclxuICogd2FudCB0byBiZSBhYmxlIHRvIHVzZSB0aGVtIGFzIGtleXMgaW4gYFdlYWtNYXBgIG9iamVjdHMuXHJcbiAqL1xuXG5jbGFzcyBLZXkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmlkID0gXCJcIi5jb25jYXQobisrKTtcbiAgfVxuXG59XG5cbi8qKlxyXG4gKiBUd28gd2VhayBtYXBzIHRoYXQgYWxsb3cgdXMgcmVidWlsZCBhIHBhdGggZ2l2ZW4gYSBub2RlLiBUaGV5IGFyZSBwb3B1bGF0ZWRcclxuICogYXQgcmVuZGVyIHRpbWUgc3VjaCB0aGF0IGFmdGVyIGEgcmVuZGVyIG9jY3VycyB3ZSBjYW4gYWx3YXlzIGJhY2t0cmFjay5cclxuICovXG52YXIgTk9ERV9UT19JTkRFWCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTk9ERV9UT19QQVJFTlQgPSBuZXcgV2Vha01hcCgpO1xuLyoqXHJcbiAqIFdlYWsgbWFwcyB0aGF0IGFsbG93IHVzIHRvIGdvIGJldHdlZW4gU2xhdGUgbm9kZXMgYW5kIERPTSBub2Rlcy4gVGhlc2VcclxuICogYXJlIHVzZWQgdG8gcmVzb2x2ZSBET00gZXZlbnQtcmVsYXRlZCBsb2dpYyBpbnRvIFNsYXRlIGFjdGlvbnMuXHJcbiAqL1xuXG52YXIgRURJVE9SX1RPX0VMRU1FTlQgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVMRU1FTlRfVE9fTk9ERSA9IG5ldyBXZWFrTWFwKCk7XG52YXIgS0VZX1RPX0VMRU1FTlQgPSBuZXcgV2Vha01hcCgpO1xudmFyIE5PREVfVE9fRUxFTUVOVCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTk9ERV9UT19LRVkgPSBuZXcgV2Vha01hcCgpO1xuLyoqXHJcbiAqIFdlYWsgbWFwcyBmb3Igc3RvcmluZyBlZGl0b3ItcmVsYXRlZCBzdGF0ZS5cclxuICovXG5cbnZhciBJU19SRUFEX09OTFkgPSBuZXcgV2Vha01hcCgpO1xudmFyIElTX0ZPQ1VTRUQgPSBuZXcgV2Vha01hcCgpO1xuLyoqXHJcbiAqIFdlYWsgbWFwIGZvciBhc3NvY2lhdGluZyB0aGUgY29udGV4dCBgb25DaGFuZ2VgIGNvbnRleHQgd2l0aCB0aGUgcGx1Z2luLlxyXG4gKi9cblxudmFyIEVESVRPUl9UT19PTl9DSEFOR0UgPSBuZXcgV2Vha01hcCgpO1xuLyoqXHJcbiAqIFN5bWJvbHMuXHJcbiAqL1xuXG52YXIgUExBQ0VIT0xERVJfU1lNQk9MID0gU3ltYm9sKCdwbGFjZWhvbGRlcicpO1xuXG4vKipcclxuICogVHlwZXMuXHJcbiAqL1xuLyoqXHJcbiAqIENoZWNrIGlmIGEgRE9NIG5vZGUgaXMgYSBjb21tZW50IG5vZGUuXHJcbiAqL1xuXG52YXIgaXNET01Db21tZW50ID0gdmFsdWUgPT4ge1xuICByZXR1cm4gaXNET01Ob2RlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gODtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSBET00gbm9kZSBpcyBhbiBlbGVtZW50IG5vZGUuXHJcbiAqL1xuXG52YXIgaXNET01FbGVtZW50ID0gdmFsdWUgPT4ge1xuICByZXR1cm4gaXNET01Ob2RlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMTtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIERPTSBub2RlLlxyXG4gKi9cblxudmFyIGlzRE9NTm9kZSA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTm9kZTtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSBET00gbm9kZSBpcyBhbiBlbGVtZW50IG5vZGUuXHJcbiAqL1xuXG52YXIgaXNET01UZXh0ID0gdmFsdWUgPT4ge1xuICByZXR1cm4gaXNET01Ob2RlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMztcbn07XG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgYSBwYXN0ZSBldmVudCBpcyBhIHBsYWludGV4dC1vbmx5IGV2ZW50LlxyXG4gKi9cblxudmFyIGlzUGxhaW5UZXh0T25seVBhc3RlID0gZXZlbnQgPT4ge1xuICByZXR1cm4gZXZlbnQuY2xpcGJvYXJkRGF0YSAmJiBldmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKSAhPT0gJycgJiYgZXZlbnQuY2xpcGJvYXJkRGF0YS50eXBlcy5sZW5ndGggPT09IDE7XG59O1xuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhIERPTSBwb2ludCBzbyB0aGF0IGl0IGFsd2F5cyByZWZlcnMgdG8gYSB0ZXh0IG5vZGUuXHJcbiAqL1xuXG52YXIgbm9ybWFsaXplRE9NUG9pbnQgPSBkb21Qb2ludCA9PiB7XG4gIHZhciBbbm9kZSwgb2Zmc2V0XSA9IGRvbVBvaW50OyAvLyBJZiBpdCdzIGFuIGVsZW1lbnQgbm9kZSwgaXRzIG9mZnNldCByZWZlcnMgdG8gdGhlIGluZGV4IG9mIGl0cyBjaGlsZHJlblxuICAvLyBpbmNsdWRpbmcgY29tbWVudCBub2Rlcywgc28gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IHRleHQgY2hpbGQgbm9kZS5cblxuICBpZiAoaXNET01FbGVtZW50KG5vZGUpICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICB2YXIgaXNMYXN0ID0gb2Zmc2V0ID09PSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIHZhciBkaXJlY3Rpb24gPSBpc0xhc3QgPyAnYmFja3dhcmQnIDogJ2ZvcndhcmQnO1xuICAgIHZhciBpbmRleCA9IGlzTGFzdCA/IG9mZnNldCAtIDEgOiBvZmZzZXQ7XG4gICAgbm9kZSA9IGdldEVkaXRhYmxlQ2hpbGQobm9kZSwgaW5kZXgsIGRpcmVjdGlvbik7IC8vIElmIHRoZSBub2RlIGhhcyBjaGlsZHJlbiwgdHJhdmVyc2UgdW50aWwgd2UgaGF2ZSBhIGxlYWYgbm9kZS4gTGVhZiBub2Rlc1xuICAgIC8vIGNhbiBiZSBlaXRoZXIgdGV4dCBub2Rlcywgb3Igb3RoZXIgdm9pZCBET00gbm9kZXMuXG5cbiAgICB3aGlsZSAoaXNET01FbGVtZW50KG5vZGUpICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHZhciBpID0gaXNMYXN0ID8gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDEgOiAwO1xuICAgICAgbm9kZSA9IGdldEVkaXRhYmxlQ2hpbGQobm9kZSwgaSwgZGlyZWN0aW9uKTtcbiAgICB9IC8vIERldGVybWluZSB0aGUgbmV3IG9mZnNldCBpbnNpZGUgdGhlIHRleHQgbm9kZS5cblxuXG4gICAgb2Zmc2V0ID0gaXNMYXN0ICYmIG5vZGUudGV4dENvbnRlbnQgIT0gbnVsbCA/IG5vZGUudGV4dENvbnRlbnQubGVuZ3RoIDogMDtcbiAgfSAvLyBSZXR1cm4gdGhlIG5vZGUgYW5kIG9mZnNldC5cblxuXG4gIHJldHVybiBbbm9kZSwgb2Zmc2V0XTtcbn07XG4vKipcclxuICogR2V0IHRoZSBuZWFyZXN0IGVkaXRhYmxlIGNoaWxkIGF0IGBpbmRleGAgaW4gYSBgcGFyZW50YCwgcHJlZmVycmluZ1xyXG4gKiBgZGlyZWN0aW9uYC5cclxuICovXG5cbnZhciBnZXRFZGl0YWJsZUNoaWxkID0gKHBhcmVudCwgaW5kZXgsIGRpcmVjdGlvbikgPT4ge1xuICB2YXIge1xuICAgIGNoaWxkTm9kZXNcbiAgfSA9IHBhcmVudDtcbiAgdmFyIGNoaWxkID0gY2hpbGROb2Rlc1tpbmRleF07XG4gIHZhciBpID0gaW5kZXg7XG4gIHZhciB0cmllZEZvcndhcmQgPSBmYWxzZTtcbiAgdmFyIHRyaWVkQmFja3dhcmQgPSBmYWxzZTsgLy8gV2hpbGUgdGhlIGNoaWxkIGlzIGEgY29tbWVudCBub2RlLCBvciBhbiBlbGVtZW50IG5vZGUgd2l0aCBubyBjaGlsZHJlbixcbiAgLy8ga2VlcCBpdGVyYXRpbmcgdG8gZmluZCBhIHNpYmxpbmcgbm9uLXZvaWQsIG5vbi1jb21tZW50IG5vZGUuXG5cbiAgd2hpbGUgKGlzRE9NQ29tbWVudChjaGlsZCkgfHwgaXNET01FbGVtZW50KGNoaWxkKSAmJiBjaGlsZC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCB8fCBpc0RPTUVsZW1lbnQoY2hpbGQpICYmIGNoaWxkLmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgPT09ICdmYWxzZScpIHtcbiAgICBpZiAodHJpZWRGb3J3YXJkICYmIHRyaWVkQmFja3dhcmQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChpID49IGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICB0cmllZEZvcndhcmQgPSB0cnVlO1xuICAgICAgaSA9IGluZGV4IC0gMTtcbiAgICAgIGRpcmVjdGlvbiA9ICdiYWNrd2FyZCc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIHRyaWVkQmFja3dhcmQgPSB0cnVlO1xuICAgICAgaSA9IGluZGV4ICsgMTtcbiAgICAgIGRpcmVjdGlvbiA9ICdmb3J3YXJkJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNoaWxkID0gY2hpbGROb2Rlc1tpXTtcbiAgICBpICs9IGRpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnID8gMSA6IC0xO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkO1xufTtcbi8qKlxyXG4gKiBHZXQgYSBwbGFpbnRleHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbnRlbnQgb2YgYSBub2RlLCBhY2NvdW50aW5nIGZvciBibG9ja1xyXG4gKiBlbGVtZW50cyB3aGljaCBnZXQgYSBuZXdsaW5lIGFwcGVuZGVkLlxyXG4gKlxyXG4gKiBUaGUgZG9tTm9kZSBtdXN0IGJlIGF0dGFjaGVkIHRvIHRoZSBET00uXHJcbiAqL1xuXG52YXIgZ2V0UGxhaW5UZXh0ID0gZG9tTm9kZSA9PiB7XG4gIHZhciB0ZXh0ID0gJyc7XG5cbiAgaWYgKGlzRE9NVGV4dChkb21Ob2RlKSAmJiBkb21Ob2RlLm5vZGVWYWx1ZSkge1xuICAgIHJldHVybiBkb21Ob2RlLm5vZGVWYWx1ZTtcbiAgfVxuXG4gIGlmIChpc0RPTUVsZW1lbnQoZG9tTm9kZSkpIHtcbiAgICBmb3IgKHZhciBjaGlsZE5vZGUgb2YgQXJyYXkuZnJvbShkb21Ob2RlLmNoaWxkTm9kZXMpKSB7XG4gICAgICB0ZXh0ICs9IGdldFBsYWluVGV4dChjaGlsZE5vZGUpO1xuICAgIH1cblxuICAgIHZhciBkaXNwbGF5ID0gZ2V0Q29tcHV0ZWRTdHlsZShkb21Ob2RlKS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXNwbGF5Jyk7XG5cbiAgICBpZiAoZGlzcGxheSA9PT0gJ2Jsb2NrJyB8fCBkaXNwbGF5ID09PSAnbGlzdCcgfHwgZG9tTm9kZS50YWdOYW1lID09PSAnQlInKSB7XG4gICAgICB0ZXh0ICs9ICdcXG4nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0ZXh0O1xufTtcblxudmFyIFJlYWN0RWRpdG9yID0ge1xuICAvKipcclxuICAgKiBGaW5kIGEga2V5IGZvciBhIFNsYXRlIG5vZGUuXHJcbiAgICovXG4gIGZpbmRLZXkoZWRpdG9yLCBub2RlKSB7XG4gICAgdmFyIGtleSA9IE5PREVfVE9fS0VZLmdldChub2RlKTtcblxuICAgIGlmICgha2V5KSB7XG4gICAgICBrZXkgPSBuZXcgS2V5KCk7XG4gICAgICBOT0RFX1RPX0tFWS5zZXQobm9kZSwga2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEZpbmQgdGhlIHBhdGggb2YgU2xhdGUgbm9kZS5cclxuICAgKi9cbiAgZmluZFBhdGgoZWRpdG9yLCBub2RlKSB7XG4gICAgdmFyIHBhdGggPSBbXTtcbiAgICB2YXIgY2hpbGQgPSBub2RlO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBOT0RFX1RPX1BBUkVOVC5nZXQoY2hpbGQpO1xuXG4gICAgICBpZiAocGFyZW50ID09IG51bGwpIHtcbiAgICAgICAgaWYgKEVkaXRvci5pc0VkaXRvcihjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaSA9IE5PREVfVE9fSU5ERVguZ2V0KGNoaWxkKTtcblxuICAgICAgaWYgKGkgPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcGF0aC51bnNoaWZ0KGkpO1xuICAgICAgY2hpbGQgPSBwYXJlbnQ7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgdGhlIHBhdGggZm9yIFNsYXRlIG5vZGU6IFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShub2RlKSkpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSBlZGl0b3IgaXMgZm9jdXNlZC5cclxuICAgKi9cbiAgaXNGb2N1c2VkKGVkaXRvcikge1xuICAgIHJldHVybiAhIUlTX0ZPQ1VTRUQuZ2V0KGVkaXRvcik7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIGVkaXRvciBpcyBpbiByZWFkLW9ubHkgbW9kZS5cclxuICAgKi9cbiAgaXNSZWFkT25seShlZGl0b3IpIHtcbiAgICByZXR1cm4gISFJU19SRUFEX09OTFkuZ2V0KGVkaXRvcik7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQmx1ciB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBibHVyKGVkaXRvcikge1xuICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgSVNfRk9DVVNFRC5zZXQoZWRpdG9yLCBmYWxzZSk7XG5cbiAgICBpZiAod2luZG93LmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsKSB7XG4gICAgICBlbC5ibHVyKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIEZvY3VzIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIGZvY3VzKGVkaXRvcikge1xuICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgSVNfRk9DVVNFRC5zZXQoZWRpdG9yLCB0cnVlKTtcblxuICAgIGlmICh3aW5kb3cuZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWwpIHtcbiAgICAgIGVsLmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIERlc2VsZWN0IHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIGRlc2VsZWN0KGVkaXRvcikge1xuICAgIHZhciB7XG4gICAgICBzZWxlY3Rpb25cbiAgICB9ID0gZWRpdG9yO1xuICAgIHZhciBkb21TZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoZG9tU2VsZWN0aW9uICYmIGRvbVNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkge1xuICAgICAgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIH1cblxuICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgIFRyYW5zZm9ybXMuZGVzZWxlY3QoZWRpdG9yKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBET00gbm9kZSBpcyB3aXRoaW4gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgaGFzRE9NTm9kZShlZGl0b3IsIHRhcmdldCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgZWRpdGFibGUgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBlZGl0b3JFbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgdmFyIHRhcmdldEVsOyAvLyBDT01QQVQ6IEluIEZpcmVmb3gsIHJlYWRpbmcgYHRhcmdldC5ub2RlVHlwZWAgd2lsbCB0aHJvdyBhbiBlcnJvciBpZlxuICAgIC8vIHRhcmdldCBpcyBvcmlnaW5hdGluZyBmcm9tIGFuIGludGVybmFsIFwicmVzdHJpY3RlZFwiIGVsZW1lbnQgKGUuZy4gYVxuICAgIC8vIHN0ZXBwZXIgYXJyb3cgb24gYSBudW1iZXIgaW5wdXQpLiAoMjAxOC8wNS8wNClcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaWFuc3Rvcm10YXlsb3Ivc2xhdGUvaXNzdWVzLzE4MTlcblxuICAgIHRyeSB7XG4gICAgICB0YXJnZXRFbCA9IGlzRE9NRWxlbWVudCh0YXJnZXQpID8gdGFyZ2V0IDogdGFyZ2V0LnBhcmVudEVsZW1lbnQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIWVyci5tZXNzYWdlLmluY2x1ZGVzKCdQZXJtaXNzaW9uIGRlbmllZCB0byBhY2Nlc3MgcHJvcGVydHkgXCJub2RlVHlwZVwiJykpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGFyZ2V0RWwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0RWwuY2xvc2VzdChcIltkYXRhLXNsYXRlLWVkaXRvcl1cIikgPT09IGVkaXRvckVsICYmICghZWRpdGFibGUgfHwgdGFyZ2V0RWwuaXNDb250ZW50RWRpdGFibGUgfHwgISF0YXJnZXRFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgZGF0YSBmcm9tIGEgYERhdGFUcmFuc2ZlcmAgaW50byB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBpbnNlcnREYXRhKGVkaXRvciwgZGF0YSkge1xuICAgIGVkaXRvci5pbnNlcnREYXRhKGRhdGEpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNldHMgZGF0YSBmcm9tIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZnJhZ21lbnQgb24gYSBgRGF0YVRyYW5zZmVyYC5cclxuICAgKi9cbiAgc2V0RnJhZ21lbnREYXRhKGVkaXRvciwgZGF0YSkge1xuICAgIGVkaXRvci5zZXRGcmFnbWVudERhdGEoZGF0YSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRmluZCB0aGUgbmF0aXZlIERPTSBlbGVtZW50IGZyb20gYSBTbGF0ZSBub2RlLlxyXG4gICAqL1xuICB0b0RPTU5vZGUoZWRpdG9yLCBub2RlKSB7XG4gICAgdmFyIGRvbU5vZGUgPSBFZGl0b3IuaXNFZGl0b3Iobm9kZSkgPyBFRElUT1JfVE9fRUxFTUVOVC5nZXQoZWRpdG9yKSA6IEtFWV9UT19FTEVNRU5ULmdldChSZWFjdEVkaXRvci5maW5kS2V5KGVkaXRvciwgbm9kZSkpO1xuXG4gICAgaWYgKCFkb21Ob2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIERPTSBub2RlIGZyb20gU2xhdGUgbm9kZTogXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvbU5vZGU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRmluZCBhIG5hdGl2ZSBET00gc2VsZWN0aW9uIHBvaW50IGZyb20gYSBTbGF0ZSBwb2ludC5cclxuICAgKi9cbiAgdG9ET01Qb2ludChlZGl0b3IsIHBvaW50KSB7XG4gICAgdmFyIFtub2RlXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcG9pbnQucGF0aCk7XG4gICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgbm9kZSk7XG4gICAgdmFyIGRvbVBvaW50OyAvLyBJZiB3ZSdyZSBpbnNpZGUgYSB2b2lkIG5vZGUsIGZvcmNlIHRoZSBvZmZzZXQgdG8gMCwgb3RoZXJ3aXNlIHRoZSB6ZXJvXG4gICAgLy8gd2lkdGggc3BhY2luZyBjaGFyYWN0ZXIgd2lsbCByZXN1bHQgaW4gYW4gaW5jb3JyZWN0IG9mZnNldCBvZiAxXG5cbiAgICBpZiAoRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICBhdDogcG9pbnRcbiAgICB9KSkge1xuICAgICAgcG9pbnQgPSB7XG4gICAgICAgIHBhdGg6IHBvaW50LnBhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfTtcbiAgICB9IC8vIEZvciBlYWNoIGxlYWYsIHdlIG5lZWQgdG8gaXNvbGF0ZSBpdHMgY29udGVudCwgd2hpY2ggbWVhbnMgZmlsdGVyaW5nXG4gICAgLy8gdG8gaXRzIGRpcmVjdCB0ZXh0IGFuZCB6ZXJvLXdpZHRoIHNwYW5zLiAoV2UgaGF2ZSB0byBmaWx0ZXIgb3V0IGFueVxuICAgIC8vIG90aGVyIHNpYmxpbmdzIHRoYXQgbWF5IGhhdmUgYmVlbiByZW5kZXJlZCBhbG9uZ3NpZGUgdGhlbS4pXG5cblxuICAgIHZhciBzZWxlY3RvciA9IFwiW2RhdGEtc2xhdGUtc3RyaW5nXSwgW2RhdGEtc2xhdGUtemVyby13aWR0aF1cIjtcbiAgICB2YXIgdGV4dHMgPSBBcnJheS5mcm9tKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgICB2YXIgc3RhcnQgPSAwO1xuXG4gICAgZm9yICh2YXIgdGV4dCBvZiB0ZXh0cykge1xuICAgICAgdmFyIGRvbU5vZGUgPSB0ZXh0LmNoaWxkTm9kZXNbMF07XG5cbiAgICAgIGlmIChkb21Ob2RlID09IG51bGwgfHwgZG9tTm9kZS50ZXh0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIge1xuICAgICAgICBsZW5ndGhcbiAgICAgIH0gPSBkb21Ob2RlLnRleHRDb250ZW50O1xuICAgICAgdmFyIGF0dHIgPSB0ZXh0LmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1sZW5ndGgnKTtcbiAgICAgIHZhciB0cnVlTGVuZ3RoID0gYXR0ciA9PSBudWxsID8gbGVuZ3RoIDogcGFyc2VJbnQoYXR0ciwgMTApO1xuICAgICAgdmFyIGVuZCA9IHN0YXJ0ICsgdHJ1ZUxlbmd0aDtcblxuICAgICAgaWYgKHBvaW50Lm9mZnNldCA8PSBlbmQpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IE1hdGgubWluKGxlbmd0aCwgTWF0aC5tYXgoMCwgcG9pbnQub2Zmc2V0IC0gc3RhcnQpKTtcbiAgICAgICAgZG9tUG9pbnQgPSBbZG9tTm9kZSwgb2Zmc2V0XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0ID0gZW5kO1xuICAgIH1cblxuICAgIGlmICghZG9tUG9pbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgRE9NIHBvaW50IGZyb20gU2xhdGUgcG9pbnQ6IFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShwb2ludCkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9tUG9pbnQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRmluZCBhIG5hdGl2ZSBET00gcmFuZ2UgZnJvbSBhIFNsYXRlIGByYW5nZWAuXHJcbiAgICovXG4gIHRvRE9NUmFuZ2UoZWRpdG9yLCByYW5nZSkge1xuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSByYW5nZTtcbiAgICB2YXIgaXNCYWNrd2FyZCA9IFJhbmdlLmlzQmFja3dhcmQocmFuZ2UpO1xuICAgIHZhciBkb21BbmNob3IgPSBSZWFjdEVkaXRvci50b0RPTVBvaW50KGVkaXRvciwgYW5jaG9yKTtcbiAgICB2YXIgZG9tRm9jdXMgPSBSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkgPyBkb21BbmNob3IgOiBSZWFjdEVkaXRvci50b0RPTVBvaW50KGVkaXRvciwgZm9jdXMpO1xuICAgIHZhciBkb21SYW5nZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHZhciBbc3RhcnROb2RlLCBzdGFydE9mZnNldF0gPSBpc0JhY2t3YXJkID8gZG9tRm9jdXMgOiBkb21BbmNob3I7XG4gICAgdmFyIFtlbmROb2RlLCBlbmRPZmZzZXRdID0gaXNCYWNrd2FyZCA/IGRvbUFuY2hvciA6IGRvbUZvY3VzOyAvLyBBIHNsYXRlIFBvaW50IGF0IHplcm8td2lkdGggTGVhZiBhbHdheXMgaGFzIGFuIG9mZnNldCBvZiAwIGJ1dCBhIG5hdGl2ZSBET00gc2VsZWN0aW9uIGF0XG4gICAgLy8gemVyby13aWR0aCBub2RlIGhhcyBhbiBvZmZzZXQgb2YgMSBzbyB3ZSBoYXZlIHRvIGNoZWNrIGlmIHdlIGFyZSBpbiBhIHplcm8td2lkdGggbm9kZSBhbmRcbiAgICAvLyBhZGp1c3QgdGhlIG9mZnNldCBhY2NvcmRpbmdseS5cblxuICAgIHZhciBzdGFydEVsID0gaXNET01FbGVtZW50KHN0YXJ0Tm9kZSkgPyBzdGFydE5vZGUgOiBzdGFydE5vZGUucGFyZW50RWxlbWVudDtcbiAgICB2YXIgaXNTdGFydEF0WmVyb1dpZHRoID0gISFzdGFydEVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJyk7XG4gICAgdmFyIGVuZEVsID0gaXNET01FbGVtZW50KGVuZE5vZGUpID8gZW5kTm9kZSA6IGVuZE5vZGUucGFyZW50RWxlbWVudDtcbiAgICB2YXIgaXNFbmRBdFplcm9XaWR0aCA9ICEhZW5kRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKTtcbiAgICBkb21SYW5nZS5zZXRTdGFydChzdGFydE5vZGUsIGlzU3RhcnRBdFplcm9XaWR0aCA/IDEgOiBzdGFydE9mZnNldCk7XG4gICAgZG9tUmFuZ2Uuc2V0RW5kKGVuZE5vZGUsIGlzRW5kQXRaZXJvV2lkdGggPyAxIDogZW5kT2Zmc2V0KTtcbiAgICByZXR1cm4gZG9tUmFuZ2U7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRmluZCBhIFNsYXRlIG5vZGUgZnJvbSBhIG5hdGl2ZSBET00gYGVsZW1lbnRgLlxyXG4gICAqL1xuICB0b1NsYXRlTm9kZShlZGl0b3IsIGRvbU5vZGUpIHtcbiAgICB2YXIgZG9tRWwgPSBpc0RPTUVsZW1lbnQoZG9tTm9kZSkgPyBkb21Ob2RlIDogZG9tTm9kZS5wYXJlbnRFbGVtZW50O1xuXG4gICAgaWYgKGRvbUVsICYmICFkb21FbC5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtbm9kZScpKSB7XG4gICAgICBkb21FbCA9IGRvbUVsLmNsb3Nlc3QoXCJbZGF0YS1zbGF0ZS1ub2RlXVwiKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IGRvbUVsID8gRUxFTUVOVF9UT19OT0RFLmdldChkb21FbCkgOiBudWxsO1xuXG4gICAgaWYgKCFub2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIG5vZGUgZnJvbSBET00gbm9kZTogXCIuY29uY2F0KGRvbUVsKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSB0YXJnZXQgcmFuZ2UgZnJvbSBhIERPTSBgZXZlbnRgLlxyXG4gICAqL1xuICBmaW5kRXZlbnRSYW5nZShlZGl0b3IsIGV2ZW50KSB7XG4gICAgaWYgKCduYXRpdmVFdmVudCcgaW4gZXZlbnQpIHtcbiAgICAgIGV2ZW50ID0gZXZlbnQubmF0aXZlRXZlbnQ7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIGNsaWVudFg6IHgsXG4gICAgICBjbGllbnRZOiB5LFxuICAgICAgdGFyZ2V0XG4gICAgfSA9IGV2ZW50O1xuXG4gICAgaWYgKHggPT0gbnVsbCB8fCB5ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgU2xhdGUgcmFuZ2UgZnJvbSBhIERPTSBldmVudDogXCIuY29uY2F0KGV2ZW50KSk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBSZWFjdEVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIGV2ZW50LnRhcmdldCk7XG4gICAgdmFyIHBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIG5vZGUpOyAvLyBJZiB0aGUgZHJvcCB0YXJnZXQgaXMgaW5zaWRlIGEgdm9pZCBub2RlLCBtb3ZlIGl0IGludG8gZWl0aGVyIHRoZVxuICAgIC8vIG5leHQgb3IgcHJldmlvdXMgbm9kZSwgZGVwZW5kaW5nIG9uIHdoaWNoIHNpZGUgdGhlIGB4YCBhbmQgYHlgXG4gICAgLy8gY29vcmRpbmF0ZXMgYXJlIGNsb3Nlc3QgdG8uXG5cbiAgICBpZiAoRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICB2YXIgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBpc1ByZXYgPSBlZGl0b3IuaXNJbmxpbmUobm9kZSkgPyB4IC0gcmVjdC5sZWZ0IDwgcmVjdC5sZWZ0ICsgcmVjdC53aWR0aCAtIHggOiB5IC0gcmVjdC50b3AgPCByZWN0LnRvcCArIHJlY3QuaGVpZ2h0IC0geTtcbiAgICAgIHZhciBlZGdlID0gRWRpdG9yLnBvaW50KGVkaXRvciwgcGF0aCwge1xuICAgICAgICBlZGdlOiBpc1ByZXYgPyAnc3RhcnQnIDogJ2VuZCdcbiAgICAgIH0pO1xuICAgICAgdmFyIHBvaW50ID0gaXNQcmV2ID8gRWRpdG9yLmJlZm9yZShlZGl0b3IsIGVkZ2UpIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgZWRnZSk7XG5cbiAgICAgIGlmIChwb2ludCkge1xuICAgICAgICB2YXIgX3JhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9pbnQpO1xuXG4gICAgICAgIHJldHVybiBfcmFuZ2U7XG4gICAgICB9XG4gICAgfSAvLyBFbHNlIHJlc29sdmUgYSByYW5nZSBmcm9tIHRoZSBjYXJldCBwb3NpdGlvbiB3aGVyZSB0aGUgZHJvcCBvY2N1cmVkLlxuXG5cbiAgICB2YXIgZG9tUmFuZ2U7XG4gICAgdmFyIHtcbiAgICAgIGRvY3VtZW50XG4gICAgfSA9IHdpbmRvdzsgLy8gQ09NUEFUOiBJbiBGaXJlZm94LCBgY2FyZXRSYW5nZUZyb21Qb2ludGAgZG9lc24ndCBleGlzdC4gKDIwMTYvMDcvMjUpXG5cbiAgICBpZiAoZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludCkge1xuICAgICAgZG9tUmFuZ2UgPSBkb2N1bWVudC5jYXJldFJhbmdlRnJvbVBvaW50KHgsIHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSBkb2N1bWVudC5jYXJldFBvc2l0aW9uRnJvbVBvaW50KHgsIHkpO1xuXG4gICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgZG9tUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICBkb21SYW5nZS5zZXRTdGFydChwb3NpdGlvbi5vZmZzZXROb2RlLCBwb3NpdGlvbi5vZmZzZXQpO1xuICAgICAgICBkb21SYW5nZS5zZXRFbmQocG9zaXRpb24ub2Zmc2V0Tm9kZSwgcG9zaXRpb24ub2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWRvbVJhbmdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIHJhbmdlIGZyb20gYSBET00gZXZlbnQ6IFwiLmNvbmNhdChldmVudCkpO1xuICAgIH0gLy8gUmVzb2x2ZSBhIFNsYXRlIHJhbmdlIGZyb20gdGhlIERPTSByYW5nZS5cblxuXG4gICAgdmFyIHJhbmdlID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgZG9tUmFuZ2UpO1xuICAgIHJldHVybiByYW5nZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBGaW5kIGEgU2xhdGUgcG9pbnQgZnJvbSBhIERPTSBzZWxlY3Rpb24ncyBgZG9tTm9kZWAgYW5kIGBkb21PZmZzZXRgLlxyXG4gICAqL1xuICB0b1NsYXRlUG9pbnQoZWRpdG9yLCBkb21Qb2ludCkge1xuICAgIHZhciBbbmVhcmVzdE5vZGUsIG5lYXJlc3RPZmZzZXRdID0gbm9ybWFsaXplRE9NUG9pbnQoZG9tUG9pbnQpO1xuICAgIHZhciBwYXJlbnROb2RlID0gbmVhcmVzdE5vZGUucGFyZW50Tm9kZTtcbiAgICB2YXIgdGV4dE5vZGUgPSBudWxsO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuXG4gICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgIHZhciB2b2lkTm9kZSA9IHBhcmVudE5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtdm9pZD1cInRydWVcIl0nKTtcbiAgICAgIHZhciBsZWFmTm9kZSA9IHBhcmVudE5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtbGVhZl0nKTtcbiAgICAgIHZhciBkb21Ob2RlID0gbnVsbDsgLy8gQ2FsY3VsYXRlIGhvdyBmYXIgaW50byB0aGUgdGV4dCBub2RlIHRoZSBgbmVhcmVzdE5vZGVgIGlzLCBzbyB0aGF0IHdlXG4gICAgICAvLyBjYW4gZGV0ZXJtaW5lIHdoYXQgdGhlIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgdGV4dCBub2RlIGlzLlxuXG4gICAgICBpZiAobGVhZk5vZGUpIHtcbiAgICAgICAgdGV4dE5vZGUgPSBsZWFmTm9kZS5jbG9zZXN0KCdbZGF0YS1zbGF0ZS1ub2RlPVwidGV4dFwiXScpO1xuICAgICAgICB2YXIgcmFuZ2UgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQodGV4dE5vZGUsIDApO1xuICAgICAgICByYW5nZS5zZXRFbmQobmVhcmVzdE5vZGUsIG5lYXJlc3RPZmZzZXQpO1xuICAgICAgICB2YXIgY29udGVudHMgPSByYW5nZS5jbG9uZUNvbnRlbnRzKCk7XG4gICAgICAgIHZhciByZW1vdmFscyA9IFsuLi5jb250ZW50cy5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXScpLCAuLi5jb250ZW50cy5xdWVyeVNlbGVjdG9yQWxsKCdbY29udGVudGVkaXRhYmxlPWZhbHNlXScpXTtcbiAgICAgICAgcmVtb3ZhbHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgIH0pOyAvLyBDT01QQVQ6IEVkZ2UgaGFzIGEgYnVnIHdoZXJlIFJhbmdlLnByb3RvdHlwZS50b1N0cmluZygpIHdpbGxcbiAgICAgICAgLy8gY29udmVydCBcXG4gaW50byBcXHJcXG4uIFRoZSBidWcgY2F1c2VzIGEgbG9vcCB3aGVuIHNsYXRlLXJlYWN0XG4gICAgICAgIC8vIGF0dGVtcHRzIHRvIHJlcG9zaXRpb24gaXRzIGN1cnNvciB0byBtYXRjaCB0aGUgbmF0aXZlIHBvc2l0aW9uLiBVc2VcbiAgICAgICAgLy8gdGV4dENvbnRlbnQubGVuZ3RoIGluc3RlYWQuXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwMjkxMTE2L1xuXG4gICAgICAgIG9mZnNldCA9IGNvbnRlbnRzLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgICAgICAgZG9tTm9kZSA9IHRleHROb2RlO1xuICAgICAgfSBlbHNlIGlmICh2b2lkTm9kZSkge1xuICAgICAgICAvLyBGb3Igdm9pZCBub2RlcywgdGhlIGVsZW1lbnQgd2l0aCB0aGUgb2Zmc2V0IGtleSB3aWxsIGJlIGEgY291c2luLCBub3QgYW5cbiAgICAgICAgLy8gYW5jZXN0b3IsIHNvIGZpbmQgaXQgYnkgZ29pbmcgZG93biBmcm9tIHRoZSBuZWFyZXN0IHZvaWQgcGFyZW50LlxuICAgICAgICBsZWFmTm9kZSA9IHZvaWROb2RlLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXNsYXRlLWxlYWZdJyk7XG4gICAgICAgIHRleHROb2RlID0gbGVhZk5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtbm9kZT1cInRleHRcIl0nKTtcbiAgICAgICAgZG9tTm9kZSA9IGxlYWZOb2RlO1xuICAgICAgICBvZmZzZXQgPSBkb21Ob2RlLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgICAgIH0gLy8gQ09NUEFUOiBJZiB0aGUgcGFyZW50IG5vZGUgaXMgYSBTbGF0ZSB6ZXJvLXdpZHRoIHNwYWNlLCBlZGl0b3IgaXNcbiAgICAgIC8vIGJlY2F1c2UgdGhlIHRleHQgbm9kZSBzaG91bGQgaGF2ZSBubyBjaGFyYWN0ZXJzLiBIb3dldmVyLCBkdXJpbmcgSU1FXG4gICAgICAvLyBjb21wb3NpdGlvbiB0aGUgQVNDSUkgY2hhcmFjdGVycyB3aWxsIGJlIHByZXBlbmRlZCB0byB0aGUgemVyby13aWR0aFxuICAgICAgLy8gc3BhY2UsIHNvIHN1YnRyYWN0IDEgZnJvbSB0aGUgb2Zmc2V0IHRvIGFjY291bnQgZm9yIHRoZSB6ZXJvLXdpZHRoXG4gICAgICAvLyBzcGFjZSBjaGFyYWN0ZXIuXG5cblxuICAgICAgaWYgKGRvbU5vZGUgJiYgb2Zmc2V0ID09PSBkb21Ob2RlLnRleHRDb250ZW50Lmxlbmd0aCAmJiBwYXJlbnROb2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJykpIHtcbiAgICAgICAgb2Zmc2V0LS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0ZXh0Tm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBTbGF0ZSBwb2ludCBmcm9tIERPTSBwb2ludDogXCIuY29uY2F0KGRvbVBvaW50KSk7XG4gICAgfSAvLyBDT01QQVQ6IElmIHNvbWVvbmUgaXMgY2xpY2tpbmcgZnJvbSBvbmUgU2xhdGUgZWRpdG9yIGludG8gYW5vdGhlcixcbiAgICAvLyB0aGUgc2VsZWN0IGV2ZW50IGZpcmVzIHR3aWNlLCBvbmNlIGZvciB0aGUgb2xkIGVkaXRvcidzIGBlbGVtZW50YFxuICAgIC8vIGZpcnN0LCBhbmQgdGhlbiBhZnRlcndhcmRzIGZvciB0aGUgY29ycmVjdCBgZWxlbWVudGAuICgyMDE3LzAzLzAzKVxuXG5cbiAgICB2YXIgc2xhdGVOb2RlID0gUmVhY3RFZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCB0ZXh0Tm9kZSk7XG4gICAgdmFyIHBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIHNsYXRlTm9kZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGgsXG4gICAgICBvZmZzZXRcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEZpbmQgYSBTbGF0ZSByYW5nZSBmcm9tIGEgRE9NIHJhbmdlIG9yIHNlbGVjdGlvbi5cclxuICAgKi9cbiAgdG9TbGF0ZVJhbmdlKGVkaXRvciwgZG9tUmFuZ2UpIHtcbiAgICB2YXIgZWwgPSBkb21SYW5nZSBpbnN0YW5jZW9mIFNlbGVjdGlvbiA/IGRvbVJhbmdlLmFuY2hvck5vZGUgOiBkb21SYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICB2YXIgYW5jaG9yTm9kZTtcbiAgICB2YXIgYW5jaG9yT2Zmc2V0O1xuICAgIHZhciBmb2N1c05vZGU7XG4gICAgdmFyIGZvY3VzT2Zmc2V0O1xuICAgIHZhciBpc0NvbGxhcHNlZDtcblxuICAgIGlmIChlbCkge1xuICAgICAgaWYgKGRvbVJhbmdlIGluc3RhbmNlb2YgU2VsZWN0aW9uKSB7XG4gICAgICAgIGFuY2hvck5vZGUgPSBkb21SYW5nZS5hbmNob3JOb2RlO1xuICAgICAgICBhbmNob3JPZmZzZXQgPSBkb21SYW5nZS5hbmNob3JPZmZzZXQ7XG4gICAgICAgIGZvY3VzTm9kZSA9IGRvbVJhbmdlLmZvY3VzTm9kZTtcbiAgICAgICAgZm9jdXNPZmZzZXQgPSBkb21SYW5nZS5mb2N1c09mZnNldDtcbiAgICAgICAgaXNDb2xsYXBzZWQgPSBkb21SYW5nZS5pc0NvbGxhcHNlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuY2hvck5vZGUgPSBkb21SYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgYW5jaG9yT2Zmc2V0ID0gZG9tUmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgICAgIGZvY3VzTm9kZSA9IGRvbVJhbmdlLmVuZENvbnRhaW5lcjtcbiAgICAgICAgZm9jdXNPZmZzZXQgPSBkb21SYW5nZS5lbmRPZmZzZXQ7XG4gICAgICAgIGlzQ29sbGFwc2VkID0gZG9tUmFuZ2UuY29sbGFwc2VkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhbmNob3JOb2RlID09IG51bGwgfHwgZm9jdXNOb2RlID09IG51bGwgfHwgYW5jaG9yT2Zmc2V0ID09IG51bGwgfHwgZm9jdXNPZmZzZXQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBTbGF0ZSByYW5nZSBmcm9tIERPTSByYW5nZTogXCIuY29uY2F0KGRvbVJhbmdlKSk7XG4gICAgfVxuXG4gICAgdmFyIGFuY2hvciA9IFJlYWN0RWRpdG9yLnRvU2xhdGVQb2ludChlZGl0b3IsIFthbmNob3JOb2RlLCBhbmNob3JPZmZzZXRdKTtcbiAgICB2YXIgZm9jdXMgPSBpc0NvbGxhcHNlZCA/IGFuY2hvciA6IFJlYWN0RWRpdG9yLnRvU2xhdGVQb2ludChlZGl0b3IsIFtmb2N1c05vZGUsIGZvY3VzT2Zmc2V0XSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfTtcbiAgfVxuXG59O1xuXG4vKipcclxuICogQSBSZWFjdCBjb250ZXh0IGZvciBzaGFyaW5nIHRoZSBgZm9jdXNlZGAgc3RhdGUgb2YgdGhlIGVkaXRvci5cclxuICovXG5cbnZhciBGb2N1c2VkQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoZmFsc2UpO1xuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCBgZm9jdXNlZGAgc3RhdGUgb2YgdGhlIGVkaXRvci5cclxuICovXG5cbnZhciB1c2VGb2N1c2VkID0gKCkgPT4ge1xuICByZXR1cm4gdXNlQ29udGV4dChGb2N1c2VkQ29udGV4dCk7XG59O1xuXG4vKipcclxuICogQSBSZWFjdCBjb250ZXh0IGZvciBzaGFyaW5nIHRoZSBlZGl0b3Igb2JqZWN0LlxyXG4gKi9cblxudmFyIEVkaXRvckNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCBlZGl0b3Igb2JqZWN0IGZyb20gdGhlIFJlYWN0IGNvbnRleHQuXHJcbiAqL1xuXG52YXIgdXNlRWRpdG9yID0gKCkgPT4ge1xuICB2YXIgZWRpdG9yID0gdXNlQ29udGV4dChFZGl0b3JDb250ZXh0KTtcblxuICBpZiAoIWVkaXRvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgdXNlRWRpdG9yYCBob29rIG11c3QgYmUgdXNlZCBpbnNpZGUgdGhlIDxTbGF0ZT4gY29tcG9uZW50J3MgY29udGV4dC5cIik7XG4gIH1cblxuICByZXR1cm4gZWRpdG9yO1xufTtcblxuLyoqXHJcbiAqIEEgUmVhY3QgY29udGV4dCBmb3Igc2hhcmluZyB0aGUgZWRpdG9yIG9iamVjdCwgaW4gYSB3YXkgdGhhdCByZS1yZW5kZXJzIHRoZVxyXG4gKiBjb250ZXh0IHdoZW5ldmVyIGNoYW5nZXMgb2NjdXIuXHJcbiAqL1xuXG52YXIgU2xhdGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgZWRpdG9yIG9iamVjdCBmcm9tIHRoZSBSZWFjdCBjb250ZXh0LlxyXG4gKi9cblxudmFyIHVzZVNsYXRlID0gKCkgPT4ge1xuICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoU2xhdGVDb250ZXh0KTtcblxuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHVzZVNsYXRlYCBob29rIG11c3QgYmUgdXNlZCBpbnNpZGUgdGhlIDxTbGF0ZVByb3ZpZGVyPiBjb21wb25lbnQncyBjb250ZXh0LlwiKTtcbiAgfVxuXG4gIHZhciBbZWRpdG9yXSA9IGNvbnRleHQ7XG4gIHJldHVybiBlZGl0b3I7XG59O1xuXG4vKipcclxuICogQSB3cmFwcGVyIGFyb3VuZCB0aGUgcHJvdmlkZXIgdG8gaGFuZGxlIGBvbkNoYW5nZWAgZXZlbnRzLCBiZWNhdXNlIHRoZSBlZGl0b3JcclxuICogaXMgYSBtdXRhYmxlIHNpbmdsZXRvbiBzbyBpdCB3b24ndCBldmVyIHJlZ2lzdGVyIGFzIFwiY2hhbmdlZFwiIG90aGVyd2lzZS5cclxuICovXG5cbnZhciBTbGF0ZSA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBlZGl0b3IsXG4gICAgY2hpbGRyZW4sXG4gICAgb25DaGFuZ2UsXG4gICAgdmFsdWVcbiAgfSA9IHByb3BzLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiZWRpdG9yXCIsIFwiY2hpbGRyZW5cIiwgXCJvbkNoYW5nZVwiLCBcInZhbHVlXCJdKTtcblxuICB2YXIgW2tleSwgc2V0S2V5XSA9IHVzZVN0YXRlKDApO1xuICB2YXIgY29udGV4dCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGVkaXRvci5jaGlsZHJlbiA9IHZhbHVlO1xuICAgIE9iamVjdC5hc3NpZ24oZWRpdG9yLCByZXN0KTtcbiAgICByZXR1cm4gW2VkaXRvcl07XG4gIH0sIFtrZXksIHZhbHVlLCAuLi5PYmplY3QudmFsdWVzKHJlc3QpXSk7XG4gIHZhciBvbkNvbnRleHRDaGFuZ2UgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgb25DaGFuZ2UoZWRpdG9yLmNoaWxkcmVuKTtcbiAgICBzZXRLZXkoa2V5ICsgMSk7XG4gIH0sIFtrZXksIG9uQ2hhbmdlXSk7XG4gIEVESVRPUl9UT19PTl9DSEFOR0Uuc2V0KGVkaXRvciwgb25Db250ZXh0Q2hhbmdlKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgRURJVE9SX1RPX09OX0NIQU5HRS5zZXQoZWRpdG9yLCAoKSA9PiB7fSk7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChTbGF0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KEVkaXRvckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZWRpdG9yXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRm9jdXNlZENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogUmVhY3RFZGl0b3IuaXNGb2N1c2VkKGVkaXRvcilcbiAgfSwgY2hpbGRyZW4pKSk7XG59O1xuXG4vKipcclxuICogQSBSZWFjdCBjb250ZXh0IGZvciBzaGFyaW5nIHRoZSBgcmVhZE9ubHlgIHN0YXRlIG9mIHRoZSBlZGl0b3IuXHJcbiAqL1xuXG52YXIgUmVhZE9ubHlDb250ZXh0ID0gY3JlYXRlQ29udGV4dChmYWxzZSk7XG4vKipcclxuICogR2V0IHRoZSBjdXJyZW50IGByZWFkT25seWAgc3RhdGUgb2YgdGhlIGVkaXRvci5cclxuICovXG5cbnZhciB1c2VSZWFkT25seSA9ICgpID0+IHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoUmVhZE9ubHlDb250ZXh0KTtcbn07XG5cbi8qKlxyXG4gKiBBIFJlYWN0IGNvbnRleHQgZm9yIHNoYXJpbmcgdGhlIGBzZWxlY3RlZGAgc3RhdGUgb2YgYW4gZWxlbWVudC5cclxuICovXG5cbnZhciBTZWxlY3RlZENvbnRleHQgPSBjcmVhdGVDb250ZXh0KGZhbHNlKTtcbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgYHNlbGVjdGVkYCBzdGF0ZSBvZiBhbiBlbGVtZW50LlxyXG4gKi9cblxudmFyIHVzZVNlbGVjdGVkID0gKCkgPT4ge1xuICByZXR1cm4gdXNlQ29udGV4dChTZWxlY3RlZENvbnRleHQpO1xufTtcblxuLyoqXHJcbiAqIGB3aXRoUmVhY3RgIGFkZHMgUmVhY3QgYW5kIERPTSBzcGVjaWZpYyBiZWhhdmlvcnMgdG8gdGhlIGVkaXRvci5cclxuICovXG5cbnZhciB3aXRoUmVhY3QgPSBlZGl0b3IgPT4ge1xuICB2YXIgZSA9IGVkaXRvcjtcbiAgdmFyIHtcbiAgICBhcHBseSxcbiAgICBvbkNoYW5nZVxuICB9ID0gZTtcblxuICBlLmFwcGx5ID0gb3AgPT4ge1xuICAgIHZhciBtYXRjaGVzID0gW107XG5cbiAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBFZGl0b3IubGV2ZWxzKGUsIHtcbiAgICAgICAgICAgIGF0OiBvcC5wYXRoXG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBSZWFjdEVkaXRvci5maW5kS2V5KGUsIG5vZGUpO1xuICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKFtwYXRoLCBrZXldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgZm9yICh2YXIgW19ub2RlLCBfcGF0aF0gb2YgRWRpdG9yLmxldmVscyhlLCB7XG4gICAgICAgICAgICBhdDogUGF0aC5wYXJlbnQob3AucGF0aClcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgdmFyIF9rZXkgPSBSZWFjdEVkaXRvci5maW5kS2V5KGUsIF9ub2RlKTtcblxuICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKFtfcGF0aCwgX2tleV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXBwbHkob3ApO1xuXG4gICAgZm9yICh2YXIgW19wYXRoMiwgX2tleTJdIG9mIG1hdGNoZXMpIHtcbiAgICAgIHZhciBbX25vZGUyXSA9IEVkaXRvci5ub2RlKGUsIF9wYXRoMik7XG4gICAgICBOT0RFX1RPX0tFWS5zZXQoX25vZGUyLCBfa2V5Mik7XG4gICAgfVxuICB9O1xuXG4gIGUuc2V0RnJhZ21lbnREYXRhID0gZGF0YSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBlO1xuXG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoc2VsZWN0aW9uKTtcbiAgICB2YXIgc3RhcnRWb2lkID0gRWRpdG9yLnZvaWQoZSwge1xuICAgICAgYXQ6IHN0YXJ0LnBhdGhcbiAgICB9KTtcbiAgICB2YXIgZW5kVm9pZCA9IEVkaXRvci52b2lkKGUsIHtcbiAgICAgIGF0OiBlbmQucGF0aFxuICAgIH0pO1xuXG4gICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikgJiYgIXN0YXJ0Vm9pZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ3JlYXRlIGEgZmFrZSBzZWxlY3Rpb24gc28gdGhhdCB3ZSBjYW4gYWRkIGEgQmFzZTY0LWVuY29kZWQgY29weSBvZiB0aGVcbiAgICAvLyBmcmFnbWVudCB0byB0aGUgSFRNTCwgdG8gZGVjb2RlIG9uIGZ1dHVyZSBwYXN0ZXMuXG5cblxuICAgIHZhciBkb21SYW5nZSA9IFJlYWN0RWRpdG9yLnRvRE9NUmFuZ2UoZSwgc2VsZWN0aW9uKTtcbiAgICB2YXIgY29udGVudHMgPSBkb21SYW5nZS5jbG9uZUNvbnRlbnRzKCk7XG4gICAgdmFyIGF0dGFjaCA9IGNvbnRlbnRzLmNoaWxkTm9kZXNbMF07IC8vIE1ha2Ugc3VyZSBhdHRhY2ggaXMgbm9uLWVtcHR5LCBzaW5jZSBlbXB0eSBub2RlcyB3aWxsIG5vdCBnZXQgY29waWVkLlxuXG4gICAgY29udGVudHMuY2hpbGROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgaWYgKG5vZGUudGV4dENvbnRlbnQgJiYgbm9kZS50ZXh0Q29udGVudC50cmltKCkgIT09ICcnKSB7XG4gICAgICAgIGF0dGFjaCA9IG5vZGU7XG4gICAgICB9XG4gICAgfSk7IC8vIENPTVBBVDogSWYgdGhlIGVuZCBub2RlIGlzIGEgdm9pZCBub2RlLCB3ZSBuZWVkIHRvIG1vdmUgdGhlIGVuZCBvZiB0aGVcbiAgICAvLyByYW5nZSBmcm9tIHRoZSB2b2lkIG5vZGUncyBzcGFjZXIgc3BhbiwgdG8gdGhlIGVuZCBvZiB0aGUgdm9pZCBub2RlJ3NcbiAgICAvLyBjb250ZW50LCBzaW5jZSB0aGUgc3BhY2VyIGlzIGJlZm9yZSB2b2lkJ3MgY29udGVudCBpbiB0aGUgRE9NLlxuXG4gICAgaWYgKGVuZFZvaWQpIHtcbiAgICAgIHZhciBbdm9pZE5vZGVdID0gZW5kVm9pZDtcbiAgICAgIHZhciByID0gZG9tUmFuZ2UuY2xvbmVSYW5nZSgpO1xuICAgICAgdmFyIGRvbU5vZGUgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZSwgdm9pZE5vZGUpO1xuICAgICAgci5zZXRFbmRBZnRlcihkb21Ob2RlKTtcbiAgICAgIGNvbnRlbnRzID0gci5jbG9uZUNvbnRlbnRzKCk7XG4gICAgfSAvLyBDT01QQVQ6IElmIHRoZSBzdGFydCBub2RlIGlzIGEgdm9pZCBub2RlLCB3ZSBuZWVkIHRvIGF0dGFjaCB0aGUgZW5jb2RlZFxuICAgIC8vIGZyYWdtZW50IHRvIHRoZSB2b2lkIG5vZGUncyBjb250ZW50IG5vZGUgaW5zdGVhZCBvZiB0aGUgc3BhY2VyLCBiZWNhdXNlXG4gICAgLy8gYXR0YWNoaW5nIGl0IHRvIGVtcHR5IGA8ZGl2Pi88c3Bhbj5gIG5vZGVzIHdpbGwgZW5kIHVwIGhhdmluZyBpdCBlcmFzZWQgYnlcbiAgICAvLyBtb3N0IGJyb3dzZXJzLiAoMjAxOC8wNC8yNylcblxuXG4gICAgaWYgKHN0YXJ0Vm9pZCkge1xuICAgICAgYXR0YWNoID0gY29udGVudHMucXVlcnlTZWxlY3RvcignW2RhdGEtc2xhdGUtc3BhY2VyXScpO1xuICAgIH0gLy8gUmVtb3ZlIGFueSB6ZXJvLXdpZHRoIHNwYWNlIHNwYW5zIGZyb20gdGhlIGNsb25lZCBET00gc28gdGhhdCB0aGV5IGRvbid0XG4gICAgLy8gc2hvdyB1cCBlbHNld2hlcmUgd2hlbiBwYXN0ZWQuXG5cblxuICAgIEFycmF5LmZyb20oY29udGVudHMucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2xhdGUtemVyby13aWR0aF0nKSkuZm9yRWFjaCh6dyA9PiB7XG4gICAgICB2YXIgaXNOZXdsaW5lID0gencuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKSA9PT0gJ24nO1xuICAgICAgencudGV4dENvbnRlbnQgPSBpc05ld2xpbmUgPyAnXFxuJyA6ICcnO1xuICAgIH0pOyAvLyBTZXQgYSBgZGF0YS1zbGF0ZS1mcmFnbWVudGAgYXR0cmlidXRlIG9uIGEgbm9uLWVtcHR5IG5vZGUsIHNvIGl0IHNob3dzIHVwXG4gICAgLy8gaW4gdGhlIEhUTUwsIGFuZCBjYW4gYmUgdXNlZCBmb3IgaW50cmEtU2xhdGUgcGFzdGluZy4gSWYgaXQncyBhIHRleHRcbiAgICAvLyBub2RlLCB3cmFwIGl0IGluIGEgYDxzcGFuPmAgc28gd2UgaGF2ZSBzb21ldGhpbmcgdG8gc2V0IGFuIGF0dHJpYnV0ZSBvbi5cblxuICAgIGlmIChpc0RPTVRleHQoYXR0YWNoKSkge1xuICAgICAgdmFyIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7IC8vIENPTVBBVDogSW4gQ2hyb21lIGFuZCBTYWZhcmksIGlmIHdlIGRvbid0IGFkZCB0aGUgYHdoaXRlLXNwYWNlYCBzdHlsZVxuICAgICAgLy8gdGhlbiBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZXMgd2lsbCBiZSBpZ25vcmVkLiAoMjAxNy8wOS8yMSlcblxuICAgICAgc3Bhbi5zdHlsZS53aGl0ZVNwYWNlID0gJ3ByZSc7XG4gICAgICBzcGFuLmFwcGVuZENoaWxkKGF0dGFjaCk7XG4gICAgICBjb250ZW50cy5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgIGF0dGFjaCA9IHNwYW47XG4gICAgfVxuXG4gICAgdmFyIGZyYWdtZW50ID0gZS5nZXRGcmFnbWVudCgpO1xuICAgIHZhciBzdHJpbmcgPSBKU09OLnN0cmluZ2lmeShmcmFnbWVudCk7XG4gICAgdmFyIGVuY29kZWQgPSB3aW5kb3cuYnRvYShlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nKSk7XG4gICAgYXR0YWNoLnNldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1mcmFnbWVudCcsIGVuY29kZWQpO1xuICAgIGRhdGEuc2V0RGF0YSgnYXBwbGljYXRpb24veC1zbGF0ZS1mcmFnbWVudCcsIGVuY29kZWQpOyAvLyBBZGQgdGhlIGNvbnRlbnQgdG8gYSA8ZGl2PiBzbyB0aGF0IHdlIGNhbiBnZXQgaXRzIGlubmVyIEhUTUwuXG5cbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LmFwcGVuZENoaWxkKGNvbnRlbnRzKTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKCdoaWRkZW4nLCAndHJ1ZScpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICBkYXRhLnNldERhdGEoJ3RleHQvaHRtbCcsIGRpdi5pbm5lckhUTUwpO1xuICAgIGRhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsIGdldFBsYWluVGV4dChkaXYpKTtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG4gIH07XG5cbiAgZS5pbnNlcnREYXRhID0gZGF0YSA9PiB7XG4gICAgdmFyIGZyYWdtZW50ID0gZGF0YS5nZXREYXRhKCdhcHBsaWNhdGlvbi94LXNsYXRlLWZyYWdtZW50Jyk7XG5cbiAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgIHZhciBkZWNvZGVkID0gZGVjb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5hdG9iKGZyYWdtZW50KSk7XG4gICAgICB2YXIgcGFyc2VkID0gSlNPTi5wYXJzZShkZWNvZGVkKTtcbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0RnJhZ21lbnQoZSwgcGFyc2VkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGV4dCA9IGRhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xuXG4gICAgaWYgKHRleHQpIHtcbiAgICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoL1xcclxcbnxcXHJ8XFxuLyk7XG4gICAgICB2YXIgc3BsaXQgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgbGluZSBvZiBsaW5lcykge1xuICAgICAgICBpZiAoc3BsaXQpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZSwge1xuICAgICAgICAgICAgYWx3YXlzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBUcmFuc2Zvcm1zLmluc2VydFRleHQoZSwgbGluZSk7XG4gICAgICAgIHNwbGl0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZS5vbkNoYW5nZSA9ICgpID0+IHtcbiAgICAvLyBDT01QQVQ6IFJlYWN0IGRvZXNuJ3QgYmF0Y2ggYHNldFN0YXRlYCBob29rIGNhbGxzLCB3aGljaCBtZWFucyB0aGF0IHRoZVxuICAgIC8vIGNoaWxkcmVuIGFuZCBzZWxlY3Rpb24gY2FuIGdldCBvdXQgb2Ygc3luYyBmb3Igb25lIHJlbmRlciBwYXNzLiBTbyB3ZVxuICAgIC8vIGhhdmUgdG8gdXNlIHRoaXMgdW5zdGFibGUgQVBJIHRvIGVuc3VyZSBpdCBiYXRjaGVzIHRoZW0uICgyMDE5LzEyLzAzKVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTQyNTkjaXNzdWVjb21tZW50LTQzOTcwMjM2N1xuICAgIFJlYWN0RE9NLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKCgpID0+IHtcbiAgICAgIHZhciBvbkNvbnRleHRDaGFuZ2UgPSBFRElUT1JfVE9fT05fQ0hBTkdFLmdldChlKTtcblxuICAgICAgaWYgKG9uQ29udGV4dENoYW5nZSkge1xuICAgICAgICBvbkNvbnRleHRDaGFuZ2UoKTtcbiAgICAgIH1cblxuICAgICAgb25DaGFuZ2UoKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gZTtcbn07XG5cbi8qKlxyXG4gKiBMZWFmIGNvbnRlbnQgc3RyaW5ncy5cclxuICovXG5cbnZhciBTdHJpbmcgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgaXNMYXN0LFxuICAgIGxlYWYsXG4gICAgcGFyZW50LFxuICAgIHRleHRcbiAgfSA9IHByb3BzO1xuICB2YXIgZWRpdG9yID0gdXNlRWRpdG9yKCk7XG4gIHZhciBwYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCB0ZXh0KTtcbiAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChwYXRoKTsgLy8gQ09NUEFUOiBSZW5kZXIgdGV4dCBpbnNpZGUgdm9pZCBub2RlcyB3aXRoIGEgemVyby13aWR0aCBzcGFjZS5cbiAgLy8gU28gdGhlIG5vZGUgY2FuIGNvbnRhaW4gc2VsZWN0aW9uIGJ1dCB0aGUgdGV4dCBpcyBub3QgdmlzaWJsZS5cblxuICBpZiAoZWRpdG9yLmlzVm9pZChwYXJlbnQpKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoWmVyb1dpZHRoU3RyaW5nLCB7XG4gICAgICBsZW5ndGg6IE5vZGUkMS5zdHJpbmcocGFyZW50KS5sZW5ndGhcbiAgICB9KTtcbiAgfSAvLyBDT01QQVQ6IElmIHRoaXMgaXMgdGhlIGxhc3QgdGV4dCBub2RlIGluIGFuIGVtcHR5IGJsb2NrLCByZW5kZXIgYSB6ZXJvLVxuICAvLyB3aWR0aCBzcGFjZSB0aGF0IHdpbGwgY29udmVydCBpbnRvIGEgbGluZSBicmVhayB3aGVuIGNvcHlpbmcgYW5kIHBhc3RpbmdcbiAgLy8gdG8gc3VwcG9ydCBleHBlY3RlZCBwbGFpbiB0ZXh0LlxuXG5cbiAgaWYgKGxlYWYudGV4dCA9PT0gJycgJiYgcGFyZW50LmNoaWxkcmVuW3BhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxXSA9PT0gdGV4dCAmJiAhZWRpdG9yLmlzSW5saW5lKHBhcmVudCkgJiYgRWRpdG9yLnN0cmluZyhlZGl0b3IsIHBhcmVudFBhdGgpID09PSAnJykge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFplcm9XaWR0aFN0cmluZywge1xuICAgICAgaXNMaW5lQnJlYWs6IHRydWVcbiAgICB9KTtcbiAgfSAvLyBDT01QQVQ6IElmIHRoZSB0ZXh0IGlzIGVtcHR5LCBpdCdzIGJlY2F1c2UgaXQncyBvbiB0aGUgZWRnZSBvZiBhbiBpbmxpbmVcbiAgLy8gbm9kZSwgc28gd2UgcmVuZGVyIGEgemVyby13aWR0aCBzcGFjZSBzbyB0aGF0IHRoZSBzZWxlY3Rpb24gY2FuIGJlXG4gIC8vIGluc2VydGVkIG5leHQgdG8gaXQgc3RpbGwuXG5cblxuICBpZiAobGVhZi50ZXh0ID09PSAnJykge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFplcm9XaWR0aFN0cmluZywgbnVsbCk7XG4gIH0gLy8gQ09NUEFUOiBCcm93c2VycyB3aWxsIGNvbGxhcHNlIHRyYWlsaW5nIG5ldyBsaW5lcyBhdCB0aGUgZW5kIG9mIGJsb2NrcyxcbiAgLy8gc28gd2UgbmVlZCB0byBhZGQgYW4gZXh0cmEgdHJhaWxpbmcgbmV3IGxpbmVzIHRvIHByZXZlbnQgdGhhdC5cblxuXG4gIGlmIChpc0xhc3QgJiYgbGVhZi50ZXh0LnNsaWNlKC0xKSA9PT0gJ1xcbicpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChUZXh0U3RyaW5nLCB7XG4gICAgICBpc1RyYWlsaW5nOiB0cnVlLFxuICAgICAgdGV4dDogbGVhZi50ZXh0XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChUZXh0U3RyaW5nLCB7XG4gICAgdGV4dDogbGVhZi50ZXh0XG4gIH0pO1xufTtcbi8qKlxyXG4gKiBMZWFmIHN0cmluZ3Mgd2l0aCB0ZXh0IGluIHRoZW0uXHJcbiAqL1xuXG5cbnZhciBUZXh0U3RyaW5nID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIHRleHQsXG4gICAgaXNUcmFpbGluZyA9IGZhbHNlXG4gIH0gPSBwcm9wcztcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBcImRhdGEtc2xhdGUtc3RyaW5nXCI6IHRydWVcbiAgfSwgdGV4dCwgaXNUcmFpbGluZyA/ICdcXG4nIDogbnVsbCk7XG59O1xuLyoqXHJcbiAqIExlYWYgc3RyaW5ncyB3aXRob3V0IHRleHQsIHJlbmRlciBhcyB6ZXJvLXdpZHRoIHN0cmluZ3MuXHJcbiAqL1xuXG5cbnZhciBaZXJvV2lkdGhTdHJpbmcgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgbGVuZ3RoID0gMCxcbiAgICBpc0xpbmVCcmVhayA9IGZhbHNlXG4gIH0gPSBwcm9wcztcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBcImRhdGEtc2xhdGUtemVyby13aWR0aFwiOiBpc0xpbmVCcmVhayA/ICduJyA6ICd6JyxcbiAgICBcImRhdGEtc2xhdGUtbGVuZ3RoXCI6IGxlbmd0aFxuICB9LCAnXFx1RkVGRicsIGlzTGluZUJyZWFrID8gUmVhY3QuY3JlYXRlRWxlbWVudChcImJyXCIsIG51bGwpIDogbnVsbCk7XG59O1xuXG4vKipcclxuICogSW5kaXZpZHVhbCBsZWF2ZXMgaW4gYSB0ZXh0IG5vZGUgd2l0aCB1bmlxdWUgZm9ybWF0dGluZy5cclxuICovXG5cbnZhciBMZWFmID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGxlYWYsXG4gICAgaXNMYXN0LFxuICAgIHRleHQsXG4gICAgcGFyZW50LFxuICAgIHJlbmRlckxlYWYgPSBwcm9wcyA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KERlZmF1bHRMZWFmLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcykpXG4gIH0gPSBwcm9wcztcbiAgdmFyIGNoaWxkcmVuID0gUmVhY3QuY3JlYXRlRWxlbWVudChTdHJpbmcsIHtcbiAgICBpc0xhc3Q6IGlzTGFzdCxcbiAgICBsZWFmOiBsZWFmLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIHRleHQ6IHRleHRcbiAgfSk7XG5cbiAgaWYgKGxlYWZbUExBQ0VIT0xERVJfU1lNQk9MXSkge1xuICAgIGNoaWxkcmVuID0gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgY29udGVudEVkaXRhYmxlOiBmYWxzZSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246ICd0ZXh0LXRvcCcsXG4gICAgICAgIHdpZHRoOiAnMCcsXG4gICAgICAgIG1heFdpZHRoOiAnMTAwJScsXG4gICAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgICAgICBvcGFjaXR5OiAnMC4zMzMnLFxuICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgICAgIGZvbnRTdHlsZTogJ25vcm1hbCcsXG4gICAgICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogJ25vbmUnXG4gICAgICB9XG4gICAgfSwgbGVhZi5wbGFjZWhvbGRlciksIGNoaWxkcmVuKTtcbiAgfSAvLyBDT01QQVQ6IEhhdmluZyB0aGUgYGRhdGEtYCBhdHRyaWJ1dGVzIG9uIHRoZXNlIGxlYWYgZWxlbWVudHMgZW5zdXJlcyB0aGF0XG4gIC8vIGluIGNlcnRhaW4gbWlzYmVoYXZpbmcgYnJvd3NlcnMgdGhleSBhcmVuJ3Qgd2VpcmRseSBjbG9uZWQvZGVzdHJveWVkIGJ5XG4gIC8vIGNvbnRlbnRlZGl0YWJsZSBiZWhhdmlvcnMuICgyMDE5LzA1LzA4KVxuXG5cbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ2RhdGEtc2xhdGUtbGVhZic6IHRydWVcbiAgfTtcbiAgcmV0dXJuIHJlbmRlckxlYWYoe1xuICAgIGF0dHJpYnV0ZXMsXG4gICAgY2hpbGRyZW4sXG4gICAgbGVhZixcbiAgICB0ZXh0XG4gIH0pO1xufTtcblxudmFyIE1lbW9pemVkTGVhZiA9IFJlYWN0Lm1lbW8oTGVhZiwgKHByZXYsIG5leHQpID0+IHtcbiAgcmV0dXJuIG5leHQucGFyZW50ID09PSBwcmV2LnBhcmVudCAmJiBuZXh0LmlzTGFzdCA9PT0gcHJldi5pc0xhc3QgJiYgbmV4dC5yZW5kZXJMZWFmID09PSBwcmV2LnJlbmRlckxlYWYgJiYgbmV4dC50ZXh0ID09PSBwcmV2LnRleHQgJiYgVGV4dCQxLm1hdGNoZXMobmV4dC5sZWFmLCBwcmV2LmxlYWYpO1xufSk7XG4vKipcclxuICogVGhlIGRlZmF1bHQgY3VzdG9tIGxlYWYgcmVuZGVyZXIuXHJcbiAqL1xuXG52YXIgRGVmYXVsdExlYWYgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlblxuICB9ID0gcHJvcHM7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKSwgY2hpbGRyZW4pO1xufTtcblxuLyoqXHJcbiAqIFByZXZlbnQgd2FybmluZyBvbiBTU1IgYnkgZmFsbGluZyBiYWNrIHRvIHVzZUVmZmVjdCB3aGVuIHdpbmRvdyBpcyBub3QgZGVmaW5lZFxyXG4gKi9cblxudmFyIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxuLyoqXHJcbiAqIFRleHQuXHJcbiAqL1xuXG52YXIgVGV4dCA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBkZWNvcmF0aW9ucyxcbiAgICBpc0xhc3QsXG4gICAgcGFyZW50LFxuICAgIHJlbmRlckxlYWYsXG4gICAgdGV4dFxuICB9ID0gcHJvcHM7XG4gIHZhciBlZGl0b3IgPSB1c2VFZGl0b3IoKTtcbiAgdmFyIHJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIGxlYXZlcyA9IFRleHQkMS5kZWNvcmF0aW9ucyh0ZXh0LCBkZWNvcmF0aW9ucyk7XG4gIHZhciBrZXkgPSBSZWFjdEVkaXRvci5maW5kS2V5KGVkaXRvciwgdGV4dCk7XG4gIHZhciBjaGlsZHJlbiA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVhdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxlYWYgPSBsZWF2ZXNbaV07XG4gICAgY2hpbGRyZW4ucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KE1lbW9pemVkTGVhZiwge1xuICAgICAgaXNMYXN0OiBpc0xhc3QgJiYgaSA9PT0gbGVhdmVzLmxlbmd0aCAtIDEsXG4gICAgICBrZXk6IFwiXCIuY29uY2F0KGtleS5pZCwgXCItXCIpLmNvbmNhdChpKSxcbiAgICAgIGxlYWY6IGxlYWYsXG4gICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICByZW5kZXJMZWFmOiByZW5kZXJMZWFmXG4gICAgfSkpO1xuICB9IC8vIFVwZGF0ZSBlbGVtZW50LXJlbGF0ZWQgd2VhayBtYXBzIHdpdGggdGhlIERPTSBlbGVtZW50IHJlZi5cblxuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudCkge1xuICAgICAgS0VZX1RPX0VMRU1FTlQuc2V0KGtleSwgcmVmLmN1cnJlbnQpO1xuICAgICAgTk9ERV9UT19FTEVNRU5ULnNldCh0ZXh0LCByZWYuY3VycmVudCk7XG4gICAgICBFTEVNRU5UX1RPX05PREUuc2V0KHJlZi5jdXJyZW50LCB0ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgS0VZX1RPX0VMRU1FTlQuZGVsZXRlKGtleSk7XG4gICAgICBOT0RFX1RPX0VMRU1FTlQuZGVsZXRlKHRleHQpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgXCJkYXRhLXNsYXRlLW5vZGVcIjogXCJ0ZXh0XCIsXG4gICAgcmVmOiByZWZcbiAgfSwgY2hpbGRyZW4pO1xufTtcblxudmFyIE1lbW9pemVkVGV4dCA9IFJlYWN0Lm1lbW8oVGV4dCwgKHByZXYsIG5leHQpID0+IHtcbiAgcmV0dXJuIG5leHQucGFyZW50ID09PSBwcmV2LnBhcmVudCAmJiBuZXh0LmlzTGFzdCA9PT0gcHJldi5pc0xhc3QgJiYgbmV4dC5yZW5kZXJMZWFmID09PSBwcmV2LnJlbmRlckxlYWYgJiYgbmV4dC50ZXh0ID09PSBwcmV2LnRleHQ7XG59KTtcblxuLyoqXHJcbiAqIEVsZW1lbnQuXHJcbiAqL1xuXG52YXIgRWxlbWVudCA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBkZWNvcmF0ZSxcbiAgICBkZWNvcmF0aW9ucyxcbiAgICBlbGVtZW50LFxuICAgIHJlbmRlckVsZW1lbnQgPSBwID0+IFJlYWN0LmNyZWF0ZUVsZW1lbnQoRGVmYXVsdEVsZW1lbnQsIE9iamVjdC5hc3NpZ24oe30sIHApKSxcbiAgICByZW5kZXJMZWFmLFxuICAgIHNlbGVjdGlvblxuICB9ID0gcHJvcHM7XG4gIHZhciByZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBlZGl0b3IgPSB1c2VFZGl0b3IoKTtcbiAgdmFyIHJlYWRPbmx5ID0gdXNlUmVhZE9ubHkoKTtcbiAgdmFyIGlzSW5saW5lID0gZWRpdG9yLmlzSW5saW5lKGVsZW1lbnQpO1xuICB2YXIga2V5ID0gUmVhY3RFZGl0b3IuZmluZEtleShlZGl0b3IsIGVsZW1lbnQpO1xuICB2YXIgY2hpbGRyZW4gPSBSZWFjdC5jcmVhdGVFbGVtZW50KENoaWxkcmVuLCB7XG4gICAgZGVjb3JhdGU6IGRlY29yYXRlLFxuICAgIGRlY29yYXRpb25zOiBkZWNvcmF0aW9ucyxcbiAgICBub2RlOiBlbGVtZW50LFxuICAgIHJlbmRlckVsZW1lbnQ6IHJlbmRlckVsZW1lbnQsXG4gICAgcmVuZGVyTGVhZjogcmVuZGVyTGVhZixcbiAgICBzZWxlY3Rpb246IHNlbGVjdGlvblxuICB9KTsgLy8gQXR0cmlidXRlcyB0aGF0IHRoZSBkZXZlbG9wZXIgbXVzdCBtaXggaW50byB0aGUgZWxlbWVudCBpbiB0aGVpclxuICAvLyBjdXN0b20gbm9kZSByZW5kZXJlciBjb21wb25lbnQuXG5cbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ2RhdGEtc2xhdGUtbm9kZSc6ICdlbGVtZW50JyxcbiAgICByZWZcbiAgfTtcblxuICBpZiAoaXNJbmxpbmUpIHtcbiAgICBhdHRyaWJ1dGVzWydkYXRhLXNsYXRlLWlubGluZSddID0gdHJ1ZTtcbiAgfSAvLyBJZiBpdCdzIGEgYmxvY2sgbm9kZSB3aXRoIGlubGluZSBjaGlsZHJlbiwgYWRkIHRoZSBwcm9wZXIgYGRpcmAgYXR0cmlidXRlXG4gIC8vIGZvciB0ZXh0IGRpcmVjdGlvbi5cblxuXG4gIGlmICghaXNJbmxpbmUgJiYgRWRpdG9yLmhhc0lubGluZXMoZWRpdG9yLCBlbGVtZW50KSkge1xuICAgIHZhciB0ZXh0ID0gTm9kZSQxLnN0cmluZyhlbGVtZW50KTtcbiAgICB2YXIgZGlyID0gZ2V0RGlyZWN0aW9uKHRleHQpO1xuXG4gICAgaWYgKGRpciA9PT0gJ3J0bCcpIHtcbiAgICAgIGF0dHJpYnV0ZXMuZGlyID0gZGlyO1xuICAgIH1cbiAgfSAvLyBJZiBpdCdzIGEgdm9pZCBub2RlLCB3cmFwIHRoZSBjaGlsZHJlbiBpbiBleHRyYSB2b2lkLXNwZWNpZmljIGVsZW1lbnRzLlxuXG5cbiAgaWYgKEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBlbGVtZW50KSkge1xuICAgIGF0dHJpYnV0ZXNbJ2RhdGEtc2xhdGUtdm9pZCddID0gdHJ1ZTtcblxuICAgIGlmICghcmVhZE9ubHkgJiYgaXNJbmxpbmUpIHtcbiAgICAgIGF0dHJpYnV0ZXMuY29udGVudEVkaXRhYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIFRhZyA9IGlzSW5saW5lID8gJ3NwYW4nIDogJ2Rpdic7XG4gICAgdmFyIFtbX3RleHRdXSA9IE5vZGUkMS50ZXh0cyhlbGVtZW50KTtcbiAgICBjaGlsZHJlbiA9IHJlYWRPbmx5ID8gbnVsbCA6IFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGFnLCB7XG4gICAgICBcImRhdGEtc2xhdGUtc3BhY2VyXCI6IHRydWUsXG4gICAgICBzdHlsZToge1xuICAgICAgICBoZWlnaHQ6ICcwJyxcbiAgICAgICAgY29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgIG91dGxpbmU6ICdub25lJyxcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICAgIH1cbiAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KE1lbW9pemVkVGV4dCwge1xuICAgICAgZGVjb3JhdGlvbnM6IFtdLFxuICAgICAgaXNMYXN0OiBmYWxzZSxcbiAgICAgIHBhcmVudDogZWxlbWVudCxcbiAgICAgIHRleHQ6IF90ZXh0XG4gICAgfSkpO1xuICAgIE5PREVfVE9fSU5ERVguc2V0KF90ZXh0LCAwKTtcbiAgICBOT0RFX1RPX1BBUkVOVC5zZXQoX3RleHQsIGVsZW1lbnQpO1xuICB9IC8vIFVwZGF0ZSBlbGVtZW50LXJlbGF0ZWQgd2VhayBtYXBzIHdpdGggdGhlIERPTSBlbGVtZW50IHJlZi5cblxuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudCkge1xuICAgICAgS0VZX1RPX0VMRU1FTlQuc2V0KGtleSwgcmVmLmN1cnJlbnQpO1xuICAgICAgTk9ERV9UT19FTEVNRU5ULnNldChlbGVtZW50LCByZWYuY3VycmVudCk7XG4gICAgICBFTEVNRU5UX1RPX05PREUuc2V0KHJlZi5jdXJyZW50LCBlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgS0VZX1RPX0VMRU1FTlQuZGVsZXRlKGtleSk7XG4gICAgICBOT0RFX1RPX0VMRU1FTlQuZGVsZXRlKGVsZW1lbnQpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFNlbGVjdGVkQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiAhIXNlbGVjdGlvblxuICB9LCByZW5kZXJFbGVtZW50KHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuLFxuICAgIGVsZW1lbnRcbiAgfSkpO1xufTtcblxudmFyIE1lbW9pemVkRWxlbWVudCA9IFJlYWN0Lm1lbW8oRWxlbWVudCwgKHByZXYsIG5leHQpID0+IHtcbiAgcmV0dXJuIHByZXYuZGVjb3JhdGUgPT09IG5leHQuZGVjb3JhdGUgJiYgcHJldi5lbGVtZW50ID09PSBuZXh0LmVsZW1lbnQgJiYgcHJldi5yZW5kZXJFbGVtZW50ID09PSBuZXh0LnJlbmRlckVsZW1lbnQgJiYgcHJldi5yZW5kZXJMZWFmID09PSBuZXh0LnJlbmRlckxlYWYgJiYgaXNSYW5nZUxpc3RFcXVhbChwcmV2LmRlY29yYXRpb25zLCBuZXh0LmRlY29yYXRpb25zKSAmJiAocHJldi5zZWxlY3Rpb24gPT09IG5leHQuc2VsZWN0aW9uIHx8ICEhcHJldi5zZWxlY3Rpb24gJiYgISFuZXh0LnNlbGVjdGlvbiAmJiBSYW5nZS5lcXVhbHMocHJldi5zZWxlY3Rpb24sIG5leHQuc2VsZWN0aW9uKSk7XG59KTtcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBlbGVtZW50IHJlbmRlcmVyLlxyXG4gKi9cblxudmFyIERlZmF1bHRFbGVtZW50ID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGF0dHJpYnV0ZXMsXG4gICAgY2hpbGRyZW4sXG4gICAgZWxlbWVudFxuICB9ID0gcHJvcHM7XG4gIHZhciBlZGl0b3IgPSB1c2VFZGl0b3IoKTtcbiAgdmFyIFRhZyA9IGVkaXRvci5pc0lubGluZShlbGVtZW50KSA/ICdzcGFuJyA6ICdkaXYnO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChUYWcsIE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMsIHtcbiAgICBzdHlsZToge1xuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICB9XG4gIH0pLCBjaGlsZHJlbik7XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIGEgbGlzdCBvZiByYW5nZXMgaXMgZXF1YWwgdG8gYW5vdGhlci5cclxuICpcclxuICogUEVSRjogdGhpcyByZXF1aXJlcyB0aGUgdHdvIGxpc3RzIHRvIGFsc28gaGF2ZSB0aGUgcmFuZ2VzIGluc2lkZSB0aGVtIGluIHRoZVxyXG4gKiBzYW1lIG9yZGVyLCBidXQgdGhpcyBpcyBhbiBva2F5IGNvbnN0cmFpbnQgZm9yIHVzIHNpbmNlIGRlY29yYXRpb25zIGFyZVxyXG4gKiBrZXB0IGluIG9yZGVyLCBhbmQgdGhlIG9kZCBjYXNlIHdoZXJlIHRoZXkgYXJlbid0IGlzIG9rYXkgdG8gcmUtcmVuZGVyIGZvci5cclxuICovXG5cbnZhciBpc1JhbmdlTGlzdEVxdWFsID0gKGxpc3QsIGFub3RoZXIpID0+IHtcbiAgaWYgKGxpc3QubGVuZ3RoICE9PSBhbm90aGVyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciByYW5nZSA9IGxpc3RbaV07XG4gICAgdmFyIG90aGVyID0gYW5vdGhlcltpXTtcblxuICAgIGlmICghUmFuZ2UuZXF1YWxzKHJhbmdlLCBvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxyXG4gKiBDaGlsZHJlbi5cclxuICovXG5cbnZhciBDaGlsZHJlbiA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBkZWNvcmF0ZSxcbiAgICBkZWNvcmF0aW9ucyxcbiAgICBub2RlLFxuICAgIHJlbmRlckVsZW1lbnQsXG4gICAgcmVuZGVyTGVhZixcbiAgICBzZWxlY3Rpb25cbiAgfSA9IHByb3BzO1xuICB2YXIgZWRpdG9yID0gdXNlRWRpdG9yKCk7XG4gIHZhciBwYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBub2RlKTtcbiAgdmFyIGNoaWxkcmVuID0gW107XG4gIHZhciBpc0xlYWZCbG9jayA9IEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgIWVkaXRvci5pc0lubGluZShub2RlKSAmJiBFZGl0b3IuaGFzSW5saW5lcyhlZGl0b3IsIG5vZGUpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gcGF0aC5jb25jYXQoaSk7XG4gICAgdmFyIG4gPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgIHZhciBrZXkgPSBSZWFjdEVkaXRvci5maW5kS2V5KGVkaXRvciwgbik7XG4gICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcCk7XG4gICAgdmFyIHNlbCA9IHNlbGVjdGlvbiAmJiBSYW5nZS5pbnRlcnNlY3Rpb24ocmFuZ2UsIHNlbGVjdGlvbik7XG4gICAgdmFyIGRzID0gZGVjb3JhdGUoW24sIHBdKTtcblxuICAgIGZvciAodmFyIGRlYyBvZiBkZWNvcmF0aW9ucykge1xuICAgICAgdmFyIGQgPSBSYW5nZS5pbnRlcnNlY3Rpb24oZGVjLCByYW5nZSk7XG5cbiAgICAgIGlmIChkKSB7XG4gICAgICAgIGRzLnB1c2goZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQobikpIHtcbiAgICAgIGNoaWxkcmVuLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudChNZW1vaXplZEVsZW1lbnQsIHtcbiAgICAgICAgZGVjb3JhdGU6IGRlY29yYXRlLFxuICAgICAgICBkZWNvcmF0aW9uczogZHMsXG4gICAgICAgIGVsZW1lbnQ6IG4sXG4gICAgICAgIGtleToga2V5LmlkLFxuICAgICAgICByZW5kZXJFbGVtZW50OiByZW5kZXJFbGVtZW50LFxuICAgICAgICByZW5kZXJMZWFmOiByZW5kZXJMZWFmLFxuICAgICAgICBzZWxlY3Rpb246IHNlbFxuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtb2l6ZWRUZXh0LCB7XG4gICAgICAgIGRlY29yYXRpb25zOiBkcyxcbiAgICAgICAga2V5OiBrZXkuaWQsXG4gICAgICAgIGlzTGFzdDogaXNMZWFmQmxvY2sgJiYgaSA9PT0gbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxLFxuICAgICAgICBwYXJlbnQ6IG5vZGUsXG4gICAgICAgIHJlbmRlckxlYWY6IHJlbmRlckxlYWYsXG4gICAgICAgIHRleHQ6IG5cbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBOT0RFX1RPX0lOREVYLnNldChuLCBpKTtcbiAgICBOT0RFX1RPX1BBUkVOVC5zZXQobiwgbm9kZSk7XG4gIH1cblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufTtcblxudmFyIElTX0lPUyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF3aW5kb3cuTVNTdHJlYW07XG52YXIgSVNfQVBQTEUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvTWFjIE9TIFgvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgSVNfRklSRUZPWCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9eKD8hLipTZWFtb25rZXkpKD89LipGaXJlZm94KS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJU19TQUZBUkkgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvVmVyc2lvblxcL1tcXGRcXC5dKy4qU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyBcIm1vZGVyblwiIEVkZ2Ugd2FzIHJlbGVhc2VkIGF0IDc5LnhcblxudmFyIElTX0VER0VfTEVHQUNZID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0VkZ2U/XFwvKD86WzAtNl1bMC05XXxbMC03XVswLThdKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxyXG4gKiBIb3RrZXkgbWFwcGluZ3MgZm9yIGVhY2ggcGxhdGZvcm0uXHJcbiAqL1xuXG52YXIgSE9US0VZUyA9IHtcbiAgYm9sZDogJ21vZCtiJyxcbiAgY29tcG9zZTogWydkb3duJywgJ2xlZnQnLCAncmlnaHQnLCAndXAnLCAnYmFja3NwYWNlJywgJ2VudGVyJ10sXG4gIG1vdmVCYWNrd2FyZDogJ2xlZnQnLFxuICBtb3ZlRm9yd2FyZDogJ3JpZ2h0JyxcbiAgbW92ZVdvcmRCYWNrd2FyZDogJ2N0cmwrbGVmdCcsXG4gIG1vdmVXb3JkRm9yd2FyZDogJ2N0cmwrcmlnaHQnLFxuICBkZWxldGVCYWNrd2FyZDogJ3NoaWZ0PytiYWNrc3BhY2UnLFxuICBkZWxldGVGb3J3YXJkOiAnc2hpZnQ/K2RlbGV0ZScsXG4gIGV4dGVuZEJhY2t3YXJkOiAnc2hpZnQrbGVmdCcsXG4gIGV4dGVuZEZvcndhcmQ6ICdzaGlmdCtyaWdodCcsXG4gIGl0YWxpYzogJ21vZCtpJyxcbiAgc3BsaXRCbG9jazogJ3NoaWZ0PytlbnRlcicsXG4gIHVuZG86ICdtb2Qreidcbn07XG52YXIgQVBQTEVfSE9US0VZUyA9IHtcbiAgbW92ZUxpbmVCYWNrd2FyZDogJ29wdCt1cCcsXG4gIG1vdmVMaW5lRm9yd2FyZDogJ29wdCtkb3duJyxcbiAgbW92ZVdvcmRCYWNrd2FyZDogJ29wdCtsZWZ0JyxcbiAgbW92ZVdvcmRGb3J3YXJkOiAnb3B0K3JpZ2h0JyxcbiAgZGVsZXRlQmFja3dhcmQ6IFsnY3RybCtiYWNrc3BhY2UnLCAnY3RybCtoJ10sXG4gIGRlbGV0ZUZvcndhcmQ6IFsnY3RybCtkZWxldGUnLCAnY3RybCtkJ10sXG4gIGRlbGV0ZUxpbmVCYWNrd2FyZDogJ2NtZCtzaGlmdD8rYmFja3NwYWNlJyxcbiAgZGVsZXRlTGluZUZvcndhcmQ6IFsnY21kK3NoaWZ0PytkZWxldGUnLCAnY3RybCtrJ10sXG4gIGRlbGV0ZVdvcmRCYWNrd2FyZDogJ29wdCtzaGlmdD8rYmFja3NwYWNlJyxcbiAgZGVsZXRlV29yZEZvcndhcmQ6ICdvcHQrc2hpZnQ/K2RlbGV0ZScsXG4gIGV4dGVuZExpbmVCYWNrd2FyZDogJ29wdCtzaGlmdCt1cCcsXG4gIGV4dGVuZExpbmVGb3J3YXJkOiAnb3B0K3NoaWZ0K2Rvd24nLFxuICByZWRvOiAnY21kK3NoaWZ0K3onLFxuICB0cmFuc3Bvc2VDaGFyYWN0ZXI6ICdjdHJsK3QnXG59O1xudmFyIFdJTkRPV1NfSE9US0VZUyA9IHtcbiAgZGVsZXRlV29yZEJhY2t3YXJkOiAnY3RybCtzaGlmdD8rYmFja3NwYWNlJyxcbiAgZGVsZXRlV29yZEZvcndhcmQ6ICdjdHJsK3NoaWZ0PytkZWxldGUnLFxuICByZWRvOiBbJ2N0cmwreScsICdjdHJsK3NoaWZ0K3onXVxufTtcbi8qKlxyXG4gKiBDcmVhdGUgYSBwbGF0Zm9ybS1hd2FyZSBob3RrZXkgY2hlY2tlci5cclxuICovXG5cbnZhciBjcmVhdGUgPSBrZXkgPT4ge1xuICB2YXIgZ2VuZXJpYyA9IEhPVEtFWVNba2V5XTtcbiAgdmFyIGFwcGxlID0gQVBQTEVfSE9US0VZU1trZXldO1xuICB2YXIgd2luZG93cyA9IFdJTkRPV1NfSE9US0VZU1trZXldO1xuICB2YXIgaXNHZW5lcmljID0gZ2VuZXJpYyAmJiBpc0tleUhvdGtleShnZW5lcmljKTtcbiAgdmFyIGlzQXBwbGUgPSBhcHBsZSAmJiBpc0tleUhvdGtleShhcHBsZSk7XG4gIHZhciBpc1dpbmRvd3MgPSB3aW5kb3dzICYmIGlzS2V5SG90a2V5KHdpbmRvd3MpO1xuICByZXR1cm4gZXZlbnQgPT4ge1xuICAgIGlmIChpc0dlbmVyaWMgJiYgaXNHZW5lcmljKGV2ZW50KSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKElTX0FQUExFICYmIGlzQXBwbGUgJiYgaXNBcHBsZShldmVudCkpIHJldHVybiB0cnVlO1xuICAgIGlmICghSVNfQVBQTEUgJiYgaXNXaW5kb3dzICYmIGlzV2luZG93cyhldmVudCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn07XG4vKipcclxuICogSG90a2V5cy5cclxuICovXG5cblxudmFyIEhvdGtleXMgPSB7XG4gIGlzQm9sZDogY3JlYXRlKCdib2xkJyksXG4gIGlzQ29tcG9zZTogY3JlYXRlKCdjb21wb3NlJyksXG4gIGlzTW92ZUJhY2t3YXJkOiBjcmVhdGUoJ21vdmVCYWNrd2FyZCcpLFxuICBpc01vdmVGb3J3YXJkOiBjcmVhdGUoJ21vdmVGb3J3YXJkJyksXG4gIGlzRGVsZXRlQmFja3dhcmQ6IGNyZWF0ZSgnZGVsZXRlQmFja3dhcmQnKSxcbiAgaXNEZWxldGVGb3J3YXJkOiBjcmVhdGUoJ2RlbGV0ZUZvcndhcmQnKSxcbiAgaXNEZWxldGVMaW5lQmFja3dhcmQ6IGNyZWF0ZSgnZGVsZXRlTGluZUJhY2t3YXJkJyksXG4gIGlzRGVsZXRlTGluZUZvcndhcmQ6IGNyZWF0ZSgnZGVsZXRlTGluZUZvcndhcmQnKSxcbiAgaXNEZWxldGVXb3JkQmFja3dhcmQ6IGNyZWF0ZSgnZGVsZXRlV29yZEJhY2t3YXJkJyksXG4gIGlzRGVsZXRlV29yZEZvcndhcmQ6IGNyZWF0ZSgnZGVsZXRlV29yZEZvcndhcmQnKSxcbiAgaXNFeHRlbmRCYWNrd2FyZDogY3JlYXRlKCdleHRlbmRCYWNrd2FyZCcpLFxuICBpc0V4dGVuZEZvcndhcmQ6IGNyZWF0ZSgnZXh0ZW5kRm9yd2FyZCcpLFxuICBpc0V4dGVuZExpbmVCYWNrd2FyZDogY3JlYXRlKCdleHRlbmRMaW5lQmFja3dhcmQnKSxcbiAgaXNFeHRlbmRMaW5lRm9yd2FyZDogY3JlYXRlKCdleHRlbmRMaW5lRm9yd2FyZCcpLFxuICBpc0l0YWxpYzogY3JlYXRlKCdpdGFsaWMnKSxcbiAgaXNNb3ZlTGluZUJhY2t3YXJkOiBjcmVhdGUoJ21vdmVMaW5lQmFja3dhcmQnKSxcbiAgaXNNb3ZlTGluZUZvcndhcmQ6IGNyZWF0ZSgnbW92ZUxpbmVGb3J3YXJkJyksXG4gIGlzTW92ZVdvcmRCYWNrd2FyZDogY3JlYXRlKCdtb3ZlV29yZEJhY2t3YXJkJyksXG4gIGlzTW92ZVdvcmRGb3J3YXJkOiBjcmVhdGUoJ21vdmVXb3JkRm9yd2FyZCcpLFxuICBpc1JlZG86IGNyZWF0ZSgncmVkbycpLFxuICBpc1NwbGl0QmxvY2s6IGNyZWF0ZSgnc3BsaXRCbG9jaycpLFxuICBpc1RyYW5zcG9zZUNoYXJhY3RlcjogY3JlYXRlKCd0cmFuc3Bvc2VDaGFyYWN0ZXInKSxcbiAgaXNVbmRvOiBjcmVhdGUoJ3VuZG8nKVxufTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgPSAhKElTX0ZJUkVGT1ggfHwgSVNfRURHRV9MRUdBQ1kpO1xuLyoqXHJcbiAqIEVkaXRhYmxlLlxyXG4gKi9cblxudmFyIEVkaXRhYmxlID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGF1dG9Gb2N1cyxcbiAgICBkZWNvcmF0ZSA9IGRlZmF1bHREZWNvcmF0ZSxcbiAgICBvbkRPTUJlZm9yZUlucHV0OiBwcm9wc09uRE9NQmVmb3JlSW5wdXQsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgcmVhZE9ubHkgPSBmYWxzZSxcbiAgICByZW5kZXJFbGVtZW50LFxuICAgIHJlbmRlckxlYWYsXG4gICAgc3R5bGUgPSB7fSxcbiAgICBhczogQ29tcG9uZW50ID0gJ2RpdidcbiAgfSA9IHByb3BzLFxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiYXV0b0ZvY3VzXCIsIFwiZGVjb3JhdGVcIiwgXCJvbkRPTUJlZm9yZUlucHV0XCIsIFwicGxhY2Vob2xkZXJcIiwgXCJyZWFkT25seVwiLCBcInJlbmRlckVsZW1lbnRcIiwgXCJyZW5kZXJMZWFmXCIsIFwic3R5bGVcIiwgXCJhc1wiXSk7XG5cbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlKCk7XG4gIHZhciByZWYgPSB1c2VSZWYobnVsbCk7IC8vIFVwZGF0ZSBpbnRlcm5hbCBzdGF0ZSBvbiBlYWNoIHJlbmRlci5cblxuICBJU19SRUFEX09OTFkuc2V0KGVkaXRvciwgcmVhZE9ubHkpOyAvLyBLZWVwIHRyYWNrIG9mIHNvbWUgc3RhdGUgZm9yIHRoZSBldmVudCBoYW5kbGVyIGxvZ2ljLlxuXG4gIHZhciBzdGF0ZSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBpc0NvbXBvc2luZzogZmFsc2UsXG4gICAgaXNVcGRhdGluZ1NlbGVjdGlvbjogZmFsc2UsXG4gICAgbGF0ZXN0RWxlbWVudDogbnVsbFxuICB9KSwgW10pOyAvLyBVcGRhdGUgZWxlbWVudC1yZWxhdGVkIHdlYWsgbWFwcyB3aXRoIHRoZSBET00gZWxlbWVudCByZWYuXG5cbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50KSB7XG4gICAgICBFRElUT1JfVE9fRUxFTUVOVC5zZXQoZWRpdG9yLCByZWYuY3VycmVudCk7XG4gICAgICBOT0RFX1RPX0VMRU1FTlQuc2V0KGVkaXRvciwgcmVmLmN1cnJlbnQpO1xuICAgICAgRUxFTUVOVF9UT19OT0RFLnNldChyZWYuY3VycmVudCwgZWRpdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgTk9ERV9UT19FTEVNRU5ULmRlbGV0ZShlZGl0b3IpO1xuICAgIH1cbiAgfSk7IC8vIFdoZW5ldmVyIHRoZSBlZGl0b3IgdXBkYXRlcywgbWFrZSBzdXJlIHRoZSBET00gc2VsZWN0aW9uIHN0YXRlIGlzIGluIHN5bmMuXG5cbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBlZGl0b3I7XG4gICAgdmFyIGRvbVNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmIChzdGF0ZS5pc0NvbXBvc2luZyB8fCAhZG9tU2VsZWN0aW9uIHx8ICFSZWFjdEVkaXRvci5pc0ZvY3VzZWQoZWRpdG9yKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBoYXNEb21TZWxlY3Rpb24gPSBkb21TZWxlY3Rpb24udHlwZSAhPT0gJ05vbmUnOyAvLyBJZiB0aGUgRE9NIHNlbGVjdGlvbiBpcyBwcm9wZXJseSB1bnNldCwgd2UncmUgZG9uZS5cblxuICAgIGlmICghc2VsZWN0aW9uICYmICFoYXNEb21TZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHZlcmlmeSB0aGF0IHRoZSBkb20gc2VsZWN0aW9uIGlzIGluIHRoZSBlZGl0b3JcblxuXG4gICAgdmFyIGVkaXRvckVsZW1lbnQgPSBFRElUT1JfVE9fRUxFTUVOVC5nZXQoZWRpdG9yKTtcbiAgICB2YXIgaGFzRG9tU2VsZWN0aW9uSW5FZGl0b3IgPSBmYWxzZTtcblxuICAgIGlmIChlZGl0b3JFbGVtZW50LmNvbnRhaW5zKGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlKSAmJiBlZGl0b3JFbGVtZW50LmNvbnRhaW5zKGRvbVNlbGVjdGlvbi5mb2N1c05vZGUpKSB7XG4gICAgICBoYXNEb21TZWxlY3Rpb25JbkVkaXRvciA9IHRydWU7XG4gICAgfSAvLyBJZiB0aGUgRE9NIHNlbGVjdGlvbiBpcyBpbiB0aGUgZWRpdG9yIGFuZCB0aGUgZWRpdG9yIHNlbGVjdGlvbiBpcyBhbHJlYWR5IGNvcnJlY3QsIHdlJ3JlIGRvbmUuXG5cblxuICAgIGlmIChoYXNEb21TZWxlY3Rpb24gJiYgaGFzRG9tU2VsZWN0aW9uSW5FZGl0b3IgJiYgc2VsZWN0aW9uICYmIFJhbmdlLmVxdWFscyhSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCBkb21TZWxlY3Rpb24pLCBzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBPdGhlcndpc2UgdGhlIERPTSBzZWxlY3Rpb24gaXMgb3V0IG9mIHN5bmMsIHNvIHVwZGF0ZSBpdC5cblxuXG4gICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICBzdGF0ZS5pc1VwZGF0aW5nU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICBkb21TZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgdmFyIG5ld0RvbVJhbmdlID0gc2VsZWN0aW9uICYmIFJlYWN0RWRpdG9yLnRvRE9NUmFuZ2UoZWRpdG9yLCBzZWxlY3Rpb24pO1xuXG4gICAgaWYgKG5ld0RvbVJhbmdlKSB7XG4gICAgICBkb21TZWxlY3Rpb24uYWRkUmFuZ2UobmV3RG9tUmFuZ2UpO1xuICAgICAgdmFyIGxlYWZFbCA9IG5ld0RvbVJhbmdlLnN0YXJ0Q29udGFpbmVyLnBhcmVudEVsZW1lbnQ7XG4gICAgICBzY3JvbGxJbnRvVmlldyhsZWFmRWwsIHtcbiAgICAgICAgc2Nyb2xsTW9kZTogJ2lmLW5lZWRlZCcsXG4gICAgICAgIGJvdW5kYXJ5OiBlbFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAvLyBDT01QQVQ6IEluIEZpcmVmb3gsIGl0J3Mgbm90IGVub3VnaCB0byBjcmVhdGUgYSByYW5nZSwgeW91IGFsc28gbmVlZFxuICAgICAgLy8gdG8gZm9jdXMgdGhlIGNvbnRlbnRlZGl0YWJsZSBlbGVtZW50IHRvby4gKDIwMTYvMTEvMTYpXG4gICAgICBpZiAobmV3RG9tUmFuZ2UgJiYgSVNfRklSRUZPWCkge1xuICAgICAgICBlbC5mb2N1cygpO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5pc1VwZGF0aW5nU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgfSk7XG4gIH0pOyAvLyBUaGUgYXV0b0ZvY3VzIFRleHRhcmVhSFRNTEF0dHJpYnV0ZSBkb2Vzbid0IGRvIGFueXRoaW5nIG9uIGEgZGl2LCBzbyBpdFxuICAvLyBuZWVkcyB0byBiZSBtYW51YWxseSBmb2N1c2VkLlxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50ICYmIGF1dG9Gb2N1cykge1xuICAgICAgcmVmLmN1cnJlbnQuZm9jdXMoKTtcbiAgICB9XG4gIH0sIFthdXRvRm9jdXNdKTsgLy8gTGlzdGVuIG9uIHRoZSBuYXRpdmUgYGJlZm9yZWlucHV0YCBldmVudCB0byBnZXQgcmVhbCBcIkxldmVsIDJcIiBldmVudHMuIFRoaXNcbiAgLy8gaXMgcmVxdWlyZWQgYmVjYXVzZSBSZWFjdCdzIGBiZWZvcmVpbnB1dGAgaXMgZmFrZSBhbmQgbmV2ZXIgcmVhbGx5IGF0dGFjaGVzXG4gIC8vIHRvIHRoZSByZWFsIGV2ZW50IHNhZGx5LiAoMjAxOS8xMS8wMSlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTIxMVxuXG4gIHZhciBvbkRPTUJlZm9yZUlucHV0ID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgIGlmICghcmVhZE9ubHkgJiYgaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0RPTUV2ZW50SGFuZGxlZChldmVudCwgcHJvcHNPbkRPTUJlZm9yZUlucHV0KSkge1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9ID0gZWRpdG9yO1xuICAgICAgdmFyIHtcbiAgICAgICAgaW5wdXRUeXBlOiB0eXBlXG4gICAgICB9ID0gZXZlbnQ7XG4gICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGFUcmFuc2ZlciB8fCBldmVudC5kYXRhIHx8IHVuZGVmaW5lZDsgLy8gVGhlc2UgdHdvIHR5cGVzIG9jY3VyIHdoaWxlIGEgdXNlciBpcyBjb21wb3NpbmcgdGV4dCBhbmQgY2FuJ3QgYmVcbiAgICAgIC8vIGNhbmNlbGxlZC4gTGV0IHRoZW0gdGhyb3VnaCBhbmQgd2FpdCBmb3IgdGhlIGNvbXBvc2l0aW9uIHRvIGVuZC5cblxuICAgICAgaWYgKHR5cGUgPT09ICdpbnNlcnRDb21wb3NpdGlvblRleHQnIHx8IHR5cGUgPT09ICdkZWxldGVDb21wb3NpdGlvblRleHQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gQ09NUEFUOiBGb3IgdGhlIGRlbGV0aW5nIGZvcndhcmQvYmFja3dhcmQgaW5wdXQgdHlwZXMgd2UgZG9uJ3Qgd2FudFxuICAgICAgLy8gdG8gY2hhbmdlIHRoZSBzZWxlY3Rpb24gYmVjYXVzZSBpdCBpcyB0aGUgcmFuZ2UgdGhhdCB3aWxsIGJlIGRlbGV0ZWQsXG4gICAgICAvLyBhbmQgdGhvc2UgY29tbWFuZHMgZGV0ZXJtaW5lIHRoYXQgZm9yIHRoZW1zZWx2ZXMuXG5cbiAgICAgIGlmICghdHlwZS5zdGFydHNXaXRoKCdkZWxldGUnKSB8fCB0eXBlLnN0YXJ0c1dpdGgoJ2RlbGV0ZUJ5JykpIHtcbiAgICAgICAgdmFyIFt0YXJnZXRSYW5nZV0gPSBldmVudC5nZXRUYXJnZXRSYW5nZXMoKTtcblxuICAgICAgICBpZiAodGFyZ2V0UmFuZ2UpIHtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCB0YXJnZXRSYW5nZSk7XG5cbiAgICAgICAgICBpZiAoIXNlbGVjdGlvbiB8fCAhUmFuZ2UuZXF1YWxzKHNlbGVjdGlvbiwgcmFuZ2UpKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ09NUEFUOiBJZiB0aGUgc2VsZWN0aW9uIGlzIGV4cGFuZGVkLCBldmVuIGlmIHRoZSBjb21tYW5kIHNlZW1zIGxpa2VcbiAgICAgIC8vIGEgZGVsZXRlIGZvcndhcmQvYmFja3dhcmQgY29tbWFuZCBpdCBzaG91bGQgZGVsZXRlIHRoZSBzZWxlY3Rpb24uXG5cblxuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikgJiYgdHlwZS5zdGFydHNXaXRoKCdkZWxldGUnKSkge1xuICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZGVsZXRlQnlDb21wb3NpdGlvbic6XG4gICAgICAgIGNhc2UgJ2RlbGV0ZUJ5Q3V0JzpcbiAgICAgICAgY2FzZSAnZGVsZXRlQnlEcmFnJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVDb250ZW50JzpcbiAgICAgICAgY2FzZSAnZGVsZXRlQ29udGVudEZvcndhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGVsZXRlQ29udGVudEJhY2t3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVFbnRpcmVTb2Z0TGluZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGVsZXRlSGFyZExpbmVCYWNrd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnYmxvY2snXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVTb2Z0TGluZUJhY2t3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGVsZXRlSGFyZExpbmVGb3J3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2Jsb2NrJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGVsZXRlU29mdExpbmVGb3J3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVXb3JkQmFja3dhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ3dvcmQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVXb3JkRm9yd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICd3b3JkJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnaW5zZXJ0TGluZUJyZWFrJzpcbiAgICAgICAgY2FzZSAnaW5zZXJ0UGFyYWdyYXBoJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuaW5zZXJ0QnJlYWsoZWRpdG9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdpbnNlcnRGcm9tQ29tcG9zaXRpb24nOlxuICAgICAgICBjYXNlICdpbnNlcnRGcm9tRHJvcCc6XG4gICAgICAgIGNhc2UgJ2luc2VydEZyb21QYXN0ZSc6XG4gICAgICAgIGNhc2UgJ2luc2VydEZyb21ZYW5rJzpcbiAgICAgICAgY2FzZSAnaW5zZXJ0UmVwbGFjZW1lbnRUZXh0JzpcbiAgICAgICAgY2FzZSAnaW5zZXJ0VGV4dCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBEYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICAgICAgUmVhY3RFZGl0b3IuaW5zZXJ0RGF0YShlZGl0b3IsIGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBkYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwgW3JlYWRPbmx5XSk7IC8vIEF0dGFjaCBhIG5hdGl2ZSBET00gZXZlbnQgaGFuZGxlciBmb3IgYGJlZm9yZWlucHV0YCBldmVudHMsIGJlY2F1c2UgUmVhY3Qnc1xuICAvLyBidWlsdC1pbiBgb25CZWZvcmVJbnB1dGAgaXMgYWN0dWFsbHkgYSBsZWFreSBwb2x5ZmlsbCB0aGF0IGRvZXNuJ3QgZXhwb3NlXG4gIC8vIHJlYWwgYGJlZm9yZWlucHV0YCBldmVudHMgc2FkbHkuLi4gKDIwMTkvMTEvMDQpXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTEyMTFcblxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAocmVmLmN1cnJlbnQpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgVGhlIGBiZWZvcmVpbnB1dGAgZXZlbnQgaXNuJ3QgcmVjb2duaXplZC5cbiAgICAgIHJlZi5jdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZWlucHV0Jywgb25ET01CZWZvcmVJbnB1dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChyZWYuY3VycmVudCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlIFRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50IGlzbid0IHJlY29nbml6ZWQuXG4gICAgICAgIHJlZi5jdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JlZm9yZWlucHV0Jywgb25ET01CZWZvcmVJbnB1dCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW29uRE9NQmVmb3JlSW5wdXRdKTsgLy8gTGlzdGVuIG9uIHRoZSBuYXRpdmUgYHNlbGVjdGlvbmNoYW5nZWAgZXZlbnQgdG8gYmUgYWJsZSB0byB1cGRhdGUgYW55IHRpbWVcbiAgLy8gdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgUmVhY3QncyBgb25TZWxlY3RgIGlzIGxlYWt5XG4gIC8vIGFuZCBub24tc3RhbmRhcmQgc28gaXQgZG9lc24ndCBmaXJlIHVudGlsIGFmdGVyIGEgc2VsZWN0aW9uIGhhcyBiZWVuXG4gIC8vIHJlbGVhc2VkLiBUaGlzIGNhdXNlcyBpc3N1ZXMgaW4gc2l0dWF0aW9ucyB3aGVyZSBhbm90aGVyIGNoYW5nZSBoYXBwZW5zXG4gIC8vIHdoaWxlIGEgc2VsZWN0aW9uIGlzIGJlaW5nIGRyYWdnZWQuXG5cbiAgdmFyIG9uRE9NU2VsZWN0aW9uQ2hhbmdlID0gdXNlQ2FsbGJhY2sodGhyb3R0bGUoKCkgPT4ge1xuICAgIGlmICghcmVhZE9ubHkgJiYgIXN0YXRlLmlzQ29tcG9zaW5nICYmICFzdGF0ZS5pc1VwZGF0aW5nU2VsZWN0aW9uKSB7XG4gICAgICB2YXIge1xuICAgICAgICBhY3RpdmVFbGVtZW50XG4gICAgICB9ID0gd2luZG93LmRvY3VtZW50O1xuICAgICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICAgIHZhciBkb21TZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgIGlmIChhY3RpdmVFbGVtZW50ID09PSBlbCkge1xuICAgICAgICBzdGF0ZS5sYXRlc3RFbGVtZW50ID0gYWN0aXZlRWxlbWVudDtcbiAgICAgICAgSVNfRk9DVVNFRC5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIElTX0ZPQ1VTRUQuZGVsZXRlKGVkaXRvcik7XG4gICAgICB9XG5cbiAgICAgIGlmICghZG9tU2VsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvcik7XG4gICAgICB9XG5cbiAgICAgIHZhciB7XG4gICAgICAgIGFuY2hvck5vZGUsXG4gICAgICAgIGZvY3VzTm9kZVxuICAgICAgfSA9IGRvbVNlbGVjdGlvbjtcbiAgICAgIHZhciBhbmNob3JOb2RlU2VsZWN0YWJsZSA9IGhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgYW5jaG9yTm9kZSkgfHwgaXNUYXJnZXRJbnNpZGVWb2lkKGVkaXRvciwgYW5jaG9yTm9kZSk7XG4gICAgICB2YXIgZm9jdXNOb2RlU2VsZWN0YWJsZSA9IGhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgZm9jdXNOb2RlKSB8fCBpc1RhcmdldEluc2lkZVZvaWQoZWRpdG9yLCBmb2N1c05vZGUpO1xuXG4gICAgICBpZiAoYW5jaG9yTm9kZVNlbGVjdGFibGUgJiYgZm9jdXNOb2RlU2VsZWN0YWJsZSkge1xuICAgICAgICB2YXIgcmFuZ2UgPSBSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCBkb21TZWxlY3Rpb24pO1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFRyYW5zZm9ybXMuZGVzZWxlY3QoZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIDEwMCksIFtyZWFkT25seV0pOyAvLyBBdHRhY2ggYSBuYXRpdmUgRE9NIGV2ZW50IGhhbmRsZXIgZm9yIGBzZWxlY3Rpb25jaGFuZ2VgLCBiZWNhdXNlIFJlYWN0J3NcbiAgLy8gYnVpbHQtaW4gYG9uU2VsZWN0YCBoYW5kbGVyIGRvZXNuJ3QgZmlyZSBmb3IgYWxsIHNlbGVjdGlvbiBjaGFuZ2VzLiBJdCdzIGFcbiAgLy8gbGVha3kgcG9seWZpbGwgdGhhdCBvbmx5IGZpcmVzIG9uIGtleXByZXNzZXMgb3IgY2xpY2tzLiBJbnN0ZWFkLCB3ZSB3YW50IHRvXG4gIC8vIGZpcmUgZm9yIGFueSBjaGFuZ2UgdG8gdGhlIHNlbGVjdGlvbiBpbnNpZGUgdGhlIGVkaXRvci4gKDIwMTkvMTEvMDQpXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNTc4NVxuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBvbkRPTVNlbGVjdGlvbkNoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBvbkRPTVNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfTtcbiAgfSwgW29uRE9NU2VsZWN0aW9uQ2hhbmdlXSk7XG4gIHZhciBkZWNvcmF0aW9ucyA9IGRlY29yYXRlKFtlZGl0b3IsIFtdXSk7XG5cbiAgaWYgKHBsYWNlaG9sZGVyICYmIGVkaXRvci5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgQXJyYXkuZnJvbShOb2RlJDEudGV4dHMoZWRpdG9yKSkubGVuZ3RoID09PSAxICYmIE5vZGUkMS5zdHJpbmcoZWRpdG9yKSA9PT0gJycpIHtcbiAgICB2YXIgc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBbXSk7XG4gICAgZGVjb3JhdGlvbnMucHVzaCh7XG4gICAgICBbUExBQ0VIT0xERVJfU1lNQk9MXTogdHJ1ZSxcbiAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgYW5jaG9yOiBzdGFydCxcbiAgICAgIGZvY3VzOiBzdGFydFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhZE9ubHlDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHJlYWRPbmx5XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50IC8vIENPTVBBVDogVGhlIEdyYW1tYXJseSBDaHJvbWUgZXh0ZW5zaW9uIHdvcmtzIGJ5IGNoYW5naW5nIHRoZSBET01cbiAgLy8gb3V0IGZyb20gdW5kZXIgYGNvbnRlbnRlZGl0YWJsZWAgZWxlbWVudHMsIHdoaWNoIGxlYWRzIHRvIHdlaXJkXG4gIC8vIGJlaGF2aW9ycyBzbyB3ZSBoYXZlIHRvIGRpc2FibGUgaXQgbGlrZSBlZGl0b3IuICgyMDE3LzA0LzI0KVxuICAsIE9iamVjdC5hc3NpZ24oe1xuICAgIFwiZGF0YS1ncmFtbVwiOiBmYWxzZSxcbiAgICByb2xlOiByZWFkT25seSA/IHVuZGVmaW5lZCA6ICd0ZXh0Ym94J1xuICB9LCBhdHRyaWJ1dGVzLCB7XG4gICAgLy8gQ09NUEFUOiBDZXJ0YWluIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIGBiZWZvcmVpbnB1dGAgZXZlbnQsIHNvIHdlJ2RcbiAgICAvLyBoYXZlIHRvIHVzZSBoYWNrcyB0byBtYWtlIHRoZXNlIHJlcGxhY2VtZW50LWJhc2VkIGZlYXR1cmVzIHdvcmsuXG4gICAgc3BlbGxDaGVjazogIUhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCA/IHVuZGVmaW5lZCA6IGF0dHJpYnV0ZXMuc3BlbGxDaGVjayxcbiAgICBhdXRvQ29ycmVjdDogIUhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCA/IHVuZGVmaW5lZCA6IGF0dHJpYnV0ZXMuYXV0b0NvcnJlY3QsXG4gICAgYXV0b0NhcGl0YWxpemU6ICFIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgPyB1bmRlZmluZWQgOiBhdHRyaWJ1dGVzLmF1dG9DYXBpdGFsaXplLFxuICAgIFwiZGF0YS1zbGF0ZS1lZGl0b3JcIjogdHJ1ZSxcbiAgICBcImRhdGEtc2xhdGUtbm9kZVwiOiBcInZhbHVlXCIsXG4gICAgY29udGVudEVkaXRhYmxlOiByZWFkT25seSA/IHVuZGVmaW5lZCA6IHRydWUsXG4gICAgc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nOiB0cnVlLFxuICAgIHJlZjogcmVmLFxuICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgIC8vIFByZXZlbnQgdGhlIGRlZmF1bHQgb3V0bGluZSBzdHlsZXMuXG4gICAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgICAvLyBQcmVzZXJ2ZSBhZGphY2VudCB3aGl0ZXNwYWNlIGFuZCBuZXcgbGluZXMuXG4gICAgICB3aGl0ZVNwYWNlOiAncHJlLXdyYXAnLFxuICAgICAgLy8gQWxsb3cgd29yZHMgdG8gYnJlYWsgaWYgdGhleSBhcmUgdG9vIGxvbmcuXG4gICAgICB3b3JkV3JhcDogJ2JyZWFrLXdvcmQnXG4gICAgfSwgc3R5bGUpLFxuICAgIG9uQmVmb3JlSW5wdXQ6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIC8vIENPTVBBVDogQ2VydGFpbiBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50LCBzbyB3ZVxuICAgICAgLy8gZmFsbCBiYWNrIHRvIFJlYWN0J3MgbGVha3kgcG9seWZpbGwgaW5zdGVhZCBqdXN0IGZvciBpdC4gSXRcbiAgICAgIC8vIG9ubHkgd29ya3MgZm9yIHRoZSBgaW5zZXJ0VGV4dGAgaW5wdXQgdHlwZS5cbiAgICAgIGlmICghSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUICYmICFyZWFkT25seSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25CZWZvcmVJbnB1dCkgJiYgaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciB0ZXh0ID0gZXZlbnQuZGF0YTtcbiAgICAgICAgRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9LCBbcmVhZE9ubHldKSxcbiAgICBvbkJsdXI6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmIChyZWFkT25seSB8fCBzdGF0ZS5pc1VwZGF0aW5nU2VsZWN0aW9uIHx8ICFoYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgfHwgaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25CbHVyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIENPTVBBVDogSWYgdGhlIGN1cnJlbnQgYGFjdGl2ZUVsZW1lbnRgIGlzIHN0aWxsIHRoZSBwcmV2aW91c1xuICAgICAgLy8gb25lLCB0aGlzIGlzIGR1ZSB0byB0aGUgd2luZG93IGJlaW5nIGJsdXJyZWQgd2hlbiB0aGUgdGFiXG4gICAgICAvLyBpdHNlbGYgYmVjb21lcyB1bmZvY3VzZWQsIHNvIHdlIHdhbnQgdG8gYWJvcnQgZWFybHkgdG8gYWxsb3cgdG9cbiAgICAgIC8vIGVkaXRvciB0byBzdGF5IGZvY3VzZWQgd2hlbiB0aGUgdGFiIGJlY29tZXMgZm9jdXNlZCBhZ2Fpbi5cblxuXG4gICAgICBpZiAoc3RhdGUubGF0ZXN0RWxlbWVudCA9PT0gd2luZG93LmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIge1xuICAgICAgICByZWxhdGVkVGFyZ2V0XG4gICAgICB9ID0gZXZlbnQ7XG4gICAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpOyAvLyBDT01QQVQ6IFRoZSBldmVudCBzaG91bGQgYmUgaWdub3JlZCBpZiB0aGUgZm9jdXMgaXMgcmV0dXJuaW5nXG4gICAgICAvLyB0byB0aGUgZWRpdG9yIGZyb20gYW4gZW1iZWRkZWQgZWRpdGFibGUgZWxlbWVudCAoZWcuIGFuIDxpbnB1dD5cbiAgICAgIC8vIGVsZW1lbnQgaW5zaWRlIGEgdm9pZCBub2RlKS5cblxuICAgICAgaWYgKHJlbGF0ZWRUYXJnZXQgPT09IGVsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQ09NUEFUOiBUaGUgZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQgaWYgdGhlIGZvY3VzIGlzIG1vdmluZyBmcm9tXG4gICAgICAvLyB0aGUgZWRpdG9yIHRvIGluc2lkZSBhIHZvaWQgbm9kZSdzIHNwYWNlciBlbGVtZW50LlxuXG5cbiAgICAgIGlmIChpc0RPTUVsZW1lbnQocmVsYXRlZFRhcmdldCkgJiYgcmVsYXRlZFRhcmdldC5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtc3BhY2VyJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBDT01QQVQ6IFRoZSBldmVudCBzaG91bGQgYmUgaWdub3JlZCBpZiB0aGUgZm9jdXMgaXMgbW92aW5nIHRvIGFcbiAgICAgIC8vIG5vbi0gZWRpdGFibGUgc2VjdGlvbiBvZiBhbiBlbGVtZW50IHRoYXQgaXNuJ3QgYSB2b2lkIG5vZGUgKGVnLlxuICAgICAgLy8gYSBsaXN0IGl0ZW0gb2YgdGhlIGNoZWNrIGxpc3QgZXhhbXBsZSkuXG5cblxuICAgICAgaWYgKHJlbGF0ZWRUYXJnZXQgIT0gbnVsbCAmJiBpc0RPTU5vZGUocmVsYXRlZFRhcmdldCkgJiYgUmVhY3RFZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIHJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgIHZhciBub2RlID0gUmVhY3RFZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCByZWxhdGVkVGFyZ2V0KTtcblxuICAgICAgICBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSAmJiAhZWRpdG9yLmlzVm9pZChub2RlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBJU19GT0NVU0VELmRlbGV0ZShlZGl0b3IpO1xuICAgIH0sIFtyZWFkT25seSwgYXR0cmlidXRlcy5vbkJsdXJdKSxcbiAgICBvbkNsaWNrOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmIGhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQ2xpY2spICYmIGlzRE9NTm9kZShldmVudC50YXJnZXQpKSB7XG4gICAgICAgIHZhciBub2RlID0gUmVhY3RFZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCBldmVudC50YXJnZXQpO1xuICAgICAgICB2YXIgcGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgbm9kZSk7XG5cbiAgICAgICAgdmFyIF9zdGFydCA9IEVkaXRvci5zdGFydChlZGl0b3IsIHBhdGgpO1xuXG4gICAgICAgIHZhciBlbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgcGF0aCk7XG4gICAgICAgIHZhciBzdGFydFZvaWQgPSBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgICBhdDogX3N0YXJ0XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZW5kVm9pZCA9IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlbmRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHN0YXJ0Vm9pZCAmJiBlbmRWb2lkICYmIFBhdGguZXF1YWxzKHN0YXJ0Vm9pZFsxXSwgZW5kVm9pZFsxXSkpIHtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBfc3RhcnQpO1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBhdHRyaWJ1dGVzLm9uQ2xpY2tdKSxcbiAgICBvbkNvbXBvc2l0aW9uRW5kOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkNvbXBvc2l0aW9uRW5kKSkge1xuICAgICAgICBzdGF0ZS5pc0NvbXBvc2luZyA9IGZhbHNlOyAvLyBDT01QQVQ6IEluIENocm9tZSwgYGJlZm9yZWlucHV0YCBldmVudHMgZm9yIGNvbXBvc2l0aW9uc1xuICAgICAgICAvLyBhcmVuJ3QgY29ycmVjdCBhbmQgbmV2ZXIgZmlyZSB0aGUgXCJpbnNlcnRGcm9tQ29tcG9zaXRpb25cIlxuICAgICAgICAvLyB0eXBlIHRoYXQgd2UgbmVlZC4gU28gaW5zdGVhZCwgaW5zZXJ0IHdoZW5ldmVyIGEgY29tcG9zaXRpb25cbiAgICAgICAgLy8gZW5kcyBzaW5jZSBpdCB3aWxsIGFscmVhZHkgaGF2ZSBiZWVuIGNvbW1pdHRlZCB0byB0aGUgRE9NLlxuXG4gICAgICAgIGlmICghSVNfU0FGQVJJICYmICFJU19GSVJFRk9YICYmIGV2ZW50LmRhdGEpIHtcbiAgICAgICAgICBFZGl0b3IuaW5zZXJ0VGV4dChlZGl0b3IsIGV2ZW50LmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW2F0dHJpYnV0ZXMub25Db21wb3NpdGlvbkVuZF0pLFxuICAgIG9uQ29tcG9zaXRpb25TdGFydDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKGhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25Db21wb3NpdGlvblN0YXJ0KSkge1xuICAgICAgICBzdGF0ZS5pc0NvbXBvc2luZyA9IHRydWU7XG4gICAgICB9XG4gICAgfSwgW2F0dHJpYnV0ZXMub25Db21wb3NpdGlvblN0YXJ0XSksXG4gICAgb25Db3B5OiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkNvcHkpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIFJlYWN0RWRpdG9yLnNldEZyYWdtZW50RGF0YShlZGl0b3IsIGV2ZW50LmNsaXBib2FyZERhdGEpO1xuICAgICAgfVxuICAgIH0sIFthdHRyaWJ1dGVzLm9uQ29weV0pLFxuICAgIG9uQ3V0OiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmIGhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25DdXQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIFJlYWN0RWRpdG9yLnNldEZyYWdtZW50RGF0YShlZGl0b3IsIGV2ZW50LmNsaXBib2FyZERhdGEpO1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHNlbGVjdGlvblxuICAgICAgICB9ID0gZWRpdG9yO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbcmVhZE9ubHksIGF0dHJpYnV0ZXMub25DdXRdKSxcbiAgICBvbkRyYWdPdmVyOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoaGFzVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25EcmFnT3ZlcikpIHtcbiAgICAgICAgLy8gT25seSB3aGVuIHRoZSB0YXJnZXQgaXMgdm9pZCwgY2FsbCBgcHJldmVudERlZmF1bHRgIHRvIHNpZ25hbFxuICAgICAgICAvLyB0aGF0IGRyb3BzIGFyZSBhbGxvd2VkLiBFZGl0YWJsZSBjb250ZW50IGlzIGRyb3BwYWJsZSBieVxuICAgICAgICAvLyBkZWZhdWx0LCBhbmQgY2FsbGluZyBgcHJldmVudERlZmF1bHRgIGhpZGVzIHRoZSBjdXJzb3IuXG4gICAgICAgIHZhciBub2RlID0gUmVhY3RFZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCBldmVudC50YXJnZXQpO1xuXG4gICAgICAgIGlmIChFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW2F0dHJpYnV0ZXMub25EcmFnT3Zlcl0pLFxuICAgIG9uRHJhZ1N0YXJ0OiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoaGFzVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25EcmFnU3RhcnQpKSB7XG4gICAgICAgIHZhciBub2RlID0gUmVhY3RFZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCBldmVudC50YXJnZXQpO1xuICAgICAgICB2YXIgcGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgbm9kZSk7XG4gICAgICAgIHZhciB2b2lkTWF0Y2ggPSBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aFxuICAgICAgICB9KTsgLy8gSWYgc3RhcnRpbmcgYSBkcmFnIG9uIGEgdm9pZCBub2RlLCBtYWtlIHN1cmUgaXQgaXMgc2VsZWN0ZWRcbiAgICAgICAgLy8gc28gdGhhdCBpdCBzaG93cyB1cCBpbiB0aGUgc2VsZWN0aW9uJ3MgZnJhZ21lbnQuXG5cbiAgICAgICAgaWYgKHZvaWRNYXRjaCkge1xuICAgICAgICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgUmVhY3RFZGl0b3Iuc2V0RnJhZ21lbnREYXRhKGVkaXRvciwgZXZlbnQuZGF0YVRyYW5zZmVyKTtcbiAgICAgIH1cbiAgICB9LCBbYXR0cmlidXRlcy5vbkRyYWdTdGFydF0pLFxuICAgIG9uRHJvcDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKGhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIXJlYWRPbmx5ICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkRyb3ApKSB7XG4gICAgICAgIC8vIENPTVBBVDogQ2VydGFpbiBicm93c2VycyBkb24ndCBmaXJlIGBiZWZvcmVpbnB1dGAgZXZlbnRzIGF0IGFsbCwgYW5kXG4gICAgICAgIC8vIENocm9taXVtIGJyb3dzZXJzIGRvbid0IHByb3Blcmx5IGZpcmUgdGhlbSBmb3IgZmlsZXMgYmVpbmdcbiAgICAgICAgLy8gZHJvcHBlZCBpbnRvIGEgYGNvbnRlbnRlZGl0YWJsZWAuICgyMDE5LzExLzI2KVxuICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDI4NjY4XG4gICAgICAgIGlmICghSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUIHx8ICFJU19TQUZBUkkgJiYgZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHZhciByYW5nZSA9IFJlYWN0RWRpdG9yLmZpbmRFdmVudFJhbmdlKGVkaXRvciwgZXZlbnQpO1xuICAgICAgICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YVRyYW5zZmVyO1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpO1xuICAgICAgICAgIFJlYWN0RWRpdG9yLmluc2VydERhdGEoZWRpdG9yLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtyZWFkT25seSwgYXR0cmlidXRlcy5vbkRyb3BdKSxcbiAgICBvbkZvY3VzOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmICFzdGF0ZS5pc1VwZGF0aW5nU2VsZWN0aW9uICYmIGhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25Gb2N1cykpIHtcbiAgICAgICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICAgICAgc3RhdGUubGF0ZXN0RWxlbWVudCA9IHdpbmRvdy5kb2N1bWVudC5hY3RpdmVFbGVtZW50OyAvLyBDT01QQVQ6IElmIHRoZSBlZGl0b3IgaGFzIG5lc3RlZCBlZGl0YWJsZSBlbGVtZW50cywgdGhlIGZvY3VzXG4gICAgICAgIC8vIGNhbiBnbyB0byB0aGVtLiBJbiBGaXJlZm94LCB0aGlzIG11c3QgYmUgcHJldmVudGVkIGJlY2F1c2UgaXRcbiAgICAgICAgLy8gcmVzdWx0cyBpbiBpc3N1ZXMgd2l0aCBrZXlib2FyZCBuYXZpZ2F0aW9uLiAoMjAxNy8wMy8zMClcblxuICAgICAgICBpZiAoSVNfRklSRUZPWCAmJiBldmVudC50YXJnZXQgIT09IGVsKSB7XG4gICAgICAgICAgZWwuZm9jdXMoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBJU19GT0NVU0VELnNldChlZGl0b3IsIHRydWUpO1xuICAgICAgfVxuICAgIH0sIFtyZWFkT25seSwgYXR0cmlidXRlcy5vbkZvY3VzXSksXG4gICAgb25LZXlEb3duOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmIGhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25LZXlEb3duKSkge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIG5hdGl2ZUV2ZW50XG4gICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBzZWxlY3Rpb25cbiAgICAgICAgfSA9IGVkaXRvcjsgLy8gQ09NUEFUOiBTaW5jZSB3ZSBwcmV2ZW50IHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9uXG4gICAgICAgIC8vIGBiZWZvcmVpbnB1dGAgZXZlbnRzLCB0aGUgYnJvd3NlciBkb2Vzbid0IHRoaW5rIHRoZXJlJ3MgZXZlclxuICAgICAgICAvLyBhbnkgaGlzdG9yeSBzdGFjayB0byB1bmRvIG9yIHJlZG8sIHNvIHdlIGhhdmUgdG8gbWFuYWdlIHRoZXNlXG4gICAgICAgIC8vIGhvdGtleXMgb3Vyc2VsdmVzLiAoMjAxOS8xMS8wNilcblxuICAgICAgICBpZiAoSG90a2V5cy5pc1JlZG8obmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZWRpdG9yLnJlZG8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVkaXRvci5yZWRvKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNVbmRvKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGVkaXRvci51bmRvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBlZGl0b3IudW5kbygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBDT01QQVQ6IENlcnRhaW4gYnJvd3NlcnMgZG9uJ3QgaGFuZGxlIHRoZSBzZWxlY3Rpb24gdXBkYXRlc1xuICAgICAgICAvLyBwcm9wZXJseS4gSW4gQ2hyb21lLCB0aGUgc2VsZWN0aW9uIGlzbid0IHByb3Blcmx5IGV4dGVuZGVkLlxuICAgICAgICAvLyBBbmQgaW4gRmlyZWZveCwgdGhlIHNlbGVjdGlvbiBpc24ndCBwcm9wZXJseSBjb2xsYXBzZWQuXG4gICAgICAgIC8vICgyMDE3LzEwLzE3KVxuXG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNNb3ZlTGluZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ2xpbmUnLFxuICAgICAgICAgICAgcmV2ZXJzZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzTW92ZUxpbmVGb3J3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNFeHRlbmRMaW5lQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnbGluZScsXG4gICAgICAgICAgICBlZGdlOiAnZm9jdXMnLFxuICAgICAgICAgICAgcmV2ZXJzZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzRXh0ZW5kTGluZUZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnbGluZScsXG4gICAgICAgICAgICBlZGdlOiAnZm9jdXMnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIENPTVBBVDogSWYgYSB2b2lkIG5vZGUgaXMgc2VsZWN0ZWQsIG9yIGEgemVyby13aWR0aCB0ZXh0IG5vZGVcbiAgICAgICAgLy8gYWRqYWNlbnQgdG8gYW4gaW5saW5lIGlzIHNlbGVjdGVkLCB3ZSBuZWVkIHRvIGhhbmRsZSB0aGVzZVxuICAgICAgICAvLyBob3RrZXlzIG1hbnVhbGx5IGJlY2F1c2UgYnJvd3NlcnMgd29uJ3QgYmUgYWJsZSB0byBza2lwIG92ZXJcbiAgICAgICAgLy8gdGhlIHZvaWQgbm9kZSB3aXRoIHRoZSB6ZXJvLXdpZHRoIHNwYWNlIG5vdCBiZWluZyBhbiBlbXB0eVxuICAgICAgICAvLyBzdHJpbmcuXG5cblxuICAgICAgICBpZiAoSG90a2V5cy5pc01vdmVCYWNrd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHJldmVyc2U6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmNvbGxhcHNlKGVkaXRvciwge1xuICAgICAgICAgICAgICBlZGdlOiAnc3RhcnQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSG90a2V5cy5pc01vdmVGb3J3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmNvbGxhcHNlKGVkaXRvciwge1xuICAgICAgICAgICAgICBlZGdlOiAnZW5kJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNNb3ZlV29yZEJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ3dvcmQnLFxuICAgICAgICAgICAgcmV2ZXJzZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzTW92ZVdvcmRGb3J3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ3dvcmQnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIENPTVBBVDogQ2VydGFpbiBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50LCBzbyB3ZVxuICAgICAgICAvLyBmYWxsIGJhY2sgdG8gZ3Vlc3NpbmcgYXQgdGhlIGlucHV0IGludGVudGlvbiBmb3IgaG90a2V5cy5cbiAgICAgICAgLy8gQ09NUEFUOiBJbiBpT1MsIHNvbWUgb2YgdGhlc2UgaG90a2V5cyBhcmUgaGFuZGxlZCBpbiB0aGVcblxuXG4gICAgICAgIGlmICghSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUKSB7XG4gICAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBhIGNvcmUgYmVoYXZpb3IgZm9yIHRoZXNlLCBidXQgdGhleSBjaGFuZ2UgdGhlXG4gICAgICAgICAgLy8gRE9NIGlmIHdlIGRvbid0IHByZXZlbnQgdGhlbSwgc28gd2UgaGF2ZSB0by5cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc0JvbGQobmF0aXZlRXZlbnQpIHx8IEhvdGtleXMuaXNJdGFsaWMobmF0aXZlRXZlbnQpIHx8IEhvdGtleXMuaXNUcmFuc3Bvc2VDaGFyYWN0ZXIobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzU3BsaXRCbG9jayhuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBFZGl0b3IuaW5zZXJ0QnJlYWsoZWRpdG9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc0RlbGV0ZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzRGVsZXRlRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzRGVsZXRlTGluZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNEZWxldGVMaW5lRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNEZWxldGVXb3JkQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICB1bml0OiAnd29yZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc0RlbGV0ZVdvcmRGb3J3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICB1bml0OiAnd29yZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbcmVhZE9ubHksIGF0dHJpYnV0ZXMub25LZXlEb3duXSksXG4gICAgb25QYXN0ZTogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgLy8gQ09NUEFUOiBDZXJ0YWluIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIGBiZWZvcmVpbnB1dGAgZXZlbnQsIHNvIHdlXG4gICAgICAvLyBmYWxsIGJhY2sgdG8gUmVhY3QncyBgb25QYXN0ZWAgaGVyZSBpbnN0ZWFkLlxuICAgICAgLy8gQ09NUEFUOiBGaXJlZm94LCBDaHJvbWUgYW5kIFNhZmFyaSBhcmUgbm90IGVtaXR0aW5nIGBiZWZvcmVpbnB1dGAgZXZlbnRzXG4gICAgICAvLyB3aGVuIFwicGFzdGUgd2l0aG91dCBmb3JtYXR0aW5nXCIgb3B0aW9uIGlzIHVzZWQuXG4gICAgICAvLyBUaGlzIHVuZm9ydHVuYXRlbHkgbmVlZHMgdG8gYmUgaGFuZGxlZCB3aXRoIHBhc3RlIGV2ZW50cyBpbnN0ZWFkLlxuICAgICAgaWYgKCFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vblBhc3RlKSAmJiAoIUhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCB8fCBpc1BsYWluVGV4dE9ubHlQYXN0ZShldmVudC5uYXRpdmVFdmVudCkpICYmICFyZWFkT25seSAmJiBoYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgUmVhY3RFZGl0b3IuaW5zZXJ0RGF0YShlZGl0b3IsIGV2ZW50LmNsaXBib2FyZERhdGEpO1xuICAgICAgfVxuICAgIH0sIFtyZWFkT25seSwgYXR0cmlidXRlcy5vblBhc3RlXSlcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hpbGRyZW4sIHtcbiAgICBkZWNvcmF0ZTogZGVjb3JhdGUsXG4gICAgZGVjb3JhdGlvbnM6IGRlY29yYXRpb25zLFxuICAgIG5vZGU6IGVkaXRvcixcbiAgICByZW5kZXJFbGVtZW50OiByZW5kZXJFbGVtZW50LFxuICAgIHJlbmRlckxlYWY6IHJlbmRlckxlYWYsXG4gICAgc2VsZWN0aW9uOiBlZGl0b3Iuc2VsZWN0aW9uXG4gIH0pKSk7XG59O1xuLyoqXHJcbiAqIEEgZGVmYXVsdCBtZW1vaXplZCBkZWNvcmF0ZSBmdW5jdGlvbi5cclxuICovXG5cbnZhciBkZWZhdWx0RGVjb3JhdGUgPSAoKSA9PiBbXTtcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGUgdGFyZ2V0IGlzIGluIHRoZSBlZGl0b3IuXHJcbiAqL1xuXG5cbnZhciBoYXNUYXJnZXQgPSAoZWRpdG9yLCB0YXJnZXQpID0+IHtcbiAgcmV0dXJuIGlzRE9NTm9kZSh0YXJnZXQpICYmIFJlYWN0RWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCB0YXJnZXQpO1xufTtcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGUgdGFyZ2V0IGlzIGVkaXRhYmxlIGFuZCBpbiB0aGUgZWRpdG9yLlxyXG4gKi9cblxuXG52YXIgaGFzRWRpdGFibGVUYXJnZXQgPSAoZWRpdG9yLCB0YXJnZXQpID0+IHtcbiAgcmV0dXJuIGlzRE9NTm9kZSh0YXJnZXQpICYmIFJlYWN0RWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCB0YXJnZXQsIHtcbiAgICBlZGl0YWJsZTogdHJ1ZVxuICB9KTtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgdGhlIHRhcmdldCBpcyBpbnNpZGUgdm9pZCBhbmQgaW4gdGhlIGVkaXRvci5cclxuICovXG5cblxudmFyIGlzVGFyZ2V0SW5zaWRlVm9pZCA9IChlZGl0b3IsIHRhcmdldCkgPT4ge1xuICB2YXIgc2xhdGVOb2RlID0gaGFzVGFyZ2V0KGVkaXRvciwgdGFyZ2V0KSAmJiBSZWFjdEVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIHRhcmdldCk7XG4gIHJldHVybiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgc2xhdGVOb2RlKTtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYW4gZXZlbnQgaXMgb3ZlcnJpZGVkIGJ5IGEgaGFuZGxlci5cclxuICovXG5cblxudmFyIGlzRXZlbnRIYW5kbGVkID0gKGV2ZW50LCBoYW5kbGVyKSA9PiB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZXIoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSBET00gZXZlbnQgaXMgb3ZlcnJpZGVkIGJ5IGEgaGFuZGxlci5cclxuICovXG5cblxudmFyIGlzRE9NRXZlbnRIYW5kbGVkID0gKGV2ZW50LCBoYW5kbGVyKSA9PiB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZXIoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbn07XG5cbmV4cG9ydCB7IERlZmF1bHRFbGVtZW50LCBEZWZhdWx0TGVhZiwgRWRpdGFibGUsIFJlYWN0RWRpdG9yLCBTbGF0ZSwgdXNlRWRpdG9yLCB1c2VGb2N1c2VkLCB1c2VSZWFkT25seSwgdXNlU2VsZWN0ZWQsIHVzZVNsYXRlLCB3aXRoUmVhY3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIiwiaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnaXMtcGxhaW4tb2JqZWN0JztcbmltcG9ydCB7IGNyZWF0ZURyYWZ0LCBmaW5pc2hEcmFmdCwgaXNEcmFmdCwgcHJvZHVjZSB9IGZyb20gJ2ltbWVyJztcbmltcG9ydCB7IHJldmVyc2UgfSBmcm9tICdlc3JldmVyJztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgRElSVFlfUEFUSFMgPSBuZXcgV2Vha01hcCgpO1xudmFyIEZMVVNISU5HID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT1JNQUxJWklORyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgUEFUSF9SRUZTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBQT0lOVF9SRUZTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBSQU5HRV9SRUZTID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXHJcbiAqIENvbnN0YW50cyBmb3Igc3RyaW5nIGRpc3RhbmNlIGNoZWNraW5nLlxyXG4gKi9cbnZhciBTUEFDRSA9IC9cXHMvO1xudmFyIFBVTkNUVUFUSU9OID0gL1tcXHUwMDIxLVxcdTAwMjNcXHUwMDI1LVxcdTAwMkFcXHUwMDJDLVxcdTAwMkZcXHUwMDNBXFx1MDAzQlxcdTAwM0ZcXHUwMDQwXFx1MDA1Qi1cXHUwMDVEXFx1MDA1RlxcdTAwN0JcXHUwMDdEXFx1MDBBMVxcdTAwQTdcXHUwMEFCXFx1MDBCNlxcdTAwQjdcXHUwMEJCXFx1MDBCRlxcdTAzN0VcXHUwMzg3XFx1MDU1QS1cXHUwNTVGXFx1MDU4OVxcdTA1OEFcXHUwNUJFXFx1MDVDMFxcdTA1QzNcXHUwNUM2XFx1MDVGM1xcdTA1RjRcXHUwNjA5XFx1MDYwQVxcdTA2MENcXHUwNjBEXFx1MDYxQlxcdTA2MUVcXHUwNjFGXFx1MDY2QS1cXHUwNjZEXFx1MDZENFxcdTA3MDAtXFx1MDcwRFxcdTA3RjctXFx1MDdGOVxcdTA4MzAtXFx1MDgzRVxcdTA4NUVcXHUwOTY0XFx1MDk2NVxcdTA5NzBcXHUwQUYwXFx1MERGNFxcdTBFNEZcXHUwRTVBXFx1MEU1QlxcdTBGMDQtXFx1MEYxMlxcdTBGMTRcXHUwRjNBLVxcdTBGM0RcXHUwRjg1XFx1MEZEMC1cXHUwRkQ0XFx1MEZEOVxcdTBGREFcXHUxMDRBLVxcdTEwNEZcXHUxMEZCXFx1MTM2MC1cXHUxMzY4XFx1MTQwMFxcdTE2NkRcXHUxNjZFXFx1MTY5QlxcdTE2OUNcXHUxNkVCLVxcdTE2RURcXHUxNzM1XFx1MTczNlxcdTE3RDQtXFx1MTdENlxcdTE3RDgtXFx1MTdEQVxcdTE4MDAtXFx1MTgwQVxcdTE5NDRcXHUxOTQ1XFx1MUExRVxcdTFBMUZcXHUxQUEwLVxcdTFBQTZcXHUxQUE4LVxcdTFBQURcXHUxQjVBLVxcdTFCNjBcXHUxQkZDLVxcdTFCRkZcXHUxQzNCLVxcdTFDM0ZcXHUxQzdFXFx1MUM3RlxcdTFDQzAtXFx1MUNDN1xcdTFDRDNcXHUyMDEwLVxcdTIwMjdcXHUyMDMwLVxcdTIwNDNcXHUyMDQ1LVxcdTIwNTFcXHUyMDUzLVxcdTIwNUVcXHUyMDdEXFx1MjA3RVxcdTIwOERcXHUyMDhFXFx1MjMyOVxcdTIzMkFcXHUyNzY4LVxcdTI3NzVcXHUyN0M1XFx1MjdDNlxcdTI3RTYtXFx1MjdFRlxcdTI5ODMtXFx1Mjk5OFxcdTI5RDgtXFx1MjlEQlxcdTI5RkNcXHUyOUZEXFx1MkNGOS1cXHUyQ0ZDXFx1MkNGRVxcdTJDRkZcXHUyRDcwXFx1MkUwMC1cXHUyRTJFXFx1MkUzMC1cXHUyRTNCXFx1MzAwMS1cXHUzMDAzXFx1MzAwOC1cXHUzMDExXFx1MzAxNC1cXHUzMDFGXFx1MzAzMFxcdTMwM0RcXHUzMEEwXFx1MzBGQlxcdUE0RkVcXHVBNEZGXFx1QTYwRC1cXHVBNjBGXFx1QTY3M1xcdUE2N0VcXHVBNkYyLVxcdUE2RjdcXHVBODc0LVxcdUE4NzdcXHVBOENFXFx1QThDRlxcdUE4RjgtXFx1QThGQVxcdUE5MkVcXHVBOTJGXFx1QTk1RlxcdUE5QzEtXFx1QTlDRFxcdUE5REVcXHVBOURGXFx1QUE1Qy1cXHVBQTVGXFx1QUFERVxcdUFBREZcXHVBQUYwXFx1QUFGMVxcdUFCRUJcXHVGRDNFXFx1RkQzRlxcdUZFMTAtXFx1RkUxOVxcdUZFMzAtXFx1RkU1MlxcdUZFNTQtXFx1RkU2MVxcdUZFNjNcXHVGRTY4XFx1RkU2QVxcdUZFNkJcXHVGRjAxLVxcdUZGMDNcXHVGRjA1LVxcdUZGMEFcXHVGRjBDLVxcdUZGMEZcXHVGRjFBXFx1RkYxQlxcdUZGMUZcXHVGRjIwXFx1RkYzQi1cXHVGRjNEXFx1RkYzRlxcdUZGNUJcXHVGRjVEXFx1RkY1Ri1cXHVGRjY1XS87XG52YXIgQ0hBTUVMRU9OID0gL1snXFx1MjAxOFxcdTIwMTldLztcbnZhciBTVVJST0dBVEVfU1RBUlQgPSAweGQ4MDA7XG52YXIgU1VSUk9HQVRFX0VORCA9IDB4ZGZmZjtcbnZhciBaRVJPX1dJRFRIX0pPSU5FUiA9IDB4MjAwZDtcbi8qKlxyXG4gKiBHZXQgdGhlIGRpc3RhbmNlIHRvIHRoZSBlbmQgb2YgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBhIHN0cmluZyBvZiB0ZXh0LlxyXG4gKi9cblxudmFyIGdldENoYXJhY3RlckRpc3RhbmNlID0gdGV4dCA9PiB7XG4gIHZhciBvZmZzZXQgPSAwOyAvLyBwcmV2IHR5cGVzOlxuICAvLyBTVVJSOiBzdXJyb2dhdGUgcGFpclxuICAvLyBNT0Q6IG1vZGlmaWVyICh0ZWNobmljYWxseSBhbHNvIHN1cnJvZ2F0ZSBwYWlyKVxuICAvLyBaV0o6IHplcm8gd2lkdGggam9pbmVyXG4gIC8vIFZBUjogdmFyaWF0aW9uIHNlbGVjdG9yXG4gIC8vIEJNUDogc2VxdWVuY2VhYmxlIGNoYXJhY3RlciBmcm9tIGJhc2ljIG11bHRpbGluZ3VhbCBwbGFuZVxuXG4gIHZhciBwcmV2ID0gbnVsbDtcbiAgdmFyIGNoYXJDb2RlID0gdGV4dC5jaGFyQ29kZUF0KDApO1xuXG4gIHdoaWxlIChjaGFyQ29kZSkge1xuICAgIGlmIChpc1N1cnJvZ2F0ZShjaGFyQ29kZSkpIHtcbiAgICAgIHZhciBtb2RpZmllciA9IGlzTW9kaWZpZXIoY2hhckNvZGUsIHRleHQsIG9mZnNldCk7IC8vIEVhcmx5IHJldHVybnMgYXJlIHRoZSBoZWFydCBvZiB0aGlzIGZ1bmN0aW9uLCB3aGVyZSB3ZSBkZWNpZGUgaWYgcHJldmlvdXMgYW5kIGN1cnJlbnRcbiAgICAgIC8vIGNvZGVwb2ludHMgc2hvdWxkIGZvcm0gYSBzaW5nbGUgY2hhcmFjdGVyIChpbiB0ZXJtcyBvZiBob3cgbWFueSBvZiB0aGVtIHNob3VsZCBzZWxlY3Rpb25cbiAgICAgIC8vIGp1bXAgb3ZlcikuXG5cbiAgICAgIGlmIChwcmV2ID09PSAnU1VSUicgfHwgcHJldiA9PT0gJ0JNUCcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIG9mZnNldCArPSAyO1xuICAgICAgcHJldiA9IG1vZGlmaWVyID8gJ01PRCcgOiAnU1VSUic7XG4gICAgICBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChvZmZzZXQpOyAvLyBBYnNvbHV0ZWx5IGZpbmUgdG8gYGNvbnRpbnVlYCB3aXRob3V0IGFueSBjaGVja3MgYmVjYXVzZSBpZiBgY2hhckNvZGVgIGlzIE5hTiAod2hpY2hcbiAgICAgIC8vIGlzIHRoZSBjYXNlIHdoZW4gb3V0IG9mIGB0ZXh0YCByYW5nZSksIG5leHQgYHdoaWxlYCBsb29wIHdvblwidCBleGVjdXRlIGFuZCB3ZVwicmUgZG9uZS5cblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGNoYXJDb2RlID09PSBaRVJPX1dJRFRIX0pPSU5FUikge1xuICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICBwcmV2ID0gJ1pXSic7XG4gICAgICBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChvZmZzZXQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGlzQk1QRW1vamkoY2hhckNvZGUpKSB7XG4gICAgICBpZiAocHJldiAmJiBwcmV2ICE9PSAnWldKJyAmJiBwcmV2ICE9PSAnVkFSJykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICBwcmV2ID0gJ0JNUCc7XG4gICAgICBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChvZmZzZXQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGlzVmFyaWF0aW9uU2VsZWN0b3IoY2hhckNvZGUpKSB7XG4gICAgICBpZiAocHJldiAmJiBwcmV2ICE9PSAnWldKJykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICBwcmV2ID0gJ1ZBUic7XG4gICAgICBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChvZmZzZXQpO1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBNb2RpZmllciAnZ3JvdXBzIHVwJyB3aXRoIHdoYXQgZXZlciBjaGFyYWN0ZXIgaXMgYmVmb3JlIHRoYXQgKGV2ZW4gd2hpdGVzcGFjZSksIG5lZWQgdG9cbiAgICAvLyBsb29rIGFoZWFkLlxuXG5cbiAgICBpZiAocHJldiA9PT0gJ01PRCcpIHtcbiAgICAgIG9mZnNldCArPSAxO1xuICAgICAgYnJlYWs7XG4gICAgfSAvLyBJZiB3aGlsZSBsb29wIGV2ZXIgZ2V0cyBoZXJlLCB3ZSdyZSBkb25lIChlLmcgbGF0aW4gY2hhcnMpLlxuXG5cbiAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgfHwgMTtcbn07XG4vKipcclxuICogR2V0IHRoZSBkaXN0YW5jZSB0byB0aGUgZW5kIG9mIHRoZSBmaXJzdCB3b3JkIGluIGEgc3RyaW5nIG9mIHRleHQuXHJcbiAqL1xuXG52YXIgZ2V0V29yZERpc3RhbmNlID0gdGV4dCA9PiB7XG4gIHZhciBsZW5ndGggPSAwO1xuICB2YXIgaSA9IDA7XG4gIHZhciBzdGFydGVkID0gZmFsc2U7XG4gIHZhciBjaGFyO1xuXG4gIHdoaWxlIChjaGFyID0gdGV4dC5jaGFyQXQoaSkpIHtcbiAgICB2YXIgbCA9IGdldENoYXJhY3RlckRpc3RhbmNlKGNoYXIpO1xuICAgIGNoYXIgPSB0ZXh0LnNsaWNlKGksIGkgKyBsKTtcbiAgICB2YXIgcmVzdCA9IHRleHQuc2xpY2UoaSArIGwpO1xuXG4gICAgaWYgKGlzV29yZENoYXJhY3RlcihjaGFyLCByZXN0KSkge1xuICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICBsZW5ndGggKz0gbDtcbiAgICB9IGVsc2UgaWYgKCFzdGFydGVkKSB7XG4gICAgICBsZW5ndGggKz0gbDtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaSArPSBsO1xuICB9XG5cbiAgcmV0dXJuIGxlbmd0aDtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSBjaGFyYWN0ZXIgaXMgYSB3b3JkIGNoYXJhY3Rlci4gVGhlIGByZW1haW5pbmdgIGFyZ3VtZW50IGlzIHVzZWRcclxuICogYmVjYXVzZSBzb21ldGltZXMgeW91IG11c3QgcmVhZCBzdWJzZXF1ZW50IGNoYXJhY3RlcnMgdG8gdHJ1bHkgZGV0ZXJtaW5lIGl0LlxyXG4gKi9cblxudmFyIGlzV29yZENoYXJhY3RlciA9IChjaGFyLCByZW1haW5pbmcpID0+IHtcbiAgaWYgKFNQQUNFLnRlc3QoY2hhcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gQ2hhbWVsZW9ucyBjb3VudCBhcyB3b3JkIGNoYXJhY3RlcnMgYXMgbG9uZyBhcyB0aGV5J3JlIGluIGEgd29yZCwgc29cbiAgLy8gcmVjdXJzZSB0byBzZWUgaWYgdGhlIG5leHQgb25lIGlzIGEgd29yZCBjaGFyYWN0ZXIgb3Igbm90LlxuXG5cbiAgaWYgKENIQU1FTEVPTi50ZXN0KGNoYXIpKSB7XG4gICAgdmFyIG5leHQgPSByZW1haW5pbmcuY2hhckF0KDApO1xuICAgIHZhciBsZW5ndGggPSBnZXRDaGFyYWN0ZXJEaXN0YW5jZShuZXh0KTtcbiAgICBuZXh0ID0gcmVtYWluaW5nLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgdmFyIHJlc3QgPSByZW1haW5pbmcuc2xpY2UobGVuZ3RoKTtcblxuICAgIGlmIChpc1dvcmRDaGFyYWN0ZXIobmV4dCwgcmVzdCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChQVU5DVFVBVElPTi50ZXN0KGNoYXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqXHJcbiAqIERldGVybWluZXMgaWYgYGNvZGVgIGlzIGEgc3Vycm9nYXRlXHJcbiAqL1xuXG5cbnZhciBpc1N1cnJvZ2F0ZSA9IGNvZGUgPT4gU1VSUk9HQVRFX1NUQVJUIDw9IGNvZGUgJiYgY29kZSA8PSBTVVJST0dBVEVfRU5EO1xuLyoqXHJcbiAqIERvZXMgYGNvZGVgIGZvcm0gTW9kaWZpZXIgd2l0aCBuZXh0IG9uZS5cclxuICpcclxuICogaHR0cHM6Ly9lbW9qaXBlZGlhLm9yZy9tb2RpZmllcnMvXHJcbiAqL1xuXG5cbnZhciBpc01vZGlmaWVyID0gKGNvZGUsIHRleHQsIG9mZnNldCkgPT4ge1xuICBpZiAoY29kZSA9PT0gMHhkODNjKSB7XG4gICAgdmFyIG5leHQgPSB0ZXh0LmNoYXJDb2RlQXQob2Zmc2V0ICsgMSk7XG4gICAgcmV0dXJuIG5leHQgPD0gMHhkZmZmICYmIG5leHQgPj0gMHhkZmZiO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxyXG4gKiBJcyBgY29kZWAgYSBWYXJpYXRpb24gU2VsZWN0b3IuXHJcbiAqXHJcbiAqIGh0dHBzOi8vY29kZXBvaW50cy5uZXQvdmFyaWF0aW9uX3NlbGVjdG9yc1xyXG4gKi9cblxuXG52YXIgaXNWYXJpYXRpb25TZWxlY3RvciA9IGNvZGUgPT4ge1xuICByZXR1cm4gY29kZSA8PSAweGZlMGYgJiYgY29kZSA+PSAweGZlMDA7XG59O1xuLyoqXHJcbiAqIElzIGBjb2RlYCBvbmUgb2YgdGhlIEJNUCBjb2RlcyB1c2VkIGluIGVtb2ppIHNlcXVlbmNlcy5cclxuICpcclxuICogaHR0cHM6Ly9lbW9qaXBlZGlhLm9yZy9lbW9qaS16d2otc2VxdWVuY2VzL1xyXG4gKi9cblxuXG52YXIgaXNCTVBFbW9qaSA9IGNvZGUgPT4ge1xuICAvLyBUaGlzIHJlcXVpcmVzIHRpbnkgYml0IG9mIG1haW50YW5hbmNlLCBiZXR0ZXIgaWRlYXM/XG4gIC8vIEZvcnR1bmF0ZWx5IGl0IG9ubHkgaGFwcGVucyBpZiBuZXcgVW5pY29kZSBTdGFuZGFyZFxuICAvLyBpcyByZWxlYXNlZC4gRmFpbHMgZ3JhY2VmdWxseSBpZiB1cGtlZXAgbGFncyBiZWhpbmQsXG4gIC8vIHNhbWUgd2F5IFNsYXRlIHByZXZpb3VzbHkgYmVoYXZlZCB3aXRoIGFsbCBlbW9qaXMuXG4gIHJldHVybiBjb2RlID09PSAweDI3NjQgfHwgLy8gaGVhcnQgKOKdpClcbiAgY29kZSA9PT0gMHgyNjQyIHx8IC8vIG1hbGUgKOKZgilcbiAgY29kZSA9PT0gMHgyNjQwIHx8IC8vIGZlbWFsZSAo4pmAKVxuICBjb2RlID09PSAweDI2MjAgfHwgLy8gc2N1bGwgKOKYoClcbiAgY29kZSA9PT0gMHgyNjk1IHx8IC8vIG1lZGljYWwgKOKalSlcbiAgY29kZSA9PT0gMHgyNzA4IHx8IC8vIHBsYW5lICjinIjvuI8pXG4gIGNvZGUgPT09IDB4MjVlZiAvLyBsYXJnZSBjaXJjbGUgKOKXrylcbiAgO1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG52YXIgRWRpdG9yID0ge1xuICAvKipcclxuICAgKiBHZXQgdGhlIGFuY2VzdG9yIGFib3ZlIGEgbG9jYXRpb24gaW4gdGhlIGRvY3VtZW50LlxyXG4gICAqL1xuICBhYm92ZShlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHZvaWRzID0gZmFsc2UsXG4gICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBtYXRjaFxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCk7XG4gICAgdmFyIHJldmVyc2UgPSBtb2RlID09PSAnbG93ZXN0JztcblxuICAgIGZvciAodmFyIFtuLCBwXSBvZiBFZGl0b3IubGV2ZWxzKGVkaXRvciwge1xuICAgICAgYXQ6IHBhdGgsXG4gICAgICB2b2lkcyxcbiAgICAgIG1hdGNoLFxuICAgICAgcmV2ZXJzZVxuICAgIH0pKSB7XG4gICAgICBpZiAoIVRleHQuaXNUZXh0KG4pICYmICFQYXRoLmVxdWFscyhwYXRoLCBwKSkge1xuICAgICAgICByZXR1cm4gW24sIHBdO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBBZGQgYSBjdXN0b20gcHJvcGVydHkgdG8gdGhlIGxlYWYgdGV4dCBub2RlcyBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBjb2xsYXBzZWQsIHRoZSBtYXJrcyB3aWxsIGJlIGFkZGVkIHRvIHRoZVxyXG4gICAqIGBlZGl0b3IubWFya3NgIHByb3BlcnR5IGluc3RlYWQsIGFuZCBhcHBsaWVkIHdoZW4gdGV4dCBpcyBpbnNlcnRlZCBuZXh0LlxyXG4gICAqL1xuICBhZGRNYXJrKGVkaXRvciwga2V5LCB2YWx1ZSkge1xuICAgIGVkaXRvci5hZGRNYXJrKGtleSwgdmFsdWUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcG9pbnQgYWZ0ZXIgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgYWZ0ZXIoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgYW5jaG9yID0gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdlbmQnXG4gICAgfSk7XG4gICAgdmFyIGZvY3VzID0gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH07XG4gICAgdmFyIHtcbiAgICAgIGRpc3RhbmNlID0gMVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBkID0gMDtcbiAgICB2YXIgdGFyZ2V0O1xuXG4gICAgZm9yICh2YXIgcCBvZiBFZGl0b3IucG9zaXRpb25zKGVkaXRvciwgX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucywge1xuICAgICAgYXQ6IHJhbmdlXG4gICAgfSkpKSB7XG4gICAgICBpZiAoZCA+IGRpc3RhbmNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoZCAhPT0gMCkge1xuICAgICAgICB0YXJnZXQgPSBwO1xuICAgICAgfVxuXG4gICAgICBkKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHBvaW50IGJlZm9yZSBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBiZWZvcmUoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgYW5jaG9yID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgW10pO1xuICAgIHZhciBmb2N1cyA9IEVkaXRvci5wb2ludChlZGl0b3IsIGF0LCB7XG4gICAgICBlZGdlOiAnc3RhcnQnXG4gICAgfSk7XG4gICAgdmFyIHJhbmdlID0ge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9O1xuICAgIHZhciB7XG4gICAgICBkaXN0YW5jZSA9IDFcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgZCA9IDA7XG4gICAgdmFyIHRhcmdldDtcblxuICAgIGZvciAodmFyIHAgb2YgRWRpdG9yLnBvc2l0aW9ucyhlZGl0b3IsIF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICAgIGF0OiByYW5nZSxcbiAgICAgIHJldmVyc2U6IHRydWVcbiAgICB9KSkpIHtcbiAgICAgIGlmIChkID4gZGlzdGFuY2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChkICE9PSAwKSB7XG4gICAgICAgIHRhcmdldCA9IHA7XG4gICAgICB9XG5cbiAgICAgIGQrKztcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIERlbGV0ZSBjb250ZW50IGluIHRoZSBlZGl0b3IgYmFja3dhcmQgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICovXG4gIGRlbGV0ZUJhY2t3YXJkKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgdW5pdCA9ICdjaGFyYWN0ZXInXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgZWRpdG9yLmRlbGV0ZUJhY2t3YXJkKHVuaXQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIERlbGV0ZSBjb250ZW50IGluIHRoZSBlZGl0b3IgZm9yd2FyZCBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKi9cbiAgZGVsZXRlRm9yd2FyZChlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHVuaXQgPSAnY2hhcmFjdGVyJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIGVkaXRvci5kZWxldGVGb3J3YXJkKHVuaXQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIERlbGV0ZSB0aGUgY29udGVudCBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICovXG4gIGRlbGV0ZUZyYWdtZW50KGVkaXRvcikge1xuICAgIGVkaXRvci5kZWxldGVGcmFnbWVudCgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgZWRnZXMoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBbRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpLCBFZGl0b3IuZW5kKGVkaXRvciwgYXQpXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGVuZCBwb2ludCBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBlbmQoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ2VuZCdcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGZpcnN0IG5vZGUgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgZmlyc3QoZWRpdG9yLCBhdCkge1xuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ3N0YXJ0J1xuICAgIH0pO1xuICAgIHJldHVybiBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZnJhZ21lbnQgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgZnJhZ21lbnQoZWRpdG9yLCBhdCkge1xuICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICB2YXIgZnJhZ21lbnQgPSBOb2RlLmZyYWdtZW50KGVkaXRvciwgcmFuZ2UpO1xuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIG5vZGUgaGFzIGJsb2NrIGNoaWxkcmVuLlxyXG4gICAqL1xuICBoYXNCbG9ja3MoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4uc29tZShuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbikpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgbm9kZSBoYXMgaW5saW5lIGFuZCB0ZXh0IGNoaWxkcmVuLlxyXG4gICAqL1xuICBoYXNJbmxpbmVzKGVkaXRvciwgZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LmNoaWxkcmVuLnNvbWUobiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBub2RlIGhhcyB0ZXh0IGNoaWxkcmVuLlxyXG4gICAqL1xuICBoYXNUZXh0cyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jaGlsZHJlbi5ldmVyeShuID0+IFRleHQuaXNUZXh0KG4pKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgYSBibG9jayBicmVhayBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBleHBhbmRlZCwgaXQgd2lsbCBiZSBkZWxldGVkIGZpcnN0LlxyXG4gICAqL1xuICBpbnNlcnRCcmVhayhlZGl0b3IpIHtcbiAgICBlZGl0b3IuaW5zZXJ0QnJlYWsoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgYSBmcmFnbWVudCBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBleHBhbmRlZCwgaXQgd2lsbCBiZSBkZWxldGVkIGZpcnN0LlxyXG4gICAqL1xuICBpbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50KSB7XG4gICAgZWRpdG9yLmluc2VydEZyYWdtZW50KGZyYWdtZW50KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgYSBub2RlIGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGV4cGFuZGVkLCBpdCB3aWxsIGJlIGRlbGV0ZWQgZmlyc3QuXHJcbiAgICovXG4gIGluc2VydE5vZGUoZWRpdG9yLCBub2RlKSB7XG4gICAgZWRpdG9yLmluc2VydE5vZGUobm9kZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IHRleHQgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIHNlbGVjdGlvbiBpcyBjdXJyZW50bHkgZXhwYW5kZWQsIGl0IHdpbGwgYmUgZGVsZXRlZCBmaXJzdC5cclxuICAgKi9cbiAgaW5zZXJ0VGV4dChlZGl0b3IsIHRleHQpIHtcbiAgICBlZGl0b3IuaW5zZXJ0VGV4dCh0ZXh0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgYmxvY2sgYEVsZW1lbnRgIG9iamVjdC5cclxuICAgKi9cbiAgaXNCbG9jayhlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KHZhbHVlKSAmJiAhZWRpdG9yLmlzSW5saW5lKHZhbHVlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGBFZGl0b3JgIG9iamVjdC5cclxuICAgKi9cbiAgaXNFZGl0b3IodmFsdWUpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlLmFkZE1hcmsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmFwcGx5ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5kZWxldGVCYWNrd2FyZCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuZGVsZXRlRm9yd2FyZCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuZGVsZXRlRnJhZ21lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydEJyZWFrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnRGcmFnbWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0Tm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0VGV4dCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaXNJbmxpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmlzVm9pZCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUubm9ybWFsaXplTm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUub25DaGFuZ2UgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLnJlbW92ZU1hcmsgPT09ICdmdW5jdGlvbicgJiYgKHZhbHVlLm1hcmtzID09PSBudWxsIHx8IGlzUGxhaW5PYmplY3QodmFsdWUubWFya3MpKSAmJiAodmFsdWUuc2VsZWN0aW9uID09PSBudWxsIHx8IFJhbmdlLmlzUmFuZ2UodmFsdWUuc2VsZWN0aW9uKSkgJiYgTm9kZS5pc05vZGVMaXN0KHZhbHVlLmNoaWxkcmVuKSAmJiBPcGVyYXRpb24uaXNPcGVyYXRpb25MaXN0KHZhbHVlLm9wZXJhdGlvbnMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgdGhlIGVuZCBwb2ludCBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBpc0VuZChlZGl0b3IsIHBvaW50LCBhdCkge1xuICAgIHZhciBlbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgYXQpO1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMocG9pbnQsIGVuZCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyBhbiBlZGdlIG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGlzRWRnZShlZGl0b3IsIHBvaW50LCBhdCkge1xuICAgIHJldHVybiBFZGl0b3IuaXNTdGFydChlZGl0b3IsIHBvaW50LCBhdCkgfHwgRWRpdG9yLmlzRW5kKGVkaXRvciwgcG9pbnQsIGF0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGVtcHR5LCBhY2NvdW50aW5nIGZvciB2b2lkIG5vZGVzLlxyXG4gICAqL1xuICBpc0VtcHR5KGVkaXRvciwgZWxlbWVudCkge1xuICAgIHZhciB7XG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBlbGVtZW50O1xuICAgIHZhciBbZmlyc3RdID0gY2hpbGRyZW47XG4gICAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgVGV4dC5pc1RleHQoZmlyc3QpICYmIGZpcnN0LnRleHQgPT09ICcnICYmICFlZGl0b3IuaXNWb2lkKGVsZW1lbnQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gaW5saW5lIGBFbGVtZW50YCBvYmplY3QuXHJcbiAgICovXG4gIGlzSW5saW5lKGVkaXRvciwgdmFsdWUpIHtcbiAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQodmFsdWUpICYmIGVkaXRvci5pc0lubGluZSh2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIGVkaXRvciBpcyBjdXJyZW50bHkgbm9ybWFsaXppbmcgYWZ0ZXIgZWFjaCBvcGVyYXRpb24uXHJcbiAgICovXG4gIGlzTm9ybWFsaXppbmcoZWRpdG9yKSB7XG4gICAgdmFyIGlzTm9ybWFsaXppbmcgPSBOT1JNQUxJWklORy5nZXQoZWRpdG9yKTtcbiAgICByZXR1cm4gaXNOb3JtYWxpemluZyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGlzTm9ybWFsaXppbmc7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyB0aGUgc3RhcnQgcG9pbnQgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgaXNTdGFydChlZGl0b3IsIHBvaW50LCBhdCkge1xuICAgIC8vIFBFUkY6IElmIHRoZSBvZmZzZXQgaXNuJ3QgYDBgIHdlIGtub3cgaXQncyBub3QgdGhlIHN0YXJ0LlxuICAgIGlmIChwb2ludC5vZmZzZXQgIT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhdCk7XG4gICAgcmV0dXJuIFBvaW50LmVxdWFscyhwb2ludCwgc3RhcnQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSB2b2lkIGBFbGVtZW50YCBvYmplY3QuXHJcbiAgICovXG4gIGlzVm9pZChlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KHZhbHVlKSAmJiBlZGl0b3IuaXNWb2lkKHZhbHVlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGxhc3Qgbm9kZSBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBsYXN0KGVkaXRvciwgYXQpIHtcbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdlbmQnXG4gICAgfSk7XG4gICAgcmV0dXJuIEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBsZWFmIHRleHQgbm9kZSBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBsZWFmKGVkaXRvciwgYXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCBvcHRpb25zKTtcbiAgICB2YXIgbm9kZSA9IE5vZGUubGVhZihlZGl0b3IsIHBhdGgpO1xuICAgIHJldHVybiBbbm9kZSwgcGF0aF07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUgbGV2ZWxzIGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gICpsZXZlbHMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICByZXZlcnNlID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSAoKSA9PiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGV2ZWxzID0gW107XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0KTtcblxuICAgIGZvciAodmFyIFtuLCBwXSBvZiBOb2RlLmxldmVscyhlZGl0b3IsIHBhdGgpKSB7XG4gICAgICBpZiAoIW1hdGNoKG4pKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXZlbHMucHVzaChbbiwgcF0pO1xuXG4gICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBuKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgbGV2ZWxzLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICB5aWVsZCogbGV2ZWxzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbWFya3MgdGhhdCB3b3VsZCBiZSBhZGRlZCB0byB0ZXh0IGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKi9cbiAgbWFya3MoZWRpdG9yKSB7XG4gICAgdmFyIHtcbiAgICAgIG1hcmtzLFxuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAobWFya3MpIHtcbiAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG5cbiAgICBpZiAoUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICB2YXIgW21hdGNoXSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0XG4gICAgICB9KTtcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhciBbX25vZGVdID0gbWF0Y2g7XG5cbiAgICAgICAgdmFyIF9yZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9ub2RlLCBbXCJ0ZXh0XCJdKTtcblxuICAgICAgICByZXR1cm4gX3Jlc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIGFuY2hvclxuICAgIH0gPSBzZWxlY3Rpb247XG4gICAgdmFyIHtcbiAgICAgIHBhdGhcbiAgICB9ID0gYW5jaG9yO1xuICAgIHZhciBbbm9kZV0gPSBFZGl0b3IubGVhZihlZGl0b3IsIHBhdGgpO1xuXG4gICAgaWYgKGFuY2hvci5vZmZzZXQgPT09IDApIHtcbiAgICAgIHZhciBwcmV2ID0gRWRpdG9yLnByZXZpb3VzKGVkaXRvciwge1xuICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0XG4gICAgICB9KTtcbiAgICAgIHZhciBibG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChwcmV2ICYmIGJsb2NrKSB7XG4gICAgICAgIHZhciBbcHJldk5vZGUsIHByZXZQYXRoXSA9IHByZXY7XG4gICAgICAgIHZhciBbLCBibG9ja1BhdGhdID0gYmxvY2s7XG5cbiAgICAgICAgaWYgKFBhdGguaXNBbmNlc3RvcihibG9ja1BhdGgsIHByZXZQYXRoKSkge1xuICAgICAgICAgIG5vZGUgPSBwcmV2Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIFtcInRleHRcIl0pO1xuXG4gICAgcmV0dXJuIHJlc3Q7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBtYXRjaGluZyBub2RlIGluIHRoZSBicmFuY2ggb2YgdGhlIGRvY3VtZW50IGFmdGVyIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIG5leHQoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoLFxuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIFssIGZyb21dID0gRWRpdG9yLmxhc3QoZWRpdG9yLCBhdCk7XG4gICAgdmFyIFssIHRvXSA9IEVkaXRvci5sYXN0KGVkaXRvciwgW10pO1xuICAgIHZhciBzcGFuID0gW2Zyb20sIHRvXTtcblxuICAgIGlmIChQYXRoLmlzUGF0aChhdCkgJiYgYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBuZXh0IG5vZGUgZnJvbSB0aGUgcm9vdCBub2RlIVwiKTtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICB2YXIgW3BhcmVudF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgYXQpO1xuXG4gICAgICAgIG1hdGNoID0gbiA9PiBwYXJlbnQuY2hpbGRyZW4uaW5jbHVkZXMobik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaCA9ICgpID0+IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFssIG5leHRdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IHNwYW4sXG4gICAgICBtYXRjaCxcbiAgICAgIG1vZGUsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbm9kZSBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBub2RlKGVkaXRvciwgYXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCBvcHRpb25zKTtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gICAgcmV0dXJuIFtub2RlLCBwYXRoXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBub2RlcyBpbiB0aGUgRWRpdG9yLlxyXG4gICAqL1xuICAqbm9kZXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBtb2RlID0gJ2FsbCcsXG4gICAgICB1bml2ZXJzYWwgPSBmYWxzZSxcbiAgICAgIHJldmVyc2UgPSBmYWxzZSxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgbWF0Y2hcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIG1hdGNoID0gKCkgPT4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZyb207XG4gICAgdmFyIHRvO1xuXG4gICAgaWYgKFNwYW4uaXNTcGFuKGF0KSkge1xuICAgICAgZnJvbSA9IGF0WzBdO1xuICAgICAgdG8gPSBhdFsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZpcnN0ID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgICBlZGdlOiAnc3RhcnQnXG4gICAgICB9KTtcbiAgICAgIHZhciBsYXN0ID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgICBlZGdlOiAnZW5kJ1xuICAgICAgfSk7XG4gICAgICBmcm9tID0gcmV2ZXJzZSA/IGxhc3QgOiBmaXJzdDtcbiAgICAgIHRvID0gcmV2ZXJzZSA/IGZpcnN0IDogbGFzdDtcbiAgICB9XG5cbiAgICB2YXIgaXRlcmFibGUgPSBOb2RlLm5vZGVzKGVkaXRvciwge1xuICAgICAgcmV2ZXJzZSxcbiAgICAgIGZyb20sXG4gICAgICB0byxcbiAgICAgIHBhc3M6IChfcmVmKSA9PiB7XG4gICAgICAgIHZhciBbbl0gPSBfcmVmO1xuICAgICAgICByZXR1cm4gdm9pZHMgPyBmYWxzZSA6IEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBuKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgIHZhciBoaXQ7XG5cbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgaXRlcmFibGUpIHtcbiAgICAgIHZhciBpc0xvd2VyID0gaGl0ICYmIFBhdGguY29tcGFyZShwYXRoLCBoaXRbMV0pID09PSAwOyAvLyBJbiBoaWdoZXN0IG1vZGUgYW55IG5vZGUgbG93ZXIgdGhhbiB0aGUgbGFzdCBoaXQgaXMgbm90IGEgbWF0Y2guXG5cbiAgICAgIGlmIChtb2RlID09PSAnaGlnaGVzdCcgJiYgaXNMb3dlcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFtYXRjaChub2RlKSkge1xuICAgICAgICAvLyBJZiB3ZSd2ZSBhcnJpdmVkIGF0IGEgbGVhZiB0ZXh0IG5vZGUgdGhhdCBpcyBub3QgbG93ZXIgdGhhbiB0aGUgbGFzdFxuICAgICAgICAvLyBoaXQsIHRoZW4gd2UndmUgZm91bmQgYSBicmFuY2ggdGhhdCBkb2Vzbid0IGluY2x1ZGUgYSBtYXRjaCwgd2hpY2hcbiAgICAgICAgLy8gbWVhbnMgdGhlIG1hdGNoIGlzIG5vdCB1bml2ZXJzYWwuXG4gICAgICAgIGlmICh1bml2ZXJzYWwgJiYgIWlzTG93ZXIgJiYgVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gSWYgdGhlcmUncyBhIG1hdGNoIGFuZCBpdCdzIGxvd2VyIHRoYW4gdGhlIGxhc3QsIHVwZGF0ZSB0aGUgaGl0LlxuXG5cbiAgICAgIGlmIChtb2RlID09PSAnbG93ZXN0JyAmJiBpc0xvd2VyKSB7XG4gICAgICAgIGhpdCA9IFtub2RlLCBwYXRoXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIEluIGxvd2VzdCBtb2RlIHdlIGVtaXQgdGhlIGxhc3QgaGl0LCBvbmNlIGl0J3MgZ3VhcmFudGVlZCBsb3dlc3QuXG5cblxuICAgICAgdmFyIGVtaXQgPSBtb2RlID09PSAnbG93ZXN0JyA/IGhpdCA6IFtub2RlLCBwYXRoXTtcblxuICAgICAgaWYgKGVtaXQpIHtcbiAgICAgICAgaWYgKHVuaXZlcnNhbCkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaChlbWl0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5aWVsZCBlbWl0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGhpdCA9IFtub2RlLCBwYXRoXTtcbiAgICB9IC8vIFNpbmNlIGxvd2VzdCBpcyBhbHdheXMgZW1pdHRpbmcgb25lIGJlaGluZCwgY2F0Y2ggdXAgYXQgdGhlIGVuZC5cblxuXG4gICAgaWYgKG1vZGUgPT09ICdsb3dlc3QnICYmIGhpdCkge1xuICAgICAgaWYgKHVuaXZlcnNhbCkge1xuICAgICAgICBtYXRjaGVzLnB1c2goaGl0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIGhpdDtcbiAgICAgIH1cbiAgICB9IC8vIFVuaXZlcnNhbCBkZWZlcnMgdG8gZW5zdXJlIHRoYXQgdGhlIG1hdGNoIG9jY3VycyBpbiBldmVyeSBicmFuY2gsIHNvIHdlXG4gICAgLy8geWllbGQgYWxsIG9mIHRoZSBtYXRjaGVzIGFmdGVyIGl0ZXJhdGluZy5cblxuXG4gICAgaWYgKHVuaXZlcnNhbCkge1xuICAgICAgeWllbGQqIG1hdGNoZXM7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIE5vcm1hbGl6ZSBhbnkgZGlydHkgb2JqZWN0cyBpbiB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBub3JtYWxpemUoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBmb3JjZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICB2YXIgZ2V0RGlydHlQYXRocyA9IGVkaXRvciA9PiB7XG4gICAgICByZXR1cm4gRElSVFlfUEFUSFMuZ2V0KGVkaXRvcikgfHwgW107XG4gICAgfTtcblxuICAgIGlmICghRWRpdG9yLmlzTm9ybWFsaXppbmcoZWRpdG9yKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChmb3JjZSkge1xuICAgICAgdmFyIGFsbFBhdGhzID0gQXJyYXkuZnJvbShOb2RlLm5vZGVzKGVkaXRvciksIChfcmVmMikgPT4ge1xuICAgICAgICB2YXIgWywgcF0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9KTtcbiAgICAgIERJUlRZX1BBVEhTLnNldChlZGl0b3IsIGFsbFBhdGhzKTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0RGlydHlQYXRocyhlZGl0b3IpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIgbWF4ID0gZ2V0RGlydHlQYXRocyhlZGl0b3IpLmxlbmd0aCAqIDQyOyAvLyBIQUNLOiBiZXR0ZXIgd2F5P1xuXG4gICAgICB2YXIgbSA9IDA7XG5cbiAgICAgIHdoaWxlIChnZXREaXJ0eVBhdGhzKGVkaXRvcikubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGlmIChtID4gbWF4KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxuICAgICAgICAgICAgQ291bGQgbm90IGNvbXBsZXRlbHkgbm9ybWFsaXplIHRoZSBlZGl0b3IgYWZ0ZXIgXCIuY29uY2F0KG1heCwgXCIgaXRlcmF0aW9ucyEgVGhpcyBpcyB1c3VhbGx5IGR1ZSB0byBpbmNvcnJlY3Qgbm9ybWFsaXphdGlvbiBsb2dpYyB0aGF0IGxlYXZlcyBhIG5vZGUgaW4gYW4gaW52YWxpZCBzdGF0ZS5cXG4gICAgICAgICAgXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXRoID0gZ2V0RGlydHlQYXRocyhlZGl0b3IpLnBvcCgpO1xuICAgICAgICB2YXIgZW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xuICAgICAgICBlZGl0b3Iubm9ybWFsaXplTm9kZShlbnRyeSk7XG4gICAgICAgIG0rKztcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHBhcmVudCBub2RlIG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHBhcmVudChlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwgb3B0aW9ucyk7XG4gICAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChwYXRoKTtcbiAgICB2YXIgZW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhcmVudFBhdGgpO1xuICAgIHJldHVybiBlbnRyeTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHBhdGggb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgcGF0aChlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBkZXB0aCxcbiAgICAgIGVkZ2VcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHZhciBbLCBmaXJzdFBhdGhdID0gTm9kZS5maXJzdChlZGl0b3IsIGF0KTtcbiAgICAgICAgYXQgPSBmaXJzdFBhdGg7XG4gICAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICAgIHZhciBbLCBsYXN0UGF0aF0gPSBOb2RlLmxhc3QoZWRpdG9yLCBhdCk7XG4gICAgICAgIGF0ID0gbGFzdFBhdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBhdCA9IFJhbmdlLnN0YXJ0KGF0KTtcbiAgICAgIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgYXQgPSBSYW5nZS5lbmQoYXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXQgPSBQYXRoLmNvbW1vbihhdC5hbmNob3IucGF0aCwgYXQuZm9jdXMucGF0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFBvaW50LmlzUG9pbnQoYXQpKSB7XG4gICAgICBhdCA9IGF0LnBhdGg7XG4gICAgfVxuXG4gICAgaWYgKGRlcHRoICE9IG51bGwpIHtcbiAgICAgIGF0ID0gYXQuc2xpY2UoMCwgZGVwdGgpO1xuICAgIH1cblxuICAgIHJldHVybiBhdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBtdXRhYmxlIHJlZiBmb3IgYSBgUGF0aGAgb2JqZWN0LCB3aGljaCB3aWxsIHN0YXkgaW4gc3luYyBhcyBuZXdcclxuICAgKiBvcGVyYXRpb25zIGFyZSBhcHBsaWVkIHRvIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIHBhdGhSZWYoZWRpdG9yLCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBhZmZpbml0eSA9ICdmb3J3YXJkJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciByZWYgPSB7XG4gICAgICBjdXJyZW50OiBwYXRoLFxuICAgICAgYWZmaW5pdHksXG5cbiAgICAgIHVucmVmKCkge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgfSA9IHJlZjtcbiAgICAgICAgdmFyIHBhdGhSZWZzID0gRWRpdG9yLnBhdGhSZWZzKGVkaXRvcik7XG4gICAgICAgIHBhdGhSZWZzLmRlbGV0ZShyZWYpO1xuICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuXG4gICAgfTtcbiAgICB2YXIgcmVmcyA9IEVkaXRvci5wYXRoUmVmcyhlZGl0b3IpO1xuICAgIHJlZnMuYWRkKHJlZik7XG4gICAgcmV0dXJuIHJlZjtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHNldCBvZiBjdXJyZW50bHkgdHJhY2tlZCBwYXRoIHJlZnMgb2YgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcGF0aFJlZnMoZWRpdG9yKSB7XG4gICAgdmFyIHJlZnMgPSBQQVRIX1JFRlMuZ2V0KGVkaXRvcik7XG5cbiAgICBpZiAoIXJlZnMpIHtcbiAgICAgIHJlZnMgPSBuZXcgU2V0KCk7XG4gICAgICBQQVRIX1JFRlMuc2V0KGVkaXRvciwgcmVmcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZnM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzdGFydCBvciBlbmQgcG9pbnQgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgcG9pbnQoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgZWRnZSA9ICdzdGFydCdcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIHZhciBwYXRoO1xuXG4gICAgICBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgdmFyIFssIGxhc3RQYXRoXSA9IE5vZGUubGFzdChlZGl0b3IsIGF0KTtcbiAgICAgICAgcGF0aCA9IGxhc3RQYXRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIFssIGZpcnN0UGF0aF0gPSBOb2RlLmZpcnN0KGVkaXRvciwgYXQpO1xuICAgICAgICBwYXRoID0gZmlyc3RQYXRoO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG5cbiAgICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgXCIuY29uY2F0KGVkZ2UsIFwiIHBvaW50IGluIHRoZSBub2RlIGF0IHBhdGggW1wiKS5jb25jYXQoYXQsIFwiXSBiZWNhdXNlIGl0IGhhcyBubyBcIikuY29uY2F0KGVkZ2UsIFwiIHRleHQgbm9kZS5cIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoLFxuICAgICAgICBvZmZzZXQ6IGVkZ2UgPT09ICdlbmQnID8gbm9kZS50ZXh0Lmxlbmd0aCA6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgcmV0dXJuIGVkZ2UgPT09ICdzdGFydCcgPyBzdGFydCA6IGVuZDtcbiAgICB9XG5cbiAgICByZXR1cm4gYXQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbXV0YWJsZSByZWYgZm9yIGEgYFBvaW50YCBvYmplY3QsIHdoaWNoIHdpbGwgc3RheSBpbiBzeW5jIGFzIG5ld1xyXG4gICAqIG9wZXJhdGlvbnMgYXJlIGFwcGxpZWQgdG8gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcG9pbnRSZWYoZWRpdG9yLCBwb2ludCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgYWZmaW5pdHkgPSAnZm9yd2FyZCdcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgcmVmID0ge1xuICAgICAgY3VycmVudDogcG9pbnQsXG4gICAgICBhZmZpbml0eSxcblxuICAgICAgdW5yZWYoKSB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgY3VycmVudFxuICAgICAgICB9ID0gcmVmO1xuICAgICAgICB2YXIgcG9pbnRSZWZzID0gRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpO1xuICAgICAgICBwb2ludFJlZnMuZGVsZXRlKHJlZik7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG5cbiAgICB9O1xuICAgIHZhciByZWZzID0gRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpO1xuICAgIHJlZnMuYWRkKHJlZik7XG4gICAgcmV0dXJuIHJlZjtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHNldCBvZiBjdXJyZW50bHkgdHJhY2tlZCBwb2ludCByZWZzIG9mIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIHBvaW50UmVmcyhlZGl0b3IpIHtcbiAgICB2YXIgcmVmcyA9IFBPSU5UX1JFRlMuZ2V0KGVkaXRvcik7XG5cbiAgICBpZiAoIXJlZnMpIHtcbiAgICAgIHJlZnMgPSBuZXcgU2V0KCk7XG4gICAgICBQT0lOVF9SRUZTLnNldChlZGl0b3IsIHJlZnMpO1xuICAgIH1cblxuICAgIHJldHVybiByZWZzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIHBvc2l0aW9ucyBpbiB0aGUgZG9jdW1lbnQgd2hlcmUgYSBgUG9pbnRgIGNhbiBiZVxyXG4gICAqIHBsYWNlZC5cclxuICAgKlxyXG4gICAqIEJ5IGRlZmF1bHQgaXQgd2lsbCBtb3ZlIGZvcndhcmQgYnkgaW5kaXZpZHVhbCBvZmZzZXRzIGF0IGEgdGltZSwgIGJ1dCB5b3VcclxuICAgKiBjYW4gcGFzcyB0aGUgYHVuaXQ6ICdjaGFyYWN0ZXInYCBvcHRpb24gdG8gbW92ZWQgZm9yd2FyZCBvbmUgY2hhcmFjdGVyLCB3b3JkLFxyXG4gICAqIG9yIGxpbmUgYXQgYXQgdGltZS5cclxuICAgKlxyXG4gICAqIE5vdGU6IHZvaWQgbm9kZXMgYXJlIHRyZWF0ZWQgYXMgYSBzaW5nbGUgcG9pbnQsIGFuZCBpdGVyYXRpb24gd2lsbCBub3RcclxuICAgKiBoYXBwZW4gaW5zaWRlIHRoZWlyIGNvbnRlbnQuXHJcbiAgICovXG4gICpwb3NpdGlvbnMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICB1bml0ID0gJ29mZnNldCcsXG4gICAgICByZXZlcnNlOiByZXZlcnNlJDEgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgIHZhciBmaXJzdCA9IHJldmVyc2UkMSA/IGVuZCA6IHN0YXJ0O1xuICAgIHZhciBzdHJpbmcgPSAnJztcbiAgICB2YXIgYXZhaWxhYmxlID0gMDtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICB2YXIgZGlzdGFuY2UgPSBudWxsO1xuICAgIHZhciBpc05ld0Jsb2NrID0gZmFsc2U7XG5cbiAgICB2YXIgYWR2YW5jZSA9ICgpID0+IHtcbiAgICAgIGlmIChkaXN0YW5jZSA9PSBudWxsKSB7XG4gICAgICAgIGlmICh1bml0ID09PSAnY2hhcmFjdGVyJykge1xuICAgICAgICAgIGRpc3RhbmNlID0gZ2V0Q2hhcmFjdGVyRGlzdGFuY2Uoc3RyaW5nKTtcbiAgICAgICAgfSBlbHNlIGlmICh1bml0ID09PSAnd29yZCcpIHtcbiAgICAgICAgICBkaXN0YW5jZSA9IGdldFdvcmREaXN0YW5jZShzdHJpbmcpO1xuICAgICAgICB9IGVsc2UgaWYgKHVuaXQgPT09ICdsaW5lJyB8fCB1bml0ID09PSAnYmxvY2snKSB7XG4gICAgICAgICAgZGlzdGFuY2UgPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpc3RhbmNlID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShkaXN0YW5jZSk7XG4gICAgICB9IC8vIEFkZCBvciBzdWJzdHJhY3QgdGhlIG9mZnNldC5cblxuXG4gICAgICBvZmZzZXQgPSByZXZlcnNlJDEgPyBvZmZzZXQgLSBkaXN0YW5jZSA6IG9mZnNldCArIGRpc3RhbmNlOyAvLyBTdWJ0cmFjdCB0aGUgZGlzdGFuY2UgdHJhdmVsZWQgZnJvbSB0aGUgYXZhaWxhYmxlIHRleHQuXG5cbiAgICAgIGF2YWlsYWJsZSA9IGF2YWlsYWJsZSAtIGRpc3RhbmNlOyAvLyBJZiB0aGUgYXZhaWxhYmxlIGhhZCByb29tIHRvIHNwYXJlLCByZXNldCB0aGUgZGlzdGFuY2Ugc28gdGhhdCBpdCB3aWxsXG4gICAgICAvLyBhZHZhbmNlIGFnYWluIG5leHQgdGltZS4gT3RoZXJ3aXNlLCBzZXQgaXQgdG8gdGhlIG92ZXJmbG93IGFtb3VudC5cblxuICAgICAgZGlzdGFuY2UgPSBhdmFpbGFibGUgPj0gMCA/IG51bGwgOiAwIC0gYXZhaWxhYmxlO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICByZXZlcnNlOiByZXZlcnNlJDFcbiAgICB9KSkge1xuICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgIC8vIFZvaWQgbm9kZXMgYXJlIGEgc3BlY2lhbCBjYXNlLCBzaW5jZSB3ZSBkb24ndCB3YW50IHRvIGl0ZXJhdGUgb3ZlclxuICAgICAgICAvLyB0aGVpciBjb250ZW50LiBXZSBpbnN0ZWFkIGFsd2F5cyBqdXN0IHlpZWxkIHRoZWlyIGZpcnN0IHBvaW50LlxuICAgICAgICBpZiAoZWRpdG9yLmlzVm9pZChub2RlKSkge1xuICAgICAgICAgIHlpZWxkIEVkaXRvci5zdGFydChlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVkaXRvci5pc0lubGluZShub2RlKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEVkaXRvci5oYXNJbmxpbmVzKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgICAgICB2YXIgZSA9IFBhdGguaXNBbmNlc3RvcihwYXRoLCBlbmQucGF0aCkgPyBlbmQgOiBFZGl0b3IuZW5kKGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgdmFyIHMgPSBQYXRoLmlzQW5jZXN0b3IocGF0aCwgc3RhcnQucGF0aCkgPyBzdGFydCA6IEVkaXRvci5zdGFydChlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgIHZhciB0ZXh0ID0gRWRpdG9yLnN0cmluZyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGFuY2hvcjogcyxcbiAgICAgICAgICAgIGZvY3VzOiBlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RyaW5nID0gcmV2ZXJzZSQxID8gcmV2ZXJzZSh0ZXh0KSA6IHRleHQ7XG4gICAgICAgICAgaXNOZXdCbG9jayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgIHZhciBpc0ZpcnN0ID0gUGF0aC5lcXVhbHMocGF0aCwgZmlyc3QucGF0aCk7XG4gICAgICAgIGF2YWlsYWJsZSA9IG5vZGUudGV4dC5sZW5ndGg7XG4gICAgICAgIG9mZnNldCA9IHJldmVyc2UkMSA/IGF2YWlsYWJsZSA6IDA7XG5cbiAgICAgICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgICBhdmFpbGFibGUgPSByZXZlcnNlJDEgPyBmaXJzdC5vZmZzZXQgOiBhdmFpbGFibGUgLSBmaXJzdC5vZmZzZXQ7XG4gICAgICAgICAgb2Zmc2V0ID0gZmlyc3Qub2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRmlyc3QgfHwgaXNOZXdCbG9jayB8fCB1bml0ID09PSAnb2Zmc2V0Jykge1xuICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBvZmZzZXRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIG1vcmUgc3RyaW5nLCBjb250aW51ZSB0byB0aGUgbmV4dCBibG9jay5cbiAgICAgICAgICBpZiAoc3RyaW5nID09PSAnJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkdmFuY2UoKTtcbiAgICAgICAgICB9IC8vIElmIHRoZSBhdmFpbGFibGUgc3BhY2UgaGFzbid0IG92ZXJmbG93LCB3ZSBoYXZlIGFub3RoZXIgcG9pbnQgdG9cbiAgICAgICAgICAvLyB5aWVsZCBpbiB0aGUgY3VycmVudCB0ZXh0IG5vZGUuXG5cblxuICAgICAgICAgIGlmIChhdmFpbGFibGUgPj0gMCkge1xuICAgICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICBvZmZzZXRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlzTmV3QmxvY2sgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBtYXRjaGluZyBub2RlIGluIHRoZSBicmFuY2ggb2YgdGhlIGRvY3VtZW50IGJlZm9yZSBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBwcmV2aW91cyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgbWF0Y2gsXG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb25cbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgWywgZnJvbV0gPSBFZGl0b3IuZmlyc3QoZWRpdG9yLCBhdCk7XG4gICAgdmFyIFssIHRvXSA9IEVkaXRvci5maXJzdChlZGl0b3IsIFtdKTtcbiAgICB2YXIgc3BhbiA9IFtmcm9tLCB0b107XG5cbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpICYmIGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcHJldmlvdXMgbm9kZSBmcm9tIHRoZSByb290IG5vZGUhXCIpO1xuICAgIH1cblxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIHZhciBbcGFyZW50XSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBhdCk7XG5cbiAgICAgICAgbWF0Y2ggPSBuID0+IHBhcmVudC5jaGlsZHJlbi5pbmNsdWRlcyhuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoID0gKCkgPT4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgWywgcHJldmlvdXNdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgIGF0OiBzcGFuLFxuICAgICAgbWF0Y2gsXG4gICAgICBtb2RlLFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICByZXR1cm4gcHJldmlvdXM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IGEgcmFuZ2Ugb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgcmFuZ2UoZWRpdG9yLCBhdCwgdG8pIHtcbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkgJiYgIXRvKSB7XG4gICAgICByZXR1cm4gYXQ7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpO1xuICAgIHZhciBlbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgdG8gfHwgYXQpO1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3I6IHN0YXJ0LFxuICAgICAgZm9jdXM6IGVuZFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbXV0YWJsZSByZWYgZm9yIGEgYFJhbmdlYCBvYmplY3QsIHdoaWNoIHdpbGwgc3RheSBpbiBzeW5jIGFzIG5ld1xyXG4gICAqIG9wZXJhdGlvbnMgYXJlIGFwcGxpZWQgdG8gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcmFuZ2VSZWYoZWRpdG9yLCByYW5nZSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgYWZmaW5pdHkgPSAnZm9yd2FyZCdcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgcmVmID0ge1xuICAgICAgY3VycmVudDogcmFuZ2UsXG4gICAgICBhZmZpbml0eSxcblxuICAgICAgdW5yZWYoKSB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgY3VycmVudFxuICAgICAgICB9ID0gcmVmO1xuICAgICAgICB2YXIgcmFuZ2VSZWZzID0gRWRpdG9yLnJhbmdlUmVmcyhlZGl0b3IpO1xuICAgICAgICByYW5nZVJlZnMuZGVsZXRlKHJlZik7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG5cbiAgICB9O1xuICAgIHZhciByZWZzID0gRWRpdG9yLnJhbmdlUmVmcyhlZGl0b3IpO1xuICAgIHJlZnMuYWRkKHJlZik7XG4gICAgcmV0dXJuIHJlZjtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHNldCBvZiBjdXJyZW50bHkgdHJhY2tlZCByYW5nZSByZWZzIG9mIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIHJhbmdlUmVmcyhlZGl0b3IpIHtcbiAgICB2YXIgcmVmcyA9IFJBTkdFX1JFRlMuZ2V0KGVkaXRvcik7XG5cbiAgICBpZiAoIXJlZnMpIHtcbiAgICAgIHJlZnMgPSBuZXcgU2V0KCk7XG4gICAgICBSQU5HRV9SRUZTLnNldChlZGl0b3IsIHJlZnMpO1xuICAgIH1cblxuICAgIHJldHVybiByZWZzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhIGN1c3RvbSBwcm9wZXJ0eSBmcm9tIGFsbCBvZiB0aGUgbGVhZiB0ZXh0IG5vZGVzIGluIHRoZSBjdXJyZW50XHJcbiAgICogc2VsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIHNlbGVjdGlvbiBpcyBjdXJyZW50bHkgY29sbGFwc2VkLCB0aGUgcmVtb3ZhbCB3aWxsIGJlIHN0b3JlZCBvblxyXG4gICAqIGBlZGl0b3IubWFya3NgIGFuZCBhcHBsaWVkIHRvIHRoZSB0ZXh0IGluc2VydGVkIG5leHQuXHJcbiAgICovXG4gIHJlbW92ZU1hcmsoZWRpdG9yLCBrZXkpIHtcbiAgICBlZGl0b3IucmVtb3ZlTWFyayhrZXkpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3RhcnQgcG9pbnQgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgc3RhcnQoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ3N0YXJ0J1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgdGV4dCBzdHJpbmcgY29udGVudCBvZiBhIGxvY2F0aW9uLlxyXG4gICAqXHJcbiAgICogTm90ZTogdGhlIHRleHQgb2Ygdm9pZCBub2RlcyBpcyBwcmVzdW1lZCB0byBiZSBhbiBlbXB0eSBzdHJpbmcsIHJlZ2FyZGxlc3NcclxuICAgKiBvZiB3aGF0IHRoZWlyIGFjdHVhbCBjb250ZW50IGlzLlxyXG4gICAqL1xuICBzdHJpbmcoZWRpdG9yLCBhdCkge1xuICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgIHZhciB0ZXh0ID0gJyc7XG5cbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IHJhbmdlLFxuICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0XG4gICAgfSkpIHtcbiAgICAgIHZhciB0ID0gbm9kZS50ZXh0O1xuXG4gICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgZW5kLnBhdGgpKSB7XG4gICAgICAgIHQgPSB0LnNsaWNlKDAsIGVuZC5vZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgc3RhcnQucGF0aCkpIHtcbiAgICAgICAgdCA9IHQuc2xpY2Uoc3RhcnQub2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgdGV4dCArPSB0O1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSB0aGUgZWRpdG9yIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtKGVkaXRvciwgb3ApIHtcbiAgICBlZGl0b3IuY2hpbGRyZW4gPSBjcmVhdGVEcmFmdChlZGl0b3IuY2hpbGRyZW4pO1xuICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uICYmIGNyZWF0ZURyYWZ0KGVkaXRvci5zZWxlY3Rpb24pO1xuXG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIG5vZGVcbiAgICAgICAgICB9ID0gb3A7XG4gICAgICAgICAgdmFyIHBhcmVudCA9IE5vZGUucGFyZW50KGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIG5vZGUpO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgZm9yICh2YXIgW3BvaW50LCBrZXldIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbltrZXldID0gUG9pbnQudHJhbnNmb3JtKHBvaW50LCBvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgdGV4dFxuICAgICAgICAgIH0gPSBvcDtcblxuICAgICAgICAgIHZhciBfbm9kZTIgPSBOb2RlLmxlYWYoZWRpdG9yLCBfcGF0aCk7XG5cbiAgICAgICAgICB2YXIgYmVmb3JlID0gX25vZGUyLnRleHQuc2xpY2UoMCwgb2Zmc2V0KTtcblxuICAgICAgICAgIHZhciBhZnRlciA9IF9ub2RlMi50ZXh0LnNsaWNlKG9mZnNldCk7XG5cbiAgICAgICAgICBfbm9kZTIudGV4dCA9IGJlZm9yZSArIHRleHQgKyBhZnRlcjtcblxuICAgICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQsIF9rZXldIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQsIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfcGF0aDJcbiAgICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgICB2YXIgX25vZGUzID0gTm9kZS5nZXQoZWRpdG9yLCBfcGF0aDIpO1xuXG4gICAgICAgICAgdmFyIHByZXZQYXRoID0gUGF0aC5wcmV2aW91cyhfcGF0aDIpO1xuICAgICAgICAgIHZhciBwcmV2ID0gTm9kZS5nZXQoZWRpdG9yLCBwcmV2UGF0aCk7XG5cbiAgICAgICAgICB2YXIgX3BhcmVudCA9IE5vZGUucGFyZW50KGVkaXRvciwgX3BhdGgyKTtcblxuICAgICAgICAgIHZhciBfaW5kZXggPSBfcGF0aDJbX3BhdGgyLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgaWYgKFRleHQuaXNUZXh0KF9ub2RlMykgJiYgVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgICAgIHByZXYudGV4dCArPSBfbm9kZTMudGV4dDtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFUZXh0LmlzVGV4dChfbm9kZTMpICYmICFUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICAgICAgcHJldi5jaGlsZHJlbi5wdXNoKC4uLl9ub2RlMy5jaGlsZHJlbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhIFxcXCJtZXJnZV9ub2RlXFxcIiBvcGVyYXRpb24gYXQgcGF0aCBbXCIuY29uY2F0KF9wYXRoMiwgXCJdIHRvIG5vZGVzIG9mIGRpZmZlcmVudCBpbnRlcmFjZXM6IFwiKS5jb25jYXQoX25vZGUzLCBcIiBcIikuY29uY2F0KHByZXYpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfcGFyZW50LmNoaWxkcmVuLnNwbGljZShfaW5kZXgsIDEpO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgZm9yICh2YXIgW19wb2ludDIsIF9rZXkyXSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleTJdID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDIsIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoMyxcbiAgICAgICAgICAgIG5ld1BhdGhcbiAgICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKF9wYXRoMywgbmV3UGF0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtb3ZlIGEgcGF0aCBbXCIuY29uY2F0KF9wYXRoMywgXCJdIHRvIG5ldyBwYXRoIFtcIikuY29uY2F0KG5ld1BhdGgsIFwiXSBiZWNhdXNlIHRoZSBkZXN0aW5hdGlvbiBpcyBpbnNpZGUgaXRzZWxmLlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9ub2RlNCA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGgzKTtcblxuICAgICAgICAgIHZhciBfcGFyZW50MiA9IE5vZGUucGFyZW50KGVkaXRvciwgX3BhdGgzKTtcblxuICAgICAgICAgIHZhciBfaW5kZXgyID0gX3BhdGgzW19wYXRoMy5sZW5ndGggLSAxXTsgLy8gVGhpcyBpcyB0cmlja3ksIGJ1dCBzaW5jZSB0aGUgYHBhdGhgIGFuZCBgbmV3UGF0aGAgYm90aCByZWZlciB0b1xuICAgICAgICAgIC8vIHRoZSBzYW1lIHNuYXBzaG90IGluIHRpbWUsIHRoZXJlJ3MgYSBtaXNtYXRjaC4gQWZ0ZXIgZWl0aGVyXG4gICAgICAgICAgLy8gcmVtb3ZpbmcgdGhlIG9yaWdpbmFsIHBvc2l0aW9uLCB0aGUgc2Vjb25kIHN0ZXAncyBwYXRoIGNhbiBiZSBvdXRcbiAgICAgICAgICAvLyBvZiBkYXRlLiBTbyBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBgb3AubmV3UGF0aGAgZGlyZWN0bHksIHdlXG4gICAgICAgICAgLy8gdHJhbnNmb3JtIGBvcC5wYXRoYCB0byBhc2NlcnRhaW4gd2hhdCB0aGUgYG5ld1BhdGhgIHdvdWxkIGJlIGFmdGVyXG4gICAgICAgICAgLy8gdGhlIG9wZXJhdGlvbiB3YXMgYXBwbGllZC5cblxuICAgICAgICAgIF9wYXJlbnQyLmNoaWxkcmVuLnNwbGljZShfaW5kZXgyLCAxKTtcblxuICAgICAgICAgIHZhciB0cnVlUGF0aCA9IFBhdGgudHJhbnNmb3JtKF9wYXRoMywgb3ApO1xuICAgICAgICAgIHZhciBuZXdQYXJlbnQgPSBOb2RlLmdldChlZGl0b3IsIFBhdGgucGFyZW50KHRydWVQYXRoKSk7XG4gICAgICAgICAgdmFyIG5ld0luZGV4ID0gdHJ1ZVBhdGhbdHJ1ZVBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgbmV3UGFyZW50LmNoaWxkcmVuLnNwbGljZShuZXdJbmRleCwgMCwgX25vZGU0KTtcblxuICAgICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQzLCBfa2V5M10gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXkzXSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQzLCBvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoNFxuICAgICAgICAgIH0gPSBvcDtcbiAgICAgICAgICB2YXIgX2luZGV4MyA9IF9wYXRoNFtfcGF0aDQubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICB2YXIgX3BhcmVudDMgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoNCk7XG5cbiAgICAgICAgICBfcGFyZW50My5jaGlsZHJlbi5zcGxpY2UoX2luZGV4MywgMSk7IC8vIFRyYW5zZm9ybSBhbGwgb2YgdGhlIHBvaW50cyBpbiB0aGUgdmFsdWUsIGJ1dCBpZiB0aGUgcG9pbnQgd2FzIGluIHRoZVxuICAgICAgICAgIC8vIG5vZGUgdGhhdCB3YXMgcmVtb3ZlZCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgcmFuZ2Ugb3IgcmVtb3ZlIGl0LlxuXG5cbiAgICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBbX3BvaW50NCwgX2tleTRdIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50NCwgb3ApO1xuXG4gICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gIT0gbnVsbCAmJiByZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5NF0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIF9wcmV2ID0gdm9pZCAwO1xuXG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBbbiwgcF0gb2YgTm9kZS50ZXh0cyhlZGl0b3IpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoUGF0aC5jb21wYXJlKHAsIF9wYXRoNCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIF9wcmV2ID0gW24sIHBdO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IFtuLCBwXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF9wcmV2KSB7XG4gICAgICAgICAgICAgICAgICBfcG9pbnQ0LnBhdGggPSBfcHJldlsxXTtcbiAgICAgICAgICAgICAgICAgIF9wb2ludDQub2Zmc2V0ID0gX3ByZXZbMF0udGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgICBfcG9pbnQ0LnBhdGggPSBuZXh0WzFdO1xuICAgICAgICAgICAgICAgICAgX3BvaW50NC5vZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfcGF0aDUsXG4gICAgICAgICAgICBvZmZzZXQ6IF9vZmZzZXQsXG4gICAgICAgICAgICB0ZXh0OiBfdGV4dDJcbiAgICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgICB2YXIgX25vZGU1ID0gTm9kZS5sZWFmKGVkaXRvciwgX3BhdGg1KTtcblxuICAgICAgICAgIHZhciBfYmVmb3JlID0gX25vZGU1LnRleHQuc2xpY2UoMCwgX29mZnNldCk7XG5cbiAgICAgICAgICB2YXIgX2FmdGVyID0gX25vZGU1LnRleHQuc2xpY2UoX29mZnNldCArIF90ZXh0Mi5sZW5ndGgpO1xuXG4gICAgICAgICAgX25vZGU1LnRleHQgPSBfYmVmb3JlICsgX2FmdGVyO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgZm9yICh2YXIgW19wb2ludDUsIF9rZXk1XSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleTVdID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDUsIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogX3BhdGg2LFxuICAgICAgICAgICAgbmV3UHJvcGVydGllc1xuICAgICAgICAgIH0gPSBvcDtcblxuICAgICAgICAgIGlmIChfcGF0aDYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHByb3BlcnRpZXMgb24gdGhlIHJvb3Qgbm9kZSFcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9ub2RlNiA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGg2KTtcblxuICAgICAgICAgIGZvciAodmFyIF9rZXk2IGluIG5ld1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChfa2V5NiA9PT0gJ2NoaWxkcmVuJyB8fCBfa2V5NiA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgdGhlIFxcXCJcIi5jb25jYXQoX2tleTYsIFwiXFxcIiBwcm9wZXJ0eSBvZiBub2RlcyFcIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBuZXdQcm9wZXJ0aWVzW19rZXk2XTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIF9ub2RlNltfa2V5Nl07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfbm9kZTZbX2tleTZdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgbmV3UHJvcGVydGllczogX25ld1Byb3BlcnRpZXNcbiAgICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgICBpZiAoX25ld1Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgc2VsZWN0aW9uID0gX25ld1Byb3BlcnRpZXM7XG4gICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFSYW5nZS5pc1JhbmdlKF9uZXdQcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgYW4gaW5jb21wbGV0ZSBcXFwic2V0X3NlbGVjdGlvblxcXCIgb3BlcmF0aW9uIHByb3BlcnRpZXMgXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KF9uZXdQcm9wZXJ0aWVzKSwgXCIgd2hlbiB0aGVyZSBpcyBubyBjdXJyZW50IHNlbGVjdGlvbi5cIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBfbmV3UHJvcGVydGllcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzZWxlY3Rpb24sIF9uZXdQcm9wZXJ0aWVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfcGF0aDcsXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIHByb3BlcnRpZXNcbiAgICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgICBpZiAoX3BhdGg3Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGEgXFxcInNwbGl0X25vZGVcXFwiIG9wZXJhdGlvbiBhdCBwYXRoIFtcIi5jb25jYXQoX3BhdGg3LCBcIl0gYmVjYXVzZSB0aGUgcm9vdCBub2RlIGNhbm5vdCBiZSBzcGxpdC5cIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfbm9kZTcgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoNyk7XG5cbiAgICAgICAgICB2YXIgX3BhcmVudDQgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoNyk7XG5cbiAgICAgICAgICB2YXIgX2luZGV4NCA9IF9wYXRoN1tfcGF0aDcubGVuZ3RoIC0gMV07XG4gICAgICAgICAgdmFyIG5ld05vZGU7XG5cbiAgICAgICAgICBpZiAoVGV4dC5pc1RleHQoX25vZGU3KSkge1xuICAgICAgICAgICAgdmFyIF9iZWZvcmUyID0gX25vZGU3LnRleHQuc2xpY2UoMCwgcG9zaXRpb24pO1xuXG4gICAgICAgICAgICB2YXIgX2FmdGVyMiA9IF9ub2RlNy50ZXh0LnNsaWNlKHBvc2l0aW9uKTtcblxuICAgICAgICAgICAgX25vZGU3LnRleHQgPSBfYmVmb3JlMjtcbiAgICAgICAgICAgIG5ld05vZGUgPSBfb2JqZWN0U3ByZWFkKHt9LCBfbm9kZTcsIHt9LCBwcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICAgIHRleHQ6IF9hZnRlcjJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgX2JlZm9yZTMgPSBfbm9kZTcuY2hpbGRyZW4uc2xpY2UoMCwgcG9zaXRpb24pO1xuXG4gICAgICAgICAgICB2YXIgX2FmdGVyMyA9IF9ub2RlNy5jaGlsZHJlbi5zbGljZShwb3NpdGlvbik7XG5cbiAgICAgICAgICAgIF9ub2RlNy5jaGlsZHJlbiA9IF9iZWZvcmUzO1xuICAgICAgICAgICAgbmV3Tm9kZSA9IF9vYmplY3RTcHJlYWQoe30sIF9ub2RlNywge30sIHByb3BlcnRpZXMsIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IF9hZnRlcjNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9wYXJlbnQ0LmNoaWxkcmVuLnNwbGljZShfaW5kZXg0ICsgMSwgMCwgbmV3Tm9kZSk7XG5cbiAgICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBbX3BvaW50NiwgX2tleTddIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5N10gPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50Niwgb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZWRpdG9yLmNoaWxkcmVuID0gZmluaXNoRHJhZnQoZWRpdG9yLmNoaWxkcmVuKTtcblxuICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgIGVkaXRvci5zZWxlY3Rpb24gPSBpc0RyYWZ0KHNlbGVjdGlvbikgPyBmaW5pc2hEcmFmdChzZWxlY3Rpb24pIDogc2VsZWN0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uID0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ29udmVydCBhIHJhbmdlIGludG8gYSBub24taGFuZ2luZyBvbmUuXHJcbiAgICovXG4gIHVuaGFuZ1JhbmdlKGVkaXRvciwgcmFuZ2UpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpOyAvLyBQRVJGOiBleGl0IGVhcmx5IGlmIHdlIGNhbiBndWFyYW50ZWUgdGhhdCB0aGUgcmFuZ2UgaXNuJ3QgaGFuZ2luZy5cblxuICAgIGlmIChzdGFydC5vZmZzZXQgIT09IDAgfHwgZW5kLm9mZnNldCAhPT0gMCB8fCBSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkpIHtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG5cbiAgICB2YXIgZW5kQmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICBhdDogZW5kLFxuICAgICAgbWF0Y2g6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKVxuICAgIH0pO1xuICAgIHZhciBibG9ja1BhdGggPSBlbmRCbG9jayA/IGVuZEJsb2NrWzFdIDogW107XG4gICAgdmFyIGZpcnN0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgW10pO1xuICAgIHZhciBiZWZvcmUgPSB7XG4gICAgICBhbmNob3I6IGZpcnN0LFxuICAgICAgZm9jdXM6IGVuZFxuICAgIH07XG4gICAgdmFyIHNraXAgPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBiZWZvcmUsXG4gICAgICBtYXRjaDogVGV4dC5pc1RleHQsXG4gICAgICByZXZlcnNlOiB0cnVlLFxuICAgICAgdm9pZHNcbiAgICB9KSkge1xuICAgICAgaWYgKHNraXApIHtcbiAgICAgICAgc2tpcCA9IGZhbHNlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUudGV4dCAhPT0gJycgfHwgUGF0aC5pc0JlZm9yZShwYXRoLCBibG9ja1BhdGgpKSB7XG4gICAgICAgIGVuZCA9IHtcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIG9mZnNldDogbm9kZS50ZXh0Lmxlbmd0aFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yOiBzdGFydCxcbiAgICAgIGZvY3VzOiBlbmRcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1hdGNoIGEgdm9pZCBub2RlIGluIHRoZSBjdXJyZW50IGJyYW5jaCBvZiB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICB2b2lkKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICByZXR1cm4gRWRpdG9yLmFib3ZlKGVkaXRvciwgX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucywge1xuICAgICAgbWF0Y2g6IG4gPT4gRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pXG4gICAgfSkpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENhbGwgYSBmdW5jdGlvbiwgZGVmZXJyaW5nIG5vcm1hbGl6YXRpb24gdW50aWwgYWZ0ZXIgaXQgY29tcGxldGVzLlxyXG4gICAqL1xuICB3aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmbikge1xuICAgIHZhciB2YWx1ZSA9IEVkaXRvci5pc05vcm1hbGl6aW5nKGVkaXRvcik7XG4gICAgTk9STUFMSVpJTkcuc2V0KGVkaXRvciwgZmFsc2UpO1xuICAgIGZuKCk7XG4gICAgTk9STUFMSVpJTkcuc2V0KGVkaXRvciwgdmFsdWUpO1xuICAgIEVkaXRvci5ub3JtYWxpemUoZWRpdG9yKTtcbiAgfVxuXG59O1xuXG52YXIgRWxlbWVudCA9IHtcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBgRWxlbWVudGAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc0VsZW1lbnQodmFsdWUpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgTm9kZS5pc05vZGVMaXN0KHZhbHVlLmNoaWxkcmVuKSAmJiAhRWRpdG9yLmlzRWRpdG9yKHZhbHVlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGFycmF5IG9mIGBFbGVtZW50YCBvYmplY3RzLlxyXG4gICAqL1xuICBpc0VsZW1lbnRMaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmICh2YWx1ZS5sZW5ndGggPT09IDAgfHwgRWxlbWVudC5pc0VsZW1lbnQodmFsdWVbMF0pKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhbiBlbGVtZW50IG1hdGNoZXMgc2V0IG9mIHByb3BlcnRpZXMuXHJcbiAgICpcclxuICAgKiBOb3RlOiB0aGlzIGNoZWNrcyBjdXN0b20gcHJvcGVydGllcywgYW5kIGl0IGRvZXMgbm90IGVuc3VyZSB0aGF0IGFueVxyXG4gICAqIGNoaWxkcmVuIGFyZSBlcXVpdmFsZW50LlxyXG4gICAqL1xuICBtYXRjaGVzKGVsZW1lbnQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoa2V5ID09PSAnY2hpbGRyZW4nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudFtrZXldICE9PSBwcm9wc1trZXldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG59O1xuXG52YXIgTG9jYXRpb24gPSB7XG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgYExvY2F0aW9uYCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzTG9jYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUpIHx8IFBvaW50LmlzUG9pbnQodmFsdWUpIHx8IFJhbmdlLmlzUmFuZ2UodmFsdWUpO1xuICB9XG5cbn07XG52YXIgU3BhbiA9IHtcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBgU3BhbmAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc1NwYW4odmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAyICYmIHZhbHVlLmV2ZXJ5KFBhdGguaXNQYXRoKTtcbiAgfVxuXG59O1xuXG52YXIgTm9kZSA9IHtcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBub2RlIGF0IGEgc3BlY2lmaWMgcGF0aCwgYXNzZXJ0aW5nIHRoYXQgaXQncyBhbiBhbmNlc3RvciBub2RlLlxyXG4gICAqL1xuICBhbmNlc3Rvcihyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChyb290LCBwYXRoKTtcblxuICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgYW5jZXN0b3Igbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIGEgdGV4dCBub2RlIGluc3RlYWQ6IFwiKS5jb25jYXQobm9kZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJldHVybiBhbiBpdGVyYWJsZSBvZiBhbGwgdGhlIGFuY2VzdG9yIG5vZGVzIGFib3ZlIGEgc3BlY2lmaWMgcGF0aC5cclxuICAgKlxyXG4gICAqIEJ5IGRlZmF1bHQgdGhlIG9yZGVyIGlzIGJvdHRvbS11cCwgZnJvbSBsb3dlc3QgdG8gaGlnaGVzdCBhbmNlc3RvciBpblxyXG4gICAqIHRoZSB0cmVlLCBidXQgeW91IGNhbiBwYXNzIHRoZSBgcmV2ZXJzZTogdHJ1ZWAgb3B0aW9uIHRvIGdvIHRvcC1kb3duLlxyXG4gICAqL1xuICAqYW5jZXN0b3JzKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICBmb3IgKHZhciBwIG9mIFBhdGguYW5jZXN0b3JzKHBhdGgsIG9wdGlvbnMpKSB7XG4gICAgICB2YXIgbiA9IE5vZGUuYW5jZXN0b3Iocm9vdCwgcCk7XG4gICAgICB2YXIgZW50cnkgPSBbbiwgcF07XG4gICAgICB5aWVsZCBlbnRyeTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBjaGlsZCBvZiBhIG5vZGUgYXQgYSBzcGVjaWZpYyBpbmRleC5cclxuICAgKi9cbiAgY2hpbGQocm9vdCwgaW5kZXgpIHtcbiAgICBpZiAoVGV4dC5pc1RleHQocm9vdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGNoaWxkIG9mIGEgdGV4dCBub2RlOiBcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHJvb3QuY2hpbGRyZW5baW5kZXhdO1xuXG4gICAgaWYgKGMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBjaGlsZCBhdCBpbmRleCBgXCIuY29uY2F0KGluZGV4LCBcImAgaW4gbm9kZTogXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeShyb290KSkpO1xuICAgIH1cblxuICAgIHJldHVybiBjO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEl0ZXJhdGUgb3ZlciB0aGUgY2hpbGRyZW4gb2YgYSBub2RlIGF0IGEgc3BlY2lmaWMgcGF0aC5cclxuICAgKi9cbiAgKmNoaWxkcmVuKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBhbmNlc3RvciA9IE5vZGUuYW5jZXN0b3Iocm9vdCwgcGF0aCk7XG4gICAgdmFyIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSA9IGFuY2VzdG9yO1xuICAgIHZhciBpbmRleCA9IHJldmVyc2UgPyBjaGlsZHJlbi5sZW5ndGggLSAxIDogMDtcblxuICAgIHdoaWxlIChyZXZlcnNlID8gaW5kZXggPj0gMCA6IGluZGV4IDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB2YXIgY2hpbGQgPSBOb2RlLmNoaWxkKGFuY2VzdG9yLCBpbmRleCk7XG4gICAgICB2YXIgY2hpbGRQYXRoID0gcGF0aC5jb25jYXQoaW5kZXgpO1xuICAgICAgeWllbGQgW2NoaWxkLCBjaGlsZFBhdGhdO1xuICAgICAgaW5kZXggPSByZXZlcnNlID8gaW5kZXggLSAxIDogaW5kZXggKyAxO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgYW4gZW50cnkgZm9yIHRoZSBjb21tb24gYW5jZXNldG9yIG5vZGUgb2YgdHdvIHBhdGhzLlxyXG4gICAqL1xuICBjb21tb24ocm9vdCwgcGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBwID0gUGF0aC5jb21tb24ocGF0aCwgYW5vdGhlcik7XG4gICAgdmFyIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICByZXR1cm4gW24sIHBdO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbm9kZSBhdCBhIHNwZWNpZmljIHBhdGgsIGFzc2VydGluZyB0aGF0IGl0J3MgYSBkZXNjZW5kYW50IG5vZGUuXHJcbiAgICovXG4gIGRlc2NlbmRhbnQocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gTm9kZS5nZXQocm9vdCwgcGF0aCk7XG5cbiAgICBpZiAoRWRpdG9yLmlzRWRpdG9yKG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBkZXNjZW5kYW50IG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IHJlZmVycyB0byB0aGUgcm9vdCBlZGl0b3Igbm9kZSBpbnN0ZWFkOiBcIikuY29uY2F0KG5vZGUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYW4gaXRlcmFibGUgb2YgYWxsIHRoZSBkZXNjZW5kYW50IG5vZGUgZW50cmllcyBpbnNpZGUgYSByb290IG5vZGUuXHJcbiAgICovXG4gICpkZXNjZW5kYW50cyhyb290KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIE5vZGUubm9kZXMocm9vdCwgb3B0aW9ucykpIHtcbiAgICAgIGlmIChwYXRoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAvLyBOT1RFOiB3ZSBoYXZlIHRvIGNvZXJjZSBoZXJlIGJlY2F1c2UgY2hlY2tpbmcgdGhlIHBhdGgncyBsZW5ndGggZG9lc1xuICAgICAgICAvLyBndWFyYW50ZWUgdGhhdCBgbm9kZWAgaXMgbm90IGEgYEVkaXRvcmAsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3Qga25vdy5cbiAgICAgICAgeWllbGQgW25vZGUsIHBhdGhdO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYW4gaXRlcmFibGUgb2YgYWxsIHRoZSBlbGVtZW50IG5vZGVzIGluc2lkZSBhIHJvb3Qgbm9kZS4gRWFjaCBpdGVyYXRpb25cclxuICAgKiB3aWxsIHJldHVybiBhbiBgRWxlbWVudEVudHJ5YCB0dXBsZSBjb25zaXN0aW5nIG9mIGBbRWxlbWVudCwgUGF0aF1gLiBJZiB0aGVcclxuICAgKiByb290IG5vZGUgaXMgYW4gZWxlbWVudCBpdCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBpdGVyYXRpb24gYXMgd2VsbC5cclxuICAgKi9cbiAgKmVsZW1lbnRzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgTm9kZS5ub2Rlcyhyb290LCBvcHRpb25zKSkge1xuICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgIHlpZWxkIFtub2RlLCBwYXRoXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBmaXJzdCBub2RlIGVudHJ5IGluIGEgcm9vdCBub2RlIGZyb20gYSBwYXRoLlxyXG4gICAqL1xuICBmaXJzdChyb290LCBwYXRoKSB7XG4gICAgdmFyIHAgPSBwYXRoLnNsaWNlKCk7XG4gICAgdmFyIG4gPSBOb2RlLmdldChyb290LCBwKTtcblxuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAoVGV4dC5pc1RleHQobikgfHwgbi5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gbi5jaGlsZHJlblswXTtcbiAgICAgICAgcC5wdXNoKDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbbiwgcF07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzbGljZWQgZnJhZ21lbnQgcmVwcmVzZW50ZWQgYnkgYSByYW5nZSBpbnNpZGUgYSByb290IG5vZGUuXHJcbiAgICovXG4gIGZyYWdtZW50KHJvb3QsIHJhbmdlKSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KHJvb3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IGEgZnJhZ21lbnQgc3RhcnRpbmcgZnJvbSBhIHJvb3QgdGV4dCBub2RlOiBcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG5cbiAgICB2YXIgbmV3Um9vdCA9IHByb2R1Y2Uocm9vdCwgciA9PiB7XG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgICAgdmFyIGl0ZXJhYmxlID0gTm9kZS5ub2RlcyhyLCB7XG4gICAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICAgIHBhc3M6IChfcmVmKSA9PiB7XG4gICAgICAgICAgdmFyIFssIHBhdGhdID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gIVJhbmdlLmluY2x1ZGVzKHJhbmdlLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIFssIHBhdGhdIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgIGlmICghUmFuZ2UuaW5jbHVkZXMocmFuZ2UsIHBhdGgpKSB7XG4gICAgICAgICAgdmFyIHBhcmVudCA9IE5vZGUucGFyZW50KHIsIHBhdGgpO1xuICAgICAgICAgIHZhciBpbmRleCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChQYXRoLmVxdWFscyhwYXRoLCBlbmQucGF0aCkpIHtcbiAgICAgICAgICB2YXIgbGVhZiA9IE5vZGUubGVhZihyLCBwYXRoKTtcbiAgICAgICAgICBsZWFmLnRleHQgPSBsZWFmLnRleHQuc2xpY2UoMCwgZW5kLm9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgc3RhcnQucGF0aCkpIHtcbiAgICAgICAgICB2YXIgX2xlYWYgPSBOb2RlLmxlYWYociwgcGF0aCk7XG5cbiAgICAgICAgICBfbGVhZi50ZXh0ID0gX2xlYWYudGV4dC5zbGljZShzdGFydC5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSByLnNlbGVjdGlvbjtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3Um9vdC5jaGlsZHJlbjtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGRlc2NlbmRhbnQgbm9kZSByZWZlcnJlZCB0byBieSBhIHNwZWNpZmljIHBhdGguIElmIHRoZSBwYXRoIGlzIGFuXHJcbiAgICogZW1wdHkgYXJyYXksIGl0IHJlZmVycyB0byB0aGUgcm9vdCBub2RlIGl0c2VsZi5cclxuICAgKi9cbiAgZ2V0KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IHJvb3Q7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcGF0aFtpXTtcblxuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpIHx8ICFub2RlLmNoaWxkcmVuW3BdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGEgZGVzY2VuZGFudCBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGluIG5vZGU6IFwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBkZXNjZW5kYW50IG5vZGUgZXhpc3RzIGF0IGEgc3BlY2lmaWMgcGF0aC5cclxuICAgKi9cbiAgaGFzKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IHJvb3Q7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcGF0aFtpXTtcblxuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpIHx8ICFub2RlLmNoaWxkcmVuW3BdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBgTm9kZWAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc05vZGUodmFsdWUpIHtcbiAgICByZXR1cm4gVGV4dC5pc1RleHQodmFsdWUpIHx8IEVsZW1lbnQuaXNFbGVtZW50KHZhbHVlKSB8fCBFZGl0b3IuaXNFZGl0b3IodmFsdWUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBsaXN0IG9mIGBOb2RlYCBvYmplY3RzLlxyXG4gICAqL1xuICBpc05vZGVMaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmICh2YWx1ZS5sZW5ndGggPT09IDAgfHwgTm9kZS5pc05vZGUodmFsdWVbMF0pKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGxhc2ggbm9kZSBlbnRyeSBpbiBhIHJvb3Qgbm9kZSBmcm9tIGEgcGF0aC5cclxuICAgKi9cbiAgbGFzdChyb290LCBwYXRoKSB7XG4gICAgdmFyIHAgPSBwYXRoLnNsaWNlKCk7XG4gICAgdmFyIG4gPSBOb2RlLmdldChyb290LCBwKTtcblxuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAoVGV4dC5pc1RleHQobikgfHwgbi5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaSA9IG4uY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgbiA9IG4uY2hpbGRyZW5baV07XG4gICAgICAgIHAucHVzaChpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW24sIHBdO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbm9kZSBhdCBhIHNwZWNpZmljIHBhdGgsIGVuc3VyaW5nIGl0J3MgYSBsZWFmIHRleHQgbm9kZS5cclxuICAgKi9cbiAgbGVhZihyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChyb290LCBwYXRoKTtcblxuICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGxlYWYgbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIGEgbm9uLWxlYWYgbm9kZTogXCIpLmNvbmNhdChub2RlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGFuIGl0ZXJhYmxlIG9mIHRoZSBpbiBhIGJyYW5jaCBvZiB0aGUgdHJlZSwgZnJvbSBhIHNwZWNpZmljIHBhdGguXHJcbiAgICpcclxuICAgKiBCeSBkZWZhdWx0IHRoZSBvcmRlciBpcyB0b3AtZG93biwgZnJvbSBsb3dlc3QgdG8gaGlnaGVzdCBub2RlIGluIHRoZSB0cmVlLFxyXG4gICAqIGJ1dCB5b3UgY2FuIHBhc3MgdGhlIGByZXZlcnNlOiB0cnVlYCBvcHRpb24gdG8gZ28gYm90dG9tLXVwLlxyXG4gICAqL1xuICAqbGV2ZWxzKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICBmb3IgKHZhciBwIG9mIFBhdGgubGV2ZWxzKHBhdGgsIG9wdGlvbnMpKSB7XG4gICAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgeWllbGQgW24sIHBdO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIG5vZGUgbWF0Y2hlcyBhIHNldCBvZiBwcm9wcy5cclxuICAgKi9cbiAgbWF0Y2hlcyhub2RlLCBwcm9wcykge1xuICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBFbGVtZW50Lm1hdGNoZXMobm9kZSwgcHJvcHMpIHx8IFRleHQuaXNUZXh0KG5vZGUpICYmIFRleHQubWF0Y2hlcyhub2RlLCBwcm9wcyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGFuIGl0ZXJhYmxlIG9mIGFsbCB0aGUgbm9kZSBlbnRyaWVzIG9mIGEgcm9vdCBub2RlLiBFYWNoIGVudHJ5IGlzXHJcbiAgICogcmV0dXJuZWQgYXMgYSBgW05vZGUsIFBhdGhdYCB0dXBsZSwgd2l0aCB0aGUgcGF0aCByZWZlcnJpbmcgdG8gdGhlIG5vZGUnc1xyXG4gICAqIHBvc2l0aW9uIGluc2lkZSB0aGUgcm9vdCBub2RlLlxyXG4gICAqL1xuICAqbm9kZXMocm9vdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgcGFzcyxcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBmcm9tID0gW10sXG4gICAgICB0b1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgIHZhciBwID0gW107XG4gICAgdmFyIG4gPSByb290O1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICh0byAmJiAocmV2ZXJzZSA/IFBhdGguaXNCZWZvcmUocCwgdG8pIDogUGF0aC5pc0FmdGVyKHAsIHRvKSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmICghdmlzaXRlZC5oYXMobikpIHtcbiAgICAgICAgeWllbGQgW24sIHBdO1xuICAgICAgfSAvLyBJZiB3ZSdyZSBhbGxvd2VkIHRvIGdvIGRvd253YXJkIGFuZCB3ZSBoYXZlbid0IGRlY3NlbmRlZCB5ZXQsIGRvLlxuXG5cbiAgICAgIGlmICghdmlzaXRlZC5oYXMobikgJiYgIVRleHQuaXNUZXh0KG4pICYmIG4uY2hpbGRyZW4ubGVuZ3RoICE9PSAwICYmIChwYXNzID09IG51bGwgfHwgcGFzcyhbbiwgcF0pID09PSBmYWxzZSkpIHtcbiAgICAgICAgdmlzaXRlZC5hZGQobik7XG4gICAgICAgIHZhciBuZXh0SW5kZXggPSByZXZlcnNlID8gbi5jaGlsZHJlbi5sZW5ndGggLSAxIDogMDtcblxuICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKHAsIGZyb20pKSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gZnJvbVtwLmxlbmd0aF07XG4gICAgICAgIH1cblxuICAgICAgICBwID0gcC5jb25jYXQobmV4dEluZGV4KTtcbiAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gSWYgd2UncmUgYXQgdGhlIHJvb3QgYW5kIHdlIGNhbid0IGdvIGRvd24sIHdlJ3JlIGRvbmUuXG5cblxuICAgICAgaWYgKHAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBJZiB3ZSdyZSBnb2luZyBmb3J3YXJkLi4uXG5cblxuICAgICAgaWYgKCFyZXZlcnNlKSB7XG4gICAgICAgIHZhciBuZXdQYXRoID0gUGF0aC5uZXh0KHApO1xuXG4gICAgICAgIGlmIChOb2RlLmhhcyhyb290LCBuZXdQYXRoKSkge1xuICAgICAgICAgIHAgPSBuZXdQYXRoO1xuICAgICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBJZiB3ZSdyZSBnb2luZyBiYWNrd2FyZC4uLlxuXG5cbiAgICAgIGlmIChyZXZlcnNlICYmIHBbcC5sZW5ndGggLSAxXSAhPT0gMCkge1xuICAgICAgICB2YXIgX25ld1BhdGggPSBQYXRoLnByZXZpb3VzKHApO1xuXG4gICAgICAgIHAgPSBfbmV3UGF0aDtcbiAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gT3RoZXJ3aXNlIHdlJ3JlIGdvaW5nIHVwd2FyZC4uLlxuXG5cbiAgICAgIHAgPSBQYXRoLnBhcmVudChwKTtcbiAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgIHZpc2l0ZWQuYWRkKG4pO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHBhcmVudCBvZiBhIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLlxyXG4gICAqL1xuICBwYXJlbnQocm9vdCwgcGF0aCkge1xuICAgIHZhciBwYXJlbnRQYXRoID0gUGF0aC5wYXJlbnQocGF0aCk7XG4gICAgdmFyIHAgPSBOb2RlLmdldChyb290LCBwYXJlbnRQYXRoKTtcblxuICAgIGlmIChUZXh0LmlzVGV4dChwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcGFyZW50IG9mIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgcm9vdC5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY29uY2F0ZW5hdGVkIHRleHQgc3RyaW5nIG9mIGEgbm9kZSdzIGNvbnRlbnQuXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBpbmNsdWRlIHNwYWNlcyBvciBsaW5lIGJyZWFrcyBiZXR3ZWVuIGJsb2NrIG5vZGVzLlxyXG4gICAqIEl0IGlzIG5vdCBhIHVzZXItZmFjaW5nIHN0cmluZywgYnV0IGEgc3RyaW5nIGZvciBwZXJmb3JtaW5nIG9mZnNldC1yZWxhdGVkXHJcbiAgICogY29tcHV0YXRpb25zIGZvciBhIG5vZGUuXHJcbiAgICovXG4gIHN0cmluZyhub2RlKSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZS50ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5tYXAoTm9kZS5zdHJpbmcpLmpvaW4oJycpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYW4gaXRlcmFibGUgb2YgYWxsIGxlYWYgdGV4dCBub2RlcyBpbiBhIHJvb3Qgbm9kZS5cclxuICAgKi9cbiAgKnRleHRzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgTm9kZS5ub2Rlcyhyb290LCBvcHRpb25zKSkge1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgIHlpZWxkIFtub2RlLCBwYXRoXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQxKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDEodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMShPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbnZhciBPcGVyYXRpb24gPSB7XG4gIC8qKlxyXG4gICAqIENoZWNrIG9mIGEgdmFsdWUgaXMgYSBgTm9kZU9wZXJhdGlvbmAgb2JqZWN0LlxyXG4gICAqL1xuICBpc05vZGVPcGVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbHVlKSAmJiB2YWx1ZS50eXBlLmVuZHNXaXRoKCdfbm9kZScpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIG9mIGEgdmFsdWUgaXMgYW4gYE9wZXJhdGlvbmAgb2JqZWN0LlxyXG4gICAqL1xuICBpc09wZXJhdGlvbih2YWx1ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIE5vZGUuaXNOb2RlKHZhbHVlLm5vZGUpO1xuXG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZycgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCk7XG5cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLnBvc2l0aW9uID09PSAnbnVtYmVyJyAmJiAodHlwZW9mIHZhbHVlLnRhcmdldCA9PT0gJ251bWJlcicgfHwgdmFsdWUudGFyZ2V0ID09PSBudWxsKSAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBpc1BsYWluT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpO1xuXG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgUGF0aC5pc1BhdGgodmFsdWUubmV3UGF0aCk7XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIE5vZGUuaXNOb2RlKHZhbHVlLm5vZGUpO1xuXG4gICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZycgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCk7XG5cbiAgICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIGlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcykgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZS5uZXdQcm9wZXJ0aWVzKTtcblxuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIHJldHVybiB2YWx1ZS5wcm9wZXJ0aWVzID09PSBudWxsICYmIFJhbmdlLmlzUmFuZ2UodmFsdWUubmV3UHJvcGVydGllcykgfHwgdmFsdWUubmV3UHJvcGVydGllcyA9PT0gbnVsbCAmJiBSYW5nZS5pc1JhbmdlKHZhbHVlLnByb3BlcnRpZXMpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcykgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZS5uZXdQcm9wZXJ0aWVzKTtcblxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiB0eXBlb2YgdmFsdWUucG9zaXRpb24gPT09ICdudW1iZXInICYmICh0eXBlb2YgdmFsdWUudGFyZ2V0ID09PSAnbnVtYmVyJyB8fCB2YWx1ZS50YXJnZXQgPT09IG51bGwpICYmIGlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcyk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGxpc3Qgb2YgYE9wZXJhdGlvbmAgb2JqZWN0cy5cclxuICAgKi9cbiAgaXNPcGVyYXRpb25MaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmICh2YWx1ZS5sZW5ndGggPT09IDAgfHwgT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbHVlWzBdKSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgb2YgYSB2YWx1ZSBpcyBhIGBTZWxlY3Rpb25PcGVyYXRpb25gIG9iamVjdC5cclxuICAgKi9cbiAgaXNTZWxlY3Rpb25PcGVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbHVlKSAmJiB2YWx1ZS50eXBlLmVuZHNXaXRoKCdfc2VsZWN0aW9uJyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgb2YgYSB2YWx1ZSBpcyBhIGBUZXh0T3BlcmF0aW9uYCBvYmplY3QuXHJcbiAgICovXG4gIGlzVGV4dE9wZXJhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsdWUpICYmIHZhbHVlLnR5cGUuZW5kc1dpdGgoJ190ZXh0Jyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW52ZXJ0IGFuIG9wZXJhdGlvbiwgcmV0dXJuaW5nIGEgbmV3IG9wZXJhdGlvbiB0aGF0IHdpbGwgZXhhY3RseSB1bmRvIHRoZVxyXG4gICAqIG9yaWdpbmFsIHdoZW4gYXBwbGllZC5cclxuICAgKi9cbiAgaW52ZXJzZShvcCkge1xuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkMSh7fSwgb3AsIHtcbiAgICAgICAgICAgIHR5cGU6ICdyZW1vdmVfbm9kZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQxKHt9LCBvcCwge1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV90ZXh0J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkMSh7fSwgb3AsIHtcbiAgICAgICAgICAgIHR5cGU6ICdzcGxpdF9ub2RlJyxcbiAgICAgICAgICAgIHBhdGg6IFBhdGgucHJldmlvdXMob3AucGF0aClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIG5ld1BhdGgsXG4gICAgICAgICAgICBwYXRoXG4gICAgICAgICAgfSA9IG9wOyAvLyBQRVJGOiBpbiB0aGlzIGNhc2UgdGhlIG1vdmUgb3BlcmF0aW9uIGlzIGEgbm8tb3AgYW55d2F5cy5cblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhuZXdQYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIG1vdmUgaGFwcGVucyBjb21wbGV0ZWx5IHdpdGhpbiBhIHNpbmdsZSBwYXJlbnQgdGhlIHBhdGggYW5kXG4gICAgICAgICAgLy8gbmV3UGF0aCBhcmUgc3RhYmxlIHdpdGggcmVzcGVjdCB0byBlYWNoIG90aGVyLlxuXG5cbiAgICAgICAgICBpZiAoUGF0aC5pc1NpYmxpbmcocGF0aCwgbmV3UGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDEoe30sIG9wLCB7XG4gICAgICAgICAgICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgICAgICAgICAgIG5ld1BhdGg6IHBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIG1vdmUgZG9lcyBub3QgaGFwcGVuIHdpdGhpbiBhIHNpbmdsZSBwYXJlbnQgaXQgaXMgcG9zc2libGVcbiAgICAgICAgICAvLyBmb3IgdGhlIG1vdmUgdG8gaW1wYWN0IHRoZSB0cnVlIHBhdGggdG8gdGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBub2RlXG4gICAgICAgICAgLy8gd2FzIHJlbW92ZWQgZnJvbSBhbmQgd2hlcmUgaXQgd2FzIGluc2VydGVkLiBXZSBoYXZlIHRvIGFkanVzdCBmb3IgdGhpc1xuICAgICAgICAgIC8vIGFuZCBmaW5kIHRoZSBvcmlnaW5hbCBwYXRoLiBXZSBjYW4gYWNjb21wbGlzaCB0aGlzIChvbmx5IGluIG5vbi1zaWJsaW5nKVxuICAgICAgICAgIC8vIG1vdmVzIGJ5IGxvb2tpbmcgYXQgdGhlIGltcGFjdCBvZiB0aGUgbW92ZSBvcGVyYXRpb24gb24gdGhlIG5vZGVcbiAgICAgICAgICAvLyBhZnRlciB0aGUgb3JpZ2luYWwgbW92ZSBwYXRoLlxuXG5cbiAgICAgICAgICB2YXIgaW52ZXJzZVBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCk7XG4gICAgICAgICAgdmFyIGludmVyc2VOZXdQYXRoID0gUGF0aC50cmFuc2Zvcm0oUGF0aC5uZXh0KHBhdGgpLCBvcCk7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkMSh7fSwgb3AsIHtcbiAgICAgICAgICAgIHBhdGg6IGludmVyc2VQYXRoLFxuICAgICAgICAgICAgbmV3UGF0aDogaW52ZXJzZU5ld1BhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQxKHt9LCBvcCwge1xuICAgICAgICAgICAgdHlwZTogJ2luc2VydF9ub2RlJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDEoe30sIG9wLCB7XG4gICAgICAgICAgICB0eXBlOiAnaW5zZXJ0X3RleHQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgICBuZXdQcm9wZXJ0aWVzXG4gICAgICAgICAgfSA9IG9wO1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDEoe30sIG9wLCB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBuZXdQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgbmV3UHJvcGVydGllczogcHJvcGVydGllc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IF9wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgbmV3UHJvcGVydGllczogX25ld1Byb3BlcnRpZXNcbiAgICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgICBpZiAoX3Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkMSh7fSwgb3AsIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllczogX25ld1Byb3BlcnRpZXMsXG4gICAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX25ld1Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkMSh7fSwgb3AsIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQxKHt9LCBvcCwge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBfbmV3UHJvcGVydGllcyxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDEoe30sIG9wLCB7XG4gICAgICAgICAgICB0eXBlOiAnbWVyZ2Vfbm9kZScsXG4gICAgICAgICAgICBwYXRoOiBQYXRoLm5leHQob3AucGF0aClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG52YXIgUGF0aCA9IHtcbiAgLyoqXHJcbiAgICogR2V0IGEgbGlzdCBvZiBhbmNlc3RvciBwYXRocyBmb3IgYSBnaXZlbiBwYXRoLlxyXG4gICAqXHJcbiAgICogVGhlIHBhdGhzIGFyZSBzb3J0ZWQgZnJvbSBkZWVwZXN0IHRvIHNoYWxsb3dlc3QgYW5jZXN0b3IuIEhvd2V2ZXIsIGlmIHRoZVxyXG4gICAqIGByZXZlcnNlOiB0cnVlYCBvcHRpb24gaXMgcGFzc2VkLCB0aGV5IGFyZSByZXZlcnNlZC5cclxuICAgKi9cbiAgYW5jZXN0b3JzKHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBwYXRocyA9IFBhdGgubGV2ZWxzKHBhdGgsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHBhdGhzID0gcGF0aHMuc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGhzID0gcGF0aHMuc2xpY2UoMCwgLTEpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRocztcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGNvbW1vbiBhbmNlc3RvciBwYXRoIG9mIHR3byBwYXRocy5cclxuICAgKi9cbiAgY29tbW9uKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgY29tbW9uID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoICYmIGkgPCBhbm90aGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgICAgdmFyIGJ2ID0gYW5vdGhlcltpXTtcblxuICAgICAgaWYgKGF2ICE9PSBidikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29tbW9uLnB1c2goYXYpO1xuICAgIH1cblxuICAgIHJldHVybiBjb21tb247XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ29tcGFyZSBhIHBhdGggdG8gYW5vdGhlciwgcmV0dXJuaW5nIGFuIGludGVnZXIgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBwYXRoXHJcbiAgICogd2FzIGJlZm9yZSwgYXQsIG9yIGFmdGVyIHRoZSBvdGhlci5cclxuICAgKlxyXG4gICAqIE5vdGU6IFR3byBwYXRocyBvZiB1bmVxdWFsIGxlbmd0aCBjYW4gc3RpbGwgcmVjZWl2ZSBhIGAwYCByZXN1bHQgaWYgb25lIGlzXHJcbiAgICogZGlyZWN0bHkgYWJvdmUgb3IgYmVsb3cgdGhlIG90aGVyLiBJZiB5b3Ugd2FudCBleGFjdCBtYXRjaGluZywgdXNlXHJcbiAgICogW1tQYXRoLmVxdWFsc11dIGluc3RlYWQuXHJcbiAgICovXG4gIGNvbXBhcmUocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihwYXRoLmxlbmd0aCwgYW5vdGhlci5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW47IGkrKykge1xuICAgICAgaWYgKHBhdGhbaV0gPCBhbm90aGVyW2ldKSByZXR1cm4gLTE7XG4gICAgICBpZiAocGF0aFtpXSA+IGFub3RoZXJbaV0pIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBlbmRzIGFmdGVyIG9uZSBvZiB0aGUgaW5kZXhlcyBpbiBhbm90aGVyLlxyXG4gICAqL1xuICBlbmRzQWZ0ZXIocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgIHZhciBidiA9IGFub3RoZXJbaV07XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicykgJiYgYXYgPiBidjtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggZW5kcyBhdCBvbmUgb2YgdGhlIGluZGV4ZXMgaW4gYW5vdGhlci5cclxuICAgKi9cbiAgZW5kc0F0KHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4gUGF0aC5lcXVhbHMoYXMsIGJzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggZW5kcyBiZWZvcmUgb25lIG9mIHRoZSBpbmRleGVzIGluIGFub3RoZXIuXHJcbiAgICovXG4gIGVuZHNCZWZvcmUocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgIHZhciBidiA9IGFub3RoZXJbaV07XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicykgJiYgYXYgPCBidjtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgZXhhY3RseSBlcXVhbCB0byBhbm90aGVyLlxyXG4gICAqL1xuICBlcXVhbHMocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA9PT0gYW5vdGhlci5sZW5ndGggJiYgcGF0aC5ldmVyeSgobiwgaSkgPT4gbiA9PT0gYW5vdGhlcltpXSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGFmdGVyIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQWZ0ZXIocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDE7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGFuIGFuY2VzdG9yIG9mIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQW5jZXN0b3IocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA8IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgYmVmb3JlIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQmVmb3JlKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAtMTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgYSBjaGlsZCBvZiBhbm90aGVyLlxyXG4gICAqL1xuICBpc0NoaWxkKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPT09IGFub3RoZXIubGVuZ3RoICsgMSAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGVxdWFsIHRvIG9yIGFuIGFuY2VzdG9yIG9mIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQ29tbW9uKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPD0gYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBhIGRlc2NlbmRhbnQgb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNEZXNjZW5kYW50KHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPiBhbm90aGVyLmxlbmd0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIHRoZSBwYXJlbnQgb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNQYXJlbnQocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCArIDEgPT09IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpcyBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBQYXRoYCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzUGF0aCh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiAodmFsdWUubGVuZ3RoID09PSAwIHx8IHR5cGVvZiB2YWx1ZVswXSA9PT0gJ251bWJlcicpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBhIHNpYmxpbmcgb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNTaWJsaW5nKHBhdGgsIGFub3RoZXIpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggIT09IGFub3RoZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGFzID0gcGF0aC5zbGljZSgwLCAtMSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCAtMSk7XG4gICAgdmFyIGFsID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIHZhciBibCA9IGFub3RoZXJbYW5vdGhlci5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gYWwgIT09IGJsICYmIFBhdGguZXF1YWxzKGFzLCBicyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IGEgbGlzdCBvZiBwYXRocyBhdCBldmVyeSBsZXZlbCBkb3duIHRvIGEgcGF0aC4gTm90ZTogdGhpcyBpcyB0aGUgc2FtZVxyXG4gICAqIGFzIGBQYXRoLmFuY2VzdG9yc2AsIGJ1dCBpbmNsdWRpbmcgdGhlIHBhdGggaXRzZWxmLlxyXG4gICAqXHJcbiAgICogVGhlIHBhdGhzIGFyZSBzb3J0ZWQgZnJvbSBzaGFsbG93ZXN0IHRvIGRlZXBlc3QuIEhvd2V2ZXIsIGlmIHRoZSBgcmV2ZXJzZTpcclxuICAgKiB0cnVlYCBvcHRpb24gaXMgcGFzc2VkLCB0aGV5IGFyZSByZXZlcnNlZC5cclxuICAgKi9cbiAgbGV2ZWxzKHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBsaXN0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0LnB1c2gocGF0aC5zbGljZSgwLCBpKSk7XG4gICAgfVxuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGxpc3QucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdpdmVuIGEgcGF0aCwgZ2V0IHRoZSBwYXRoIHRvIHRoZSBuZXh0IHNpYmxpbmcgbm9kZS5cclxuICAgKi9cbiAgbmV4dChwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBuZXh0IHBhdGggb2YgYSByb290IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0sIGJlY2F1c2UgaXQgaGFzIG5vIG5leHQgaW5kZXguXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgbGFzdCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCAtMSkuY29uY2F0KGxhc3QgKyAxKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHaXZlbiBhIHBhdGgsIHJldHVybiBhIG5ldyBwYXRoIHJlZmVycmluZyB0byB0aGUgcGFyZW50IG5vZGUgYWJvdmUgaXQuXHJcbiAgICovXG4gIHBhcmVudChwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBwYXJlbnQgcGF0aCBvZiB0aGUgcm9vdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdLlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgLTEpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdpdmVuIGEgcGF0aCwgZ2V0IHRoZSBwYXRoIHRvIHRoZSBwcmV2aW91cyBzaWJsaW5nIG5vZGUuXHJcbiAgICovXG4gIHByZXZpb3VzKHBhdGgpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHByZXZpb3VzIHBhdGggb2YgYSByb290IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0sIGJlY2F1c2UgaXQgaGFzIG5vIHByZXZpb3VzIGluZGV4LlwiKSk7XG4gICAgfVxuXG4gICAgdmFyIGxhc3QgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAobGFzdCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBwcmV2aW91cyBwYXRoIG9mIGEgZmlyc3QgY2hpbGQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IHdvdWxkIHJlc3VsdCBpbiBhIG5lZ2F0aXZlIGluZGV4LlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgLTEpLmNvbmNhdChsYXN0IC0gMSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IGEgcGF0aCByZWxhdGl2ZSB0byBhbiBhbmNlc3Rvci5cclxuICAgKi9cbiAgcmVsYXRpdmUocGF0aCwgYW5jZXN0b3IpIHtcbiAgICBpZiAoIVBhdGguaXNBbmNlc3RvcihhbmNlc3RvciwgcGF0aCkgJiYgIVBhdGguZXF1YWxzKHBhdGgsIGFuY2VzdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcmVsYXRpdmUgcGF0aCBvZiBbXCIuY29uY2F0KHBhdGgsIFwiXSBpbnNpZGUgYW5jZXN0b3IgW1wiKS5jb25jYXQoYW5jZXN0b3IsIFwiXSwgYmVjYXVzZSBpdCBpcyBub3QgYWJvdmUgb3IgZXF1YWwgdG8gdGhlIHBhdGguXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aC5zbGljZShhbmNlc3Rvci5sZW5ndGgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSBhIHBhdGggYnkgYW4gb3BlcmF0aW9uLlxyXG4gICAqL1xuICB0cmFuc2Zvcm0ocGF0aCwgb3BlcmF0aW9uKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBwcm9kdWNlKHBhdGgsIHAgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgYWZmaW5pdHkgPSAnZm9yd2FyZCdcbiAgICAgIH0gPSBvcHRpb25zOyAvLyBQRVJGOiBFeGl0IGVhcmx5IGlmIHRoZSBvcGVyYXRpb24gaXMgZ3VhcmFudGVlZCBub3QgdG8gaGF2ZSBhbiBlZmZlY3QuXG5cbiAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAob3BlcmF0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICAgIHBhdGg6IG9wXG4gICAgICAgICAgICB9ID0gb3BlcmF0aW9uO1xuXG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AsIHApIHx8IFBhdGguZW5kc0JlZm9yZShvcCwgcCkgfHwgUGF0aC5pc0FuY2VzdG9yKG9wLCBwKSkge1xuICAgICAgICAgICAgICBwW29wLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgICAgcGF0aDogX29wXG4gICAgICAgICAgICB9ID0gb3BlcmF0aW9uO1xuXG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3IoX29wLCBwKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcCwgcCkpIHtcbiAgICAgICAgICAgICAgcFtfb3AubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICAgIHBhdGg6IF9vcDIsXG4gICAgICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgICAgICB9ID0gb3BlcmF0aW9uO1xuXG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wMiwgcCkgfHwgUGF0aC5lbmRzQmVmb3JlKF9vcDIsIHApKSB7XG4gICAgICAgICAgICAgIHBbX29wMi5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wMiwgcCkpIHtcbiAgICAgICAgICAgICAgcFtfb3AyLmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICAgIHBbX29wMi5sZW5ndGhdICs9IHBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgICAgcGF0aDogX29wMyxcbiAgICAgICAgICAgICAgcG9zaXRpb246IF9wb3NpdGlvblxuICAgICAgICAgICAgfSA9IG9wZXJhdGlvbjtcblxuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDMsIHApKSB7XG4gICAgICAgICAgICAgIGlmIChhZmZpbml0eSA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgICAgICAgICAgICAgcFtwLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWZmaW5pdHkgPT09ICdiYWNrd2FyZCcpIDsgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDMsIHApKSB7XG4gICAgICAgICAgICAgIHBbX29wMy5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wMywgcCkgJiYgcGF0aFtfb3AzLmxlbmd0aF0gPj0gX3Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIHBbX29wMy5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgICBwW19vcDMubGVuZ3RoXSAtPSBfcG9zaXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICAgIHBhdGg6IF9vcDQsXG4gICAgICAgICAgICAgIG5ld1BhdGg6IG9ucFxuICAgICAgICAgICAgfSA9IG9wZXJhdGlvbjsgLy8gSWYgdGhlIG9sZCBhbmQgbmV3IHBhdGggYXJlIHRoZSBzYW1lLCBpdCdzIGEgbm8tb3AuXG5cbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhfb3A0LCBvbnApKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFBhdGguaXNBbmNlc3Rvcihfb3A0LCBwKSB8fCBQYXRoLmVxdWFscyhfb3A0LCBwKSkge1xuICAgICAgICAgICAgICB2YXIgY29weSA9IG9ucC5zbGljZSgpO1xuXG4gICAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgb25wKSAmJiBfb3A0Lmxlbmd0aCA8IG9ucC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb3B5W19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBjb3B5LmNvbmNhdChwLnNsaWNlKF9vcDQubGVuZ3RoKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguaXNTaWJsaW5nKF9vcDQsIG9ucCkgJiYgKFBhdGguaXNBbmNlc3RvcihvbnAsIHApIHx8IFBhdGguZXF1YWxzKG9ucCwgcCkpKSB7XG4gICAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgcCkpIHtcbiAgICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUob25wLCBwKSB8fCBQYXRoLmVxdWFscyhvbnAsIHApIHx8IFBhdGguaXNBbmNlc3RvcihvbnAsIHApKSB7XG4gICAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgcCkpIHtcbiAgICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHBbb25wLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBwKSkge1xuICAgICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob25wLCBwKSkge1xuICAgICAgICAgICAgICAgIHBbb25wLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn07XG5cbnZhciBQYXRoUmVmID0ge1xuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gdGhlIHBhdGggcmVmJ3MgY3VycmVudCB2YWx1ZSBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybShyZWYsIG9wKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBhZmZpbml0eVxuICAgIH0gPSByZWY7XG5cbiAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhdGggPSBQYXRoLnRyYW5zZm9ybShjdXJyZW50LCBvcCwge1xuICAgICAgYWZmaW5pdHlcbiAgICB9KTtcbiAgICByZWYuY3VycmVudCA9IHBhdGg7XG5cbiAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICByZWYudW5yZWYoKTtcbiAgICB9XG4gIH1cblxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQyKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDIodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQyKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMihPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbnZhciBQb2ludCA9IHtcbiAgLyoqXHJcbiAgICogQ29tcGFyZSBhIHBvaW50IHRvIGFub3RoZXIsIHJldHVybmluZyBhbiBpbnRlZ2VyIGluZGljYXRpbmcgd2hldGhlciB0aGVcclxuICAgKiBwb2ludCB3YXMgYmVmb3JlLCBhdCwgb3IgYWZ0ZXIgdGhlIG90aGVyLlxyXG4gICAqL1xuICBjb21wYXJlKHBvaW50LCBhbm90aGVyKSB7XG4gICAgdmFyIHJlc3VsdCA9IFBhdGguY29tcGFyZShwb2ludC5wYXRoLCBhbm90aGVyLnBhdGgpO1xuXG4gICAgaWYgKHJlc3VsdCA9PT0gMCkge1xuICAgICAgaWYgKHBvaW50Lm9mZnNldCA8IGFub3RoZXIub2Zmc2V0KSByZXR1cm4gLTE7XG4gICAgICBpZiAocG9pbnQub2Zmc2V0ID4gYW5vdGhlci5vZmZzZXQpIHJldHVybiAxO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIGFmdGVyIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQWZ0ZXIocG9pbnQsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUG9pbnQuY29tcGFyZShwb2ludCwgYW5vdGhlcikgPT09IDE7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyBiZWZvcmUgYW5vdGhlci5cclxuICAgKi9cbiAgaXNCZWZvcmUocG9pbnQsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUG9pbnQuY29tcGFyZShwb2ludCwgYW5vdGhlcikgPT09IC0xO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgZXhhY3RseSBlcXVhbCB0byBhbm90aGVyLlxyXG4gICAqL1xuICBlcXVhbHMocG9pbnQsIGFub3RoZXIpIHtcbiAgICAvLyBQRVJGOiBlbnN1cmUgdGhlIG9mZnNldHMgYXJlIGVxdWFsIGZpcnN0IHNpbmNlIHRoZXkgYXJlIGNoZWFwZXIgdG8gY2hlY2suXG4gICAgcmV0dXJuIHBvaW50Lm9mZnNldCA9PT0gYW5vdGhlci5vZmZzZXQgJiYgUGF0aC5lcXVhbHMocG9pbnQucGF0aCwgYW5vdGhlci5wYXRoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBQb2ludGAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc1BvaW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpICYmIHR5cGVvZiB2YWx1ZS5vZmZzZXQgPT09ICdudW1iZXInICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSBhIHBvaW50IGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtKHBvaW50LCBvcCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gcHJvZHVjZShwb2ludCwgcCA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBhZmZpbml0eSA9ICdmb3J3YXJkJ1xuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBwYXRoLFxuICAgICAgICBvZmZzZXRcbiAgICAgIH0gPSBwO1xuXG4gICAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpICYmIG9wLm9mZnNldCA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgcC5vZmZzZXQgKz0gb3AudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICAgICAgcC5vZmZzZXQgKz0gb3AucG9zaXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpICYmIG9wLm9mZnNldCA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgcC5vZmZzZXQgLT0gTWF0aC5taW4ob2Zmc2V0IC0gb3Aub2Zmc2V0LCBvcC50ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpIHx8IFBhdGguaXNBbmNlc3RvcihvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcC5wYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgICBpZiAob3AucG9zaXRpb24gPT09IG9mZnNldCAmJiBhZmZpbml0eSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAob3AucG9zaXRpb24gPCBvZmZzZXQgfHwgb3AucG9zaXRpb24gPT09IG9mZnNldCAmJiBhZmZpbml0eSA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgICAgICAgICAgICAgcC5vZmZzZXQgLT0gb3AucG9zaXRpb247XG4gICAgICAgICAgICAgICAgcC5wYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIF9vYmplY3RTcHJlYWQkMih7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgYWZmaW5pdHk6ICdmb3J3YXJkJ1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcC5wYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufTtcblxudmFyIFBvaW50UmVmID0ge1xuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gdGhlIHBvaW50IHJlZidzIGN1cnJlbnQgdmFsdWUgYnkgYW4gb3BlcmF0aW9uLlxyXG4gICAqL1xuICB0cmFuc2Zvcm0ocmVmLCBvcCkge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgYWZmaW5pdHlcbiAgICB9ID0gcmVmO1xuXG4gICAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwb2ludCA9IFBvaW50LnRyYW5zZm9ybShjdXJyZW50LCBvcCwge1xuICAgICAgYWZmaW5pdHlcbiAgICB9KTtcbiAgICByZWYuY3VycmVudCA9IHBvaW50O1xuXG4gICAgaWYgKHBvaW50ID09IG51bGwpIHtcbiAgICAgIHJlZi51bnJlZigpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMyh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIFJhbmdlID0ge1xuICAvKipcclxuICAgKiBHZXQgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIG9mIGEgcmFuZ2UsIGluIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IGFwcGVhclxyXG4gICAqIGluIHRoZSBkb2N1bWVudC5cclxuICAgKi9cbiAgZWRnZXMocmFuZ2UpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSByYW5nZTtcbiAgICByZXR1cm4gUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSkgPT09IHJldmVyc2UgPyBbYW5jaG9yLCBmb2N1c10gOiBbZm9jdXMsIGFuY2hvcl07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBlbmQgcG9pbnQgb2YgYSByYW5nZS5cclxuICAgKi9cbiAgZW5kKHJhbmdlKSB7XG4gICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgcmV0dXJuIGVuZDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGlzIGV4YWN0bHkgZXF1YWwgdG8gYW5vdGhlci5cclxuICAgKi9cbiAgZXF1YWxzKHJhbmdlLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmVxdWFscyhyYW5nZS5hbmNob3IsIGFub3RoZXIuYW5jaG9yKSAmJiBQb2ludC5lcXVhbHMocmFuZ2UuZm9jdXMsIGFub3RoZXIuZm9jdXMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcmFuZ2UgaW5jbHVkZXMgYSBwYXRoLCBhIHBvaW50IG9yIHBhcnQgb2YgYW5vdGhlciByYW5nZS5cclxuICAgKi9cbiAgaW5jbHVkZXMocmFuZ2UsIHRhcmdldCkge1xuICAgIGlmIChSYW5nZS5pc1JhbmdlKHRhcmdldCkpIHtcbiAgICAgIGlmIChSYW5nZS5pbmNsdWRlcyhyYW5nZSwgdGFyZ2V0LmFuY2hvcikgfHwgUmFuZ2UuaW5jbHVkZXMocmFuZ2UsIHRhcmdldC5mb2N1cykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBbcnMsIHJlXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICAgIHZhciBbdHMsIHRlXSA9IFJhbmdlLmVkZ2VzKHRhcmdldCk7XG4gICAgICByZXR1cm4gUG9pbnQuaXNCZWZvcmUocnMsIHRzKSAmJiBQb2ludC5pc0FmdGVyKHJlLCB0ZSk7XG4gICAgfVxuXG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICB2YXIgaXNBZnRlclN0YXJ0ID0gZmFsc2U7XG4gICAgdmFyIGlzQmVmb3JlRW5kID0gZmFsc2U7XG5cbiAgICBpZiAoUG9pbnQuaXNQb2ludCh0YXJnZXQpKSB7XG4gICAgICBpc0FmdGVyU3RhcnQgPSBQb2ludC5jb21wYXJlKHRhcmdldCwgc3RhcnQpID49IDA7XG4gICAgICBpc0JlZm9yZUVuZCA9IFBvaW50LmNvbXBhcmUodGFyZ2V0LCBlbmQpIDw9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzQWZ0ZXJTdGFydCA9IFBhdGguY29tcGFyZSh0YXJnZXQsIHN0YXJ0LnBhdGgpID49IDA7XG4gICAgICBpc0JlZm9yZUVuZCA9IFBhdGguY29tcGFyZSh0YXJnZXQsIGVuZC5wYXRoKSA8PSAwO1xuICAgIH1cblxuICAgIHJldHVybiBpc0FmdGVyU3RhcnQgJiYgaXNCZWZvcmVFbmQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBpbnRlcnNlY3Rpb24gb2YgYSByYW5nZSB3aXRoIGFub3RoZXIuXHJcbiAgICovXG4gIGludGVyc2VjdGlvbihyYW5nZSwgYW5vdGhlcikge1xuICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHJhbmdlLCBbXCJhbmNob3JcIiwgXCJmb2N1c1wiXSk7XG5cbiAgICB2YXIgW3MxLCBlMV0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIFtzMiwgZTJdID0gUmFuZ2UuZWRnZXMoYW5vdGhlcik7XG4gICAgdmFyIHN0YXJ0ID0gUG9pbnQuaXNCZWZvcmUoczEsIHMyKSA/IHMyIDogczE7XG4gICAgdmFyIGVuZCA9IFBvaW50LmlzQmVmb3JlKGUxLCBlMikgPyBlMSA6IGUyO1xuXG4gICAgaWYgKFBvaW50LmlzQmVmb3JlKGVuZCwgc3RhcnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkMyh7XG4gICAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICAgIGZvY3VzOiBlbmRcbiAgICAgIH0sIHJlc3QpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGlzIGJhY2t3YXJkLCBtZWFuaW5nIHRoYXQgaXRzIGFuY2hvciBwb2ludCBhcHBlYXJzIGluIHRoZVxyXG4gICAqIGRvY3VtZW50IF9hZnRlcl8gaXRzIGZvY3VzIHBvaW50LlxyXG4gICAqL1xuICBpc0JhY2t3YXJkKHJhbmdlKSB7XG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHJhbmdlO1xuICAgIHJldHVybiBQb2ludC5pc0FmdGVyKGFuY2hvciwgZm9jdXMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcmFuZ2UgaXMgY29sbGFwc2VkLCBtZWFuaW5nIHRoYXQgYm90aCBpdHMgYW5jaG9yIGFuZCBmb2N1c1xyXG4gICAqIHBvaW50cyByZWZlciB0byB0aGUgZXhhY3Qgc2FtZSBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgICovXG4gIGlzQ29sbGFwc2VkKHJhbmdlKSB7XG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHJhbmdlO1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMoYW5jaG9yLCBmb2N1cyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSByYW5nZSBpcyBleHBhbmRlZC5cclxuICAgKlxyXG4gICAqIFRoaXMgaXMgdGhlIG9wcG9zaXRlIG9mIFtbUmFuZ2UuaXNDb2xsYXBzZWRdXSBhbmQgaXMgcHJvdmlkZWQgZm9yIGxlZ2liaWxpdHkuXHJcbiAgICovXG4gIGlzRXhwYW5kZWQocmFuZ2UpIHtcbiAgICByZXR1cm4gIVJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGlzIGZvcndhcmQuXHJcbiAgICpcclxuICAgKiBUaGlzIGlzIHRoZSBvcHBvc2l0ZSBvZiBbW1JhbmdlLmlzQmFja3dhcmRdXSBhbmQgaXMgcHJvdmlkZWQgZm9yIGxlZ2liaWxpdHkuXHJcbiAgICovXG4gIGlzRm9yd2FyZChyYW5nZSkge1xuICAgIHJldHVybiAhUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBbW1JhbmdlXV0gaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc1JhbmdlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpICYmIFBvaW50LmlzUG9pbnQodmFsdWUuYW5jaG9yKSAmJiBQb2ludC5pc1BvaW50KHZhbHVlLmZvY3VzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBwb2ludCBlbnRyaWVzIGluIGEgcmFuZ2UuXHJcbiAgICovXG4gICpwb2ludHMocmFuZ2UpIHtcbiAgICB5aWVsZCBbcmFuZ2UuYW5jaG9yLCAnYW5jaG9yJ107XG4gICAgeWllbGQgW3JhbmdlLmZvY3VzLCAnZm9jdXMnXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHN0YXJ0IHBvaW50IG9mIGEgcmFuZ2UuXHJcbiAgICovXG4gIHN0YXJ0KHJhbmdlKSB7XG4gICAgdmFyIFtzdGFydF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgcmV0dXJuIHN0YXJ0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSBhIHJhbmdlIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtKHJhbmdlLCBvcCwgb3B0aW9ucykge1xuICAgIHZhciB7XG4gICAgICBhZmZpbml0eSA9ICdpbndhcmQnXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIGFmZmluaXR5QW5jaG9yO1xuICAgIHZhciBhZmZpbml0eUZvY3VzO1xuXG4gICAgaWYgKGFmZmluaXR5ID09PSAnaW53YXJkJykge1xuICAgICAgaWYgKFJhbmdlLmlzRm9yd2FyZChyYW5nZSkpIHtcbiAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnZm9yd2FyZCc7XG4gICAgICAgIGFmZmluaXR5Rm9jdXMgPSAnYmFja3dhcmQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnYmFja3dhcmQnO1xuICAgICAgICBhZmZpbml0eUZvY3VzID0gJ2ZvcndhcmQnO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWZmaW5pdHkgPT09ICdvdXR3YXJkJykge1xuICAgICAgaWYgKFJhbmdlLmlzRm9yd2FyZChyYW5nZSkpIHtcbiAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnYmFja3dhcmQnO1xuICAgICAgICBhZmZpbml0eUZvY3VzID0gJ2ZvcndhcmQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnZm9yd2FyZCc7XG4gICAgICAgIGFmZmluaXR5Rm9jdXMgPSAnYmFja3dhcmQnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhZmZpbml0eUFuY2hvciA9IGFmZmluaXR5O1xuICAgICAgYWZmaW5pdHlGb2N1cyA9IGFmZmluaXR5O1xuICAgIH1cblxuICAgIHJldHVybiBwcm9kdWNlKHJhbmdlLCByID0+IHtcbiAgICAgIHZhciBhbmNob3IgPSBQb2ludC50cmFuc2Zvcm0oci5hbmNob3IsIG9wLCB7XG4gICAgICAgIGFmZmluaXR5OiBhZmZpbml0eUFuY2hvclxuICAgICAgfSk7XG4gICAgICB2YXIgZm9jdXMgPSBQb2ludC50cmFuc2Zvcm0oci5mb2N1cywgb3AsIHtcbiAgICAgICAgYWZmaW5pdHk6IGFmZmluaXR5Rm9jdXNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWFuY2hvciB8fCAhZm9jdXMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHIuYW5jaG9yID0gYW5jaG9yO1xuICAgICAgci5mb2N1cyA9IGZvY3VzO1xuICAgIH0pO1xuICB9XG5cbn07XG5cbnZhciBSYW5nZVJlZiA9IHtcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtIHRoZSByYW5nZSByZWYncyBjdXJyZW50IHZhbHVlIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtKHJlZiwgb3ApIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIGFmZmluaXR5XG4gICAgfSA9IHJlZjtcblxuICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGF0aCA9IFJhbmdlLnRyYW5zZm9ybShjdXJyZW50LCBvcCwge1xuICAgICAgYWZmaW5pdHlcbiAgICB9KTtcbiAgICByZWYuY3VycmVudCA9IHBhdGg7XG5cbiAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICByZWYudW5yZWYoKTtcbiAgICB9XG4gIH1cblxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ0KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ0KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkNChPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbnZhciBUZXh0ID0ge1xuICAvKipcclxuICAgKiBDaGVjayBpZiB0d28gdGV4dCBub2RlcyBhcmUgZXF1YWwuXHJcbiAgICovXG4gIGVxdWFscyh0ZXh0LCBhbm90aGVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBsb29zZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGV4dCkge1xuICAgICAgaWYgKGxvb3NlICYmIGtleSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dFtrZXldICE9PSBhbm90aGVyW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9rZXkgaW4gYW5vdGhlcikge1xuICAgICAgaWYgKGxvb3NlICYmIF9rZXkgPT09ICd0ZXh0Jykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRbX2tleV0gIT09IGFub3RoZXJbX2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgYFRleHRgIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNUZXh0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpICYmIHR5cGVvZiB2YWx1ZS50ZXh0ID09PSAnc3RyaW5nJztcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgbGlzdCBvZiBgVGV4dGAgb2JqZWN0cy5cclxuICAgKi9cbiAgaXNUZXh0TGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiAodmFsdWUubGVuZ3RoID09PSAwIHx8IFRleHQuaXNUZXh0KHZhbHVlWzBdKSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYW4gdGV4dCBtYXRjaGVzIHNldCBvZiBwcm9wZXJ0aWVzLlxyXG4gICAqXHJcbiAgICogTm90ZTogdGhpcyBpcyBmb3IgbWF0Y2hpbmcgY3VzdG9tIHByb3BlcnRpZXMsIGFuZCBpdCBkb2VzIG5vdCBlbnN1cmUgdGhhdFxyXG4gICAqIHRoZSBgdGV4dGAgcHJvcGVydHkgYXJlIHR3byBub2RlcyBlcXVhbC5cclxuICAgKi9cbiAgbWF0Y2hlcyh0ZXh0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKGtleSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dFtrZXldICE9PSBwcm9wc1trZXldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGxlYXZlcyBmb3IgYSB0ZXh0IG5vZGUgZ2l2ZW4gZGVjb3JhdGlvbnMuXHJcbiAgICovXG4gIGRlY29yYXRpb25zKG5vZGUsIGRlY29yYXRpb25zKSB7XG4gICAgdmFyIGxlYXZlcyA9IFtfb2JqZWN0U3ByZWFkJDQoe30sIG5vZGUpXTtcblxuICAgIGZvciAodmFyIGRlYyBvZiBkZWNvcmF0aW9ucykge1xuICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoZGVjLCBbXCJhbmNob3JcIiwgXCJmb2N1c1wiXSk7XG5cbiAgICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhkZWMpO1xuICAgICAgdmFyIG5leHQgPSBbXTtcbiAgICAgIHZhciBvID0gMDtcblxuICAgICAgZm9yICh2YXIgbGVhZiBvZiBsZWF2ZXMpIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBsZW5ndGhcbiAgICAgICAgfSA9IGxlYWYudGV4dDtcbiAgICAgICAgdmFyIG9mZnNldCA9IG87XG4gICAgICAgIG8gKz0gbGVuZ3RoOyAvLyBJZiB0aGUgcmFuZ2UgZW5jb21wYXNlcyB0aGUgZW50aXJlIGxlYWYsIGFkZCB0aGUgcmFuZ2UuXG5cbiAgICAgICAgaWYgKHN0YXJ0Lm9mZnNldCA8PSBvZmZzZXQgJiYgZW5kLm9mZnNldCA+PSBvZmZzZXQgKyBsZW5ndGgpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGxlYWYsIHJlc3QpO1xuICAgICAgICAgIG5leHQucHVzaChsZWFmKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBJZiB0aGUgcmFuZ2Ugc3RhcnRzIGFmdGVyIHRoZSBsZWFmLCBvciBlbmRzIGJlZm9yZSBpdCwgY29udGludWUuXG5cblxuICAgICAgICBpZiAoc3RhcnQub2Zmc2V0ID4gb2Zmc2V0ICsgbGVuZ3RoIHx8IGVuZC5vZmZzZXQgPCBvZmZzZXQgfHwgZW5kLm9mZnNldCA9PT0gb2Zmc2V0ICYmIG9mZnNldCAhPT0gMCkge1xuICAgICAgICAgIG5leHQucHVzaChsZWFmKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byBzcGxpdCB0aGUgbGVhZiwgYXQgdGhlIHN0YXJ0LCBlbmQsIG9yIGJvdGgsXG4gICAgICAgIC8vIGFuZCBhZGQgdGhlIHJhbmdlIHRvIHRoZSBtaWRkbGUgaW50ZXJzZWN0aW5nIHNlY3Rpb24uIERvIHRoZSBlbmRcbiAgICAgICAgLy8gc3BsaXQgZmlyc3Qgc2luY2Ugd2UgZG9uJ3QgbmVlZCB0byB1cGRhdGUgdGhlIG9mZnNldCB0aGF0IHdheS5cblxuXG4gICAgICAgIHZhciBtaWRkbGUgPSBsZWFmO1xuICAgICAgICB2YXIgYmVmb3JlID0gdm9pZCAwO1xuICAgICAgICB2YXIgYWZ0ZXIgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKGVuZC5vZmZzZXQgPCBvZmZzZXQgKyBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgb2ZmID0gZW5kLm9mZnNldCAtIG9mZnNldDtcbiAgICAgICAgICBhZnRlciA9IF9vYmplY3RTcHJlYWQkNCh7fSwgbWlkZGxlLCB7XG4gICAgICAgICAgICB0ZXh0OiBtaWRkbGUudGV4dC5zbGljZShvZmYpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbWlkZGxlID0gX29iamVjdFNwcmVhZCQ0KHt9LCBtaWRkbGUsIHtcbiAgICAgICAgICAgIHRleHQ6IG1pZGRsZS50ZXh0LnNsaWNlKDAsIG9mZilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydC5vZmZzZXQgPiBvZmZzZXQpIHtcbiAgICAgICAgICB2YXIgX29mZiA9IHN0YXJ0Lm9mZnNldCAtIG9mZnNldDtcblxuICAgICAgICAgIGJlZm9yZSA9IF9vYmplY3RTcHJlYWQkNCh7fSwgbWlkZGxlLCB7XG4gICAgICAgICAgICB0ZXh0OiBtaWRkbGUudGV4dC5zbGljZSgwLCBfb2ZmKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1pZGRsZSA9IF9vYmplY3RTcHJlYWQkNCh7fSwgbWlkZGxlLCB7XG4gICAgICAgICAgICB0ZXh0OiBtaWRkbGUudGV4dC5zbGljZShfb2ZmKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihtaWRkbGUsIHJlc3QpO1xuXG4gICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICBuZXh0LnB1c2goYmVmb3JlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQucHVzaChtaWRkbGUpO1xuXG4gICAgICAgIGlmIChhZnRlcikge1xuICAgICAgICAgIG5leHQucHVzaChhZnRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGVhdmVzID0gbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gbGVhdmVzO1xuICB9XG5cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkNShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ1KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkNShPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDUoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG52YXIgR2VuZXJhbFRyYW5zZm9ybXMgPSB7XG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSB0aGUgZWRpdG9yIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtKGVkaXRvciwgb3ApIHtcbiAgICBlZGl0b3IuY2hpbGRyZW4gPSBjcmVhdGVEcmFmdChlZGl0b3IuY2hpbGRyZW4pO1xuICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uICYmIGNyZWF0ZURyYWZ0KGVkaXRvci5zZWxlY3Rpb24pO1xuXG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIG5vZGVcbiAgICAgICAgICB9ID0gb3A7XG4gICAgICAgICAgdmFyIHBhcmVudCA9IE5vZGUucGFyZW50KGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIG5vZGUpO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgZm9yICh2YXIgW3BvaW50LCBrZXldIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbltrZXldID0gUG9pbnQudHJhbnNmb3JtKHBvaW50LCBvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgdGV4dFxuICAgICAgICAgIH0gPSBvcDtcblxuICAgICAgICAgIHZhciBfbm9kZSA9IE5vZGUubGVhZihlZGl0b3IsIF9wYXRoKTtcblxuICAgICAgICAgIHZhciBiZWZvcmUgPSBfbm9kZS50ZXh0LnNsaWNlKDAsIG9mZnNldCk7XG5cbiAgICAgICAgICB2YXIgYWZ0ZXIgPSBfbm9kZS50ZXh0LnNsaWNlKG9mZnNldCk7XG5cbiAgICAgICAgICBfbm9kZS50ZXh0ID0gYmVmb3JlICsgdGV4dCArIGFmdGVyO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgZm9yICh2YXIgW19wb2ludCwgX2tleV0gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXldID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludCwgb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoMlxuICAgICAgICAgIH0gPSBvcDtcblxuICAgICAgICAgIHZhciBfbm9kZTIgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoMik7XG5cbiAgICAgICAgICB2YXIgcHJldlBhdGggPSBQYXRoLnByZXZpb3VzKF9wYXRoMik7XG4gICAgICAgICAgdmFyIHByZXYgPSBOb2RlLmdldChlZGl0b3IsIHByZXZQYXRoKTtcblxuICAgICAgICAgIHZhciBfcGFyZW50ID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDIpO1xuXG4gICAgICAgICAgdmFyIF9pbmRleCA9IF9wYXRoMltfcGF0aDIubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICBpZiAoVGV4dC5pc1RleHQoX25vZGUyKSAmJiBUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICAgICAgcHJldi50ZXh0ICs9IF9ub2RlMi50ZXh0O1xuICAgICAgICAgIH0gZWxzZSBpZiAoIVRleHQuaXNUZXh0KF9ub2RlMikgJiYgIVRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgICAgICBwcmV2LmNoaWxkcmVuLnB1c2goLi4uX25vZGUyLmNoaWxkcmVuKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGEgXFxcIm1lcmdlX25vZGVcXFwiIG9wZXJhdGlvbiBhdCBwYXRoIFtcIi5jb25jYXQoX3BhdGgyLCBcIl0gdG8gbm9kZXMgb2YgZGlmZmVyZW50IGludGVyYWNlczogXCIpLmNvbmNhdChfbm9kZTIsIFwiIFwiKS5jb25jYXQocHJldikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKF9pbmRleCwgMSk7XG5cbiAgICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBbX3BvaW50MiwgX2tleTJdIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5Ml0gPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50Miwgb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogX3BhdGgzLFxuICAgICAgICAgICAgbmV3UGF0aFxuICAgICAgICAgIH0gPSBvcDtcblxuICAgICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IoX3BhdGgzLCBuZXdQYXRoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1vdmUgYSBwYXRoIFtcIi5jb25jYXQoX3BhdGgzLCBcIl0gdG8gbmV3IHBhdGggW1wiKS5jb25jYXQobmV3UGF0aCwgXCJdIGJlY2F1c2UgdGhlIGRlc3RpbmF0aW9uIGlzIGluc2lkZSBpdHNlbGYuXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX25vZGUzID0gTm9kZS5nZXQoZWRpdG9yLCBfcGF0aDMpO1xuXG4gICAgICAgICAgdmFyIF9wYXJlbnQyID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDMpO1xuXG4gICAgICAgICAgdmFyIF9pbmRleDIgPSBfcGF0aDNbX3BhdGgzLmxlbmd0aCAtIDFdOyAvLyBUaGlzIGlzIHRyaWNreSwgYnV0IHNpbmNlIHRoZSBgcGF0aGAgYW5kIGBuZXdQYXRoYCBib3RoIHJlZmVyIHRvXG4gICAgICAgICAgLy8gdGhlIHNhbWUgc25hcHNob3QgaW4gdGltZSwgdGhlcmUncyBhIG1pc21hdGNoLiBBZnRlciBlaXRoZXJcbiAgICAgICAgICAvLyByZW1vdmluZyB0aGUgb3JpZ2luYWwgcG9zaXRpb24sIHRoZSBzZWNvbmQgc3RlcCdzIHBhdGggY2FuIGJlIG91dFxuICAgICAgICAgIC8vIG9mIGRhdGUuIFNvIGluc3RlYWQgb2YgdXNpbmcgdGhlIGBvcC5uZXdQYXRoYCBkaXJlY3RseSwgd2VcbiAgICAgICAgICAvLyB0cmFuc2Zvcm0gYG9wLnBhdGhgIHRvIGFzY2VydGFpbiB3aGF0IHRoZSBgbmV3UGF0aGAgd291bGQgYmUgYWZ0ZXJcbiAgICAgICAgICAvLyB0aGUgb3BlcmF0aW9uIHdhcyBhcHBsaWVkLlxuXG4gICAgICAgICAgX3BhcmVudDIuY2hpbGRyZW4uc3BsaWNlKF9pbmRleDIsIDEpO1xuXG4gICAgICAgICAgdmFyIHRydWVQYXRoID0gUGF0aC50cmFuc2Zvcm0oX3BhdGgzLCBvcCk7XG4gICAgICAgICAgdmFyIG5ld1BhcmVudCA9IE5vZGUuZ2V0KGVkaXRvciwgUGF0aC5wYXJlbnQodHJ1ZVBhdGgpKTtcbiAgICAgICAgICB2YXIgbmV3SW5kZXggPSB0cnVlUGF0aFt0cnVlUGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICBuZXdQYXJlbnQuY2hpbGRyZW4uc3BsaWNlKG5ld0luZGV4LCAwLCBfbm9kZTMpO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgZm9yICh2YXIgW19wb2ludDMsIF9rZXkzXSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleTNdID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDMsIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogX3BhdGg0XG4gICAgICAgICAgfSA9IG9wO1xuICAgICAgICAgIHZhciBfaW5kZXgzID0gX3BhdGg0W19wYXRoNC5sZW5ndGggLSAxXTtcblxuICAgICAgICAgIHZhciBfcGFyZW50MyA9IE5vZGUucGFyZW50KGVkaXRvciwgX3BhdGg0KTtcblxuICAgICAgICAgIF9wYXJlbnQzLmNoaWxkcmVuLnNwbGljZShfaW5kZXgzLCAxKTsgLy8gVHJhbnNmb3JtIGFsbCBvZiB0aGUgcG9pbnRzIGluIHRoZSB2YWx1ZSwgYnV0IGlmIHRoZSBwb2ludCB3YXMgaW4gdGhlXG4gICAgICAgICAgLy8gbm9kZSB0aGF0IHdhcyByZW1vdmVkIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSByYW5nZSBvciByZW1vdmUgaXQuXG5cblxuICAgICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQ0LCBfa2V5NF0gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQ0LCBvcCk7XG5cbiAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAhPSBudWxsICYmIHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk0XSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgX3ByZXYgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIFtuLCBwXSBvZiBOb2RlLnRleHRzKGVkaXRvcikpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChQYXRoLmNvbXBhcmUocCwgX3BhdGg0KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgX3ByZXYgPSBbbiwgcF07XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gW24sIHBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX3ByZXYpIHtcbiAgICAgICAgICAgICAgICAgIF9wb2ludDQucGF0aCA9IF9wcmV2WzFdO1xuICAgICAgICAgICAgICAgICAgX3BvaW50NC5vZmZzZXQgPSBfcHJldlswXS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICAgIF9wb2ludDQucGF0aCA9IG5leHRbMV07XG4gICAgICAgICAgICAgICAgICBfcG9pbnQ0Lm9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoNSxcbiAgICAgICAgICAgIG9mZnNldDogX29mZnNldCxcbiAgICAgICAgICAgIHRleHQ6IF90ZXh0XG4gICAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgICAgdmFyIF9ub2RlNCA9IE5vZGUubGVhZihlZGl0b3IsIF9wYXRoNSk7XG5cbiAgICAgICAgICB2YXIgX2JlZm9yZSA9IF9ub2RlNC50ZXh0LnNsaWNlKDAsIF9vZmZzZXQpO1xuXG4gICAgICAgICAgdmFyIF9hZnRlciA9IF9ub2RlNC50ZXh0LnNsaWNlKF9vZmZzZXQgKyBfdGV4dC5sZW5ndGgpO1xuXG4gICAgICAgICAgX25vZGU0LnRleHQgPSBfYmVmb3JlICsgX2FmdGVyO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgZm9yICh2YXIgW19wb2ludDUsIF9rZXk1XSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleTVdID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDUsIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogX3BhdGg2LFxuICAgICAgICAgICAgbmV3UHJvcGVydGllc1xuICAgICAgICAgIH0gPSBvcDtcblxuICAgICAgICAgIGlmIChfcGF0aDYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHByb3BlcnRpZXMgb24gdGhlIHJvb3Qgbm9kZSFcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9ub2RlNSA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGg2KTtcblxuICAgICAgICAgIGZvciAodmFyIF9rZXk2IGluIG5ld1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChfa2V5NiA9PT0gJ2NoaWxkcmVuJyB8fCBfa2V5NiA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgdGhlIFxcXCJcIi5jb25jYXQoX2tleTYsIFwiXFxcIiBwcm9wZXJ0eSBvZiBub2RlcyFcIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBuZXdQcm9wZXJ0aWVzW19rZXk2XTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIF9ub2RlNVtfa2V5Nl07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfbm9kZTVbX2tleTZdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgbmV3UHJvcGVydGllczogX25ld1Byb3BlcnRpZXNcbiAgICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgICBpZiAoX25ld1Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgc2VsZWN0aW9uID0gX25ld1Byb3BlcnRpZXM7XG4gICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFSYW5nZS5pc1JhbmdlKF9uZXdQcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgYW4gaW5jb21wbGV0ZSBcXFwic2V0X3NlbGVjdGlvblxcXCIgb3BlcmF0aW9uIHByb3BlcnRpZXMgXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KF9uZXdQcm9wZXJ0aWVzKSwgXCIgd2hlbiB0aGVyZSBpcyBubyBjdXJyZW50IHNlbGVjdGlvbi5cIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBfbmV3UHJvcGVydGllcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzZWxlY3Rpb24sIF9uZXdQcm9wZXJ0aWVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfcGF0aDcsXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIHByb3BlcnRpZXNcbiAgICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgICBpZiAoX3BhdGg3Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGEgXFxcInNwbGl0X25vZGVcXFwiIG9wZXJhdGlvbiBhdCBwYXRoIFtcIi5jb25jYXQoX3BhdGg3LCBcIl0gYmVjYXVzZSB0aGUgcm9vdCBub2RlIGNhbm5vdCBiZSBzcGxpdC5cIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfbm9kZTYgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoNyk7XG5cbiAgICAgICAgICB2YXIgX3BhcmVudDQgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoNyk7XG5cbiAgICAgICAgICB2YXIgX2luZGV4NCA9IF9wYXRoN1tfcGF0aDcubGVuZ3RoIC0gMV07XG4gICAgICAgICAgdmFyIG5ld05vZGU7XG5cbiAgICAgICAgICBpZiAoVGV4dC5pc1RleHQoX25vZGU2KSkge1xuICAgICAgICAgICAgdmFyIF9iZWZvcmUyID0gX25vZGU2LnRleHQuc2xpY2UoMCwgcG9zaXRpb24pO1xuXG4gICAgICAgICAgICB2YXIgX2FmdGVyMiA9IF9ub2RlNi50ZXh0LnNsaWNlKHBvc2l0aW9uKTtcblxuICAgICAgICAgICAgX25vZGU2LnRleHQgPSBfYmVmb3JlMjtcbiAgICAgICAgICAgIG5ld05vZGUgPSBfb2JqZWN0U3ByZWFkJDUoe30sIF9ub2RlNiwge30sIHByb3BlcnRpZXMsIHtcbiAgICAgICAgICAgICAgdGV4dDogX2FmdGVyMlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfYmVmb3JlMyA9IF9ub2RlNi5jaGlsZHJlbi5zbGljZSgwLCBwb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHZhciBfYWZ0ZXIzID0gX25vZGU2LmNoaWxkcmVuLnNsaWNlKHBvc2l0aW9uKTtcblxuICAgICAgICAgICAgX25vZGU2LmNoaWxkcmVuID0gX2JlZm9yZTM7XG4gICAgICAgICAgICBuZXdOb2RlID0gX29iamVjdFNwcmVhZCQ1KHt9LCBfbm9kZTYsIHt9LCBwcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBfYWZ0ZXIzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfcGFyZW50NC5jaGlsZHJlbi5zcGxpY2UoX2luZGV4NCArIDEsIDAsIG5ld05vZGUpO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgZm9yICh2YXIgW19wb2ludDYsIF9rZXk3XSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleTddID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDYsIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVkaXRvci5jaGlsZHJlbiA9IGZpbmlzaERyYWZ0KGVkaXRvci5jaGlsZHJlbik7XG5cbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uID0gaXNEcmFmdChzZWxlY3Rpb24pID8gZmluaXNoRHJhZnQoc2VsZWN0aW9uKSA6IHNlbGVjdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IG51bGw7XG4gICAgfVxuICB9XG5cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkNihvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ2KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkNihPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDYoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG52YXIgTm9kZVRyYW5zZm9ybXMgPSB7XG4gIC8qKlxyXG4gICAqIEluc2VydCBub2RlcyBhdCBhIHNwZWNpZmljIGxvY2F0aW9uIGluIHRoZSBFZGl0b3IuXHJcbiAgICovXG4gIGluc2VydE5vZGVzKGVkaXRvciwgbm9kZXMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIGhhbmdpbmcgPSBmYWxzZSxcbiAgICAgICAgdm9pZHMgPSBmYWxzZSxcbiAgICAgICAgbW9kZSA9ICdsb3dlc3QnXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgc2VsZWN0XG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKE5vZGUuaXNOb2RlKG5vZGVzKSkge1xuICAgICAgICBub2RlcyA9IFtub2Rlc107XG4gICAgICB9XG5cbiAgICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgW25vZGVdID0gbm9kZXM7IC8vIEJ5IGRlZmF1bHQsIHVzZSB0aGUgc2VsZWN0aW9uIGFzIHRoZSB0YXJnZXQgbG9jYXRpb24uIEJ1dCBpZiB0aGVyZSBpc1xuICAgICAgLy8gbm8gc2VsZWN0aW9uLCBpbnNlcnQgYXQgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQgc2luY2UgdGhhdCBpcyBzdWNoIGFcbiAgICAgIC8vIGNvbW1vbiB1c2UgY2FzZSB3aGVuIGluc2VydGluZyBmcm9tIGEgbm9uLXNlbGVjdGVkIHN0YXRlLlxuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKGVkaXRvci5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYXQgPSBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF0ID0gWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZWN0ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdCA9PSBudWxsKSB7XG4gICAgICAgIHNlbGVjdCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgaWYgKCFoYW5naW5nKSB7XG4gICAgICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICAgICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXQgPSBwb2ludFJlZi51bnJlZigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChQb2ludC5pc1BvaW50KGF0KSkge1xuICAgICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICAgICAgbWF0Y2ggPSBuID0+IFRleHQuaXNUZXh0KG4pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWRpdG9yLmlzSW5saW5lKG5vZGUpKSB7XG4gICAgICAgICAgICBtYXRjaCA9IG4gPT4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoID0gbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBbZW50cnldID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBhdC5wYXRoLFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFyIFssIF9tYXRjaFBhdGhdID0gZW50cnk7XG4gICAgICAgICAgdmFyIHBhdGhSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsIF9tYXRjaFBhdGgpO1xuICAgICAgICAgIHZhciBpc0F0RW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIF9tYXRjaFBhdGgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0LFxuICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcbiAgICAgICAgICBhdCA9IGlzQXRFbmQgPyBQYXRoLm5leHQocGF0aCkgOiBwYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50UGF0aCA9IFBhdGgucGFyZW50KGF0KTtcbiAgICAgIHZhciBpbmRleCA9IGF0W2F0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICBhdDogcGFyZW50UGF0aFxuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfbm9kZSBvZiBub2Rlcykge1xuICAgICAgICB2YXIgX3BhdGggPSBwYXJlbnRQYXRoLmNvbmNhdChpbmRleCk7XG5cbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICB0eXBlOiAnaW5zZXJ0X25vZGUnLFxuICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgIG5vZGU6IF9ub2RlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0KSB7XG4gICAgICAgIHZhciBwb2ludCA9IEVkaXRvci5lbmQoZWRpdG9yLCBhdCk7XG5cbiAgICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBwb2ludCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBMaWZ0IG5vZGVzIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24gdXB3YXJkcyBpbiB0aGUgZG9jdW1lbnQgdHJlZSwgc3BsaXR0aW5nXHJcbiAgICogdGhlaXIgcGFyZW50IGluIHR3byBpZiBuZWNlc3NhcnkuXHJcbiAgICovXG4gIGxpZnROb2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIG1hdGNoXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2hlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtb2RlLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKG1hdGNoZXMsIChfcmVmKSA9PiB7XG4gICAgICAgIHZhciBbLCBwXSA9IF9yZWY7XG4gICAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIHBhdGhSZWYgb2YgcGF0aFJlZnMpIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG5cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoIDwgMikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBsaWZ0IG5vZGUgYXQgYSBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgaGFzIGEgZGVwdGggb2YgbGVzcyB0aGFuIGAyYC5cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcmVudE5vZGVFbnRyeSA9IEVkaXRvci5ub2RlKGVkaXRvciwgUGF0aC5wYXJlbnQocGF0aCkpO1xuICAgICAgICB2YXIgW3BhcmVudCwgcGFyZW50UGF0aF0gPSBwYXJlbnROb2RlRW50cnk7XG4gICAgICAgIHZhciBpbmRleCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBsZW5ndGhcbiAgICAgICAgfSA9IHBhcmVudC5jaGlsZHJlbjtcblxuICAgICAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdmFyIHRvUGF0aCA9IFBhdGgubmV4dChwYXJlbnRQYXRoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgdG86IHRvUGF0aCxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXJlbnRQYXRoLFxuICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgICB0bzogcGFyZW50UGF0aCxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICB2YXIgX3RvUGF0aCA9IFBhdGgubmV4dChwYXJlbnRQYXRoKTtcblxuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgICB0bzogX3RvUGF0aCxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNwbGl0UGF0aCA9IFBhdGgubmV4dChwYXRoKTtcblxuICAgICAgICAgIHZhciBfdG9QYXRoMiA9IFBhdGgubmV4dChwYXJlbnRQYXRoKTtcblxuICAgICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBzcGxpdFBhdGgsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgICB0bzogX3RvUGF0aDIsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogTWVyZ2UgYSBub2RlIGF0IGEgbG9jYXRpb24gd2l0aCB0aGUgcHJldmlvdXMgbm9kZSBvZiB0aGUgc2FtZSBkZXB0aCxcclxuICAgKiByZW1vdmluZyBhbnkgZW1wdHkgY29udGFpbmluZyBub2RlcyBhZnRlciB0aGUgbWVyZ2UgaWYgbmVjZXNzYXJ5LlxyXG4gICAqL1xuICBtZXJnZU5vZGVzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBoYW5naW5nID0gZmFsc2UsXG4gICAgICAgIHZvaWRzID0gZmFsc2UsXG4gICAgICAgIG1vZGUgPSAnbG93ZXN0J1xuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgICAgdmFyIFtwYXJlbnRdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIGF0KTtcblxuICAgICAgICAgIG1hdGNoID0gbiA9PiBwYXJlbnQuY2hpbGRyZW4uaW5jbHVkZXMobik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2ggPSBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFoYW5naW5nICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGF0ID0gcG9pbnRSZWYudW5yZWYoKTtcblxuICAgICAgICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgYXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgW2N1cnJlbnRdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIHZvaWRzLFxuICAgICAgICBtb2RlXG4gICAgICB9KTtcbiAgICAgIHZhciBwcmV2ID0gRWRpdG9yLnByZXZpb3VzKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIHZvaWRzLFxuICAgICAgICBtb2RlXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFjdXJyZW50IHx8ICFwcmV2KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIFtub2RlLCBwYXRoXSA9IGN1cnJlbnQ7XG4gICAgICB2YXIgW3ByZXZOb2RlLCBwcmV2UGF0aF0gPSBwcmV2O1xuXG4gICAgICBpZiAocGF0aC5sZW5ndGggPT09IDAgfHwgcHJldlBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld1BhdGggPSBQYXRoLm5leHQocHJldlBhdGgpO1xuICAgICAgdmFyIGNvbW1vblBhdGggPSBQYXRoLmNvbW1vbihwYXRoLCBwcmV2UGF0aCk7XG4gICAgICB2YXIgaXNQcmV2aW91c1NpYmxpbmcgPSBQYXRoLmlzU2libGluZyhwYXRoLCBwcmV2UGF0aCk7XG4gICAgICB2YXIgbGV2ZWxzID0gQXJyYXkuZnJvbShFZGl0b3IubGV2ZWxzKGVkaXRvciwge1xuICAgICAgICBhdDogcGF0aFxuICAgICAgfSksIChfcmVmMikgPT4ge1xuICAgICAgICB2YXIgW25dID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfSkuc2xpY2UoY29tbW9uUGF0aC5sZW5ndGgpLnNsaWNlKDAsIC0xKTsgLy8gRGV0ZXJtaW5lIGlmIHRoZSBtZXJnZSB3aWxsIGxlYXZlIGFuIGFuY2VzdG9yIG9mIHRoZSBwYXRoIGVtcHR5IGFzIGFcbiAgICAgIC8vIHJlc3VsdCwgaW4gd2hpY2ggY2FzZSB3ZSdsbCB3YW50IHRvIHJlbW92ZSBpdCBhZnRlciBtZXJnaW5nLlxuXG4gICAgICB2YXIgZW1wdHlBbmNlc3RvciA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgICAgbWF0Y2g6IG4gPT4gbGV2ZWxzLmluY2x1ZGVzKG4pICYmIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIG4uY2hpbGRyZW4ubGVuZ3RoID09PSAxXG4gICAgICB9KTtcbiAgICAgIHZhciBlbXB0eVJlZiA9IGVtcHR5QW5jZXN0b3IgJiYgRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBlbXB0eUFuY2VzdG9yWzFdKTtcbiAgICAgIHZhciBwcm9wZXJ0aWVzO1xuICAgICAgdmFyIHBvc2l0aW9uOyAvLyBFbnN1cmUgdGhhdCB0aGUgbm9kZXMgYXJlIGVxdWl2YWxlbnQsIGFuZCBmaWd1cmUgb3V0IHdoYXQgdGhlIHBvc2l0aW9uXG4gICAgICAvLyBhbmQgZXh0cmEgcHJvcGVydGllcyBvZiB0aGUgbWVyZ2Ugd2lsbCBiZS5cblxuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpICYmIFRleHQuaXNUZXh0KHByZXZOb2RlKSkge1xuICAgICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBbXCJ0ZXh0XCJdKTtcblxuICAgICAgICBwb3NpdGlvbiA9IHByZXZOb2RlLnRleHQubGVuZ3RoO1xuICAgICAgICBwcm9wZXJ0aWVzID0gcmVzdDtcbiAgICAgIH0gZWxzZSBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgRWxlbWVudC5pc0VsZW1lbnQocHJldk5vZGUpKSB7XG4gICAgICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIFtcImNoaWxkcmVuXCJdKTtcblxuICAgICAgICBwb3NpdGlvbiA9IHByZXZOb2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgcHJvcGVydGllcyA9IHJlc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbWVyZ2UgdGhlIG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSB3aXRoIHRoZSBwcmV2aW91cyBzaWJsaW5nIGJlY2F1c2UgaXQgaXMgbm90IHRoZSBzYW1lIGtpbmQ6IFwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkobm9kZSksIFwiIFwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkocHJldk5vZGUpKSk7XG4gICAgICB9IC8vIElmIHRoZSBub2RlIGlzbid0IGFscmVhZHkgdGhlIG5leHQgc2libGluZyBvZiB0aGUgcHJldmlvdXMgbm9kZSwgbW92ZVxuICAgICAgLy8gaXQgc28gdGhhdCBpdCBpcyBiZWZvcmUgbWVyZ2luZy5cblxuXG4gICAgICBpZiAoIWlzUHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgIHRvOiBuZXdQYXRoLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBJZiB0aGVyZSB3YXMgZ29pbmcgdG8gYmUgYW4gZW1wdHkgYW5jZXN0b3Igb2YgdGhlIG5vZGUgdGhhdCB3YXMgbWVyZ2VkLFxuICAgICAgLy8gd2UgcmVtb3ZlIGl0IGZyb20gdGhlIHRyZWUuXG5cblxuICAgICAgaWYgKGVtcHR5UmVmKSB7XG4gICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVtcHR5UmVmLmN1cnJlbnQsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIElmIHRoZSB0YXJnZXQgbm9kZSB0aGF0IHdlJ3JlIG1lcmdpbmcgd2l0aCBpcyBlbXB0eSwgcmVtb3ZlIGl0IGluc3RlYWRcbiAgICAgIC8vIG9mIG1lcmdpbmcgdGhlIHR3by4gVGhpcyBpcyBhIGNvbW1vbiByaWNoIHRleHQgZWRpdG9yIGJlaGF2aW9yIHRvXG4gICAgICAvLyBwcmV2ZW50IGxvc2luZyBmb3JtYXR0aW5nIHdoZW4gZGVsZXRpbmcgZW50aXJlIG5vZGVzIHdoZW4geW91IGhhdmUgYVxuICAgICAgLy8gaGFuZ2luZyBzZWxlY3Rpb24uXG5cblxuICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KHByZXZOb2RlKSAmJiBFZGl0b3IuaXNFbXB0eShlZGl0b3IsIHByZXZOb2RlKSB8fCBUZXh0LmlzVGV4dChwcmV2Tm9kZSkgJiYgcHJldk5vZGUudGV4dCA9PT0gJycpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcHJldlBhdGgsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgIHR5cGU6ICdtZXJnZV9ub2RlJyxcbiAgICAgICAgICBwYXRoOiBuZXdQYXRoLFxuICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICAgICBwcm9wZXJ0aWVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW1wdHlSZWYpIHtcbiAgICAgICAgZW1wdHlSZWYudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBNb3ZlIHRoZSBub2RlcyBhdCBhIGxvY2F0aW9uIHRvIGEgbmV3IGxvY2F0aW9uLlxyXG4gICAqL1xuICBtb3ZlTm9kZXMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHRvLFxuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgICAgdm9pZHMgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBtYXRjaFxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCB0byk7XG4gICAgICB2YXIgdGFyZ2V0cyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtb2RlLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKHRhcmdldHMsIChfcmVmMykgPT4ge1xuICAgICAgICB2YXIgWywgcF0gPSBfcmVmMztcbiAgICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgcGF0aFJlZiBvZiBwYXRoUmVmcykge1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcbiAgICAgICAgdmFyIG5ld1BhdGggPSB0b1JlZi5jdXJyZW50O1xuXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICB0eXBlOiAnbW92ZV9ub2RlJyxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBuZXdQYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdG9SZWYudW5yZWYoKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZW1vdmUgdGhlIG5vZGVzIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24gaW4gdGhlIGRvY3VtZW50LlxyXG4gICAqL1xuICByZW1vdmVOb2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIGhhbmdpbmcgPSBmYWxzZSxcbiAgICAgICAgdm9pZHMgPSBmYWxzZSxcbiAgICAgICAgbW9kZSA9ICdsb3dlc3QnXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgbWF0Y2hcbiAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFuZ2luZyAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlcHRocyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtb2RlLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKGRlcHRocywgKF9yZWY0KSA9PiB7XG4gICAgICAgIHZhciBbLCBwXSA9IF9yZWY0O1xuICAgICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBwYXRoUmVmIG9mIHBhdGhSZWZzKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuXG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgdmFyIFtub2RlXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgIHR5cGU6ICdyZW1vdmVfbm9kZScsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgbm9kZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogU2V0IG5ldyBwcm9wZXJ0aWVzIG9uIHRoZSBub2RlcyBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBzZXROb2RlcyhlZGl0b3IsIHByb3BzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBtYXRjaCxcbiAgICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIGhhbmdpbmcgPSBmYWxzZSxcbiAgICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgICBzcGxpdCA9IGZhbHNlLFxuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWhhbmdpbmcgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcGxpdCAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICB2YXIgcmFuZ2VSZWYgPSBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIGFmZmluaXR5OiAnaW53YXJkJ1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgICAgdmFyIHNwbGl0TW9kZSA9IG1vZGUgPT09ICdsb3dlc3QnID8gJ2xvd2VzdCcgOiAnaGlnaGVzdCc7XG4gICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogZW5kLFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIG1vZGU6IHNwbGl0TW9kZSxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBzdGFydCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlOiBzcGxpdE1vZGUsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICAgIGF0ID0gcmFuZ2VSZWYudW5yZWYoKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBhdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtb2RlLFxuICAgICAgICB2b2lkc1xuICAgICAgfSkpIHtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgdmFyIG5ld1Byb3BlcnRpZXMgPSB7fTsgLy8gWW91IGNhbid0IHNldCBwcm9wZXJ0aWVzIG9uIHRoZSBlZGl0b3Igbm9kZS5cblxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGsgaW4gcHJvcHMpIHtcbiAgICAgICAgICBpZiAoayA9PT0gJ2NoaWxkcmVuJyB8fCBrID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwcm9wc1trXSAhPT0gbm9kZVtrXSkge1xuICAgICAgICAgICAgcHJvcGVydGllc1trXSA9IG5vZGVba107XG4gICAgICAgICAgICBuZXdQcm9wZXJ0aWVzW2tdID0gcHJvcHNba107XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKG5ld1Byb3BlcnRpZXMpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICB0eXBlOiAnc2V0X25vZGUnLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgICBuZXdQcm9wZXJ0aWVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBTcGxpdCB0aGUgbm9kZXMgYXQgYSBzcGVjaWZpYyBsb2NhdGlvbi5cclxuICAgKi9cbiAgc3BsaXROb2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgICAgdm9pZHMgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBtYXRjaCxcbiAgICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICBoZWlnaHQgPSAwLFxuICAgICAgICBhbHdheXMgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIG1hdGNoID0gbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfVxuXG4gICAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgYXQgPSBkZWxldGVSYW5nZShlZGl0b3IsIGF0KTtcbiAgICAgIH0gLy8gSWYgdGhlIHRhcmdldCBpcyBhIHBhdGgsIHRoZSBkZWZhdWx0IGhlaWdodC1za2lwcGluZyBhbmQgcG9zaXRpb25cbiAgICAgIC8vIGNvdW50ZXJzIG5lZWQgdG8gYWNjb3VudCBmb3IgdXMgcG90ZW50aWFsbHkgc3BsaXR0aW5nIGF0IGEgbm9uLWxlYWYuXG5cblxuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICB2YXIgcGF0aCA9IGF0O1xuICAgICAgICB2YXIgcG9pbnQgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgdmFyIFtwYXJlbnRdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHBhdGgpO1xuXG4gICAgICAgIG1hdGNoID0gbiA9PiBuID09PSBwYXJlbnQ7XG5cbiAgICAgICAgaGVpZ2h0ID0gcG9pbnQucGF0aC5sZW5ndGggLSBwYXRoLmxlbmd0aCArIDE7XG4gICAgICAgIGF0ID0gcG9pbnQ7XG4gICAgICAgIGFsd2F5cyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmVmb3JlUmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgYXQsIHtcbiAgICAgICAgYWZmaW5pdHk6ICdiYWNrd2FyZCdcbiAgICAgIH0pO1xuICAgICAgdmFyIFtoaWdoZXN0XSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtb2RlLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghaGlnaGVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB2b2lkTWF0Y2ggPSBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgICAgfSk7XG4gICAgICB2YXIgbnVkZ2UgPSAwO1xuXG4gICAgICBpZiAoIXZvaWRzICYmIHZvaWRNYXRjaCkge1xuICAgICAgICB2YXIgW3ZvaWROb2RlLCB2b2lkUGF0aF0gPSB2b2lkTWF0Y2g7XG5cbiAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KHZvaWROb2RlKSAmJiBlZGl0b3IuaXNJbmxpbmUodm9pZE5vZGUpKSB7XG4gICAgICAgICAgdmFyIGFmdGVyID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgdm9pZFBhdGgpO1xuXG4gICAgICAgICAgaWYgKCFhZnRlcikge1xuICAgICAgICAgICAgdmFyIHRleHQgPSB7XG4gICAgICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGFmdGVyUGF0aCA9IFBhdGgubmV4dCh2b2lkUGF0aCk7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgdGV4dCwge1xuICAgICAgICAgICAgICBhdDogYWZ0ZXJQYXRoLFxuICAgICAgICAgICAgICB2b2lkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhZnRlciA9IEVkaXRvci5wb2ludChlZGl0b3IsIGFmdGVyUGF0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXQgPSBhZnRlcjtcbiAgICAgICAgICBhbHdheXMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpYmxpbmdIZWlnaHQgPSBhdC5wYXRoLmxlbmd0aCAtIHZvaWRQYXRoLmxlbmd0aDtcbiAgICAgICAgaGVpZ2h0ID0gc2libGluZ0hlaWdodCArIDE7XG4gICAgICAgIGFsd2F5cyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBhZnRlclJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGF0KTtcbiAgICAgIHZhciBkZXB0aCA9IGF0LnBhdGgubGVuZ3RoIC0gaGVpZ2h0O1xuICAgICAgdmFyIFssIGhpZ2hlc3RQYXRoXSA9IGhpZ2hlc3Q7XG4gICAgICB2YXIgbG93ZXN0UGF0aCA9IGF0LnBhdGguc2xpY2UoMCwgZGVwdGgpO1xuICAgICAgdmFyIHBvc2l0aW9uID0gaGVpZ2h0ID09PSAwID8gYXQub2Zmc2V0IDogYXQucGF0aFtkZXB0aF0gKyBudWRnZTtcbiAgICAgIHZhciB0YXJnZXQgPSBudWxsO1xuXG4gICAgICBmb3IgKHZhciBbbm9kZSwgX3BhdGgyXSBvZiBFZGl0b3IubGV2ZWxzKGVkaXRvciwge1xuICAgICAgICBhdDogbG93ZXN0UGF0aCxcbiAgICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChfcGF0aDIubGVuZ3RoIDwgaGlnaGVzdFBhdGgubGVuZ3RoIHx8IF9wYXRoMi5sZW5ndGggPT09IDAgfHwgIXZvaWRzICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9wb2ludCA9IGJlZm9yZVJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgaXNFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBfcG9pbnQsIF9wYXRoMik7XG5cbiAgICAgICAgaWYgKGFsd2F5cyB8fCAhYmVmb3JlUmVmIHx8ICFFZGl0b3IuaXNFZGdlKGVkaXRvciwgX3BvaW50LCBfcGF0aDIpKSB7XG4gICAgICAgICAgc3BsaXQgPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgW1widGV4dFwiLCBcImNoaWxkcmVuXCJdKTtcblxuICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICB0eXBlOiAnc3BsaXRfbm9kZScsXG4gICAgICAgICAgICBwYXRoOiBfcGF0aDIsXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIHByb3BlcnRpZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldCA9IHBvc2l0aW9uO1xuICAgICAgICBwb3NpdGlvbiA9IF9wYXRoMltfcGF0aDIubGVuZ3RoIC0gMV0gKyAoc3BsaXQgfHwgaXNFbmQgPyAxIDogMCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwpIHtcbiAgICAgICAgdmFyIF9wb2ludDIgPSBhZnRlclJlZi5jdXJyZW50IHx8IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG5cbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBfcG9pbnQyKTtcbiAgICAgIH1cblxuICAgICAgYmVmb3JlUmVmLnVucmVmKCk7XG4gICAgICBhZnRlclJlZi51bnJlZigpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFVuc2V0IHByb3BlcnRpZXMgb24gdGhlIG5vZGVzIGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHVuc2V0Tm9kZXMoZWRpdG9yLCBwcm9wcykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICAgIHByb3BzID0gW3Byb3BzXTtcbiAgICB9XG5cbiAgICB2YXIgb2JqID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgb2YgcHJvcHMpIHtcbiAgICAgIG9ialtrZXldID0gbnVsbDtcbiAgICB9XG5cbiAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwgb2JqLCBvcHRpb25zKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBVbndyYXAgdGhlIG5vZGVzIGF0IGEgbG9jYXRpb24gZnJvbSBhIHBhcmVudCBub2RlLCBzcGxpdHRpbmcgdGhlIHBhcmVudCBpZlxyXG4gICAqIG5lY2Vzc2FyeSB0byBlbnN1cmUgdGhhdCBvbmx5IHRoZSBjb250ZW50IGluIHRoZSByYW5nZSBpcyB1bndyYXBwZWQuXHJcbiAgICovXG4gIHVud3JhcE5vZGVzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICAgIHNwbGl0ID0gZmFsc2UsXG4gICAgICAgIHZvaWRzID0gZmFsc2VcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICBtYXRjaFxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJhbmdlUmVmID0gUmFuZ2UuaXNSYW5nZShhdCkgPyBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCkgOiBudWxsO1xuICAgICAgdmFyIG1hdGNoZXMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShtYXRjaGVzLCAoX3JlZjUpID0+IHtcbiAgICAgICAgdmFyIFssIHBdID0gX3JlZjU7XG4gICAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHBhdGhSZWYpIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICAgIHZhciBbbm9kZV0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xuICAgICAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBwYXRoKTtcblxuICAgICAgICBpZiAoc3BsaXQgJiYgcmFuZ2VSZWYpIHtcbiAgICAgICAgICByYW5nZSA9IFJhbmdlLmludGVyc2VjdGlvbihyYW5nZVJlZi5jdXJyZW50LCByYW5nZSk7XG4gICAgICAgIH1cblxuICAgICAgICBUcmFuc2Zvcm1zLmxpZnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcmFuZ2UsXG4gICAgICAgICAgbWF0Y2g6IG4gPT4gbm9kZS5jaGlsZHJlbi5pbmNsdWRlcyhuKSxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIHBhdGhSZWYgb2YgcGF0aFJlZnMpIHtcbiAgICAgICAgX2xvb3AocGF0aFJlZik7XG4gICAgICB9XG5cbiAgICAgIGlmIChyYW5nZVJlZikge1xuICAgICAgICByYW5nZVJlZi51bnJlZigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFdyYXAgdGhlIG5vZGVzIGF0IGEgbG9jYXRpb24gaW4gYSBuZXcgY29udGFpbmVyIG5vZGUsIHNwbGl0dGluZyB0aGUgZWRnZXNcclxuICAgKiBvZiB0aGUgcmFuZ2UgZmlyc3QgdG8gZW5zdXJlIHRoYXQgb25seSB0aGUgY29udGVudCBpbiB0aGUgcmFuZ2UgaXMgd3JhcHBlZC5cclxuICAgKi9cbiAgd3JhcE5vZGVzKGVkaXRvciwgZWxlbWVudCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgICBzcGxpdCA9IGZhbHNlLFxuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIG1hdGNoLFxuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb25cbiAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICAgIG1hdGNoID0gbWF0Y2hQYXRoKGVkaXRvciwgYXQpO1xuICAgICAgICB9IGVsc2UgaWYgKGVkaXRvci5pc0lubGluZShlbGVtZW50KSkge1xuICAgICAgICAgIG1hdGNoID0gbiA9PiBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSB8fCBUZXh0LmlzVGV4dChuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaCA9IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3BsaXQgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgICAgdmFyIHJhbmdlUmVmID0gRWRpdG9yLnJhbmdlUmVmKGVkaXRvciwgYXQsIHtcbiAgICAgICAgICBhZmZpbml0eTogJ2lud2FyZCdcbiAgICAgICAgfSk7XG4gICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogZW5kLFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgICBhdCA9IHJhbmdlUmVmLnVucmVmKCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgYXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciByb290cyA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2g6IGVkaXRvci5pc0lubGluZShlbGVtZW50KSA/IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSA6IG4gPT4gRWRpdG9yLmlzRWRpdG9yKG4pLFxuICAgICAgICBtb2RlOiAnbG93ZXN0JyxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pKTtcblxuICAgICAgZm9yICh2YXIgWywgcm9vdFBhdGhdIG9mIHJvb3RzKSB7XG4gICAgICAgIHZhciBhID0gUmFuZ2UuaXNSYW5nZShhdCkgPyBSYW5nZS5pbnRlcnNlY3Rpb24oYXQsIEVkaXRvci5yYW5nZShlZGl0b3IsIHJvb3RQYXRoKSkgOiBhdDtcblxuICAgICAgICBpZiAoIWEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXRjaGVzID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGEsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgbW9kZSxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgW2ZpcnN0XSA9IG1hdGNoZXM7XG4gICAgICAgICAgICB2YXIgbGFzdCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciBbLCBmaXJzdFBhdGhdID0gZmlyc3Q7XG4gICAgICAgICAgICB2YXIgWywgbGFzdFBhdGhdID0gbGFzdDtcbiAgICAgICAgICAgIHZhciBjb21tb25QYXRoID0gUGF0aC5lcXVhbHMoZmlyc3RQYXRoLCBsYXN0UGF0aCkgPyBQYXRoLnBhcmVudChmaXJzdFBhdGgpIDogUGF0aC5jb21tb24oZmlyc3RQYXRoLCBsYXN0UGF0aCk7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBmaXJzdFBhdGgsIGxhc3RQYXRoKTtcbiAgICAgICAgICAgIHZhciBjb21tb25Ob2RlRW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIGNvbW1vblBhdGgpO1xuICAgICAgICAgICAgdmFyIFtjb21tb25Ob2RlXSA9IGNvbW1vbk5vZGVFbnRyeTtcbiAgICAgICAgICAgIHZhciBkZXB0aCA9IGNvbW1vblBhdGgubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIHZhciB3cmFwcGVyUGF0aCA9IFBhdGgubmV4dChsYXN0UGF0aC5zbGljZSgwLCBkZXB0aCkpO1xuXG4gICAgICAgICAgICB2YXIgd3JhcHBlciA9IF9vYmplY3RTcHJlYWQkNih7fSwgZWxlbWVudCwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgd3JhcHBlciwge1xuICAgICAgICAgICAgICBhdDogd3JhcHBlclBhdGgsXG4gICAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogcmFuZ2UsXG4gICAgICAgICAgICAgIG1hdGNoOiBuID0+IGNvbW1vbk5vZGUuY2hpbGRyZW4uaW5jbHVkZXMobiksXG4gICAgICAgICAgICAgIHRvOiB3cmFwcGVyUGF0aC5jb25jYXQoMCksXG4gICAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufTtcbi8qKlxyXG4gKiBDb252ZXJ0IGEgcmFuZ2UgaW50byBhIHBvaW50IGJ5IGRlbGV0aW5nIGl0J3MgY29udGVudC5cclxuICovXG5cbnZhciBkZWxldGVSYW5nZSA9IChlZGl0b3IsIHJhbmdlKSA9PiB7XG4gIGlmIChSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkpIHtcbiAgICByZXR1cm4gcmFuZ2UuYW5jaG9yO1xuICB9IGVsc2Uge1xuICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICBhdDogcmFuZ2VcbiAgICB9KTtcbiAgICByZXR1cm4gcG9pbnRSZWYudW5yZWYoKTtcbiAgfVxufTtcblxudmFyIG1hdGNoUGF0aCA9IChlZGl0b3IsIHBhdGgpID0+IHtcbiAgdmFyIFtub2RlXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCk7XG4gIHJldHVybiBuID0+IG4gPT09IG5vZGU7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDcob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNyh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDcoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQ3KE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIFNlbGVjdGlvblRyYW5zZm9ybXMgPSB7XG4gIC8qKlxyXG4gICAqIENvbGxhcHNlIHRoZSBzZWxlY3Rpb24uXHJcbiAgICovXG4gIGNvbGxhcHNlKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgZWRnZSA9ICdhbmNob3InXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBlZGl0b3I7XG5cbiAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2FuY2hvcicpIHtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2VsZWN0aW9uLmFuY2hvcik7XG4gICAgfSBlbHNlIGlmIChlZGdlID09PSAnZm9jdXMnKSB7XG4gICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHNlbGVjdGlvbi5mb2N1cyk7XG4gICAgfSBlbHNlIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgICB2YXIgW3N0YXJ0XSA9IFJhbmdlLmVkZ2VzKHNlbGVjdGlvbik7XG4gICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHN0YXJ0KTtcbiAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICB2YXIgWywgZW5kXSA9IFJhbmdlLmVkZ2VzKHNlbGVjdGlvbik7XG4gICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGVuZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIFVuc2V0IHRoZSBzZWxlY3Rpb24uXHJcbiAgICovXG4gIGRlc2VsZWN0KGVkaXRvcikge1xuICAgIHZhciB7XG4gICAgICBzZWxlY3Rpb25cbiAgICB9ID0gZWRpdG9yO1xuXG4gICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogJ3NldF9zZWxlY3Rpb24nLFxuICAgICAgICBwcm9wZXJ0aWVzOiBzZWxlY3Rpb24sXG4gICAgICAgIG5ld1Byb3BlcnRpZXM6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBNb3ZlIHRoZSBzZWxlY3Rpb24ncyBwb2ludCBmb3J3YXJkIG9yIGJhY2t3YXJkLlxyXG4gICAqL1xuICBtb3ZlKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICB2YXIge1xuICAgICAgZGlzdGFuY2UgPSAxLFxuICAgICAgdW5pdCA9ICdjaGFyYWN0ZXInLFxuICAgICAgcmV2ZXJzZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIGVkZ2UgPSBudWxsXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgICBlZGdlID0gUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pID8gJ2ZvY3VzJyA6ICdhbmNob3InO1xuICAgIH1cblxuICAgIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdhbmNob3InIDogJ2ZvY3VzJztcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIHZhciBvcHRzID0ge1xuICAgICAgZGlzdGFuY2UsXG4gICAgICB1bml0XG4gICAgfTtcbiAgICB2YXIgcHJvcHMgPSB7fTtcblxuICAgIGlmIChlZGdlID09IG51bGwgfHwgZWRnZSA9PT0gJ2FuY2hvcicpIHtcbiAgICAgIHZhciBwb2ludCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYW5jaG9yLCBvcHRzKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGFuY2hvciwgb3B0cyk7XG5cbiAgICAgIGlmIChwb2ludCkge1xuICAgICAgICBwcm9wcy5hbmNob3IgPSBwb2ludDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZWRnZSA9PSBudWxsIHx8IGVkZ2UgPT09ICdmb2N1cycpIHtcbiAgICAgIHZhciBfcG9pbnQgPSByZXZlcnNlID8gRWRpdG9yLmJlZm9yZShlZGl0b3IsIGZvY3VzLCBvcHRzKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGZvY3VzLCBvcHRzKTtcblxuICAgICAgaWYgKF9wb2ludCkge1xuICAgICAgICBwcm9wcy5mb2N1cyA9IF9wb2ludDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHByb3BzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBTZXQgdGhlIHNlbGVjdGlvbiB0byBhIG5ldyB2YWx1ZS5cclxuICAgKi9cbiAgc2VsZWN0KGVkaXRvciwgdGFyZ2V0KSB7XG4gICAgdmFyIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBlZGl0b3I7XG4gICAgdGFyZ2V0ID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgdGFyZ2V0KTtcblxuICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwgdGFyZ2V0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIVJhbmdlLmlzUmFuZ2UodGFyZ2V0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2hlbiBzZXR0aW5nIHRoZSBzZWxlY3Rpb24gYW5kIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyBgbnVsbGAgeW91IG11c3QgcHJvdmlkZSBhdCBsZWFzdCBhbiBgYW5jaG9yYCBhbmQgYGZvY3VzYCwgYnV0IHlvdSBwYXNzZWQ6IFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeSh0YXJnZXQpKSk7XG4gICAgfVxuXG4gICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgIHR5cGU6ICdzZXRfc2VsZWN0aW9uJyxcbiAgICAgIHByb3BlcnRpZXM6IHNlbGVjdGlvbixcbiAgICAgIG5ld1Byb3BlcnRpZXM6IHRhcmdldFxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNldCBuZXcgcHJvcGVydGllcyBvbiBvbmUgb2YgdGhlIHNlbGVjdGlvbidzIHBvaW50cy5cclxuICAgKi9cbiAgc2V0UG9pbnQoZWRpdG9yLCBwcm9wcywgb3B0aW9ucykge1xuICAgIHZhciB7XG4gICAgICBzZWxlY3Rpb25cbiAgICB9ID0gZWRpdG9yO1xuICAgIHZhciB7XG4gICAgICBlZGdlID0gJ2JvdGgnXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgICBlZGdlID0gUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pID8gJ2ZvY3VzJyA6ICdhbmNob3InO1xuICAgIH1cblxuICAgIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdhbmNob3InIDogJ2ZvY3VzJztcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIHZhciBwb2ludCA9IGVkZ2UgPT09ICdhbmNob3InID8gYW5jaG9yIDogZm9jdXM7XG4gICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB7XG4gICAgICBbZWRnZSA9PT0gJ2FuY2hvcicgPyAnYW5jaG9yJyA6ICdmb2N1cyddOiBfb2JqZWN0U3ByZWFkJDcoe30sIHBvaW50LCB7fSwgcHJvcHMpXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogU2V0IG5ldyBwcm9wZXJ0aWVzIG9uIHRoZSBzZWxlY3Rpb24uXHJcbiAgICovXG4gIHNldFNlbGVjdGlvbihlZGl0b3IsIHByb3BzKSB7XG4gICAgdmFyIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBlZGl0b3I7XG4gICAgdmFyIG9sZFByb3BzID0ge307XG4gICAgdmFyIG5ld1Byb3BzID0ge307XG5cbiAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGsgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChrID09PSAnYW5jaG9yJyAmJiBwcm9wcy5hbmNob3IgIT0gbnVsbCAmJiAhUG9pbnQuZXF1YWxzKHByb3BzLmFuY2hvciwgc2VsZWN0aW9uLmFuY2hvcikgfHwgayA9PT0gJ2ZvY3VzJyAmJiBwcm9wcy5mb2N1cyAhPSBudWxsICYmICFQb2ludC5lcXVhbHMocHJvcHMuZm9jdXMsIHNlbGVjdGlvbi5mb2N1cykgfHwgayAhPT0gJ2FuY2hvcicgJiYgayAhPT0gJ2ZvY3VzJyAmJiBwcm9wc1trXSAhPT0gc2VsZWN0aW9uW2tdKSB7XG4gICAgICAgIG9sZFByb3BzW2tdID0gc2VsZWN0aW9uW2tdO1xuICAgICAgICBuZXdQcm9wc1trXSA9IHByb3BzW2tdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChPYmplY3Qua2V5cyhvbGRQcm9wcykubGVuZ3RoID4gMCkge1xuICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogJ3NldF9zZWxlY3Rpb24nLFxuICAgICAgICBwcm9wZXJ0aWVzOiBvbGRQcm9wcyxcbiAgICAgICAgbmV3UHJvcGVydGllczogbmV3UHJvcHNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG59O1xuXG52YXIgVGV4dFRyYW5zZm9ybXMgPSB7XG4gIC8qKlxyXG4gICAqIERlbGV0ZSBjb250ZW50IGluIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIGRlbGV0ZShlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHJldmVyc2UgPSBmYWxzZSxcbiAgICAgICAgdW5pdCA9ICdjaGFyYWN0ZXInLFxuICAgICAgICBkaXN0YW5jZSA9IDEsXG4gICAgICAgIHZvaWRzID0gZmFsc2VcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICBoYW5naW5nID0gZmFsc2VcbiAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpICYmIFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKFBvaW50LmlzUG9pbnQoYXQpKSB7XG4gICAgICAgIHZhciBmdXJ0aGVzdFZvaWQgPSBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgICBhdCxcbiAgICAgICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCF2b2lkcyAmJiBmdXJ0aGVzdFZvaWQpIHtcbiAgICAgICAgICB2YXIgWywgdm9pZFBhdGhdID0gZnVydGhlc3RWb2lkO1xuICAgICAgICAgIGF0ID0gdm9pZFBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgICAgICB1bml0LFxuICAgICAgICAgICAgZGlzdGFuY2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciB0YXJnZXQgPSByZXZlcnNlID8gRWRpdG9yLmJlZm9yZShlZGl0b3IsIGF0LCBvcHRzKSB8fCBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBbXSkgOiBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBhdCwgb3B0cykgfHwgRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgICAgICAgICBhdCA9IHtcbiAgICAgICAgICAgIGFuY2hvcjogYXQsXG4gICAgICAgICAgICBmb2N1czogdGFyZ2V0XG4gICAgICAgICAgfTtcbiAgICAgICAgICBoYW5naW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFuZ2luZykge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICB2YXIgc3RhcnRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgZW5kQmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICAgIGF0OiBlbmQsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBpc0Fjcm9zc0Jsb2NrcyA9IHN0YXJ0QmxvY2sgJiYgZW5kQmxvY2sgJiYgIVBhdGguZXF1YWxzKHN0YXJ0QmxvY2tbMV0sIGVuZEJsb2NrWzFdKTtcbiAgICAgIHZhciBpc1NpbmdsZVRleHQgPSBQYXRoLmVxdWFscyhzdGFydC5wYXRoLCBlbmQucGF0aCk7XG4gICAgICB2YXIgc3RhcnRWb2lkID0gdm9pZHMgPyBudWxsIDogRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBzdGFydCxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICB9KTtcbiAgICAgIHZhciBlbmRWb2lkID0gdm9pZHMgPyBudWxsIDogRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlbmQsXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgICAgfSk7IC8vIElmIHRoZSBzdGFydCBvciBlbmQgcG9pbnRzIGFyZSBpbnNpZGUgYW4gaW5saW5lIHZvaWQsIG51ZGdlIHRoZW0gb3V0LlxuXG4gICAgICBpZiAoc3RhcnRWb2lkKSB7XG4gICAgICAgIHZhciBiZWZvcmUgPSBFZGl0b3IuYmVmb3JlKGVkaXRvciwgc3RhcnQpO1xuXG4gICAgICAgIGlmIChiZWZvcmUgJiYgc3RhcnRCbG9jayAmJiBQYXRoLmlzQW5jZXN0b3Ioc3RhcnRCbG9ja1sxXSwgYmVmb3JlLnBhdGgpKSB7XG4gICAgICAgICAgc3RhcnQgPSBiZWZvcmU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVuZFZvaWQpIHtcbiAgICAgICAgdmFyIGFmdGVyID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgZW5kKTtcblxuICAgICAgICBpZiAoYWZ0ZXIgJiYgZW5kQmxvY2sgJiYgUGF0aC5pc0FuY2VzdG9yKGVuZEJsb2NrWzFdLCBhZnRlci5wYXRoKSkge1xuICAgICAgICAgIGVuZCA9IGFmdGVyO1xuICAgICAgICB9XG4gICAgICB9IC8vIEdldCB0aGUgaGlnaGVzdCBub2RlcyB0aGF0IGFyZSBjb21wbGV0ZWx5IGluc2lkZSB0aGUgcmFuZ2UsIGFzIHdlbGwgYXNcbiAgICAgIC8vIHRoZSBzdGFydCBhbmQgZW5kIG5vZGVzLlxuXG5cbiAgICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgICB2YXIgbGFzdFBhdGg7XG5cbiAgICAgIGZvciAodmFyIGVudHJ5IG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KSkge1xuICAgICAgICB2YXIgW25vZGUsIHBhdGhdID0gZW50cnk7XG5cbiAgICAgICAgaWYgKGxhc3RQYXRoICYmIFBhdGguY29tcGFyZShwYXRoLCBsYXN0UGF0aCkgPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpIHx8ICFQYXRoLmlzQ29tbW9uKHBhdGgsIHN0YXJ0LnBhdGgpICYmICFQYXRoLmlzQ29tbW9uKHBhdGgsIGVuZC5wYXRoKSkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgbGFzdFBhdGggPSBwYXRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20obWF0Y2hlcywgKF9yZWYpID0+IHtcbiAgICAgICAgdmFyIFssIHBdID0gX3JlZjtcbiAgICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgICB9KTtcbiAgICAgIHZhciBzdGFydFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIHN0YXJ0KTtcbiAgICAgIHZhciBlbmRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuXG4gICAgICBpZiAoIWlzU2luZ2xlVGV4dCAmJiAhc3RhcnRWb2lkKSB7XG4gICAgICAgIHZhciBfcG9pbnQgPSBzdGFydFJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgW19ub2RlXSA9IEVkaXRvci5sZWFmKGVkaXRvciwgX3BvaW50KTtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aFxuICAgICAgICB9ID0gX3BvaW50O1xuICAgICAgICB2YXIge1xuICAgICAgICAgIG9mZnNldFxuICAgICAgICB9ID0gc3RhcnQ7XG5cbiAgICAgICAgdmFyIHRleHQgPSBfbm9kZS50ZXh0LnNsaWNlKG9mZnNldCk7XG5cbiAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICB0eXBlOiAncmVtb3ZlX3RleHQnLFxuICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBwYXRoUmVmIG9mIHBhdGhSZWZzKSB7XG4gICAgICAgIHZhciBfcGF0aDIgPSBwYXRoUmVmLnVucmVmKCk7XG5cbiAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogX3BhdGgyLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWVuZFZvaWQpIHtcbiAgICAgICAgdmFyIF9wb2ludDIgPSBlbmRSZWYuY3VycmVudDtcbiAgICAgICAgdmFyIFtfbm9kZTJdID0gRWRpdG9yLmxlYWYoZWRpdG9yLCBfcG9pbnQyKTtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDNcbiAgICAgICAgfSA9IF9wb2ludDI7XG5cbiAgICAgICAgdmFyIF9vZmZzZXQgPSBpc1NpbmdsZVRleHQgPyBzdGFydC5vZmZzZXQgOiAwO1xuXG4gICAgICAgIHZhciBfdGV4dCA9IF9ub2RlMi50ZXh0LnNsaWNlKF9vZmZzZXQsIGVuZC5vZmZzZXQpO1xuXG4gICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogJ3JlbW92ZV90ZXh0JyxcbiAgICAgICAgICBwYXRoOiBfcGF0aDMsXG4gICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0LFxuICAgICAgICAgIHRleHQ6IF90ZXh0XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzU2luZ2xlVGV4dCAmJiBpc0Fjcm9zc0Jsb2NrcyAmJiBlbmRSZWYuY3VycmVudCAmJiBzdGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAgIFRyYW5zZm9ybXMubWVyZ2VOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogZW5kUmVmLmN1cnJlbnQsXG4gICAgICAgICAgaGFuZ2luZzogdHJ1ZSxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50ID0gZW5kUmVmLnVucmVmKCkgfHwgc3RhcnRSZWYudW5yZWYoKTtcblxuICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCAmJiBwb2ludCkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHBvaW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgYSBmcmFnbWVudCBhdCBhIHNwZWNpZmljIGxvY2F0aW9uIGluIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIGluc2VydEZyYWdtZW50KGVkaXRvciwgZnJhZ21lbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIGhhbmdpbmcgPSBmYWxzZSxcbiAgICAgICAgdm9pZHMgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb25cbiAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICBpZiAoIWZyYWdtZW50Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoIWhhbmdpbmcpIHtcbiAgICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgWywgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcblxuICAgICAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogZW5kXG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcG9pbnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgICAgYXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhdCA9IHBvaW50UmVmLnVucmVmKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICBhdFxuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBJZiB0aGUgaW5zZXJ0IHBvaW50IGlzIGF0IHRoZSBlZGdlIG9mIGFuIGlubGluZSBub2RlLCBtb3ZlIGl0IG91dHNpZGVcbiAgICAgIC8vIGluc3RlYWQgc2luY2UgaXQgd2lsbCBuZWVkIHRvIGJlIHNwbGl0IG90aGVyd2lzZS5cblxuXG4gICAgICB2YXIgaW5saW5lRWxlbWVudE1hdGNoID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbiksXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaW5saW5lRWxlbWVudE1hdGNoKSB7XG4gICAgICAgIHZhciBbLCBfaW5saW5lUGF0aF0gPSBpbmxpbmVFbGVtZW50TWF0Y2g7XG5cbiAgICAgICAgaWYgKEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBfaW5saW5lUGF0aCkpIHtcbiAgICAgICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBfaW5saW5lUGF0aCk7XG4gICAgICAgICAgYXQgPSBhZnRlcjtcbiAgICAgICAgfSBlbHNlIGlmIChFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBfaW5saW5lUGF0aCkpIHtcbiAgICAgICAgICB2YXIgYmVmb3JlID0gRWRpdG9yLmJlZm9yZShlZGl0b3IsIF9pbmxpbmVQYXRoKTtcbiAgICAgICAgICBhdCA9IGJlZm9yZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYmxvY2tNYXRjaCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICAgICAgYXQsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBbLCBibG9ja1BhdGhdID0gYmxvY2tNYXRjaDtcbiAgICAgIHZhciBpc0Jsb2NrU3RhcnQgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBibG9ja1BhdGgpO1xuICAgICAgdmFyIGlzQmxvY2tFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBhdCwgYmxvY2tQYXRoKTtcbiAgICAgIHZhciBtZXJnZVN0YXJ0ID0gIWlzQmxvY2tTdGFydCB8fCBpc0Jsb2NrU3RhcnQgJiYgaXNCbG9ja0VuZDtcbiAgICAgIHZhciBtZXJnZUVuZCA9ICFpc0Jsb2NrRW5kO1xuICAgICAgdmFyIFssIGZpcnN0UGF0aF0gPSBOb2RlLmZpcnN0KHtcbiAgICAgICAgY2hpbGRyZW46IGZyYWdtZW50XG4gICAgICB9LCBbXSk7XG4gICAgICB2YXIgWywgbGFzdFBhdGhdID0gTm9kZS5sYXN0KHtcbiAgICAgICAgY2hpbGRyZW46IGZyYWdtZW50XG4gICAgICB9LCBbXSk7XG4gICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuXG4gICAgICB2YXIgbWF0Y2hlciA9IChfcmVmMikgPT4ge1xuICAgICAgICB2YXIgW24sIHBdID0gX3JlZjI7XG5cbiAgICAgICAgaWYgKG1lcmdlU3RhcnQgJiYgUGF0aC5pc0FuY2VzdG9yKHAsIGZpcnN0UGF0aCkgJiYgRWxlbWVudC5pc0VsZW1lbnQobikgJiYgIWVkaXRvci5pc1ZvaWQobikgJiYgIWVkaXRvci5pc0lubGluZShuKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXJnZUVuZCAmJiBQYXRoLmlzQW5jZXN0b3IocCwgbGFzdFBhdGgpICYmIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmICFlZGl0b3IuaXNWb2lkKG4pICYmICFlZGl0b3IuaXNJbmxpbmUobikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGVudHJ5IG9mIE5vZGUubm9kZXMoe1xuICAgICAgICBjaGlsZHJlbjogZnJhZ21lbnRcbiAgICAgIH0sIHtcbiAgICAgICAgcGFzczogbWF0Y2hlclxuICAgICAgfSkpIHtcbiAgICAgICAgaWYgKGVudHJ5WzFdLmxlbmd0aCA+IDAgJiYgbWF0Y2hlcihlbnRyeSkpIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goZW50cnkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydHMgPSBbXTtcbiAgICAgIHZhciBtaWRkbGVzID0gW107XG4gICAgICB2YXIgZW5kcyA9IFtdO1xuICAgICAgdmFyIHN0YXJ0aW5nID0gdHJ1ZTtcbiAgICAgIHZhciBoYXNCbG9ja3MgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgW25vZGVdIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmICFlZGl0b3IuaXNJbmxpbmUobm9kZSkpIHtcbiAgICAgICAgICBzdGFydGluZyA9IGZhbHNlO1xuICAgICAgICAgIGhhc0Jsb2NrcyA9IHRydWU7XG4gICAgICAgICAgbWlkZGxlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nKSB7XG4gICAgICAgICAgc3RhcnRzLnB1c2gobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBbaW5saW5lTWF0Y2hdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2g6IG4gPT4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbiksXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIFssIGlubGluZVBhdGhdID0gaW5saW5lTWF0Y2g7XG4gICAgICB2YXIgaXNJbmxpbmVTdGFydCA9IEVkaXRvci5pc1N0YXJ0KGVkaXRvciwgYXQsIGlubGluZVBhdGgpO1xuICAgICAgdmFyIGlzSW5saW5lRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIGlubGluZVBhdGgpO1xuICAgICAgdmFyIG1pZGRsZVJlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgaXNCbG9ja0VuZCA/IFBhdGgubmV4dChibG9ja1BhdGgpIDogYmxvY2tQYXRoKTtcbiAgICAgIHZhciBlbmRSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsIGlzSW5saW5lRW5kID8gUGF0aC5uZXh0KGlubGluZVBhdGgpIDogaW5saW5lUGF0aCk7XG4gICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaDogbiA9PiBoYXNCbG9ja3MgPyBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pIDogVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbiksXG4gICAgICAgIG1vZGU6IGhhc0Jsb2NrcyA/ICdsb3dlc3QnIDogJ2hpZ2hlc3QnLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsICFpc0lubGluZVN0YXJ0IHx8IGlzSW5saW5lU3RhcnQgJiYgaXNJbmxpbmVFbmQgPyBQYXRoLm5leHQoaW5saW5lUGF0aCkgOiBpbmxpbmVQYXRoKTtcbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBzdGFydHMsIHtcbiAgICAgICAgYXQ6IHN0YXJ0UmVmLmN1cnJlbnQsXG4gICAgICAgIG1hdGNoOiBuID0+IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBtaWRkbGVzLCB7XG4gICAgICAgIGF0OiBtaWRkbGVSZWYuY3VycmVudCxcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICAgICAgbW9kZTogJ2xvd2VzdCcsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBlbmRzLCB7XG4gICAgICAgIGF0OiBlbmRSZWYuY3VycmVudCxcbiAgICAgICAgbWF0Y2g6IG4gPT4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbiksXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIW9wdGlvbnMuYXQpIHtcbiAgICAgICAgdmFyIHBhdGg7XG5cbiAgICAgICAgaWYgKGVuZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHBhdGggPSBQYXRoLnByZXZpb3VzKGVuZFJlZi5jdXJyZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChtaWRkbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBwYXRoID0gUGF0aC5wcmV2aW91cyhtaWRkbGVSZWYuY3VycmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aCA9IFBhdGgucHJldmlvdXMoc3RhcnRSZWYuY3VycmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2VuZCA9IEVkaXRvci5lbmQoZWRpdG9yLCBwYXRoKTtcblxuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIF9lbmQpO1xuICAgICAgfVxuXG4gICAgICBzdGFydFJlZi51bnJlZigpO1xuICAgICAgbWlkZGxlUmVmLnVucmVmKCk7XG4gICAgICBlbmRSZWYudW5yZWYoKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgYSBzdHJpbmcgb2YgdGV4dCBpbiB0aGUgRWRpdG9yLlxyXG4gICAqL1xuICBpbnNlcnRUZXh0KGVkaXRvciwgdGV4dCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgdm9pZHMgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb25cbiAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZW5kID0gUmFuZ2UuZW5kKGF0KTtcblxuICAgICAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogZW5kXG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcG9pbnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgICAgYXQsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGF0ID0gcG9pbnRSZWYudW5yZWYoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHtcbiAgICAgICAgICAgIGFuY2hvcjogYXQsXG4gICAgICAgICAgICBmb2N1czogYXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICBhdFxuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIge1xuICAgICAgICBwYXRoLFxuICAgICAgICBvZmZzZXRcbiAgICAgIH0gPSBhdDtcbiAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6ICdpbnNlcnRfdGV4dCcsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgdGV4dFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ4KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDgodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ4KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkOChPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbnZhciBUcmFuc2Zvcm1zID0gX29iamVjdFNwcmVhZCQ4KHt9LCBHZW5lcmFsVHJhbnNmb3Jtcywge30sIE5vZGVUcmFuc2Zvcm1zLCB7fSwgU2VsZWN0aW9uVHJhbnNmb3Jtcywge30sIFRleHRUcmFuc2Zvcm1zKTtcblxuZnVuY3Rpb24gb3duS2V5cyQ5KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDkodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ5KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkOShPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgU2xhdGUgYEVkaXRvcmAgb2JqZWN0LlxyXG4gKi9cblxudmFyIGNyZWF0ZUVkaXRvciA9ICgpID0+IHtcbiAgdmFyIGVkaXRvciA9IHtcbiAgICBjaGlsZHJlbjogW10sXG4gICAgb3BlcmF0aW9uczogW10sXG4gICAgc2VsZWN0aW9uOiBudWxsLFxuICAgIG1hcmtzOiBudWxsLFxuICAgIGlzSW5saW5lOiAoKSA9PiBmYWxzZSxcbiAgICBpc1ZvaWQ6ICgpID0+IGZhbHNlLFxuICAgIG9uQ2hhbmdlOiAoKSA9PiB7fSxcbiAgICBhcHBseTogb3AgPT4ge1xuICAgICAgZm9yICh2YXIgcmVmIG9mIEVkaXRvci5wYXRoUmVmcyhlZGl0b3IpKSB7XG4gICAgICAgIFBhdGhSZWYudHJhbnNmb3JtKHJlZiwgb3ApO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfcmVmIG9mIEVkaXRvci5wb2ludFJlZnMoZWRpdG9yKSkge1xuICAgICAgICBQb2ludFJlZi50cmFuc2Zvcm0oX3JlZiwgb3ApO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfcmVmMiBvZiBFZGl0b3IucmFuZ2VSZWZzKGVkaXRvcikpIHtcbiAgICAgICAgUmFuZ2VSZWYudHJhbnNmb3JtKF9yZWYyLCBvcCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZXQgPSBuZXcgU2V0KCk7XG4gICAgICB2YXIgZGlydHlQYXRocyA9IFtdO1xuXG4gICAgICB2YXIgYWRkID0gcGF0aCA9PiB7XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHBhdGguam9pbignLCcpO1xuXG4gICAgICAgICAgaWYgKCFzZXQuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHNldC5hZGQoa2V5KTtcbiAgICAgICAgICAgIGRpcnR5UGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBvbGREaXJ0eVBhdGhzID0gRElSVFlfUEFUSFMuZ2V0KGVkaXRvcikgfHwgW107XG4gICAgICB2YXIgbmV3RGlydHlQYXRocyA9IGdldERpcnR5UGF0aHMob3ApO1xuXG4gICAgICBmb3IgKHZhciBwYXRoIG9mIG9sZERpcnR5UGF0aHMpIHtcbiAgICAgICAgdmFyIG5ld1BhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCk7XG4gICAgICAgIGFkZChuZXdQYXRoKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX3BhdGggb2YgbmV3RGlydHlQYXRocykge1xuICAgICAgICBhZGQoX3BhdGgpO1xuICAgICAgfVxuXG4gICAgICBESVJUWV9QQVRIUy5zZXQoZWRpdG9yLCBkaXJ0eVBhdGhzKTtcbiAgICAgIEVkaXRvci50cmFuc2Zvcm0oZWRpdG9yLCBvcCk7XG4gICAgICBlZGl0b3Iub3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgIEVkaXRvci5ub3JtYWxpemUoZWRpdG9yKTsgLy8gQ2xlYXIgYW55IGZvcm1hdHMgYXBwbGllZCB0byB0aGUgY3Vyc29yIGlmIHRoZSBzZWxlY3Rpb24gY2hhbmdlcy5cblxuICAgICAgaWYgKG9wLnR5cGUgPT09ICdzZXRfc2VsZWN0aW9uJykge1xuICAgICAgICBlZGl0b3IubWFya3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIUZMVVNISU5HLmdldChlZGl0b3IpKSB7XG4gICAgICAgIEZMVVNISU5HLnNldChlZGl0b3IsIHRydWUpO1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICBGTFVTSElORy5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gICAgICAgICAgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgZWRpdG9yLm9wZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBhZGRNYXJrOiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9ID0gZWRpdG9yO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgW2tleV06IHZhbHVlXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgICAgICAgICAgc3BsaXQ6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWFya3MgPSBfb2JqZWN0U3ByZWFkJDkoe30sIEVkaXRvci5tYXJrcyhlZGl0b3IpIHx8IHt9LCB7XG4gICAgICAgICAgICBba2V5XTogdmFsdWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGVkaXRvci5tYXJrcyA9IG1hcmtzO1xuICAgICAgICAgIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkZWxldGVCYWNrd2FyZDogdW5pdCA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0gPSBlZGl0b3I7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICB1bml0LFxuICAgICAgICAgIHJldmVyc2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZWxldGVGb3J3YXJkOiB1bml0ID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcblxuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgIHVuaXRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZWxldGVGcmFnbWVudDogKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9ID0gZWRpdG9yO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0RnJhZ21lbnQ6ICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcblxuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gTm9kZS5mcmFnbWVudChlZGl0b3IsIHNlbGVjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIGluc2VydEJyZWFrOiAoKSA9PiB7XG4gICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGFsd2F5czogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBpbnNlcnRGcmFnbWVudDogZnJhZ21lbnQgPT4ge1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50KTtcbiAgICB9LFxuICAgIGluc2VydE5vZGU6IG5vZGUgPT4ge1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG5vZGUpO1xuICAgIH0sXG4gICAgaW5zZXJ0VGV4dDogdGV4dCA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgIG1hcmtzXG4gICAgICB9ID0gZWRpdG9yO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIC8vIElmIHRoZSBjdXJzb3IgaXMgYXQgdGhlIGVuZCBvZiBhbiBpbmxpbmUsIG1vdmUgaXQgb3V0c2lkZSBvZlxuICAgICAgICAvLyB0aGUgaW5saW5lIGJlZm9yZSBpbnNlcnRpbmdcbiAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICB2YXIgaW5saW5lID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgbWF0Y2g6IG4gPT4gRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbiksXG4gICAgICAgICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChpbmxpbmUpIHtcbiAgICAgICAgICAgIHZhciBbLCBpbmxpbmVQYXRoXSA9IGlubGluZTtcblxuICAgICAgICAgICAgaWYgKEVkaXRvci5pc0VuZChlZGl0b3IsIHNlbGVjdGlvbi5hbmNob3IsIGlubGluZVBhdGgpKSB7XG4gICAgICAgICAgICAgIHZhciBwb2ludCA9IEVkaXRvci5hZnRlcihlZGl0b3IsIGlubGluZVBhdGgpO1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBhbmNob3I6IHBvaW50LFxuICAgICAgICAgICAgICAgIGZvY3VzOiBwb2ludFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWFya3MpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IF9vYmplY3RTcHJlYWQkOSh7XG4gICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgfSwgbWFya3MpO1xuXG4gICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0VGV4dChlZGl0b3IsIHRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWRpdG9yLm1hcmtzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5vcm1hbGl6ZU5vZGU6IGVudHJ5ID0+IHtcbiAgICAgIHZhciBbbm9kZSwgcGF0aF0gPSBlbnRyeTsgLy8gVGhlcmUgYXJlIG5vIGNvcmUgbm9ybWFsaXphdGlvbnMgZm9yIHRleHQgbm9kZXMuXG5cbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEVuc3VyZSB0aGF0IGJsb2NrIGFuZCBpbmxpbmUgbm9kZXMgaGF2ZSBhdCBsZWFzdCBvbmUgdGV4dCBjaGlsZC5cblxuXG4gICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGNoaWxkID0ge1xuICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgIH07XG4gICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBjaGlsZCwge1xuICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdCgwKSxcbiAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgaGF2ZSBibG9jayBvciBpbmxpbmUgY2hpbGRyZW4uXG5cblxuICAgICAgdmFyIHNob3VsZEhhdmVJbmxpbmVzID0gRWRpdG9yLmlzRWRpdG9yKG5vZGUpID8gZmFsc2UgOiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiAoZWRpdG9yLmlzSW5saW5lKG5vZGUpIHx8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IFRleHQuaXNUZXh0KG5vZGUuY2hpbGRyZW5bMF0pIHx8IGVkaXRvci5pc0lubGluZShub2RlLmNoaWxkcmVuWzBdKSk7IC8vIFNpbmNlIHdlJ2xsIGJlIGFwcGx5aW5nIG9wZXJhdGlvbnMgd2hpbGUgaXRlcmF0aW5nLCBrZWVwIHRyYWNrIG9mIGFuXG4gICAgICAvLyBpbmRleCB0aGF0IGFjY291bnRzIGZvciBhbnkgYWRkZWQvcmVtb3ZlZCBub2Rlcy5cblxuICAgICAgdmFyIG4gPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyssIG4rKykge1xuICAgICAgICB2YXIgX2NoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgdmFyIHByZXYgPSBub2RlLmNoaWxkcmVuW2kgLSAxXTtcbiAgICAgICAgdmFyIGlzTGFzdCA9IGkgPT09IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGlzSW5saW5lT3JUZXh0ID0gVGV4dC5pc1RleHQoX2NoaWxkKSB8fCBFbGVtZW50LmlzRWxlbWVudChfY2hpbGQpICYmIGVkaXRvci5pc0lubGluZShfY2hpbGQpOyAvLyBPbmx5IGFsbG93IGJsb2NrIG5vZGVzIGluIHRoZSB0b3AtbGV2ZWwgY2hpbGRyZW4gYW5kIHBhcmVudCBibG9ja3NcbiAgICAgICAgLy8gdGhhdCBvbmx5IGNvbnRhaW4gYmxvY2sgbm9kZXMuIFNpbWlsYXJseSwgb25seSBhbGxvdyBpbmxpbmUgbm9kZXMgaW5cbiAgICAgICAgLy8gb3RoZXIgaW5saW5lIG5vZGVzLCBvciBwYXJlbnQgYmxvY2tzIHRoYXQgb25seSBjb250YWluIGlubGluZXMgYW5kXG4gICAgICAgIC8vIHRleHQuXG5cbiAgICAgICAgaWYgKGlzSW5saW5lT3JUZXh0ICE9PSBzaG91bGRIYXZlSW5saW5lcykge1xuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG4tLTtcbiAgICAgICAgfSBlbHNlIGlmIChFbGVtZW50LmlzRWxlbWVudChfY2hpbGQpKSB7XG4gICAgICAgICAgLy8gRW5zdXJlIHRoYXQgaW5saW5lIG5vZGVzIGFyZSBzdXJyb3VuZGVkIGJ5IHRleHQgbm9kZXMuXG4gICAgICAgICAgaWYgKGVkaXRvci5pc0lubGluZShfY2hpbGQpKSB7XG4gICAgICAgICAgICBpZiAocHJldiA9PSBudWxsIHx8ICFUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICAgICAgICB2YXIgbmV3Q2hpbGQgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG5ld0NoaWxkLCB7XG4gICAgICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuKys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGFzdCkge1xuICAgICAgICAgICAgICB2YXIgX25ld0NoaWxkID0ge1xuICAgICAgICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBfbmV3Q2hpbGQsIHtcbiAgICAgICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiArIDEpLFxuICAgICAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE1lcmdlIGFkamFjZW50IHRleHQgbm9kZXMgdGhhdCBhcmUgZW1wdHkgb3IgbWF0Y2guXG4gICAgICAgICAgaWYgKHByZXYgIT0gbnVsbCAmJiBUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICAgICAgaWYgKFRleHQuZXF1YWxzKF9jaGlsZCwgcHJldiwge1xuICAgICAgICAgICAgICBsb29zZTogdHJ1ZVxuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5tZXJnZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2LnRleHQgPT09ICcnKSB7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4gLSAxKSxcbiAgICAgICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xhc3QgJiYgX2NoaWxkLnRleHQgPT09ICcnKSB7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICByZW1vdmVNYXJrOiBrZXkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9ID0gZWRpdG9yO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnVuc2V0Tm9kZXMoZWRpdG9yLCBrZXksIHtcbiAgICAgICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICAgICAgICAgIHNwbGl0OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1hcmtzID0gX29iamVjdFNwcmVhZCQ5KHt9LCBFZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fSk7XG5cbiAgICAgICAgICBkZWxldGUgbWFya3Nba2V5XTtcbiAgICAgICAgICBlZGl0b3IubWFya3MgPSBtYXJrcztcbiAgICAgICAgICBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGVkaXRvcjtcbn07XG4vKipcclxuICogR2V0IHRoZSBcImRpcnR5XCIgcGF0aHMgZ2VuZXJhdGVkIGZyb20gYW4gb3BlcmF0aW9uLlxyXG4gKi9cblxudmFyIGdldERpcnR5UGF0aHMgPSBvcCA9PiB7XG4gIHN3aXRjaCAob3AudHlwZSkge1xuICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGhcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICByZXR1cm4gUGF0aC5sZXZlbHMocGF0aCk7XG4gICAgICB9XG5cbiAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBwYXRoOiBfcGF0aDJcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICB2YXIgbGV2ZWxzID0gUGF0aC5sZXZlbHMoX3BhdGgyKTtcbiAgICAgICAgdmFyIGRlc2NlbmRhbnRzID0gVGV4dC5pc1RleHQobm9kZSkgPyBbXSA6IEFycmF5LmZyb20oTm9kZS5ub2Rlcyhub2RlKSwgKF9yZWYzKSA9PiB7XG4gICAgICAgICAgdmFyIFssIHBdID0gX3JlZjM7XG4gICAgICAgICAgcmV0dXJuIF9wYXRoMi5jb25jYXQocCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gWy4uLmxldmVscywgLi4uZGVzY2VuZGFudHNdO1xuICAgICAgfVxuXG4gICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGgzXG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgdmFyIGFuY2VzdG9ycyA9IFBhdGguYW5jZXN0b3JzKF9wYXRoMyk7XG4gICAgICAgIHZhciBwcmV2aW91c1BhdGggPSBQYXRoLnByZXZpb3VzKF9wYXRoMyk7XG4gICAgICAgIHJldHVybiBbLi4uYW5jZXN0b3JzLCBwcmV2aW91c1BhdGhdO1xuICAgICAgfVxuXG4gICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDQsXG4gICAgICAgICAgbmV3UGF0aFxuICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9wYXRoNCwgbmV3UGF0aCkpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb2xkQW5jZXN0b3JzID0gW107XG4gICAgICAgIHZhciBuZXdBbmNlc3RvcnMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBhbmNlc3RvciBvZiBQYXRoLmFuY2VzdG9ycyhfcGF0aDQpKSB7XG4gICAgICAgICAgdmFyIHAgPSBQYXRoLnRyYW5zZm9ybShhbmNlc3Rvciwgb3ApO1xuICAgICAgICAgIG9sZEFuY2VzdG9ycy5wdXNoKHApO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgX2FuY2VzdG9yIG9mIFBhdGguYW5jZXN0b3JzKG5ld1BhdGgpKSB7XG4gICAgICAgICAgdmFyIF9wID0gUGF0aC50cmFuc2Zvcm0oX2FuY2VzdG9yLCBvcCk7XG5cbiAgICAgICAgICBuZXdBbmNlc3RvcnMucHVzaChfcCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gWy4uLm9sZEFuY2VzdG9ycywgLi4ubmV3QW5jZXN0b3JzXTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDVcbiAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgIHZhciBfYW5jZXN0b3JzID0gUGF0aC5hbmNlc3RvcnMoX3BhdGg1KTtcblxuICAgICAgICByZXR1cm4gWy4uLl9hbmNlc3RvcnNdO1xuICAgICAgfVxuXG4gICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGg2XG4gICAgICAgIH0gPSBvcDtcblxuICAgICAgICB2YXIgX2xldmVscyA9IFBhdGgubGV2ZWxzKF9wYXRoNik7XG5cbiAgICAgICAgdmFyIG5leHRQYXRoID0gUGF0aC5uZXh0KF9wYXRoNik7XG4gICAgICAgIHJldHVybiBbLi4uX2xldmVscywgbmV4dFBhdGhdO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICB9XG59O1xuXG5leHBvcnQgeyBFZGl0b3IsIEVsZW1lbnQsIExvY2F0aW9uLCBOb2RlLCBPcGVyYXRpb24sIFBhdGgsIFBhdGhSZWYsIFBvaW50LCBQb2ludFJlZiwgUmFuZ2UsIFJhbmdlUmVmLCBTcGFuLCBUZXh0LCBUcmFuc2Zvcm1zLCBjcmVhdGVFZGl0b3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIiwiLyohXG4gKiBpcy1wbGFpbi1vYmplY3QgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLXBsYWluLW9iamVjdD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IGlzT2JqZWN0IGZyb20gJ2lzb2JqZWN0JztcblxuZnVuY3Rpb24gaXNPYmplY3RPYmplY3Qobykge1xuICByZXR1cm4gaXNPYmplY3QobykgPT09IHRydWVcbiAgICAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG8pIHtcbiAgdmFyIGN0b3IscHJvdDtcblxuICBpZiAoaXNPYmplY3RPYmplY3QobykgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgaGFzIG1vZGlmaWVkIGNvbnN0cnVjdG9yXG4gIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuICBpZiAodHlwZW9mIGN0b3IgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiBoYXMgbW9kaWZpZWQgcHJvdG90eXBlXG4gIHByb3QgPSBjdG9yLnByb3RvdHlwZTtcbiAgaWYgKGlzT2JqZWN0T2JqZWN0KHByb3QpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIGNvbnN0cnVjdG9yIGRvZXMgbm90IGhhdmUgYW4gT2JqZWN0LXNwZWNpZmljIG1ldGhvZFxuICBpZiAocHJvdC5oYXNPd25Qcm9wZXJ0eSgnaXNQcm90b3R5cGVPZicpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIE1vc3QgbGlrZWx5IGEgcGxhaW4gT2JqZWN0XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8qIVxuICogaXNvYmplY3QgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzb2JqZWN0PlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkodmFsKSA9PT0gZmFsc2U7XG59O1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuY29uc3Qgc3ZnSWNvbnMgPSB7XG4gIGZvcm1hdF9ib2xkOlxuICAgICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiB3aWR0aD1cIjI0XCI+PHBhdGggZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz48cGF0aCBkPVwiTTE1LjYgMTAuNzljLjk3LS42NyAxLjY1LTEuNzcgMS42NS0yLjc5IDAtMi4yNi0xLjc1LTQtNC00SDd2MTRoNy4wNGMyLjA5IDAgMy43MS0xLjcgMy43MS0zLjc5IDAtMS41Mi0uODYtMi44Mi0yLjE1LTMuNDJ6TTEwIDYuNWgzYy44MyAwIDEuNS42NyAxLjUgMS41cy0uNjcgMS41LTEuNSAxLjVoLTN2LTN6bTMuNSA5SDEwdi0zaDMuNWMuODMgMCAxLjUuNjcgMS41IDEuNXMtLjY3IDEuNS0xLjUgMS41elwiLz48L3N2Zz4nLFxuICBmb3JtYXRfaXRhbGljOlxuICAgICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiB3aWR0aD1cIjI0XCI+PHBhdGggZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz48cGF0aCBkPVwiTTEwIDR2M2gyLjIxbC0zLjQyIDhINnYzaDh2LTNoLTIuMjFsMy40Mi04SDE4VjR6XCIvPjwvc3ZnPicsXG4gIGZvcm1hdF91bmRlcmxpbmVkOlxuICAgICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiB3aWR0aD1cIjI0XCI+PHBhdGggZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz48cGF0aCBkPVwiTTEyIDE3YzMuMzEgMCA2LTIuNjkgNi02VjNoLTIuNXY4YzAgMS45My0xLjU3IDMuNS0zLjUgMy41UzguNSAxMi45MyA4LjUgMTFWM0g2djhjMCAzLjMxIDIuNjkgNiA2IDZ6bS03IDJ2MmgxNHYtMkg1elwiLz48L3N2Zz4nLFxuICBmb3JtYXRfbGlzdF9idWxsZXRlZDpcbiAgICAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgd2lkdGg9XCIyNFwiPjxwYXRoIGQ9XCJNMCAwaDI0djI0SDBWMHpcIiBmaWxsPVwibm9uZVwiLz48cGF0aCBkPVwiTTQgMTAuNWMtLjgzIDAtMS41LjY3LTEuNSAxLjVzLjY3IDEuNSAxLjUgMS41IDEuNS0uNjcgMS41LTEuNS0uNjctMS41LTEuNS0xLjV6bTAtNmMtLjgzIDAtMS41LjY3LTEuNSAxLjVTMy4xNyA3LjUgNCA3LjUgNS41IDYuODMgNS41IDYgNC44MyA0LjUgNCA0LjV6bTAgMTJjLS44MyAwLTEuNS42OC0xLjUgMS41cy42OCAxLjUgMS41IDEuNSAxLjUtLjY4IDEuNS0xLjUtLjY3LTEuNS0xLjUtMS41ek03IDE5aDE0di0ySDd2MnptMC02aDE0di0ySDd2MnptMC04djJoMTRWNUg3elwiLz48L3N2Zz4nLFxuICBmb3JtYXRfbGlzdF9udW1iZXJlZDpcbiAgICAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgd2lkdGg9XCIyNFwiPjxwYXRoIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+PHBhdGggZD1cIk0yIDE3aDJ2LjVIM3YxaDF2LjVIMnYxaDN2LTRIMnYxem0xLTloMVY0SDJ2MWgxdjN6bS0xIDNoMS44TDIgMTMuMXYuOWgzdi0xSDMuMkw1IDEwLjlWMTBIMnYxem01LTZ2MmgxNFY1SDd6bTAgMTRoMTR2LTJIN3Yyem0wLTZoMTR2LTJIN3YyelwiLz48L3N2Zz4nLFxufTtcblxuY29uc3Qgc3R5bGVzID0ge1xuICBpY29uOiB7XG4gICAgb3BhY2l0eTogMC43LFxuICB9LFxufTtcblxuY29uc3QgSWNvbiA9ICh7IGNoaWxkcmVuIH0pID0+IChcbiAgPGltZ1xuICAgIGhlaWdodD17MjB9XG4gICAgc3JjPXtgZGF0YTppbWFnZS9zdmcreG1sO3V0ZjgsJHtzdmdJY29uc1tjaGlsZHJlbl19YH1cbiAgICBzdHlsZT17c3R5bGVzLmljb259XG4gIC8+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBJY29uO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuY29uc3Qgc3R5bGVzID0ge1xuICBqc29uVmlld2VyOiB7XG4gICAgcGFkZGluZzogMTYsXG4gICAgYm9yZGVyUmFkaXVzOiA0LFxuICAgIGJhY2tncm91bmQ6ICdsaW5lbicsXG4gIH0sXG59O1xuXG5jb25zdCBKc29uVmlld2VyID0gKHsgdmFsdWUgfSkgPT4gKFxuICA8cHJlIHN0eWxlPXtzdHlsZXMuanNvblZpZXdlcn0+XG4gICAgPGNvZGU+e0pTT04uc3RyaW5naWZ5KHZhbHVlLCBudWxsLCAyKX08L2NvZGU+XG4gIDwvcHJlPlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgSnNvblZpZXdlcjtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IHN0eWxlcyA9IHtcbiAgdG9vbGJhcjoge1xuICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICBmbGV4RGlyZWN0aW9uOiAncm93JyxcbiAgfSxcbiAgYnV0dG9uOiB7XG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcblxuICAgIGhlaWdodDogMzAsXG4gICAgbWluV2lkdGg6IDMwLFxuICAgIG1hcmdpbjogNSxcbiAgICBwYWRkaW5nOiAwLFxuICAgIGJvcmRlcjogJ25vbmUnLFxuXG4gICAgYmFja2dyb3VuZDogJ3RyYW5zcGFyZW50JyxcbiAgICBib3JkZXJSYWRpdXM6IDQsXG4gICAgY3Vyc29yOiAncG9pbnRlcicsXG4gIH0sXG4gIGJ1dHRvbkFjdGl2ZToge1xuICAgIGJhY2tncm91bmQ6ICcjZjVmNWY1JyxcbiAgfSxcbiAgc2VwYXJhdG9yOiB7XG4gICAgbWFyZ2luOiAnMTBweCA1cHgnLFxuICAgIGJvcmRlclJpZ2h0OiAnc29saWQgdGhpbiAjZWFlYWVhJyxcbiAgfSxcbn07XG5cbmNvbnN0IFRvb2xiYXIgPSAoeyBjaGlsZHJlbiB9KSA9PiA8ZGl2IHN0eWxlPXtzdHlsZXMudG9vbGJhcn0+e2NoaWxkcmVufTwvZGl2PjtcblxuVG9vbGJhci5CdXR0b24gPSAoeyBhY3RpdmUsIC4uLnByb3BzIH0pID0+IChcbiAgPGJ1dHRvblxuICAgIHsuLi5wcm9wc31cbiAgICBzdHlsZT17e1xuICAgICAgLi4uc3R5bGVzLmJ1dHRvbixcbiAgICAgIC4uLihhY3RpdmUgPyBzdHlsZXMuYnV0dG9uQWN0aXZlIDogdW5kZWZpbmVkKSxcbiAgICB9fVxuICAvPlxuKTtcblxuVG9vbGJhci5TZXBhcmF0b3IgPSAoKSA9PiA8ZGl2IHN0eWxlPXtzdHlsZXMuc2VwYXJhdG9yfSAvPjtcblxuZXhwb3J0IGRlZmF1bHQgVG9vbGJhcjtcbiIsIi8vIEJsb2Nrc1xuY29uc3QgQlVMTEVURURfTElTVCA9ICdidWxsZXRlZC1saXN0JztcbmNvbnN0IE5VTUJFUkVEX0xJU1QgPSAnbnVtYmVyZWQtbGlzdCc7XG5jb25zdCBMSVNUX0lURU0gPSAnbGlzdC1pdGVtJztcbmNvbnN0IE1FTlRJT04gPSAnbWVudGlvbic7XG5cbi8vIE1hcmtzXG5jb25zdCBCT0xEID0gJ2JvbGQnO1xuY29uc3QgSVRBTElDID0gJ2l0YWxpYyc7XG5jb25zdCBVTkRFUkxJTkUgPSAndW5kZXJsaW5lJztcblxuLy8gT3RoZXIgZXZlbnRzXG5jb25zdCBFRElUT1JfQ0hBTkdFID0gJ2VkaXRvci1jaGFuZ2UnO1xuXG5leHBvcnQge1xuICBCVUxMRVRFRF9MSVNULFxuICBOVU1CRVJFRF9MSVNULFxuICBMSVNUX0lURU0sXG4gIE1FTlRJT04sXG4gIEJPTEQsXG4gIElUQUxJQyxcbiAgVU5ERVJMSU5FLFxuICBFRElUT1JfQ0hBTkdFLFxufTtcbiIsImNvbnN0IGFwcGx5ID0gKGFyZ3MgPSBbXSkgPT4gKGZ1bmMpID0+IGZ1bmMoLi4uYXJncyk7XG5cbmV4cG9ydCBkZWZhdWx0IGFwcGx5O1xuIiwiY29uc3QgY29tcG9zZSA9ICguLi5mdW5jcykgPT4gKGFyZykgPT5cbiAgZnVuY3MucmVkdWNlUmlnaHQoKGNvbXBvc2VkLCBmKSA9PiAoZiA/IGYoY29tcG9zZWQpIDogY29tcG9zZWQpLCBhcmcpO1xuXG5leHBvcnQgZGVmYXVsdCBjb21wb3NlO1xuIiwiY29uc3QgY3JlYXRlUGx1Z2luID0gKGNvbmZpZ3MpID0+IHtcbiAgY29uc3QgZGVmYXVsdFBsdWdpbiA9IHtcbiAgICBuYW1lOiAnJyxcbiAgICByZW5kZXJMZWFmOiAobmV4dCkgPT4gKHByb3BzKSA9PiBuZXh0KHByb3BzKSxcbiAgICByZW5kZXJFbGVtZW50OiAobmV4dCkgPT4gKHByb3BzKSA9PiBuZXh0KHByb3BzKSxcbiAgICBUb29sYmFyQnV0dG9uOiAoKSA9PiBudWxsLFxuICAgIHJlbmRlckN1c3RvbTogKCkgPT4gbnVsbCxcbiAgICBoYW5kbGVNZXNzYWdlOiAoKSA9PiAoKSA9PiB7fSxcbiAgICBlbmhhbmNlRWRpdG9yOiAoZWRpdG9yKSA9PiBlZGl0b3IsXG4gIH07XG4gIHJldHVybiB7IC4uLmRlZmF1bHRQbHVnaW4sIC4uLmNvbmZpZ3MgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVBsdWdpbjtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICdzbGF0ZSc7XG5pbXBvcnQgY29tcG9zZSBmcm9tICcuL2NvbXBvc2UnO1xuaW1wb3J0IHsgTlVNQkVSRURfTElTVCwgQlVMTEVURURfTElTVCB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNvbnN0IGlzQmxvY2tBY3RpdmUgPSAoZWRpdG9yLCBmb3JtYXQpID0+IHtcbiAgY29uc3QgW21hdGNoXSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICBtYXRjaDogKG4pID0+IG4udHlwZSA9PT0gZm9ybWF0LFxuICB9KTtcbiAgcmV0dXJuICEhbWF0Y2g7XG59O1xuXG5jb25zdCBpc0xpc3QgPSAobm9kZSkgPT4gW0JVTExFVEVEX0xJU1QsIE5VTUJFUkVEX0xJU1RdLmluY2x1ZGVzKG5vZGUudHlwZSk7XG5cbmNvbnN0IERlZmF1bHRFbGVtZW50ID0gUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gKFxuICA8cCByZWY9e3JlZn0gc3R5bGU9e3sgbWFyZ2luOiAwLCBsaW5lSGVpZ2h0OiAxLjUgfX0gey4uLnByb3BzfSAvPlxuKSk7XG5cbmNvbnN0IHJlbmRlckRlZmF1bHRFbGVtZW50ID0gKHsgYXR0cmlidXRlcywgY2hpbGRyZW4gfSkgPT4gKFxuICA8RGVmYXVsdEVsZW1lbnQgey4uLmF0dHJpYnV0ZXN9PntjaGlsZHJlbn08L0RlZmF1bHRFbGVtZW50PlxuKTtcblxuY29uc3QgbWFrZVJlbmRlckVsZW1lbnQgPSAoYmxvY2ssIEN1c3RvbUVsZW1lbnQpID0+IChuZXh0KSA9PiAocHJvcHMpID0+IHtcbiAgaWYgKHByb3BzLmVsZW1lbnQudHlwZSA9PT0gYmxvY2spIHtcbiAgICByZXR1cm4gPEN1c3RvbUVsZW1lbnQgey4uLnByb3BzfSAvPjtcbiAgfVxuICByZXR1cm4gbmV4dChwcm9wcyk7XG59O1xuXG5jb25zdCBjb21wb3NlUmVuZGVyRWxlbWVudCA9IChwbHVnaW5zKSA9PlxuICBjb21wb3NlKC4uLnBsdWdpbnMubWFwKChwbHVnaW4pID0+IHBsdWdpbi5yZW5kZXJFbGVtZW50KSkoXG4gICAgcmVuZGVyRGVmYXVsdEVsZW1lbnQsXG4gICk7XG5cbmV4cG9ydCB7XG4gIGlzQmxvY2tBY3RpdmUsXG4gIGlzTGlzdCxcbiAgcmVuZGVyRGVmYXVsdEVsZW1lbnQsXG4gIG1ha2VSZW5kZXJFbGVtZW50LFxuICBjb21wb3NlUmVuZGVyRWxlbWVudCxcbn07XG4iLCJjb25zdCBmbG93ID0gKC4uLmZ1bmNzKSA9PiAoYXJnKSA9PlxuICBmdW5jcy5yZWR1Y2UoKGNvbXBvc2VkLCBmKSA9PiAoZiA/IGYoY29tcG9zZWQpIDogY29tcG9zZWQpLCBhcmcpO1xuXG5leHBvcnQgZGVmYXVsdCBmbG93O1xuIiwiY29uc3QgZ2V0ID0gKHBhdGgpID0+IChvYmplY3QpID0+IG9iamVjdFtwYXRoXTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0O1xuIiwiZXhwb3J0IHsgZGVmYXVsdCBhcyBjb21wb3NlIH0gZnJvbSAnLi9jb21wb3NlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZmxvdyB9IGZyb20gJy4vZmxvdyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1hcCB9IGZyb20gJy4vbWFwJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZ2V0IH0gZnJvbSAnLi9nZXQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBhcHBseSB9IGZyb20gJy4vYXBwbHknO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIGNyZWF0ZVBsdWdpbiB9IGZyb20gJy4vY3JlYXRlUGx1Z2luJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgd2l0aElkIH0gZnJvbSAnLi93aXRoSWQnO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZUZvcmNlVXBkYXRlIH0gZnJvbSAnLi91c2VGb3JjZVVwZGF0ZSc7XG5cbmV4cG9ydCAqIGZyb20gJy4vbGVhZkhlbHBlcnMnO1xuZXhwb3J0ICogZnJvbSAnLi9lbGVtZW50SGVscGVycyc7XG5leHBvcnQgKiBmcm9tICcuL21lc3NhZ2VIZWxwZXJzJztcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICdzbGF0ZSc7XG5pbXBvcnQgY29tcG9zZSBmcm9tICcuL2NvbXBvc2UnO1xuXG5jb25zdCBpc01hcmtBY3RpdmUgPSAoZWRpdG9yLCBmb3JtYXQpID0+IHtcbiAgY29uc3QgbWFya3MgPSBFZGl0b3IubWFya3MoZWRpdG9yKTtcbiAgcmV0dXJuIG1hcmtzID8gbWFya3NbZm9ybWF0XSA9PT0gdHJ1ZSA6IGZhbHNlO1xufTtcblxuY29uc3QgdG9nZ2xlTWFyayA9IChlZGl0b3IsIGZvcm1hdCkgPT4ge1xuICBjb25zdCBpc0FjdGl2ZSA9IGlzTWFya0FjdGl2ZShlZGl0b3IsIGZvcm1hdCk7XG4gIGlmIChpc0FjdGl2ZSkge1xuICAgIEVkaXRvci5yZW1vdmVNYXJrKGVkaXRvciwgZm9ybWF0KTtcbiAgfSBlbHNlIHtcbiAgICBFZGl0b3IuYWRkTWFyayhlZGl0b3IsIGZvcm1hdCwgdHJ1ZSk7XG4gIH1cbn07XG5cbmNvbnN0IERlZmF1bHRMZWFmID0gJ3NwYW4nO1xuXG5jb25zdCByZW5kZXJEZWZhdWx0TGVhZiA9ICh7IGF0dHJpYnV0ZXMsIGNoaWxkcmVuIH0pID0+IChcbiAgPERlZmF1bHRMZWFmIHsuLi5hdHRyaWJ1dGVzfT57Y2hpbGRyZW59PC9EZWZhdWx0TGVhZj5cbik7XG5cbmNvbnN0IG1ha2VSZW5kZXJMZWFmID0gKG1hcmssIEN1c3RvbUxlYWYpID0+IChuZXh0KSA9PiAocHJvcHMpID0+IHtcbiAgaWYgKHByb3BzLmxlYWZbbWFya10pIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IDxDdXN0b21MZWFmIHsuLi5wcm9wc30gLz47XG4gICAgcmV0dXJuIG5leHQoeyAuLi5wcm9wcywgY2hpbGRyZW4gfSk7XG4gIH1cbiAgcmV0dXJuIG5leHQocHJvcHMpO1xufTtcblxuY29uc3QgY29tcG9zZVJlbmRlckxlYWYgPSAocGx1Z2lucykgPT5cbiAgY29tcG9zZSguLi5wbHVnaW5zLm1hcCgocGx1Z2luKSA9PiBwbHVnaW4ucmVuZGVyTGVhZikpKHJlbmRlckRlZmF1bHRMZWFmKTtcblxuZXhwb3J0IHtcbiAgaXNNYXJrQWN0aXZlLFxuICB0b2dnbGVNYXJrLFxuICByZW5kZXJEZWZhdWx0TGVhZixcbiAgbWFrZVJlbmRlckxlYWYsXG4gIGNvbXBvc2VSZW5kZXJMZWFmLFxufTtcbiIsImNvbnN0IG1hcCA9IChpdGVyYXRlZSkgPT4gKGNvbGxlY3Rpb24pID0+IGNvbGxlY3Rpb24ubWFwKGl0ZXJhdGVlKTtcblxuZXhwb3J0IGRlZmF1bHQgbWFwO1xuIiwiY29uc3QgbWVzc2FnZVByZWZpeCA9ICdAaGVyby1lZGl0b3InO1xuXG5jb25zdCBhZGRNZXNzYWdlTGlzdGVuZXIgPSAodHlwZSwgY2FsbGJhY2spID0+IChlZGl0b3IpID0+IHtcbiAgY29uc3QgbGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQuZGF0YS50eXBlID09PSBgJHttZXNzYWdlUHJlZml4fS8ke2VkaXRvci5pZH0vJHt0eXBlfWApIHtcbiAgICAgIGNhbGxiYWNrKHsgZWRpdG9yLCBkYXRhOiBldmVudC5kYXRhLmRhdGEgfSk7XG4gICAgfVxuICB9O1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyKTtcbiAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIpO1xufTtcblxuY29uc3QgcG9zdE1lc3NhZ2UgPSAodHlwZSwgZGF0YSwgZWRpdG9yKSA9PiB7XG4gIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgdHlwZTogYCR7bWVzc2FnZVByZWZpeH0vJHtlZGl0b3IuaWR9LyR7dHlwZX1gLFxuICAgIGRhdGEsXG4gIH07XG4gIHdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlLCAnKicpO1xuICB3aW5kb3cuUmVhY3ROYXRpdmVXZWJWaWV3Py5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeShtZXNzYWdlKSk7XG59O1xuXG5leHBvcnQgeyBhZGRNZXNzYWdlTGlzdGVuZXIsIHBvc3RNZXNzYWdlIH07XG4iLCJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuXG5jb25zdCB1c2VGb3JjZVVwZGF0ZSA9ICgpID0+IHtcbiAgY29uc3QgcHJldiA9IHVzZVJlZigwKTtcbiAgY29uc3QgW2N1cnIsIHNldEN1cnJdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IGlzRm9yY2VVcGRhdGVkID0gcHJldi5jdXJyZW50ICE9PSBjdXJyO1xuICBwcmV2LmN1cnJlbnQgPSBjdXJyO1xuICByZXR1cm4geyBpc0ZvcmNlVXBkYXRlZCwgZm9yY2VVcGRhdGU6ICgpID0+IHNldEN1cnIoY3VyciArIDEpIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VGb3JjZVVwZGF0ZTtcbiIsImNvbnN0IHdpdGhJZCA9IChpZCkgPT4gKGVkaXRvcikgPT4ge1xuICBlZGl0b3IuaWQgPSBpZDtcbiAgcmV0dXJuIGVkaXRvcjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhJZDtcbiIsImltcG9ydCBSZWFjdCwgeyB1c2VNZW1vLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVFZGl0b3IgfSBmcm9tICdzbGF0ZSc7XG5pbXBvcnQgeyBTbGF0ZSwgRWRpdGFibGUsIHdpdGhSZWFjdCB9IGZyb20gJ3NsYXRlLXJlYWN0JztcbmltcG9ydCB7XG4gIGNvbXBvc2VSZW5kZXJMZWFmLFxuICBjb21wb3NlUmVuZGVyRWxlbWVudCxcbiAgcG9zdE1lc3NhZ2UsXG4gIHdpdGhJZCxcbiAgbWFwLFxuICBnZXQsXG4gIGFwcGx5LFxuICBmbG93LFxufSBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0IFRvb2xiYXIgZnJvbSAnLi9jb21wb25lbnRzL1Rvb2xiYXInO1xuaW1wb3J0IHsgRURJVE9SX0NIQU5HRSB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuY29uc3Qgc3R5bGVzID0ge1xuICBlZGl0b3JXcmFwcGVyOiB7XG4gICAgZm9udEZhbWlseTogJ3NhbnMtc2VyaWYnLFxuICAgIGJvcmRlcjogJ3NvbGlkIHRoaW4gI2VhZWFlYScsXG4gICAgYm9yZGVyUmFkaXVzOiA0LFxuICB9LFxuICBlZGl0YWJsZVdyYXBwZXI6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgfSxcbiAgZWRpdGFibGU6IHtcbiAgICBwYWRkaW5nOiAxNixcbiAgfSxcbn07XG5cbmNvbnN0IGdldEN1c3RvbUVsZW1lbnRzID0gKGVkaXRvcikgPT5cbiAgbWFwKGZsb3coZ2V0KCdyZW5kZXJDdXN0b20nKSwgYXBwbHkoW2VkaXRvcl0pKSk7XG5cbmNvbnN0IGFkZE1lc3NhZ2VMaXN0ZW5lcnMgPSAoZWRpdG9yKSA9PlxuICBtYXAoZmxvdyhnZXQoJ2hhbmRsZU1lc3NhZ2UnKSwgYXBwbHkoW2VkaXRvcl0pKSk7XG5cbmNvbnN0IGdldFRvb2xiYXJCdXR0b25zID0gbWFwKCh7IG5hbWUsIFRvb2xiYXJCdXR0b24gfSkgPT4gKFxuICA8VG9vbGJhckJ1dHRvbiBrZXk9e25hbWV9IC8+XG4pKTtcblxuY29uc3QgSGVyb0VkaXRvciA9ICh7XG4gIGlkLFxuICBzaG93VG9vbGJhciA9IHRydWUsXG4gIHBsdWdpbnMgPSBbXSxcbiAgcGxhY2Vob2xkZXIsXG4gIHZhbHVlLFxuICBvbkNoYW5nZSxcbiAgd3JhcHBlclN0eWxlLFxufSkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSB1c2VNZW1vKFxuICAgICgpID0+XG4gICAgICBmbG93KFxuICAgICAgICBjcmVhdGVFZGl0b3IsXG4gICAgICAgIHdpdGhSZWFjdCxcbiAgICAgICAgd2l0aElkKGlkKSxcbiAgICAgICAgLi4ubWFwKGdldCgnZW5oYW5jZUVkaXRvcicpKShwbHVnaW5zKSxcbiAgICAgICkoKSxcbiAgICBbXSxcbiAgKTtcblxuICBjb25zdCByZW5kZXJMZWFmID0gdXNlTWVtbygoKSA9PiBjb21wb3NlUmVuZGVyTGVhZihwbHVnaW5zKSwgW3BsdWdpbnNdKTtcblxuICBjb25zdCByZW5kZXJFbGVtZW50ID0gdXNlTWVtbygoKSA9PiBjb21wb3NlUmVuZGVyRWxlbWVudChwbHVnaW5zKSwgW3BsdWdpbnNdKTtcblxuICBjb25zdCByZW5kZXJDdXN0b20gPSB1c2VNZW1vKCgpID0+ICgpID0+IGdldEN1c3RvbUVsZW1lbnRzKGVkaXRvcikocGx1Z2lucyksIFtcbiAgICBwbHVnaW5zLFxuICAgIHZhbHVlLFxuICBdKTtcblxuICBjb25zdCB0b29sQmFyQnV0dG9ucyA9IHVzZU1lbW8oKCkgPT4gZ2V0VG9vbGJhckJ1dHRvbnMocGx1Z2lucyksIFtwbHVnaW5zXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCByZW1vdmVIYW5kbGVycyA9IGFkZE1lc3NhZ2VMaXN0ZW5lcnMoZWRpdG9yKShwbHVnaW5zKTtcblxuICAgIHJldHVybiAoKSA9PiByZW1vdmVIYW5kbGVycy5mb3JFYWNoKChyZW1vdmVIYW5kbGVyKSA9PiByZW1vdmVIYW5kbGVyKCkpO1xuICB9LCBbcGx1Z2luc10pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBzdHlsZT17eyAuLi5zdHlsZXMuZWRpdG9yV3JhcHBlciwgLi4ud3JhcHBlclN0eWxlIH19PlxuICAgICAgPFNsYXRlXG4gICAgICAgIGVkaXRvcj17ZWRpdG9yfVxuICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgIG9uQ2hhbmdlPXsodmFsdWUpID0+IHtcbiAgICAgICAgICBvbkNoYW5nZSh2YWx1ZSk7XG4gICAgICAgICAgcG9zdE1lc3NhZ2UoRURJVE9SX0NIQU5HRSwge30sIGVkaXRvcik7XG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIHtzaG93VG9vbGJhciA/IDxUb29sYmFyPnt0b29sQmFyQnV0dG9uc308L1Rvb2xiYXI+IDogbnVsbH1cbiAgICAgICAgPGRpdiBzdHlsZT17c3R5bGVzLmVkaXRhYmxlV3JhcHBlcn0+XG4gICAgICAgICAgPEVkaXRhYmxlXG4gICAgICAgICAgICBwbGFjZWhvbGRlcj17cGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICByZW5kZXJMZWFmPXtyZW5kZXJMZWFmfVxuICAgICAgICAgICAgcmVuZGVyRWxlbWVudD17cmVuZGVyRWxlbWVudH1cbiAgICAgICAgICAgIHN0eWxlPXtzdHlsZXMuZWRpdGFibGV9XG4gICAgICAgICAgLz5cbiAgICAgICAgICB7cmVuZGVyQ3VzdG9tKCl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9TbGF0ZT5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCAqIGZyb20gJy4vcGx1Z2lucyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEpzb25WaWV3ZXIgfSBmcm9tICcuL2NvbXBvbmVudHMvSnNvblZpZXdlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRvb2xiYXIgfSBmcm9tICcuL2NvbXBvbmVudHMvVG9vbGJhcic7XG5leHBvcnQgZGVmYXVsdCBIZXJvRWRpdG9yO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVNsYXRlIH0gZnJvbSAnc2xhdGUtcmVhY3QnO1xuaW1wb3J0IHtcbiAgY3JlYXRlUGx1Z2luLFxuICBpc01hcmtBY3RpdmUsXG4gIHRvZ2dsZU1hcmssXG4gIG1ha2VSZW5kZXJMZWFmLFxuICBhZGRNZXNzYWdlTGlzdGVuZXIsXG4gIHBvc3RNZXNzYWdlLFxufSBmcm9tICcuLi9oZWxwZXJzJztcbmltcG9ydCBUb29sYmFyIGZyb20gJy4uL2NvbXBvbmVudHMvVG9vbGJhcic7XG5pbXBvcnQgSWNvbiBmcm9tICcuLi9jb21wb25lbnRzL0ljb24nO1xuaW1wb3J0IHsgQk9MRCB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNvbnN0IHJlbmRlckxlYWYgPSBtYWtlUmVuZGVyTGVhZihCT0xELCAoeyBjaGlsZHJlbiB9KSA9PiAoXG4gIDxzdHJvbmc+e2NoaWxkcmVufTwvc3Ryb25nPlxuKSk7XG5cbmNvbnN0IGhhbmRsZU1lc3NhZ2UgPSBhZGRNZXNzYWdlTGlzdGVuZXIoQk9MRCwgKHsgZWRpdG9yIH0pID0+IHtcbiAgdG9nZ2xlTWFyayhlZGl0b3IsIEJPTEQpO1xufSk7XG5cbmNvbnN0IFRvb2xiYXJCdXR0b24gPSAoKSA9PiB7XG4gIGNvbnN0IGVkaXRvciA9IHVzZVNsYXRlKCk7XG5cbiAgcmV0dXJuIChcbiAgICA8VG9vbGJhci5CdXR0b25cbiAgICAgIGFjdGl2ZT17aXNNYXJrQWN0aXZlKGVkaXRvciwgQk9MRCl9XG4gICAgICBvbk1vdXNlRG93bj17KGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHBvc3RNZXNzYWdlKEJPTEQsIHt9LCBlZGl0b3IpO1xuICAgICAgfX1cbiAgICA+XG4gICAgICA8SWNvbj5mb3JtYXRfYm9sZDwvSWNvbj5cbiAgICA8L1Rvb2xiYXIuQnV0dG9uPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlUGx1Z2luKHtcbiAgbmFtZTogQk9MRCxcbiAgcmVuZGVyTGVhZixcbiAgaGFuZGxlTWVzc2FnZSxcbiAgVG9vbGJhckJ1dHRvbixcbn0pO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFRyYW5zZm9ybXMgfSBmcm9tICdzbGF0ZSc7XG5pbXBvcnQgeyB1c2VTbGF0ZSB9IGZyb20gJ3NsYXRlLXJlYWN0JztcbmltcG9ydCB7XG4gIGNyZWF0ZVBsdWdpbixcbiAgaXNCbG9ja0FjdGl2ZSxcbiAgbWFrZVJlbmRlckVsZW1lbnQsXG4gIGFkZE1lc3NhZ2VMaXN0ZW5lcixcbiAgcG9zdE1lc3NhZ2UsXG4gIGlzTGlzdCxcbn0gZnJvbSAnLi4vaGVscGVycyc7XG5pbXBvcnQgVG9vbGJhciBmcm9tICcuLi9jb21wb25lbnRzL1Rvb2xiYXInO1xuaW1wb3J0IEljb24gZnJvbSAnLi4vY29tcG9uZW50cy9JY29uJztcbmltcG9ydCB7IEJVTExFVEVEX0xJU1QsIExJU1RfSVRFTSB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNvbnN0IHJlbmRlckVsZW1lbnQgPSBtYWtlUmVuZGVyRWxlbWVudChcbiAgQlVMTEVURURfTElTVCxcbiAgKHsgYXR0cmlidXRlcywgY2hpbGRyZW4gfSkgPT4gPHVsIHsuLi5hdHRyaWJ1dGVzfT57Y2hpbGRyZW59PC91bD4sXG4pO1xuXG5jb25zdCBoYW5kbGVNZXNzYWdlID0gYWRkTWVzc2FnZUxpc3RlbmVyKEJVTExFVEVEX0xJU1QsICh7IGVkaXRvciB9KSA9PiB7XG4gIGNvbnN0IGlzQWN0aXZlID0gaXNCbG9ja0FjdGl2ZShlZGl0b3IsIEJVTExFVEVEX0xJU1QpO1xuXG4gIC8vIFVud3JhcCBhbGwgdGhlIGl0ZW1zIG9mIGFueSBsaXN0XG4gIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgbWF0Y2g6IGlzTGlzdCxcbiAgICBzcGxpdDogdHJ1ZSxcbiAgfSk7XG5cbiAgaWYgKGlzQWN0aXZlKSB7XG4gICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHsgdHlwZTogJ3BhcmFncmFwaCcgfSk7XG4gIH0gZWxzZSB7XG4gICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHsgdHlwZTogTElTVF9JVEVNIH0pO1xuICAgIFRyYW5zZm9ybXMud3JhcE5vZGVzKGVkaXRvciwgeyB0eXBlOiBCVUxMRVRFRF9MSVNULCBjaGlsZHJlbjogW10gfSk7XG4gIH1cbn0pO1xuXG5jb25zdCBUb29sYmFyQnV0dG9uID0gKCkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSB1c2VTbGF0ZSgpO1xuXG4gIHJldHVybiAoXG4gICAgPFRvb2xiYXIuQnV0dG9uXG4gICAgICBhY3RpdmU9e2lzQmxvY2tBY3RpdmUoZWRpdG9yLCBCVUxMRVRFRF9MSVNUKX1cbiAgICAgIG9uTW91c2VEb3duPXsoZXZlbnQpID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcG9zdE1lc3NhZ2UoQlVMTEVURURfTElTVCwge30sIGVkaXRvcik7XG4gICAgICB9fVxuICAgID5cbiAgICAgIDxJY29uPmZvcm1hdF9saXN0X2J1bGxldGVkPC9JY29uPlxuICAgIDwvVG9vbGJhci5CdXR0b24+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVQbHVnaW4oe1xuICBuYW1lOiBCVUxMRVRFRF9MSVNULFxuICByZW5kZXJFbGVtZW50LFxuICBoYW5kbGVNZXNzYWdlLFxuICBUb29sYmFyQnV0dG9uLFxufSk7XG4iLCJpbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlUGx1Z2luLCB1c2VGb3JjZVVwZGF0ZSB9IGZyb20gJy4uL2hlbHBlcnMnO1xuXG5jb25zdCBzdHlsZXMgPSB7XG4gIHBsYWNlaG9sZGVyOiB7XG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBwYWRkaW5nOiAxNixcbiAgICBsaW5lSGVpZ2h0OiAxLjUsXG4gICAgY29sb3I6ICdsaWdodGdyZXknLFxuICAgIHpJbmRleDogLTEsXG4gIH0sXG59O1xuXG5jb25zdCBDQUNIRV9UVEwgPSA1MDA7XG5cbmNvbnN0IGlzRGVmaW5lZCA9IChyZWYpID0+IHR5cGVvZiByZWYuY3VycmVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbmNvbnN0IGNoZWNrRW1wdHlPcHRpbWlzdGljYWxseSA9IChjb250ZW50KSA9PlxuICBjb250ZW50Lmxlbmd0aCA9PT0gMSAmJlxuICBjb250ZW50WzBdLnR5cGUgPT09ICdwYXJhZ3JhcGgnICYmXG4gIGNvbnRlbnRbMF0uY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gIGNvbnRlbnRbMF0uY2hpbGRyZW5bMF0udGV4dCA9PT0gJyc7XG5cbmNvbnN0IEVkaXRvclBsYWNlaG9sZGVyID0gKHsgdmFsdWUsIGVkaXRvciB9KSA9PiB7XG4gIGNvbnN0IGNhY2hlID0gdXNlUmVmKHVuZGVmaW5lZCk7XG4gIGNvbnN0IHsgaXNGb3JjZVVwZGF0ZWQsIGZvcmNlVXBkYXRlIH0gPSB1c2VGb3JjZVVwZGF0ZSgpO1xuXG4gIGNvbnN0IGNyZWF0ZVBsYWNlaG9sZGVyID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGlzRW1wdHkgPSBjaGVja0VtcHR5T3B0aW1pc3RpY2FsbHkoZWRpdG9yLmNoaWxkcmVuKTtcblxuICAgIHJldHVybiBpc0VtcHR5ID8gPGRpdiBzdHlsZT17c3R5bGVzLnBsYWNlaG9sZGVyfT57dmFsdWV9PC9kaXY+IDogbnVsbDtcbiAgfSwgW10pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzRGVmaW5lZChjYWNoZSkpIHtcbiAgICAgIGNvbnN0IHRpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY2FjaGUuY3VycmVudCA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoIWlzRm9yY2VVcGRhdGVkKSBmb3JjZVVwZGF0ZSgpO1xuICAgICAgfSwgQ0FDSEVfVFRMKTtcblxuICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChpc0RlZmluZWQoY2FjaGUpKSByZXR1cm4gY2FjaGUuY3VycmVudDtcblxuICBjYWNoZS5jdXJyZW50ID0gY3JlYXRlUGxhY2Vob2xkZXIoKTtcblxuICByZXR1cm4gY2FjaGUuY3VycmVudDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0ICh7IHZhbHVlIH0pID0+XG4gIGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ2VkaXRvci1wbGFjZWhvbGRlcicsXG4gICAgcmVuZGVyQ3VzdG9tOiAoZWRpdG9yKSA9PiAoXG4gICAgICA8RWRpdG9yUGxhY2Vob2xkZXJcbiAgICAgICAga2V5PVwiZWRpdG9yLXBsYWNlaG9sZGVyXCJcbiAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICBlZGl0b3I9e2VkaXRvcn1cbiAgICAgIC8+XG4gICAgKSxcbiAgfSk7XG4iLCJleHBvcnQgeyBkZWZhdWx0IGFzIGJvbGQgfSBmcm9tICcuL2JvbGQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpdGFsaWMgfSBmcm9tICcuL2l0YWxpYyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVuZGVybGluZSB9IGZyb20gJy4vdW5kZXJsaW5lJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbG9nZ2VyIH0gZnJvbSAnLi9sb2dnZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBidWxsZXRlZExpc3QgfSBmcm9tICcuL2J1bGxldGVkTGlzdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG51bWJlcmVkTGlzdCB9IGZyb20gJy4vbnVtYmVyZWRMaXN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbGlzdEl0ZW0gfSBmcm9tICcuL2xpc3RJdGVtJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWVudGlvbiB9IGZyb20gJy4vbWVudGlvbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGVkaXRvclBsYWNlaG9sZGVyIH0gZnJvbSAnLi9lZGl0b3JQbGFjZWhvbGRlcic7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlU2xhdGUgfSBmcm9tICdzbGF0ZS1yZWFjdCc7XG5pbXBvcnQge1xuICBjcmVhdGVQbHVnaW4sXG4gIGlzTWFya0FjdGl2ZSxcbiAgdG9nZ2xlTWFyayxcbiAgbWFrZVJlbmRlckxlYWYsXG4gIGFkZE1lc3NhZ2VMaXN0ZW5lcixcbiAgcG9zdE1lc3NhZ2UsXG59IGZyb20gJy4uL2hlbHBlcnMnO1xuaW1wb3J0IFRvb2xiYXIgZnJvbSAnLi4vY29tcG9uZW50cy9Ub29sYmFyJztcbmltcG9ydCBJY29uIGZyb20gJy4uL2NvbXBvbmVudHMvSWNvbic7XG5pbXBvcnQgeyBJVEFMSUMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5jb25zdCByZW5kZXJMZWFmID0gbWFrZVJlbmRlckxlYWYoSVRBTElDLCAoeyBjaGlsZHJlbiB9KSA9PiAoXG4gIDxlbT57Y2hpbGRyZW59PC9lbT5cbikpO1xuXG5jb25zdCBoYW5kbGVNZXNzYWdlID0gYWRkTWVzc2FnZUxpc3RlbmVyKElUQUxJQywgKHsgZWRpdG9yIH0pID0+IHtcbiAgdG9nZ2xlTWFyayhlZGl0b3IsIElUQUxJQyk7XG59KTtcblxuY29uc3QgVG9vbGJhckJ1dHRvbiA9ICgpID0+IHtcbiAgY29uc3QgZWRpdG9yID0gdXNlU2xhdGUoKTtcblxuICByZXR1cm4gKFxuICAgIDxUb29sYmFyLkJ1dHRvblxuICAgICAgYWN0aXZlPXtpc01hcmtBY3RpdmUoZWRpdG9yLCBJVEFMSUMpfVxuICAgICAgb25Nb3VzZURvd249eyhldmVudCkgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBwb3N0TWVzc2FnZShJVEFMSUMsIHt9LCBlZGl0b3IpO1xuICAgICAgfX1cbiAgICA+XG4gICAgICA8SWNvbj5mb3JtYXRfaXRhbGljPC9JY29uPlxuICAgIDwvVG9vbGJhci5CdXR0b24+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVQbHVnaW4oe1xuICBuYW1lOiBJVEFMSUMsXG4gIHJlbmRlckxlYWYsXG4gIGhhbmRsZU1lc3NhZ2UsXG4gIFRvb2xiYXJCdXR0b24sXG59KTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVQbHVnaW4sIG1ha2VSZW5kZXJFbGVtZW50IH0gZnJvbSAnLi4vaGVscGVycyc7XG5pbXBvcnQgeyBMSVNUX0lURU0gfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5jb25zdCByZW5kZXJFbGVtZW50ID0gbWFrZVJlbmRlckVsZW1lbnQoXG4gIExJU1RfSVRFTSxcbiAgKHsgYXR0cmlidXRlcywgY2hpbGRyZW4gfSkgPT4gPGxpIHsuLi5hdHRyaWJ1dGVzfT57Y2hpbGRyZW59PC9saT4sXG4pO1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVQbHVnaW4oe1xuICBuYW1lOiBMSVNUX0lURU0sXG4gIHJlbmRlckVsZW1lbnQsXG59KTtcbiIsImltcG9ydCB7IGNyZWF0ZVBsdWdpbiB9IGZyb20gJy4uL2hlbHBlcnMnO1xuXG5jb25zdCBuYW1lID0gJ2xvZ2dlcic7XG5cbmNvbnN0IGlzRW1wdHkgPSAob2JqZWN0KSA9PiBPYmplY3Qua2V5cyhvYmplY3QpLmxlbmd0aCA8IDE7XG5cbmNvbnN0IGhhbmRsZU1lc3NhZ2UgPSAoKSA9PiB7XG4gIGNvbnN0IGxpc3RlbmVyID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LmRhdGEudHlwZT8uc3RhcnRzV2l0aCgnQGhlcm8tZWRpdG9yJykpIHtcbiAgICAgIGNvbnN0IGdyb3VwTWV0aG9kID0gaXNFbXB0eShldmVudC5kYXRhLmRhdGEpID8gJ2dyb3VwQ29sbGFwc2VkJyA6ICdncm91cCc7XG4gICAgICBjb25zb2xlW2dyb3VwTWV0aG9kXShgJWMgJHtldmVudC5kYXRhLnR5cGV9IGAsICdjb2xvcjogbGltZWdyZWVuOycpO1xuICAgICAgY29uc29sZS5sb2coe1xuICAgICAgICBkYXRhOiBldmVudC5kYXRhLmRhdGEsXG4gICAgICAgIGV2ZW50LFxuICAgICAgfSk7XG4gICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgfVxuICB9O1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyKTtcbiAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlUGx1Z2luKHsgbmFtZSwgaGFuZGxlTWVzc2FnZSB9KTtcbiIsImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBFZGl0b3IsIFJhbmdlLCBUcmFuc2Zvcm1zIH0gZnJvbSAnc2xhdGUnO1xuaW1wb3J0IHsgdXNlU2xhdGUsIFJlYWN0RWRpdG9yIH0gZnJvbSAnc2xhdGUtcmVhY3QnO1xuaW1wb3J0IHtcbiAgY3JlYXRlUGx1Z2luLFxuICBtYWtlUmVuZGVyRWxlbWVudCxcbiAgYWRkTWVzc2FnZUxpc3RlbmVyLFxuICBwb3N0TWVzc2FnZSxcbn0gZnJvbSAnLi4vaGVscGVycyc7XG5pbXBvcnQgeyBNRU5USU9OLCBFRElUT1JfQ0hBTkdFIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuY29uc3QgTWVudGlvbkVsZW1lbnQgPSAoeyBhdHRyaWJ1dGVzLCBjaGlsZHJlbiwgZWxlbWVudCB9KSA9PiAoXG4gIDxzcGFuXG4gICAgey4uLmF0dHJpYnV0ZXN9XG4gICAgY29udGVudEVkaXRhYmxlPXtmYWxzZX1cbiAgICBzdHlsZT17eyBwYWRkaW5nOiAnMnB4IDRweCcsIGJhY2tncm91bmQ6ICdsYXZlbmRlcicsIGJvcmRlclJhZGl1czogNCB9fVxuICA+XG4gICAgQHtlbGVtZW50LmRhdGEubmFtZX1cbiAgICB7Y2hpbGRyZW59XG4gIDwvc3Bhbj5cbik7XG5cbmNvbnN0IHJlbmRlckVsZW1lbnQgPSBtYWtlUmVuZGVyRWxlbWVudChNRU5USU9OLCBNZW50aW9uRWxlbWVudCk7XG5cbmNvbnN0IGhhbmRsZU1lc3NhZ2UgPSAoZWRpdG9yKSA9PiB7XG4gIGNvbnN0IHJlbW92ZUVkaXRvckNoYW5nZUxpc3RlbmVyID0gYWRkTWVzc2FnZUxpc3RlbmVyKFxuICAgIEVESVRPUl9DSEFOR0UsXG4gICAgKHsgZWRpdG9yIH0pID0+IHtcbiAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBlZGl0b3I7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICBjb25zdCBbc3RhcnRdID0gUmFuZ2UuZWRnZXMoc2VsZWN0aW9uKTtcbiAgICAgICAgY29uc3Qgd29yZEJlZm9yZSA9IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBzdGFydCwgeyB1bml0OiAnd29yZCcgfSk7XG4gICAgICAgIGNvbnN0IGJlZm9yZSA9IHdvcmRCZWZvcmUgJiYgRWRpdG9yLmJlZm9yZShlZGl0b3IsIHdvcmRCZWZvcmUpO1xuICAgICAgICBjb25zdCBiZWZvcmVSYW5nZSA9IGJlZm9yZSAmJiBFZGl0b3IucmFuZ2UoZWRpdG9yLCBiZWZvcmUsIHN0YXJ0KTtcbiAgICAgICAgY29uc3QgYmVmb3JlVGV4dCA9IGJlZm9yZVJhbmdlICYmIEVkaXRvci5zdHJpbmcoZWRpdG9yLCBiZWZvcmVSYW5nZSk7XG4gICAgICAgIGNvbnN0IGJlZm9yZU1hdGNoID0gYmVmb3JlVGV4dCAmJiBiZWZvcmVUZXh0Lm1hdGNoKC9eQChcXHcrKSQvKTtcbiAgICAgICAgY29uc3QgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBzdGFydCk7XG4gICAgICAgIGNvbnN0IGFmdGVyUmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBzdGFydCwgYWZ0ZXIpO1xuICAgICAgICBjb25zdCBhZnRlclRleHQgPSBFZGl0b3Iuc3RyaW5nKGVkaXRvciwgYWZ0ZXJSYW5nZSk7XG4gICAgICAgIGNvbnN0IGFmdGVyTWF0Y2ggPSBhZnRlclRleHQubWF0Y2goL14oXFxzfCQpLyk7XG5cbiAgICAgICAgaWYgKGJlZm9yZU1hdGNoICYmIGFmdGVyTWF0Y2gpIHtcbiAgICAgICAgICBwb3N0TWVzc2FnZShcbiAgICAgICAgICAgICdtZW50aW9uLXNlYXJjaCcsXG4gICAgICAgICAgICB7IHRhcmdldDogYmVmb3JlUmFuZ2UsIHNlYXJjaDogYmVmb3JlTWF0Y2hbMV0gfSxcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvc3RNZXNzYWdlKCdtZW50aW9uLXNlYXJjaCcsIHsgdGFyZ2V0OiBudWxsLCBzZWFyY2g6ICcnIH0sIGVkaXRvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICApKGVkaXRvcik7XG5cbiAgY29uc3QgcmVtb3ZlTWVudGlvbkFwcGx5TGlzdGVuZXIgPSBhZGRNZXNzYWdlTGlzdGVuZXIoXG4gICAgJ21lbnRpb24tYXBwbHknLFxuICAgICh7IGVkaXRvciwgZGF0YSB9KSA9PiB7XG4gICAgICBjb25zdCB7IGlkLCBuYW1lLCBtZXRhIH0gPSBkYXRhO1xuICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBtZXRhLnRhcmdldCk7XG4gICAgICBjb25zdCBtZW50aW9uID0ge1xuICAgICAgICB0eXBlOiBNRU5USU9OLFxuICAgICAgICBkYXRhOiB7IGlkLCBuYW1lIH0sXG4gICAgICAgIGNoaWxkcmVuOiBbeyB0ZXh0OiAnJyB9XSxcbiAgICAgIH07XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbWVudGlvbik7XG4gICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yKTtcbiAgICB9LFxuICApKGVkaXRvcik7XG5cbiAgcmV0dXJuICgpID0+IHtcbiAgICByZW1vdmVFZGl0b3JDaGFuZ2VMaXN0ZW5lcigpO1xuICAgIHJlbW92ZU1lbnRpb25BcHBseUxpc3RlbmVyKCk7XG4gIH07XG59O1xuXG5jb25zdCBNZW50aW9uTGlzdFdyYXBwZXIgPSAoeyByZW5kZXJNZW50aW9uTGlzdCB9KSA9PiB7XG4gIGNvbnN0IFtzZWFyY2gsIHNldFNlYXJjaF0gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFt0YXJnZXQsIHNldFRhcmdldF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3Qgd3JhcHBlciA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgZWRpdG9yID0gdXNlU2xhdGUoKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHJlbW92ZU1lbnRpb25TZWFyY2hMaXN0ZW5lciA9IGFkZE1lc3NhZ2VMaXN0ZW5lcihcbiAgICAgICdtZW50aW9uLXNlYXJjaCcsXG4gICAgICAoeyBkYXRhIH0pID0+IHtcbiAgICAgICAgY29uc3Qgd3JhcHBlckVsID0gd3JhcHBlci5jdXJyZW50O1xuXG4gICAgICAgIGlmIChkYXRhLnRhcmdldCkge1xuICAgICAgICAgIGNvbnN0IGRvbVJhbmdlID0gUmVhY3RFZGl0b3IudG9ET01SYW5nZShlZGl0b3IsIGRhdGEudGFyZ2V0KTtcbiAgICAgICAgICBjb25zdCByYW5nZVJlY3QgPSBkb21SYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBjb25zdCBlZGl0b3JSZWN0ID0gd3JhcHBlckVsLnBhcmVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICB3cmFwcGVyRWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgd3JhcHBlckVsLnN0eWxlLnRvcCA9IGAke3JhbmdlUmVjdC50b3AgLSBlZGl0b3JSZWN0LnRvcCArIDIwfXB4YDtcbiAgICAgICAgICB3cmFwcGVyRWwuc3R5bGUubGVmdCA9IGAke3JhbmdlUmVjdC5sZWZ0IC0gZWRpdG9yUmVjdC5sZWZ0fXB4YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3cmFwcGVyRWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfVxuXG4gICAgICAgIHNldFNlYXJjaChkYXRhLnNlYXJjaCk7XG4gICAgICAgIHNldFRhcmdldChkYXRhLnRhcmdldCk7XG4gICAgICB9LFxuICAgICkoZWRpdG9yKTtcblxuICAgIHJldHVybiAoKSA9PiByZW1vdmVNZW50aW9uU2VhcmNoTGlzdGVuZXIoKTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiByZWY9e3dyYXBwZXJ9IHN0eWxlPXt7IHBvc2l0aW9uOiAnYWJzb2x1dGUnLCBkaXNwbGF5OiAnbm9uZScgfX0+XG4gICAgICB7cmVuZGVyTWVudGlvbkxpc3Qoc2VhcmNoLCAoeyBpZCwgbmFtZSB9KSA9PiB7XG4gICAgICAgIHBvc3RNZXNzYWdlKCdtZW50aW9uLWFwcGx5JywgeyBpZCwgbmFtZSwgbWV0YTogeyB0YXJnZXQgfSB9LCBlZGl0b3IpO1xuICAgICAgfSl9XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5jb25zdCBlbmhhbmNlRWRpdG9yID0gKGVkaXRvcikgPT4ge1xuICBjb25zdCB7IGlzSW5saW5lLCBpc1ZvaWQgfSA9IGVkaXRvcjtcblxuICBlZGl0b3IuaXNJbmxpbmUgPSAoZWxlbWVudCkgPT4ge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGUgPT09IE1FTlRJT04gPyB0cnVlIDogaXNJbmxpbmUoZWxlbWVudCk7XG4gIH07XG5cbiAgZWRpdG9yLmlzVm9pZCA9IChlbGVtZW50KSA9PiB7XG4gICAgcmV0dXJuIGVsZW1lbnQudHlwZSA9PT0gTUVOVElPTiA/IHRydWUgOiBpc1ZvaWQoZWxlbWVudCk7XG4gIH07XG5cbiAgcmV0dXJuIGVkaXRvcjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0ICh7IHJlbmRlck1lbnRpb25MaXN0IH0pID0+XG4gIGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogTUVOVElPTixcbiAgICByZW5kZXJFbGVtZW50LFxuICAgIHJlbmRlckN1c3RvbTogKCkgPT4gKFxuICAgICAgPE1lbnRpb25MaXN0V3JhcHBlciBrZXk9e01FTlRJT059IHJlbmRlck1lbnRpb25MaXN0PXtyZW5kZXJNZW50aW9uTGlzdH0gLz5cbiAgICApLFxuICAgIGhhbmRsZU1lc3NhZ2UsXG4gICAgZW5oYW5jZUVkaXRvcixcbiAgfSk7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgVHJhbnNmb3JtcyB9IGZyb20gJ3NsYXRlJztcbmltcG9ydCB7IHVzZVNsYXRlIH0gZnJvbSAnc2xhdGUtcmVhY3QnO1xuaW1wb3J0IHtcbiAgY3JlYXRlUGx1Z2luLFxuICBpc0Jsb2NrQWN0aXZlLFxuICBtYWtlUmVuZGVyRWxlbWVudCxcbiAgYWRkTWVzc2FnZUxpc3RlbmVyLFxuICBwb3N0TWVzc2FnZSxcbiAgaXNMaXN0LFxufSBmcm9tICcuLi9oZWxwZXJzJztcbmltcG9ydCBUb29sYmFyIGZyb20gJy4uL2NvbXBvbmVudHMvVG9vbGJhcic7XG5pbXBvcnQgSWNvbiBmcm9tICcuLi9jb21wb25lbnRzL0ljb24nO1xuaW1wb3J0IHsgTlVNQkVSRURfTElTVCwgTElTVF9JVEVNIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuY29uc3QgcmVuZGVyRWxlbWVudCA9IG1ha2VSZW5kZXJFbGVtZW50KFxuICBOVU1CRVJFRF9MSVNULFxuICAoeyBhdHRyaWJ1dGVzLCBjaGlsZHJlbiB9KSA9PiA8b2wgey4uLmF0dHJpYnV0ZXN9PntjaGlsZHJlbn08L29sPixcbik7XG5cbmNvbnN0IGhhbmRsZU1lc3NhZ2UgPSBhZGRNZXNzYWdlTGlzdGVuZXIoTlVNQkVSRURfTElTVCwgKHsgZWRpdG9yIH0pID0+IHtcbiAgY29uc3QgaXNBY3RpdmUgPSBpc0Jsb2NrQWN0aXZlKGVkaXRvciwgTlVNQkVSRURfTElTVCk7XG5cbiAgLy8gVW53cmFwIGFsbCB0aGUgaXRlbXMgb2YgYW55IGxpc3RcbiAgVHJhbnNmb3Jtcy51bndyYXBOb2RlcyhlZGl0b3IsIHtcbiAgICBtYXRjaDogaXNMaXN0LFxuICAgIHNwbGl0OiB0cnVlLFxuICB9KTtcblxuICBpZiAoaXNBY3RpdmUpIHtcbiAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwgeyB0eXBlOiAncGFyYWdyYXBoJyB9KTtcbiAgfSBlbHNlIHtcbiAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwgeyB0eXBlOiBMSVNUX0lURU0gfSk7XG4gICAgVHJhbnNmb3Jtcy53cmFwTm9kZXMoZWRpdG9yLCB7IHR5cGU6IE5VTUJFUkVEX0xJU1QsIGNoaWxkcmVuOiBbXSB9KTtcbiAgfVxufSk7XG5cbmNvbnN0IFRvb2xiYXJCdXR0b24gPSAoKSA9PiB7XG4gIGNvbnN0IGVkaXRvciA9IHVzZVNsYXRlKCk7XG5cbiAgcmV0dXJuIChcbiAgICA8VG9vbGJhci5CdXR0b25cbiAgICAgIGFjdGl2ZT17aXNCbG9ja0FjdGl2ZShlZGl0b3IsIE5VTUJFUkVEX0xJU1QpfVxuICAgICAgb25Nb3VzZURvd249eyhldmVudCkgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBwb3N0TWVzc2FnZShOVU1CRVJFRF9MSVNULCB7fSwgZWRpdG9yKTtcbiAgICAgIH19XG4gICAgPlxuICAgICAgPEljb24+Zm9ybWF0X2xpc3RfbnVtYmVyZWQ8L0ljb24+XG4gICAgPC9Ub29sYmFyLkJ1dHRvbj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVBsdWdpbih7XG4gIG5hbWU6IE5VTUJFUkVEX0xJU1QsXG4gIHJlbmRlckVsZW1lbnQsXG4gIGhhbmRsZU1lc3NhZ2UsXG4gIFRvb2xiYXJCdXR0b24sXG59KTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VTbGF0ZSB9IGZyb20gJ3NsYXRlLXJlYWN0JztcbmltcG9ydCB7XG4gIGNyZWF0ZVBsdWdpbixcbiAgaXNNYXJrQWN0aXZlLFxuICB0b2dnbGVNYXJrLFxuICBtYWtlUmVuZGVyTGVhZixcbiAgYWRkTWVzc2FnZUxpc3RlbmVyLFxuICBwb3N0TWVzc2FnZSxcbn0gZnJvbSAnLi4vaGVscGVycyc7XG5pbXBvcnQgVG9vbGJhciBmcm9tICcuLi9jb21wb25lbnRzL1Rvb2xiYXInO1xuaW1wb3J0IEljb24gZnJvbSAnLi4vY29tcG9uZW50cy9JY29uJztcbmltcG9ydCB7IFVOREVSTElORSB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNvbnN0IHJlbmRlckxlYWYgPSBtYWtlUmVuZGVyTGVhZihVTkRFUkxJTkUsICh7IGNoaWxkcmVuIH0pID0+IChcbiAgPHU+e2NoaWxkcmVufTwvdT5cbikpO1xuXG5jb25zdCBoYW5kbGVNZXNzYWdlID0gYWRkTWVzc2FnZUxpc3RlbmVyKFVOREVSTElORSwgKHsgZWRpdG9yIH0pID0+IHtcbiAgdG9nZ2xlTWFyayhlZGl0b3IsIFVOREVSTElORSk7XG59KTtcblxuY29uc3QgVG9vbGJhckJ1dHRvbiA9ICgpID0+IHtcbiAgY29uc3QgZWRpdG9yID0gdXNlU2xhdGUoKTtcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8VG9vbGJhci5CdXR0b25cbiAgICAgICAgYWN0aXZlPXtpc01hcmtBY3RpdmUoZWRpdG9yLCBVTkRFUkxJTkUpfVxuICAgICAgICBvbk1vdXNlRG93bj17KGV2ZW50KSA9PiB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBwb3N0TWVzc2FnZShVTkRFUkxJTkUsIHt9LCBlZGl0b3IpO1xuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICA8SWNvbj5mb3JtYXRfdW5kZXJsaW5lZDwvSWNvbj5cbiAgICAgIDwvVG9vbGJhci5CdXR0b24+XG4gICAgICA8VG9vbGJhci5TZXBhcmF0b3IgLz5cbiAgICA8Lz5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVBsdWdpbih7XG4gIG5hbWU6IFVOREVSTElORSxcbiAgcmVuZGVyTGVhZixcbiAgaGFuZGxlTWVzc2FnZSxcbiAgVG9vbGJhckJ1dHRvbixcbn0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX3JlYWN0X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX3JlYWN0X2RvbV9fOyJdLCJzb3VyY2VSb290IjoiIn0=