(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"), require("react-dom"));
	else if(typeof define === 'function' && define.amd)
		define(["react", "react-dom"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("react"), require("react-dom")) : factory(root["React"], root["ReactDOM"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function(__WEBPACK_EXTERNAL_MODULE_react__, __WEBPACK_EXTERNAL_MODULE_react_dom__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/lib.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/compute-scroll-into-view/es/index.js":
/*!************************************************************!*\
  !*** ../node_modules/compute-scroll-into-view/es/index.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function isElement(el) {
  return el != null && typeof el === 'object' && el.nodeType === 1;
}

function canOverflow(overflow, skipOverflowHiddenElements) {
  if (skipOverflowHiddenElements && overflow === 'hidden') {
    return false;
  }

  return overflow !== 'visible' && overflow !== 'clip';
}

function getFrameElement(el) {
  if (!el.ownerDocument || !el.ownerDocument.defaultView) {
    return null;
  }

  try {
    return el.ownerDocument.defaultView.frameElement;
  } catch (e) {
    return null;
  }
}

function isHiddenByFrame(el) {
  var frame = getFrameElement(el);

  if (!frame) {
    return false;
  }

  return frame.clientHeight < el.scrollHeight || frame.clientWidth < el.scrollWidth;
}

function isScrollable(el, skipOverflowHiddenElements) {
  if (el.clientHeight < el.scrollHeight || el.clientWidth < el.scrollWidth) {
    var style = getComputedStyle(el, null);
    return canOverflow(style.overflowY, skipOverflowHiddenElements) || canOverflow(style.overflowX, skipOverflowHiddenElements) || isHiddenByFrame(el);
  }

  return false;
}

function alignNearest(scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, scrollingBorderStart, scrollingBorderEnd, elementEdgeStart, elementEdgeEnd, elementSize) {
  if (elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd || elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd) {
    return 0;
  }

  if (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize || elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize) {
    return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart;
  }

  if (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize || elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize) {
    return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd;
  }

  return 0;
}

/* harmony default export */ __webpack_exports__["default"] = (function (target, options) {
  var scrollMode = options.scrollMode,
      block = options.block,
      inline = options.inline,
      boundary = options.boundary,
      skipOverflowHiddenElements = options.skipOverflowHiddenElements;
  var checkBoundary = typeof boundary === 'function' ? boundary : function (node) {
    return node !== boundary;
  };

  if (!isElement(target)) {
    throw new TypeError('Invalid target');
  }

  var scrollingElement = document.scrollingElement || document.documentElement;
  var frames = [];
  var cursor = target;

  while (isElement(cursor) && checkBoundary(cursor)) {
    cursor = cursor.parentNode;

    if (cursor === scrollingElement) {
      frames.push(cursor);
      break;
    }

    if (cursor === document.body && isScrollable(cursor) && !isScrollable(document.documentElement)) {
      continue;
    }

    if (isScrollable(cursor, skipOverflowHiddenElements)) {
      frames.push(cursor);
    }
  }

  var viewportWidth = window.visualViewport ? visualViewport.width : innerWidth;
  var viewportHeight = window.visualViewport ? visualViewport.height : innerHeight;
  var viewportX = window.scrollX || pageXOffset;
  var viewportY = window.scrollY || pageYOffset;

  var _target$getBoundingCl = target.getBoundingClientRect(),
      targetHeight = _target$getBoundingCl.height,
      targetWidth = _target$getBoundingCl.width,
      targetTop = _target$getBoundingCl.top,
      targetRight = _target$getBoundingCl.right,
      targetBottom = _target$getBoundingCl.bottom,
      targetLeft = _target$getBoundingCl.left;

  var targetBlock = block === 'start' || block === 'nearest' ? targetTop : block === 'end' ? targetBottom : targetTop + targetHeight / 2;
  var targetInline = inline === 'center' ? targetLeft + targetWidth / 2 : inline === 'end' ? targetRight : targetLeft;
  var computations = [];

  for (var index = 0; index < frames.length; index++) {
    var frame = frames[index];

    var _frame$getBoundingCli = frame.getBoundingClientRect(),
        height = _frame$getBoundingCli.height,
        width = _frame$getBoundingCli.width,
        top = _frame$getBoundingCli.top,
        right = _frame$getBoundingCli.right,
        bottom = _frame$getBoundingCli.bottom,
        left = _frame$getBoundingCli.left;

    if (scrollMode === 'if-needed' && targetTop >= 0 && targetLeft >= 0 && targetBottom <= viewportHeight && targetRight <= viewportWidth && targetTop >= top && targetBottom <= bottom && targetLeft >= left && targetRight <= right) {
      return computations;
    }

    var frameStyle = getComputedStyle(frame);
    var borderLeft = parseInt(frameStyle.borderLeftWidth, 10);
    var borderTop = parseInt(frameStyle.borderTopWidth, 10);
    var borderRight = parseInt(frameStyle.borderRightWidth, 10);
    var borderBottom = parseInt(frameStyle.borderBottomWidth, 10);
    var blockScroll = 0;
    var inlineScroll = 0;
    var scrollbarWidth = 'offsetWidth' in frame ? frame.offsetWidth - frame.clientWidth - borderLeft - borderRight : 0;
    var scrollbarHeight = 'offsetHeight' in frame ? frame.offsetHeight - frame.clientHeight - borderTop - borderBottom : 0;

    if (scrollingElement === frame) {
      if (block === 'start') {
        blockScroll = targetBlock;
      } else if (block === 'end') {
        blockScroll = targetBlock - viewportHeight;
      } else if (block === 'nearest') {
        blockScroll = alignNearest(viewportY, viewportY + viewportHeight, viewportHeight, borderTop, borderBottom, viewportY + targetBlock, viewportY + targetBlock + targetHeight, targetHeight);
      } else {
        blockScroll = targetBlock - viewportHeight / 2;
      }

      if (inline === 'start') {
        inlineScroll = targetInline;
      } else if (inline === 'center') {
        inlineScroll = targetInline - viewportWidth / 2;
      } else if (inline === 'end') {
        inlineScroll = targetInline - viewportWidth;
      } else {
        inlineScroll = alignNearest(viewportX, viewportX + viewportWidth, viewportWidth, borderLeft, borderRight, viewportX + targetInline, viewportX + targetInline + targetWidth, targetWidth);
      }

      blockScroll = Math.max(0, blockScroll + viewportY);
      inlineScroll = Math.max(0, inlineScroll + viewportX);
    } else {
      if (block === 'start') {
        blockScroll = targetBlock - top - borderTop;
      } else if (block === 'end') {
        blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight;
      } else if (block === 'nearest') {
        blockScroll = alignNearest(top, bottom, height, borderTop, borderBottom + scrollbarHeight, targetBlock, targetBlock + targetHeight, targetHeight);
      } else {
        blockScroll = targetBlock - (top + height / 2) + scrollbarHeight / 2;
      }

      if (inline === 'start') {
        inlineScroll = targetInline - left - borderLeft;
      } else if (inline === 'center') {
        inlineScroll = targetInline - (left + width / 2) + scrollbarWidth / 2;
      } else if (inline === 'end') {
        inlineScroll = targetInline - right + borderRight + scrollbarWidth;
      } else {
        inlineScroll = alignNearest(left, right, width, borderLeft, borderRight + scrollbarWidth, targetInline, targetInline + targetWidth, targetWidth);
      }

      var scrollLeft = frame.scrollLeft,
          scrollTop = frame.scrollTop;
      blockScroll = Math.max(0, Math.min(scrollTop + blockScroll, frame.scrollHeight - height + scrollbarHeight));
      inlineScroll = Math.max(0, Math.min(scrollLeft + inlineScroll, frame.scrollWidth - width + scrollbarWidth));
      targetBlock += scrollTop - blockScroll;
      targetInline += scrollLeft - inlineScroll;
    }

    computations.push({
      el: frame,
      top: blockScroll,
      left: inlineScroll
    });
  }

  return computations;
});

/***/ }),

/***/ "../node_modules/direction/index.js":
/*!******************************************!*\
  !*** ../node_modules/direction/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = direction

var RTL = '\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC'
var LTR =
  'A-Za-z\u00C0-\u00D6\u00D8-\u00F6' +
  '\u00F8-\u02B8\u0300-\u0590\u0800-\u1FFF\u200E\u2C00-\uFB1C' +
  '\uFE00-\uFE6F\uFEFD-\uFFFF'

var rtl = new RegExp('^[^' + LTR + ']*[' + RTL + ']')
var ltr = new RegExp('^[^' + RTL + ']*[' + LTR + ']')

function direction(value) {
  value = String(value || '')

  if (rtl.test(value)) {
    return 'rtl'
  }

  if (ltr.test(value)) {
    return 'ltr'
  }

  return 'neutral'
}


/***/ }),

/***/ "../node_modules/esrever/esrever.js":
/*!******************************************!*\
  !*** ../node_modules/esrever/esrever.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/esrever v0.2.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports =  true && exports;

	// Detect free variable `module`
	var freeModule =  true && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var regexSymbolWithCombiningMarks = /([\0-\u02FF\u0370-\u1AAF\u1B00-\u1DBF\u1E00-\u20CF\u2100-\uD7FF\uE000-\uFE1F\uFE30-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])([\u0300-\u036F\u1AB0-\u1AFF\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]+)/g;
	var regexSurrogatePair = /([\uD800-\uDBFF])([\uDC00-\uDFFF])/g;

	var reverse = function(string) {
		// Step 1: deal with combining marks and astral symbols (surrogate pairs)
		string = string
			// Swap symbols with their combining marks so the combining marks go first
			.replace(regexSymbolWithCombiningMarks, function($0, $1, $2) {
				// Reverse the combining marks so they will end up in the same order
				// later on (after another round of reversing)
				return reverse($2) + $1;
			})
			// Swap high and low surrogates so the low surrogates go first
			.replace(regexSurrogatePair, '$2$1');
		// Step 2: reverse the code units in the string
		var result = '';
		var index = string.length;
		while (index--) {
			result += string.charAt(index);
		}
		return result;
	};

	/*--------------------------------------------------------------------------*/

	var esrever = {
		'version': '0.2.0',
		'reverse': reverse
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return esrever;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}	else { var key; }

}(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "../node_modules/webpack/buildin/module.js")(module), __webpack_require__(/*! ./../webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/immer/dist/immer.module.js":
/*!**************************************************!*\
  !*** ../node_modules/immer/dist/immer.module.js ***!
  \**************************************************/
/*! exports provided: default, Immer, applyPatches, castDraft, castImmutable, createDraft, finishDraft, immerable, isDraft, isDraftable, nothing, original, produce, produceWithPatches, setAutoFreeze, setUseProxies */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Immer", function() { return Immer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyPatches", function() { return applyPatches$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "castDraft", function() { return castDraft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "castImmutable", function() { return castImmutable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createDraft", function() { return createDraft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "finishDraft", function() { return finishDraft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "immerable", function() { return DRAFTABLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDraft", function() { return isDraft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDraftable", function() { return isDraftable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nothing", function() { return NOTHING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "original", function() { return original; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "produce", function() { return produce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "produceWithPatches", function() { return produceWithPatches; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAutoFreeze", function() { return setAutoFreeze; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setUseProxies", function() { return setUseProxies; });
// Should be no imports here!
var _a; // SOme things that should be evaluated before all else...


var hasSymbol = typeof Symbol !== "undefined";
var hasMap = typeof Map !== "undefined";
var hasSet = typeof Set !== "undefined";
/**
 * The sentinel value returned by producers to replace the draft with undefined.
 */

var NOTHING = hasSymbol ? Symbol("immer-nothing") : (_a = {}, _a["immer-nothing"] = true, _a);
/**
 * To let Immer treat your class instances as plain immutable objects
 * (albeit with a custom prototype), you must define either an instance property
 * or a static property on each of your custom classes.
 *
 * Otherwise, your class instance will never be drafted, which means it won't be
 * safe to mutate in a produce callback.
 */

var DRAFTABLE = hasSymbol ? Symbol("immer-draftable") : "__$immer_draftable";
var DRAFT_STATE = hasSymbol ? Symbol("immer-state") : "__$immer_state";
var iteratorSymbol = hasSymbol ? Symbol.iterator : "@@iterator";

/* istanbul ignore next */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) { if (b.hasOwnProperty(p)) { d[p] = b[p]; } }
  };

  return extendStatics(d, b);
}; // Ugly hack to resolve #502 and inherit built in Map / Set


function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = ( // @ts-ignore
  __.prototype = b.prototype, new __());
}

var Archtype;

(function (Archtype) {
  Archtype[Archtype["Object"] = 0] = "Object";
  Archtype[Archtype["Array"] = 1] = "Array";
  Archtype[Archtype["Map"] = 2] = "Map";
  Archtype[Archtype["Set"] = 3] = "Set";
})(Archtype || (Archtype = {}));

var ProxyType;

(function (ProxyType) {
  ProxyType[ProxyType["ProxyObject"] = 0] = "ProxyObject";
  ProxyType[ProxyType["ProxyArray"] = 1] = "ProxyArray";
  ProxyType[ProxyType["ES5Object"] = 2] = "ES5Object";
  ProxyType[ProxyType["ES5Array"] = 3] = "ES5Array";
  ProxyType[ProxyType["Map"] = 4] = "Map";
  ProxyType[ProxyType["Set"] = 5] = "Set";
})(ProxyType || (ProxyType = {}));

/** Returns true if the given value is an Immer draft */

function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
/** Returns true if the given value can be drafted by Immer */

function isDraftable(value) {
  if (!value) { return false; }
  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE] || isMap(value) || isSet(value);
}
function isPlainObject(value) {
  if (!value || typeof value !== "object") { return false; }
  var proto = Object.getPrototypeOf(value);
  return !proto || proto === Object.prototype;
}
function original(value) {
  if (value && value[DRAFT_STATE]) {
    return value[DRAFT_STATE].base;
  } // otherwise return undefined

}
var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== "undefined" ? function (obj) {
  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
} :
/* istanbul ignore next */
Object.getOwnPropertyNames;
function each(obj, iter) {
  if (getArchtype(obj) === Archtype.Object) {
    ownKeys(obj).forEach(function (key) {
      return iter(key, obj[key], obj);
    });
  } else {
    obj.forEach(function (entry, index) {
      return iter(index, entry, obj);
    });
  }
}
function isEnumerable(base, prop) {
  var desc = Object.getOwnPropertyDescriptor(base, prop);
  return desc && desc.enumerable ? true : false;
}
function getArchtype(thing) {
  /* istanbul ignore next */
  if (!thing) { die(); }

  if (thing[DRAFT_STATE]) {
    switch (thing[DRAFT_STATE].type) {
      case ProxyType.ES5Object:
      case ProxyType.ProxyObject:
        return Archtype.Object;

      case ProxyType.ES5Array:
      case ProxyType.ProxyArray:
        return Archtype.Array;

      case ProxyType.Map:
        return Archtype.Map;

      case ProxyType.Set:
        return Archtype.Set;
    }
  }

  return Array.isArray(thing) ? Archtype.Array : isMap(thing) ? Archtype.Map : isSet(thing) ? Archtype.Set : Archtype.Object;
}
function has(thing, prop) {
  return getArchtype(thing) === Archtype.Map ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function get(thing, prop) {
  // @ts-ignore
  return getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop];
}
function set(thing, propOrOldValue, value) {
  switch (getArchtype(thing)) {
    case Archtype.Map:
      thing.set(propOrOldValue, value);
      break;

    case Archtype.Set:
      thing.delete(propOrOldValue);
      thing.add(value);
      break;

    default:
      thing[propOrOldValue] = value;
  }
}
function is(x, y) {
  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function isMap(target) {
  return hasMap && target instanceof Map;
}
function isSet(target) {
  return hasSet && target instanceof Set;
}
function latest(state) {
  return state.copy || state.base;
}
function shallowCopy(base, invokeGetters) {
  if (invokeGetters === void 0) {
    invokeGetters = false;
  }

  if (Array.isArray(base)) { return base.slice(); }
  var clone = Object.create(Object.getPrototypeOf(base));
  ownKeys(base).forEach(function (key) {
    if (key === DRAFT_STATE) {
      return; // Never copy over draft state.
    }

    var desc = Object.getOwnPropertyDescriptor(base, key);
    var value = desc.value;

    if (desc.get) {
      if (!invokeGetters) {
        throw new Error("Immer drafts cannot have computed properties");
      }

      value = desc.get.call(base);
    }

    if (desc.enumerable) {
      clone[key] = value;
    } else {
      Object.defineProperty(clone, key, {
        value: value,
        writable: true,
        configurable: true
      });
    }
  });
  return clone;
}
function freeze(obj, deep) {
  if (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) { return; }
  var type = getArchtype(obj);

  if (type === Archtype.Set) {
    obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
  } else if (type === Archtype.Map) {
    obj.set = obj.clear = obj.delete = dontMutateFrozenCollections;
  }

  Object.freeze(obj);
  if (deep) { each(obj, function (_, value) {
    return freeze(value, true);
  }); }
}

function dontMutateFrozenCollections() {
  throw new Error("This object has been frozen and should not be mutated");
}

function createHiddenProperty(target, prop, value) {
  Object.defineProperty(target, prop, {
    value: value,
    enumerable: false,
    writable: true
  });
}
/* istanbul ignore next */

function die() {
  throw new Error("Illegal state, please file a bug");
}

/** Each scope represents a `produce` call. */

var ImmerScope =
/** @class */
function () {
  function ImmerScope(parent, immer) {
    this.drafts = [];
    this.parent = parent;
    this.immer = immer; // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.

    this.canAutoFreeze = true;
  }

  ImmerScope.prototype.usePatches = function (patchListener) {
    if (patchListener) {
      this.patches = [];
      this.inversePatches = [];
      this.patchListener = patchListener;
    }
  };

  ImmerScope.prototype.revoke = function () {
    this.leave();
    this.drafts.forEach(revoke); // @ts-ignore

    this.drafts = null;
  };

  ImmerScope.prototype.leave = function () {
    if (this === ImmerScope.current) {
      ImmerScope.current = this.parent;
    }
  };

  ImmerScope.enter = function (immer) {
    var scope = new ImmerScope(ImmerScope.current, immer);
    ImmerScope.current = scope;
    return scope;
  };

  return ImmerScope;
}();

function revoke(draft) {
  var state = draft[DRAFT_STATE];
  if (state.type === ProxyType.ProxyObject || state.type === ProxyType.ProxyArray) { state.revoke(); }else { state.revoked = true; }
}

function processResult(immer, result, scope) {
  var baseDraft = scope.drafts[0];
  var isReplaced = result !== undefined && result !== baseDraft;
  immer.willFinalize(scope, result, isReplaced);

  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified) {
      scope.revoke();
      throw new Error("An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft."); // prettier-ignore
    }

    if (isDraftable(result)) {
      // Finalize the result in case it contains (or is) a subset of the draft.
      result = finalize(immer, result, scope);
      if (!scope.parent) { maybeFreeze(immer, result); }
    }

    if (scope.patches) {
      scope.patches.push({
        op: "replace",
        path: [],
        value: result
      });
      scope.inversePatches.push({
        op: "replace",
        path: [],
        value: baseDraft[DRAFT_STATE].base
      });
    }
  } else {
    // Finalize the base draft.
    result = finalize(immer, baseDraft, scope, []);
  }

  scope.revoke();

  if (scope.patches) {
    scope.patchListener(scope.patches, scope.inversePatches);
  }

  return result !== NOTHING ? result : undefined;
}

function finalize(immer, draft, scope, path) {
  var state = draft[DRAFT_STATE];

  if (!state) {
    if (Object.isFrozen(draft)) { return draft; }
    return finalizeTree(immer, draft, scope);
  } // Never finalize drafts owned by another scope.


  if (state.scope !== scope) {
    return draft;
  }

  if (!state.modified) {
    maybeFreeze(immer, state.base, true);
    return state.base;
  }

  if (!state.finalized) {
    state.finalized = true;
    finalizeTree(immer, state.draft, scope, path); // We cannot really delete anything inside of a Set. We can only replace the whole Set.

    if (immer.onDelete && state.type !== ProxyType.Set) {
      // The `assigned` object is unreliable with ES5 drafts.
      if (immer.useProxies) {
        var assigned = state.assigned;
        each(assigned, function (prop, exists) {
          if (!exists) { immer.onDelete(state, prop); }
        });
      } else {
        var base = state.base,
            copy_1 = state.copy;
        each(base, function (prop) {
          if (!has(copy_1, prop)) { immer.onDelete(state, prop); }
        });
      }
    }

    if (immer.onCopy) {
      immer.onCopy(state);
    } // At this point, all descendants of `state.copy` have been finalized,
    // so we can be sure that `scope.canAutoFreeze` is accurate.


    if (immer.autoFreeze && scope.canAutoFreeze) {
      freeze(state.copy, false);
    }

    if (path && scope.patches) {
      generatePatches(state, path, scope.patches, scope.inversePatches);
    }
  }

  return state.copy;
}

function finalizeTree(immer, root, scope, rootPath) {
  var state = root[DRAFT_STATE];

  if (state) {
    if (state.type === ProxyType.ES5Object || state.type === ProxyType.ES5Array) {
      // Create the final copy, with added keys and without deleted keys.
      state.copy = shallowCopy(state.draft, true);
    }

    root = state.copy;
  }

  each(root, function (key, value) {
    return finalizeProperty(immer, scope, root, state, root, key, value, rootPath);
  });
  return root;
}

function finalizeProperty(immer, scope, root, rootState, parentValue, prop, childValue, rootPath) {
  if (childValue === parentValue) {
    throw Error("Immer forbids circular references");
  } // In the `finalizeTree` method, only the `root` object may be a draft.


  var isDraftProp = !!rootState && parentValue === root;
  var isSetMember = isSet(parentValue);

  if (isDraft(childValue)) {
    var path = rootPath && isDraftProp && !isSetMember && // Set objects are atomic since they have no keys.
    !has(rootState.assigned, prop) // Skip deep patches for assigned keys.
    ? rootPath.concat(prop) : undefined; // Drafts owned by `scope` are finalized here.

    childValue = finalize(immer, childValue, scope, path);
    set(parentValue, prop, childValue); // Drafts from another scope must prevent auto-freezing.

    if (isDraft(childValue)) {
      scope.canAutoFreeze = false;
    }
  } // Unchanged draft properties are ignored.
  else if (isDraftProp && is(childValue, get(rootState.base, prop))) {
      return;
    } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.
    // TODO: the recursion over here looks weird, shouldn't non-draft stuff have it's own recursion?
    // especially the passing on of root and rootState doesn't make sense...
    else if (isDraftable(childValue)) {
        each(childValue, function (key, grandChild) {
          return finalizeProperty(immer, scope, root, rootState, childValue, key, grandChild, rootPath);
        });
        if (!scope.parent) { maybeFreeze(immer, childValue); }
      }

  if (isDraftProp && immer.onAssign && !isSetMember) {
    immer.onAssign(rootState, prop, childValue);
  }
}

function maybeFreeze(immer, value, deep) {
  if (deep === void 0) {
    deep = false;
  }

  if (immer.autoFreeze && !isDraft(value)) {
    freeze(value, deep);
  }
}

/**
 * Returns a new draft of the `base` object.
 *
 * The second argument is the parent draft-state (used internally).
 */

function createProxy(base, parent) {
  var isArray = Array.isArray(base);
  var state = {
    type: isArray ? ProxyType.ProxyArray : ProxyType.ProxyObject,
    // Track which produce call this is associated with.
    scope: parent ? parent.scope : ImmerScope.current,
    // True for both shallow and deep changes.
    modified: false,
    // Used during finalization.
    finalized: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned: {},
    // The parent draft state.
    parent: parent,
    // The base state.
    base: base,
    // The base proxy.
    draft: null,
    // Any property proxies.
    drafts: {},
    // The base copy with any updated values.
    copy: null,
    // Called by the `produce` function.
    revoke: null,
    isManual: false
  }; // the traps must target something, a bit like the 'real' base.
  // but also, we need to be able to determine from the target what the relevant state is
  // (to avoid creating traps per instance to capture the state in closure,
  // and to avoid creating weird hidden properties as well)
  // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)
  // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb

  var target = state;
  var traps = objectTraps;

  if (isArray) {
    target = [state];
    traps = arrayTraps;
  } // TODO: optimization: might be faster, cheaper if we created a non-revocable proxy
  // and administrate revoking ourselves


  var _a = Proxy.revocable(target, traps),
      revoke = _a.revoke,
      proxy = _a.proxy;

  state.draft = proxy;
  state.revoke = revoke;
  return proxy;
}
/**
 * Object drafts
 */

var objectTraps = {
  get: function (state, prop) {
    if (prop === DRAFT_STATE) { return state; }
    var drafts = state.drafts; // Check for existing draft in unmodified state.

    if (!state.modified && has(drafts, prop)) {
      return drafts[prop];
    }

    var value = latest(state)[prop];

    if (state.finalized || !isDraftable(value)) {
      return value;
    } // Check for existing draft in modified state.


    if (state.modified) {
      // Assigned values are never drafted. This catches any drafts we created, too.
      if (value !== peek(state.base, prop)) { return value; } // Store drafts on the copy (when one exists).
      // @ts-ignore

      drafts = state.copy;
    }

    return drafts[prop] = state.scope.immer.createProxy(value, state);
  },
  has: function (state, prop) {
    return prop in latest(state);
  },
  ownKeys: function (state) {
    return Reflect.ownKeys(latest(state));
  },
  set: function (state, prop
  /* strictly not, but helps TS */
  , value) {
    if (!state.modified) {
      var baseValue = peek(state.base, prop); // Optimize based on value's truthiness. Truthy values are guaranteed to
      // never be undefined, so we can avoid the `in` operator. Lastly, truthy
      // values may be drafts, but falsy values are never drafts.

      var isUnchanged = value ? is(baseValue, value) || value === state.drafts[prop] : is(baseValue, value) && prop in state.base;
      if (isUnchanged) { return true; }
      prepareCopy(state);
      markChanged(state);
    }

    state.assigned[prop] = true; // @ts-ignore

    state.copy[prop] = value;
    return true;
  },
  deleteProperty: function (state, prop) {
    // The `undefined` check is a fast path for pre-existing keys.
    if (peek(state.base, prop) !== undefined || prop in state.base) {
      state.assigned[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else if (state.assigned[prop]) {
      // if an originally not assigned property was deleted
      delete state.assigned[prop];
    } // @ts-ignore


    if (state.copy) { delete state.copy[prop]; }
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor: function (state, prop) {
    var owner = latest(state);
    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);

    if (desc) {
      desc.writable = true;
      desc.configurable = state.type !== ProxyType.ProxyArray || prop !== "length";
    }

    return desc;
  },
  defineProperty: function () {
    throw new Error("Object.defineProperty() cannot be used on an Immer draft"); // prettier-ignore
  },
  getPrototypeOf: function (state) {
    return Object.getPrototypeOf(state.base);
  },
  setPrototypeOf: function () {
    throw new Error("Object.setPrototypeOf() cannot be used on an Immer draft"); // prettier-ignore
  }
};
/**
 * Array drafts
 */

var arrayTraps = {};
each(objectTraps, function (key, fn) {
  // @ts-ignore
  arrayTraps[key] = function () {
    arguments[0] = arguments[0][0];
    return fn.apply(this, arguments);
  };
});

arrayTraps.deleteProperty = function (state, prop) {
  if (isNaN(parseInt(prop))) {
    throw new Error("Immer only supports deleting array indices"); // prettier-ignore
  }

  return objectTraps.deleteProperty.call(this, state[0], prop);
};

arrayTraps.set = function (state, prop, value) {
  if (prop !== "length" && isNaN(parseInt(prop))) {
    throw new Error("Immer only supports setting array indices and the 'length' property"); // prettier-ignore
  }

  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
/**
 * Map drafts
 */
// Access a property without creating an Immer draft.


function peek(draft, prop) {
  var state = draft[DRAFT_STATE];
  var desc = Reflect.getOwnPropertyDescriptor(state ? latest(state) : draft, prop);
  return desc && desc.value;
}

function markChanged(state) {
  if (!state.modified) {
    state.modified = true;

    if (state.type === ProxyType.ProxyObject || state.type === ProxyType.ProxyArray) {
      var copy_1 = state.copy = shallowCopy(state.base);
      each(state.drafts, function (key, value) {
        // @ts-ignore
        copy_1[key] = value;
      });
      state.drafts = undefined;
    }

    if (state.parent) {
      markChanged(state.parent);
    }
  }
}

function prepareCopy(state) {
  if (!state.copy) {
    state.copy = shallowCopy(state.base);
  }
}

function willFinalizeES5(scope, result, isReplaced) {
  scope.drafts.forEach(function (draft) {
    draft[DRAFT_STATE].finalizing = true;
  });

  if (!isReplaced) {
    if (scope.patches) {
      markChangesRecursively(scope.drafts[0]);
    } // This is faster when we don't care about which attributes changed.


    markChangesSweep(scope.drafts);
  } // When a child draft is returned, look for changes.
  else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {
      markChangesSweep(scope.drafts);
    }
}
function createES5Proxy(base, parent) {
  var isArray = Array.isArray(base);
  var draft = clonePotentialDraft(base);
  each(draft, function (prop) {
    proxyProperty(draft, prop, isArray || isEnumerable(base, prop));
  });
  var state = {
    type: isArray ? ProxyType.ES5Array : ProxyType.ES5Object,
    scope: parent ? parent.scope : ImmerScope.current,
    modified: false,
    finalizing: false,
    finalized: false,
    assigned: {},
    parent: parent,
    base: base,
    draft: draft,
    copy: null,
    revoked: false,
    isManual: false
  };
  createHiddenProperty(draft, DRAFT_STATE, state);
  return draft;
} // Access a property without creating an Immer draft.

function peek$1(draft, prop) {
  var state = draft[DRAFT_STATE];

  if (state && !state.finalizing) {
    state.finalizing = true;
    var value = draft[prop];
    state.finalizing = false;
    return value;
  }

  return draft[prop];
}

function get$1(state, prop) {
  assertUnrevoked(state);
  var value = peek$1(latest(state), prop);
  if (state.finalizing) { return value; } // Create a draft if the value is unmodified.

  if (value === peek$1(state.base, prop) && isDraftable(value)) {
    prepareCopy$1(state); // @ts-ignore

    return state.copy[prop] = state.scope.immer.createProxy(value, state);
  }

  return value;
}

function set$1(state, prop, value) {
  assertUnrevoked(state);
  state.assigned[prop] = true;

  if (!state.modified) {
    if (is(value, peek$1(latest(state), prop))) { return; }
    markChangedES5(state);
    prepareCopy$1(state);
  } // @ts-ignore


  state.copy[prop] = value;
}

function markChangedES5(state) {
  if (!state.modified) {
    state.modified = true;
    if (state.parent) { markChangedES5(state.parent); }
  }
}

function prepareCopy$1(state) {
  if (!state.copy) { state.copy = clonePotentialDraft(state.base); }
}

function clonePotentialDraft(base) {
  var state = base && base[DRAFT_STATE];

  if (state) {
    state.finalizing = true;
    var draft = shallowCopy(state.draft, true);
    state.finalizing = false;
    return draft;
  }

  return shallowCopy(base);
} // property descriptors are recycled to make sure we don't create a get and set closure per property,
// but share them all instead


var descriptors = {};

function proxyProperty(draft, prop, enumerable) {
  var desc = descriptors[prop];

  if (desc) {
    desc.enumerable = enumerable;
  } else {
    descriptors[prop] = desc = {
      configurable: true,
      enumerable: enumerable,
      get: function () {
        return get$1(this[DRAFT_STATE], prop);
      },
      set: function (value) {
        set$1(this[DRAFT_STATE], prop, value);
      }
    };
  }

  Object.defineProperty(draft, prop, desc);
}

function assertUnrevoked(state) {
  if (state.revoked === true) { throw new Error("Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + JSON.stringify(latest(state))); }
} // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.

function markChangesSweep(drafts) {
  // The natural order of drafts in the `scope` array is based on when they
  // were accessed. By processing drafts in reverse natural order, we have a
  // better chance of processing leaf nodes first. When a leaf node is known to
  // have changed, we can avoid any traversal of its ancestor nodes.
  for (var i = drafts.length - 1; i >= 0; i--) {
    var state = drafts[i][DRAFT_STATE];

    if (!state.modified) {
      switch (state.type) {
        case ProxyType.ES5Array:
          if (hasArrayChanges(state)) { markChangedES5(state); }
          break;

        case ProxyType.ES5Object:
          if (hasObjectChanges(state)) { markChangedES5(state); }
          break;
      }
    }
  }
}

function markChangesRecursively(object) {
  if (!object || typeof object !== "object") { return; }
  var state = object[DRAFT_STATE];
  if (!state) { return; }
  var base = state.base,
      draft = state.draft,
      assigned = state.assigned,
      type = state.type;

  if (type === ProxyType.ES5Object) {
    // Look for added keys.
    // TODO: looks quite duplicate to hasObjectChanges,
    // probably there is a faster way to detect changes, as sweep + recurse seems to do some
    // unnecessary work.
    // also: probably we can store the information we detect here, to speed up tree finalization!
    each(draft, function (key) {
      if (key === DRAFT_STATE) { return; } // The `undefined` check is a fast path for pre-existing keys.

      if (base[key] === undefined && !has(base, key)) {
        assigned[key] = true;
        markChangedES5(state);
      } else if (!assigned[key]) {
        // Only untouched properties trigger recursion.
        markChangesRecursively(draft[key]);
      }
    }); // Look for removed keys.

    each(base, function (key) {
      // The `undefined` check is a fast path for pre-existing keys.
      if (draft[key] === undefined && !has(draft, key)) {
        assigned[key] = false;
        markChangedES5(state);
      }
    });
  } else if (type === ProxyType.ES5Array) {
    if (hasArrayChanges(state)) {
      markChangedES5(state);
      assigned.length = true;
    }

    if (draft.length < base.length) {
      for (var i = draft.length; i < base.length; i++) { assigned[i] = false; }
    } else {
      for (var i = base.length; i < draft.length; i++) { assigned[i] = true; }
    } // Minimum count is enough, the other parts has been processed.


    var min = Math.min(draft.length, base.length);

    for (var i = 0; i < min; i++) {
      // Only untouched indices trigger recursion.
      if (assigned[i] === undefined) { markChangesRecursively(draft[i]); }
    }
  }
}

function hasObjectChanges(state) {
  var base = state.base,
      draft = state.draft; // Search for added keys and changed keys. Start at the back, because
  // non-numeric keys are ordered by time of definition on the object.

  var keys = Object.keys(draft);

  for (var i = keys.length - 1; i >= 0; i--) {
    var key = keys[i];
    var baseValue = base[key]; // The `undefined` check is a fast path for pre-existing keys.

    if (baseValue === undefined && !has(base, key)) {
      return true;
    } // Once a base key is deleted, future changes go undetected, because its
    // descriptor is erased. This branch detects any missed changes.
    else {
        var value = draft[key];
        var state_1 = value && value[DRAFT_STATE];

        if (state_1 ? state_1.base !== baseValue : !is(value, baseValue)) {
          return true;
        }
      }
  } // At this point, no keys were added or changed.
  // Compare key count to determine if keys were deleted.


  return keys.length !== Object.keys(base).length;
}

function hasArrayChanges(state) {
  var draft = state.draft;
  if (draft.length !== state.base.length) { return true; } // See #116
  // If we first shorten the length, our array interceptors will be removed.
  // If after that new items are added, result in the same original length,
  // those last items will have no intercepting property.
  // So if there is no own descriptor on the last position, we know that items were removed and added
  // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check
  // the last one

  var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)

  if (descriptor && !descriptor.get) { return true; } // For all other cases, we don't have to compare, as they would have been picked up by the index setters

  return false;
}

var DraftMap = function (_super) {
  if (!_super) {
    /* istanbul ignore next */
    throw new Error("Map is not polyfilled");
  }

  __extends(DraftMap, _super); // Create class manually, cause #502


  function DraftMap(target, parent) {
    this[DRAFT_STATE] = {
      type: ProxyType.Map,
      parent: parent,
      scope: parent ? parent.scope : ImmerScope.current,
      modified: false,
      finalized: false,
      copy: undefined,
      assigned: undefined,
      base: target,
      draft: this,
      isManual: false,
      revoked: false
    };
    return this;
  }

  var p = DraftMap.prototype; // TODO: smaller build size if we create a util for Object.defineProperty

  Object.defineProperty(p, "size", {
    get: function () {
      return latest(this[DRAFT_STATE]).size;
    },
    enumerable: true,
    configurable: true
  });

  p.has = function (key) {
    return latest(this[DRAFT_STATE]).has(key);
  };

  p.set = function (key, value) {
    var state = this[DRAFT_STATE];
    assertUnrevoked(state);

    if (latest(state).get(key) !== value) {
      prepareCopy$2(state);
      state.scope.immer.markChanged(state);
      state.assigned.set(key, true);
      state.copy.set(key, value);
      state.assigned.set(key, true);
    }

    return this;
  };

  p.delete = function (key) {
    if (!this.has(key)) {
      return false;
    }

    var state = this[DRAFT_STATE];
    assertUnrevoked(state);
    prepareCopy$2(state);
    state.scope.immer.markChanged(state);
    state.assigned.set(key, false);
    state.copy.delete(key);
    return true;
  };

  p.clear = function () {
    var state = this[DRAFT_STATE];
    assertUnrevoked(state);
    prepareCopy$2(state);
    state.scope.immer.markChanged(state);
    state.assigned = new Map();
    return state.copy.clear();
  };

  p.forEach = function (cb, thisArg) {
    var _this = this;

    var state = this[DRAFT_STATE];
    latest(state).forEach(function (_value, key, _map) {
      cb.call(thisArg, _this.get(key), key, _this);
    });
  };

  p.get = function (key) {
    var state = this[DRAFT_STATE];
    assertUnrevoked(state);
    var value = latest(state).get(key);

    if (state.finalized || !isDraftable(value)) {
      return value;
    }

    if (value !== state.base.get(key)) {
      return value; // either already drafted or reassigned
    } // despite what it looks, this creates a draft only once, see above condition


    var draft = state.scope.immer.createProxy(value, state);
    prepareCopy$2(state);
    state.copy.set(key, draft);
    return draft;
  };

  p.keys = function () {
    return latest(this[DRAFT_STATE]).keys();
  };

  p.values = function () {
    var _a;

    var _this = this;

    var iterator = this.keys();
    return _a = {}, _a[iteratorSymbol] = function () {
      return _this.values();
    }, _a.next = function () {
      var r = iterator.next();
      /* istanbul ignore next */

      if (r.done) { return r; }

      var value = _this.get(r.value);

      return {
        done: false,
        value: value
      };
    }, _a;
  };

  p.entries = function () {
    var _a;

    var _this = this;

    var iterator = this.keys();
    return _a = {}, _a[iteratorSymbol] = function () {
      return _this.entries();
    }, _a.next = function () {
      var r = iterator.next();
      /* istanbul ignore next */

      if (r.done) { return r; }

      var value = _this.get(r.value);

      return {
        done: false,
        value: [r.value, value]
      };
    }, _a;
  };

  p[iteratorSymbol] = function () {
    return this.entries();
  };

  return DraftMap;
}(Map);

function proxyMap(target, parent) {
  // @ts-ignore
  return new DraftMap(target, parent);
}

function prepareCopy$2(state) {
  if (!state.copy) {
    state.assigned = new Map();
    state.copy = new Map(state.base);
  }
}

var DraftSet = function (_super) {
  if (!_super) {
    /* istanbul ignore next */
    throw new Error("Set is not polyfilled");
  }

  __extends(DraftSet, _super); // Create class manually, cause #502


  function DraftSet(target, parent) {
    this[DRAFT_STATE] = {
      type: ProxyType.Set,
      parent: parent,
      scope: parent ? parent.scope : ImmerScope.current,
      modified: false,
      finalized: false,
      copy: undefined,
      base: target,
      draft: this,
      drafts: new Map(),
      revoked: false,
      isManual: false
    };
    return this;
  }

  var p = DraftSet.prototype;
  Object.defineProperty(p, "size", {
    get: function () {
      return latest(this[DRAFT_STATE]).size;
    },
    enumerable: true,
    configurable: true
  });

  p.has = function (value) {
    var state = this[DRAFT_STATE];
    assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value

    if (!state.copy) {
      return state.base.has(value);
    }

    if (state.copy.has(value)) { return true; }
    if (state.drafts.has(value) && state.copy.has(state.drafts.get(value))) { return true; }
    return false;
  };

  p.add = function (value) {
    var state = this[DRAFT_STATE];
    assertUnrevoked(state);

    if (state.copy) {
      state.copy.add(value);
    } else if (!state.base.has(value)) {
      prepareCopy$3(state);
      state.scope.immer.markChanged(state);
      state.copy.add(value);
    }

    return this;
  };

  p.delete = function (value) {
    if (!this.has(value)) {
      return false;
    }

    var state = this[DRAFT_STATE];
    assertUnrevoked(state);
    prepareCopy$3(state);
    state.scope.immer.markChanged(state);
    return state.copy.delete(value) || (state.drafts.has(value) ? state.copy.delete(state.drafts.get(value)) :
    /* istanbul ignore next */
    false);
  };

  p.clear = function () {
    var state = this[DRAFT_STATE];
    assertUnrevoked(state);
    prepareCopy$3(state);
    state.scope.immer.markChanged(state);
    return state.copy.clear();
  };

  p.values = function () {
    var state = this[DRAFT_STATE];
    assertUnrevoked(state);
    prepareCopy$3(state);
    return state.copy.values();
  };

  p.entries = function entries() {
    var state = this[DRAFT_STATE];
    assertUnrevoked(state);
    prepareCopy$3(state);
    return state.copy.entries();
  };

  p.keys = function () {
    return this.values();
  };

  p[iteratorSymbol] = function () {
    return this.values();
  };

  p.forEach = function forEach(cb, thisArg) {
    var iterator = this.values();
    var result = iterator.next();

    while (!result.done) {
      cb.call(thisArg, result.value, result.value, this);
      result = iterator.next();
    }
  };

  return DraftSet;
}(Set);

function proxySet(target, parent) {
  // @ts-ignore
  return new DraftSet(target, parent);
}

function prepareCopy$3(state) {
  if (!state.copy) {
    // create drafts for all entries to preserve insertion order
    state.copy = new Set();
    state.base.forEach(function (value) {
      if (isDraftable(value)) {
        var draft = state.scope.immer.createProxy(value, state);
        state.drafts.set(value, draft);
        state.copy.add(draft);
      } else {
        state.copy.add(value);
      }
    });
  }
}

function generatePatches(state, basePath, patches, inversePatches) {
  switch (state.type) {
    case ProxyType.ProxyObject:
    case ProxyType.ES5Object:
    case ProxyType.Map:
      return generatePatchesFromAssigned(state, basePath, patches, inversePatches);

    case ProxyType.ES5Array:
    case ProxyType.ProxyArray:
      return generateArrayPatches(state, basePath, patches, inversePatches);

    case ProxyType.Set:
      return generateSetPatches(state, basePath, patches, inversePatches);
  }
}

function generateArrayPatches(state, basePath, patches, inversePatches) {
  var _a, _b;

  var base = state.base,
      assigned = state.assigned,
      copy = state.copy;
  /* istanbul ignore next */

  if (!copy) { die(); } // Reduce complexity by ensuring `base` is never longer.

  if (copy.length < base.length) {
    _a = [copy, base], base = _a[0], copy = _a[1];
    _b = [inversePatches, patches], patches = _b[0], inversePatches = _b[1];
  }

  var delta = copy.length - base.length; // Find the first replaced index.

  var start = 0;

  while (base[start] === copy[start] && start < base.length) {
    ++start;
  } // Find the last replaced index. Search from the end to optimize splice patches.


  var end = base.length;

  while (end > start && base[end - 1] === copy[end + delta - 1]) {
    --end;
  } // Process replaced indices.


  for (var i = start; i < end; ++i) {
    if (assigned[i] && copy[i] !== base[i]) {
      var path = basePath.concat([i]);
      patches.push({
        op: "replace",
        path: path,
        value: copy[i]
      });
      inversePatches.push({
        op: "replace",
        path: path,
        value: base[i]
      });
    }
  }

  var replaceCount = patches.length; // Process added indices.

  for (var i = end + delta - 1; i >= end; --i) {
    var path = basePath.concat([i]);
    patches[replaceCount + i - end] = {
      op: "add",
      path: path,
      value: copy[i]
    };
    inversePatches.push({
      op: "remove",
      path: path
    });
  }
} // This is used for both Map objects and normal objects.


function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
  var base = state.base,
      copy = state.copy;
  each(state.assigned, function (key, assignedValue) {
    var origValue = get(base, key);
    var value = get(copy, key);
    var op = !assignedValue ? "remove" : has(base, key) ? "replace" : "add";
    if (origValue === value && op === "replace") { return; }
    var path = basePath.concat(key);
    patches.push(op === "remove" ? {
      op: op,
      path: path
    } : {
      op: op,
      path: path,
      value: value
    });
    inversePatches.push(op === "add" ? {
      op: "remove",
      path: path
    } : op === "remove" ? {
      op: "add",
      path: path,
      value: origValue
    } : {
      op: "replace",
      path: path,
      value: origValue
    });
  });
}

function generateSetPatches(state, basePath, patches, inversePatches) {
  var base = state.base,
      copy = state.copy;
  var i = 0;
  base.forEach(function (value) {
    if (!copy.has(value)) {
      var path = basePath.concat([i]);
      patches.push({
        op: "remove",
        path: path,
        value: value
      });
      inversePatches.unshift({
        op: "add",
        path: path,
        value: value
      });
    }

    i++;
  });
  i = 0;
  copy.forEach(function (value) {
    if (!base.has(value)) {
      var path = basePath.concat([i]);
      patches.push({
        op: "add",
        path: path,
        value: value
      });
      inversePatches.unshift({
        op: "remove",
        path: path,
        value: value
      });
    }

    i++;
  });
}

function applyPatches(draft, patches) {
  patches.forEach(function (patch) {
    var path = patch.path,
        op = patch.op;
    /* istanbul ignore next */

    if (!path.length) { die(); }
    var base = draft;

    for (var i = 0; i < path.length - 1; i++) {
      base = get(base, path[i]);
      if (!base || typeof base !== "object") { throw new Error("Cannot apply patch, path doesn't resolve: " + path.join("/")); } // prettier-ignore
    }

    var type = getArchtype(base);
    var value = deepClonePatchValue(patch.value); // used to clone patch to ensure original patch is not modified, see #411

    var key = path[path.length - 1];

    switch (op) {
      case "replace":
        switch (type) {
          case Archtype.Map:
            return base.set(key, value);

          /* istanbul ignore next */

          case Archtype.Set:
            throw new Error('Sets cannot have "replace" patches.');

          default:
            // if value is an object, then it's assigned by reference
            // in the following add or remove ops, the value field inside the patch will also be modifyed
            // so we use value from the cloned patch
            // @ts-ignore
            return base[key] = value;
        }

      case "add":
        switch (type) {
          case Archtype.Array:
            return base.splice(key, 0, value);

          case Archtype.Map:
            return base.set(key, value);

          case Archtype.Set:
            return base.add(value);

          default:
            return base[key] = value;
        }

      case "remove":
        switch (type) {
          case Archtype.Array:
            return base.splice(key, 1);

          case Archtype.Map:
            return base.delete(key);

          case Archtype.Set:
            return base.delete(patch.value);

          default:
            return delete base[key];
        }

      default:
        throw new Error("Unsupported patch operation: " + op);
    }
  });
  return draft;
}

function deepClonePatchValue(obj) {
  if (!obj || typeof obj !== "object") { return obj; }
  if (Array.isArray(obj)) { return obj.map(deepClonePatchValue); }
  if (isMap(obj)) { return new Map(Array.from(obj.entries()).map(function (_a) {
    var k = _a[0],
        v = _a[1];
    return [k, deepClonePatchValue(v)];
  })); }
  if (isSet(obj)) { return new Set(Array.from(obj).map(deepClonePatchValue)); }
  var cloned = Object.create(Object.getPrototypeOf(obj));

  for (var key in obj) { cloned[key] = deepClonePatchValue(obj[key]); }

  return cloned;
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

/* istanbul ignore next */

function verifyMinified() {}

var configDefaults = {
  useProxies: typeof Proxy !== "undefined" && typeof Proxy.revocable !== "undefined" && typeof Reflect !== "undefined",
  autoFreeze: typeof process !== "undefined" ? "development" !== "production" :
  /* istanbul ignore next */
  verifyMinified.name === "verifyMinified",
  onAssign: null,
  onDelete: null,
  onCopy: null
};

var Immer =
/** @class */
function () {
  function Immer(config) {
    var _this = this;

    this.useProxies = false;
    this.autoFreeze = false;
    each(configDefaults, function (key, value) {
      var _a, _b; // @ts-ignore


      _this[key] = (_b = (_a = config) === null || _a === void 0 ? void 0 : _a[key], _b !== null && _b !== void 0 ? _b : value);
    });
    this.setUseProxies(this.useProxies);
    this.produce = this.produce.bind(this);
    this.produceWithPatches = this.produceWithPatches.bind(this);
  }
  /**
   * The `produce` function takes a value and a "recipe function" (whose
   * return value often depends on the base state). The recipe function is
   * free to mutate its first argument however it wants. All mutations are
   * only ever applied to a __copy__ of the base state.
   *
   * Pass only a function to create a "curried producer" which relieves you
   * from passing the recipe function every time.
   *
   * Only plain objects and arrays are made mutable. All other objects are
   * considered uncopyable.
   *
   * Note: This function is __bound__ to its `Immer` instance.
   *
   * @param {any} base - the initial state
   * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
   * @param {Function} patchListener - optional function that will be called with all the patches produced here
   * @returns {any} a new state, or the initial state if nothing was modified
   */


  Immer.prototype.produce = function (base, recipe, patchListener) {
    var _this = this; // curried invocation


    if (typeof base === "function" && typeof recipe !== "function") {
      var defaultBase_1 = recipe;
      recipe = base;
      var self_1 = this;
      return function curriedProduce(base) {
        var arguments$1 = arguments;

        var _this = this;

        if (base === void 0) {
          base = defaultBase_1;
        }

        var args = [];

        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments$1[_i];
        }

        return self_1.produce(base, function (draft) {
          return recipe.call.apply(recipe, __spreadArrays([_this, draft], args));
        }); // prettier-ignore
      };
    } // prettier-ignore


    {
      if (typeof recipe !== "function") {
        throw new Error("The first or second argument to `produce` must be a function");
      }

      if (patchListener !== undefined && typeof patchListener !== "function") {
        throw new Error("The third argument to `produce` must be a function or undefined");
      }
    }
    var result; // Only plain objects, arrays, and "immerable classes" are drafted.

    if (isDraftable(base)) {
      var scope_1 = ImmerScope.enter(this);
      var proxy = this.createProxy(base, undefined);
      var hasError = true;

      try {
        result = recipe(proxy);
        hasError = false;
      } finally {
        // finally instead of catch + rethrow better preserves original stack
        if (hasError) { scope_1.revoke(); }else { scope_1.leave(); }
      }

      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then(function (result) {
          scope_1.usePatches(patchListener);
          return processResult(_this, result, scope_1);
        }, function (error) {
          scope_1.revoke();
          throw error;
        });
      }

      scope_1.usePatches(patchListener);
      return processResult(this, result, scope_1);
    } else {
      result = recipe(base);
      if (result === NOTHING) { return undefined; }
      if (result === undefined) { result = base; }
      maybeFreeze(this, result, true);
      return result;
    }
  };

  Immer.prototype.produceWithPatches = function (arg1, arg2, arg3) {
    var _this = this;

    if (typeof arg1 === "function") {
      return function (state) {
        var arguments$1 = arguments;

        var args = [];

        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments$1[_i];
        }

        return _this.produceWithPatches(state, function (draft) {
          return arg1.apply(void 0, __spreadArrays([draft], args));
        });
      };
    } // non-curried form

    /* istanbul ignore next */


    if (arg3) { die(); }
    var patches, inversePatches;
    var nextState = this.produce(arg1, arg2, function (p, ip) {
      patches = p;
      inversePatches = ip;
    });
    return [nextState, patches, inversePatches];
  };

  Immer.prototype.createDraft = function (base) {
    if (!isDraftable(base)) {
      throw new Error("First argument to `createDraft` must be a plain object, an array, or an immerable object"); // prettier-ignore
    }

    var scope = ImmerScope.enter(this);
    var proxy = this.createProxy(base, undefined);
    proxy[DRAFT_STATE].isManual = true;
    scope.leave();
    return proxy;
  };

  Immer.prototype.finishDraft = function (draft, patchListener) {
    var state = draft && draft[DRAFT_STATE];

    if (!state || !state.isManual) {
      throw new Error("First argument to `finishDraft` must be a draft returned by `createDraft`"); // prettier-ignore
    }

    if (state.finalized) {
      throw new Error("The given draft is already finalized"); // prettier-ignore
    }

    var scope = state.scope;
    scope.usePatches(patchListener);
    return processResult(this, undefined, scope);
  };
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is disabled in production.
   */


  Immer.prototype.setAutoFreeze = function (value) {
    this.autoFreeze = value;
  };
  /**
   * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
   * always faster than using ES5 proxies.
   *
   * By default, feature detection is used, so calling this is rarely necessary.
   */


  Immer.prototype.setUseProxies = function (value) {
    this.useProxies = value;
  };

  Immer.prototype.applyPatches = function (base, patches) {
    // If a patch replaces the entire state, take that replacement as base
    // before applying patches
    var i;

    for (i = patches.length - 1; i >= 0; i--) {
      var patch = patches[i];

      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    }

    if (isDraft(base)) {
      // N.B: never hits if some patch a replacement, patches are never drafts
      return applyPatches(base, patches);
    } // Otherwise, produce a copy of the base state.


    return this.produce(base, function (draft) {
      return applyPatches(draft, patches.slice(i + 1));
    });
  };

  Immer.prototype.createProxy = function (value, parent) {
    // precondition: createProxy should be guarded by isDraftable, so we know we can safely draft
    var draft = isMap(value) ? proxyMap(value, parent) : isSet(value) ? proxySet(value, parent) : this.useProxies ? createProxy(value, parent) : createES5Proxy(value, parent);
    var scope = parent ? parent.scope : ImmerScope.current;
    scope.drafts.push(draft);
    return draft;
  };

  Immer.prototype.willFinalize = function (scope, thing, isReplaced) {
    if (!this.useProxies) { willFinalizeES5(scope, thing, isReplaced); }
  };

  Immer.prototype.markChanged = function (state) {
    if (this.useProxies) {
      markChanged(state);
    } else {
      markChangedES5(state);
    }
  };

  return Immer;
}();

var immer = new Immer();
/**
 * The `produce` function takes a value and a "recipe function" (whose
 * return value often depends on the base state). The recipe function is
 * free to mutate its first argument however it wants. All mutations are
 * only ever applied to a __copy__ of the base state.
 *
 * Pass only a function to create a "curried producer" which relieves you
 * from passing the recipe function every time.
 *
 * Only plain objects and arrays are made mutable. All other objects are
 * considered uncopyable.
 *
 * Note: This function is __bound__ to its `Immer` instance.
 *
 * @param {any} base - the initial state
 * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
 * @param {Function} patchListener - optional function that will be called with all the patches produced here
 * @returns {any} a new state, or the initial state if nothing was modified
 */

var produce = immer.produce;
/**
 * Like `produce`, but `produceWithPatches` always returns a tuple
 * [nextState, patches, inversePatches] (instead of just the next state)
 */

var produceWithPatches = immer.produceWithPatches.bind(immer);
/**
 * Pass true to automatically freeze all copies created by Immer.
 *
 * By default, auto-freezing is disabled in production.
 */

var setAutoFreeze = immer.setAutoFreeze.bind(immer);
/**
 * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
 * always faster than using ES5 proxies.
 *
 * By default, feature detection is used, so calling this is rarely necessary.
 */

var setUseProxies = immer.setUseProxies.bind(immer);
/**
 * Apply an array of Immer patches to the first argument.
 *
 * This function is a producer, which means copy-on-write is in effect.
 */

var applyPatches$1 = immer.applyPatches.bind(immer);
/**
 * Create an Immer draft from the given base state, which may be a draft itself.
 * The draft can be modified until you finalize it with the `finishDraft` function.
 */

var createDraft = immer.createDraft.bind(immer);
/**
 * Finalize an Immer draft from a `createDraft` call, returning the base state
 * (if no changes were made) or a modified copy. The draft must *not* be
 * mutated afterwards.
 *
 * Pass a function as the 2nd argument to generate Immer patches based on the
 * changes that were made.
 */

var finishDraft = immer.finishDraft.bind(immer);
/**
 * This function is actually a no-op, but can be used to cast an immutable type
 * to an draft type and make TypeScript happy
 *
 * @param value
 */

function castDraft(value) {
  return value;
}
/**
 * This function is actually a no-op, but can be used to cast a mutable type
 * to an immutable type and make TypeScript happy
 * @param value
 */

function castImmutable(value) {
  return value;
}

/* harmony default export */ __webpack_exports__["default"] = (produce);

//# sourceMappingURL=immer.module.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "../node_modules/process/browser.js")))

/***/ }),

/***/ "../node_modules/is-hotkey/lib/index.js":
/*!**********************************************!*\
  !*** ../node_modules/is-hotkey/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Constants.
 */

var IS_MAC = typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);

var MODIFIERS = {
  alt: 'altKey',
  control: 'ctrlKey',
  meta: 'metaKey',
  shift: 'shiftKey'
};

var ALIASES = {
  add: '+',
  break: 'pause',
  cmd: 'meta',
  command: 'meta',
  ctl: 'control',
  ctrl: 'control',
  del: 'delete',
  down: 'arrowdown',
  esc: 'escape',
  ins: 'insert',
  left: 'arrowleft',
  mod: IS_MAC ? 'meta' : 'control',
  opt: 'alt',
  option: 'alt',
  return: 'enter',
  right: 'arrowright',
  space: ' ',
  spacebar: ' ',
  up: 'arrowup',
  win: 'meta',
  windows: 'meta'
};

var CODES = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  ' ': 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ';': 186,
  '=': 187,
  ',': 188,
  '-': 189,
  '.': 190,
  '/': 191,
  '`': 192,
  '[': 219,
  '\\': 220,
  ']': 221,
  '\'': 222
};

for (var f = 1; f < 20; f++) {
  CODES['f' + f] = 111 + f;
}

/**
 * Is hotkey?
 */

function isHotkey(hotkey, options, event) {
  if (options && !('byKey' in options)) {
    event = options;
    options = null;
  }

  if (!Array.isArray(hotkey)) {
    hotkey = [hotkey];
  }

  var array = hotkey.map(function (string) {
    return parseHotkey(string, options);
  });
  var check = function check(e) {
    return array.some(function (object) {
      return compareHotkey(object, e);
    });
  };
  var ret = event == null ? check : check(event);
  return ret;
}

function isCodeHotkey(hotkey, event) {
  return isHotkey(hotkey, event);
}

function isKeyHotkey(hotkey, event) {
  return isHotkey(hotkey, { byKey: true }, event);
}

/**
 * Parse.
 */

function parseHotkey(hotkey, options) {
  var byKey = options && options.byKey;
  var ret = {};

  // Special case to handle the `+` key since we use it as a separator.
  hotkey = hotkey.replace('++', '+add');
  var values = hotkey.split('+');
  var length = values.length;

  // Ensure that all the modifiers are set to false unless the hotkey has them.

  for (var k in MODIFIERS) {
    ret[MODIFIERS[k]] = false;
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var value = _step.value;

      var optional = value.endsWith('?') && value.length > 1;

      if (optional) {
        value = value.slice(0, -1);
      }

      var name = toKeyName(value);
      var modifier = MODIFIERS[name];

      if (length === 1 || !modifier) {
        if (byKey) {
          ret.key = name;
        } else {
          ret.which = toKeyCode(value);
        }
      }

      if (modifier) {
        ret[modifier] = optional ? null : true;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return ret;
}

/**
 * Compare.
 */

function compareHotkey(object, event) {
  for (var key in object) {
    var expected = object[key];
    var actual = void 0;

    if (expected == null) {
      continue;
    }

    if (key === 'key' && event.key != null) {
      actual = event.key.toLowerCase();
    } else if (key === 'which') {
      actual = expected === 91 && event.which === 93 ? 91 : event.which;
    } else {
      actual = event[key];
    }

    if (actual == null && expected === false) {
      continue;
    }

    if (actual !== expected) {
      return false;
    }
  }

  return true;
}

/**
 * Utils.
 */

function toKeyCode(name) {
  name = toKeyName(name);
  var code = CODES[name] || name.toUpperCase().charCodeAt(0);
  return code;
}

function toKeyName(name) {
  name = name.toLowerCase();
  name = ALIASES[name] || name;
  return name;
}

/**
 * Export.
 */

exports.default = isHotkey;
exports.isHotkey = isHotkey;
exports.isCodeHotkey = isCodeHotkey;
exports.isKeyHotkey = isKeyHotkey;
exports.parseHotkey = parseHotkey;
exports.compareHotkey = compareHotkey;
exports.toKeyCode = toKeyCode;
exports.toKeyName = toKeyName;

/***/ }),

/***/ "../node_modules/is-url/index.js":
/*!***************************************!*\
  !*** ../node_modules/is-url/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Expose `isUrl`.
 */

module.exports = isUrl;

/**
 * RegExps.
 * A URL must match #1 and then at least one of #2/#3.
 * Use two levels of REs to avoid REDOS.
 */

var protocolAndDomainRE = /^(?:\w+:)?\/\/(\S+)$/;

var localhostDomainRE = /^localhost[\:?\d]*(?:[^\:?\d]\S*)?$/
var nonLocalhostDomainRE = /^[^\s\.]+\.\S{2,}$/;

/**
 * Loosely validate a URL `string`.
 *
 * @param {String} string
 * @return {Boolean}
 */

function isUrl(string){
  if (typeof string !== 'string') {
    return false;
  }

  var match = string.match(protocolAndDomainRE);
  if (!match) {
    return false;
  }

  var everythingAfterProtocol = match[1];
  if (!everythingAfterProtocol) {
    return false;
  }

  if (localhostDomainRE.test(everythingAfterProtocol) ||
      nonLocalhostDomainRE.test(everythingAfterProtocol)) {
    return true;
  }

  return false;
}


/***/ }),

/***/ "../node_modules/lodash/_Symbol.js":
/*!*****************************************!*\
  !*** ../node_modules/lodash/_Symbol.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "../node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ "../node_modules/lodash/_baseGetTag.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_baseGetTag.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "../node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "../node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "../node_modules/lodash/_objectToString.js");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ "../node_modules/lodash/_freeGlobal.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_freeGlobal.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/lodash/_getRawTag.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/_getRawTag.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "../node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ "../node_modules/lodash/_objectToString.js":
/*!*************************************************!*\
  !*** ../node_modules/lodash/_objectToString.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "../node_modules/lodash/_root.js":
/*!***************************************!*\
  !*** ../node_modules/lodash/_root.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "../node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "../node_modules/lodash/debounce.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/debounce.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "../node_modules/lodash/isObject.js"),
    now = __webpack_require__(/*! ./now */ "../node_modules/lodash/now.js"),
    toNumber = __webpack_require__(/*! ./toNumber */ "../node_modules/lodash/toNumber.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;


/***/ }),

/***/ "../node_modules/lodash/isObject.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/isObject.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "../node_modules/lodash/isObjectLike.js":
/*!**********************************************!*\
  !*** ../node_modules/lodash/isObjectLike.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "../node_modules/lodash/isSymbol.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/isSymbol.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "../node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "../node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),

/***/ "../node_modules/lodash/now.js":
/*!*************************************!*\
  !*** ../node_modules/lodash/now.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "../node_modules/lodash/_root.js");

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;


/***/ }),

/***/ "../node_modules/lodash/throttle.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/throttle.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var debounce = __webpack_require__(/*! ./debounce */ "../node_modules/lodash/debounce.js"),
    isObject = __webpack_require__(/*! ./isObject */ "../node_modules/lodash/isObject.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;


/***/ }),

/***/ "../node_modules/lodash/toNumber.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/toNumber.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "../node_modules/lodash/isObject.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "../node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),

/***/ "../node_modules/process/browser.js":
/*!******************************************!*\
  !*** ../node_modules/process/browser.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../node_modules/scroll-into-view-if-needed/es/index.js":
/*!**************************************************************!*\
  !*** ../node_modules/scroll-into-view-if-needed/es/index.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var compute_scroll_into_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! compute-scroll-into-view */ "../node_modules/compute-scroll-into-view/es/index.js");


function isOptionsObject(options) {
  return options === Object(options) && Object.keys(options).length !== 0;
}

function defaultBehavior(actions, behavior) {
  if (behavior === void 0) {
    behavior = 'auto';
  }

  var canSmoothScroll = ('scrollBehavior' in document.body.style);
  actions.forEach(function (_ref) {
    var el = _ref.el,
        top = _ref.top,
        left = _ref.left;

    if (el.scroll && canSmoothScroll) {
      el.scroll({
        top: top,
        left: left,
        behavior: behavior
      });
    } else {
      el.scrollTop = top;
      el.scrollLeft = left;
    }
  });
}

function getOptions(options) {
  if (options === false) {
    return {
      block: 'end',
      inline: 'nearest'
    };
  }

  if (isOptionsObject(options)) {
    return options;
  }

  return {
    block: 'start',
    inline: 'nearest'
  };
}

function scrollIntoView(target, options) {
  var targetIsDetached = !target.ownerDocument.documentElement.contains(target);

  if (isOptionsObject(options) && typeof options.behavior === 'function') {
    return options.behavior(targetIsDetached ? [] : Object(compute_scroll_into_view__WEBPACK_IMPORTED_MODULE_0__["default"])(target, options));
  }

  if (targetIsDetached) {
    return;
  }

  var computeOptions = getOptions(options);
  return defaultBehavior(Object(compute_scroll_into_view__WEBPACK_IMPORTED_MODULE_0__["default"])(target, computeOptions), computeOptions.behavior);
}

/* harmony default export */ __webpack_exports__["default"] = (scrollIntoView);

/***/ }),

/***/ "../node_modules/slate-react/dist/index.es.js":
/*!****************************************************!*\
  !*** ../node_modules/slate-react/dist/index.es.js ***!
  \****************************************************/
/*! exports provided: DefaultElement, DefaultLeaf, Editable, ReactEditor, Slate, useEditor, useFocused, useReadOnly, useSelected, useSlate, withReact */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultElement", function() { return DefaultElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultLeaf", function() { return DefaultLeaf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Editable", function() { return Editable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReactEditor", function() { return ReactEditor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Slate", function() { return Slate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useEditor", function() { return useEditor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useFocused", function() { return useFocused; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useReadOnly", function() { return useReadOnly; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useSelected", function() { return useSelected; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useSlate", function() { return useSlate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withReact", function() { return withReact; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ "../node_modules/slate/dist/index.es.js");
/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/throttle */ "../node_modules/lodash/throttle.js");
/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_throttle__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var scroll_into_view_if_needed__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! scroll-into-view-if-needed */ "../node_modules/scroll-into-view-if-needed/es/index.js");
/* harmony import */ var direction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! direction */ "../node_modules/direction/index.js");
/* harmony import */ var direction__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(direction__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-dom */ "react-dom");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var is_hotkey__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! is-hotkey */ "../node_modules/is-hotkey/lib/index.js");
/* harmony import */ var is_hotkey__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(is_hotkey__WEBPACK_IMPORTED_MODULE_6__);








function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

/**
 * An auto-incrementing identifier for keys.
 */
var n = 0;
/**
 * A class that keeps track of a key string. We use a full class here because we
 * want to be able to use them as keys in `WeakMap` objects.
 */

class Key {
  constructor() {
    this.id = "".concat(n++);
  }

}

/**
 * Two weak maps that allow us rebuild a path given a node. They are populated
 * at render time such that after a render occurs we can always backtrack.
 */
var NODE_TO_INDEX = new WeakMap();
var NODE_TO_PARENT = new WeakMap();
/**
 * Weak maps that allow us to go between Slate nodes and DOM nodes. These
 * are used to resolve DOM event-related logic into Slate actions.
 */

var EDITOR_TO_ELEMENT = new WeakMap();
var ELEMENT_TO_NODE = new WeakMap();
var KEY_TO_ELEMENT = new WeakMap();
var NODE_TO_ELEMENT = new WeakMap();
var NODE_TO_KEY = new WeakMap();
/**
 * Weak maps for storing editor-related state.
 */

var IS_READ_ONLY = new WeakMap();
var IS_FOCUSED = new WeakMap();
/**
 * Weak map for associating the context `onChange` context with the plugin.
 */

var EDITOR_TO_ON_CHANGE = new WeakMap();
/**
 * Symbols.
 */

var PLACEHOLDER_SYMBOL = Symbol('placeholder');

/**
 * Types.
 */
/**
 * Check if a DOM node is a comment node.
 */

var isDOMComment = value => {
  return isDOMNode(value) && value.nodeType === 8;
};
/**
 * Check if a DOM node is an element node.
 */

var isDOMElement = value => {
  return isDOMNode(value) && value.nodeType === 1;
};
/**
 * Check if a value is a DOM node.
 */

var isDOMNode = value => {
  return value instanceof Node;
};
/**
 * Check if a DOM node is an element node.
 */

var isDOMText = value => {
  return isDOMNode(value) && value.nodeType === 3;
};
/**
 * Checks whether a paste event is a plaintext-only event.
 */

var isPlainTextOnlyPaste = event => {
  return event.clipboardData && event.clipboardData.getData('text/plain') !== '' && event.clipboardData.types.length === 1;
};
/**
 * Normalize a DOM point so that it always refers to a text node.
 */

var normalizeDOMPoint = domPoint => {
  var [node, offset] = domPoint; // If it's an element node, its offset refers to the index of its children
  // including comment nodes, so try to find the right text child node.

  if (isDOMElement(node) && node.childNodes.length) {
    var isLast = offset === node.childNodes.length;
    var direction = isLast ? 'backward' : 'forward';
    var index = isLast ? offset - 1 : offset;
    node = getEditableChild(node, index, direction); // If the node has children, traverse until we have a leaf node. Leaf nodes
    // can be either text nodes, or other void DOM nodes.

    while (isDOMElement(node) && node.childNodes.length) {
      var i = isLast ? node.childNodes.length - 1 : 0;
      node = getEditableChild(node, i, direction);
    } // Determine the new offset inside the text node.


    offset = isLast && node.textContent != null ? node.textContent.length : 0;
  } // Return the node and offset.


  return [node, offset];
};
/**
 * Get the nearest editable child at `index` in a `parent`, preferring
 * `direction`.
 */

var getEditableChild = (parent, index, direction) => {
  var {
    childNodes
  } = parent;
  var child = childNodes[index];
  var i = index;
  var triedForward = false;
  var triedBackward = false; // While the child is a comment node, or an element node with no children,
  // keep iterating to find a sibling non-void, non-comment node.

  while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute('contenteditable') === 'false') {
    if (triedForward && triedBackward) {
      break;
    }

    if (i >= childNodes.length) {
      triedForward = true;
      i = index - 1;
      direction = 'backward';
      continue;
    }

    if (i < 0) {
      triedBackward = true;
      i = index + 1;
      direction = 'forward';
      continue;
    }

    child = childNodes[i];
    i += direction === 'forward' ? 1 : -1;
  }

  return child;
};
/**
 * Get a plaintext representation of the content of a node, accounting for block
 * elements which get a newline appended.
 *
 * The domNode must be attached to the DOM.
 */

var getPlainText = domNode => {
  var text = '';

  if (isDOMText(domNode) && domNode.nodeValue) {
    return domNode.nodeValue;
  }

  if (isDOMElement(domNode)) {
    for (var childNode of Array.from(domNode.childNodes)) {
      text += getPlainText(childNode);
    }

    var display = getComputedStyle(domNode).getPropertyValue('display');

    if (display === 'block' || display === 'list' || domNode.tagName === 'BR') {
      text += '\n';
    }
  }

  return text;
};

var ReactEditor = {
  /**
   * Find a key for a Slate node.
   */
  findKey(editor, node) {
    var key = NODE_TO_KEY.get(node);

    if (!key) {
      key = new Key();
      NODE_TO_KEY.set(node, key);
    }

    return key;
  },

  /**
   * Find the path of Slate node.
   */
  findPath(editor, node) {
    var path = [];
    var child = node;

    while (true) {
      var parent = NODE_TO_PARENT.get(child);

      if (parent == null) {
        if (slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].isEditor(child)) {
          return path;
        } else {
          break;
        }
      }

      var i = NODE_TO_INDEX.get(child);

      if (i == null) {
        break;
      }

      path.unshift(i);
      child = parent;
    }

    throw new Error("Unable to find the path for Slate node: ".concat(JSON.stringify(node)));
  },

  /**
   * Check if the editor is focused.
   */
  isFocused(editor) {
    return !!IS_FOCUSED.get(editor);
  },

  /**
   * Check if the editor is in read-only mode.
   */
  isReadOnly(editor) {
    return !!IS_READ_ONLY.get(editor);
  },

  /**
   * Blur the editor.
   */
  blur(editor) {
    var el = ReactEditor.toDOMNode(editor, editor);
    IS_FOCUSED.set(editor, false);

    if (window.document.activeElement === el) {
      el.blur();
    }
  },

  /**
   * Focus the editor.
   */
  focus(editor) {
    var el = ReactEditor.toDOMNode(editor, editor);
    IS_FOCUSED.set(editor, true);

    if (window.document.activeElement !== el) {
      el.focus({
        preventScroll: true
      });
    }
  },

  /**
   * Deselect the editor.
   */
  deselect(editor) {
    var {
      selection
    } = editor;
    var domSelection = window.getSelection();

    if (domSelection && domSelection.rangeCount > 0) {
      domSelection.removeAllRanges();
    }

    if (selection) {
      slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].deselect(editor);
    }
  },

  /**
   * Check if a DOM node is within the editor.
   */
  hasDOMNode(editor, target) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      editable = false
    } = options;
    var editorEl = ReactEditor.toDOMNode(editor, editor);
    var targetEl; // COMPAT: In Firefox, reading `target.nodeType` will throw an error if
    // target is originating from an internal "restricted" element (e.g. a
    // stepper arrow on a number input). (2018/05/04)
    // https://github.com/ianstormtaylor/slate/issues/1819

    try {
      targetEl = isDOMElement(target) ? target : target.parentElement;
    } catch (err) {
      if (!err.message.includes('Permission denied to access property "nodeType"')) {
        throw err;
      }
    }

    if (!targetEl) {
      return false;
    }

    return targetEl.closest("[data-slate-editor]") === editorEl && (!editable || targetEl.isContentEditable || !!targetEl.getAttribute('data-slate-zero-width'));
  },

  /**
   * Insert data from a `DataTransfer` into the editor.
   */
  insertData(editor, data) {
    editor.insertData(data);
  },

  /**
   * Sets data from the currently selected fragment on a `DataTransfer`.
   */
  setFragmentData(editor, data) {
    editor.setFragmentData(data);
  },

  /**
   * Find the native DOM element from a Slate node.
   */
  toDOMNode(editor, node) {
    var domNode = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT.get(ReactEditor.findKey(editor, node));

    if (!domNode) {
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(JSON.stringify(node)));
    }

    return domNode;
  },

  /**
   * Find a native DOM selection point from a Slate point.
   */
  toDOMPoint(editor, point) {
    var [node] = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].node(editor, point.path);
    var el = ReactEditor.toDOMNode(editor, node);
    var domPoint; // If we're inside a void node, force the offset to 0, otherwise the zero
    // width spacing character will result in an incorrect offset of 1

    if (slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].void(editor, {
      at: point
    })) {
      point = {
        path: point.path,
        offset: 0
      };
    } // For each leaf, we need to isolate its content, which means filtering
    // to its direct text and zero-width spans. (We have to filter out any
    // other siblings that may have been rendered alongside them.)


    var selector = "[data-slate-string], [data-slate-zero-width]";
    var texts = Array.from(el.querySelectorAll(selector));
    var start = 0;

    for (var text of texts) {
      var domNode = text.childNodes[0];

      if (domNode == null || domNode.textContent == null) {
        continue;
      }

      var {
        length
      } = domNode.textContent;
      var attr = text.getAttribute('data-slate-length');
      var trueLength = attr == null ? length : parseInt(attr, 10);
      var end = start + trueLength;

      if (point.offset <= end) {
        var offset = Math.min(length, Math.max(0, point.offset - start));
        domPoint = [domNode, offset];
        break;
      }

      start = end;
    }

    if (!domPoint) {
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(JSON.stringify(point)));
    }

    return domPoint;
  },

  /**
   * Find a native DOM range from a Slate `range`.
   */
  toDOMRange(editor, range) {
    var {
      anchor,
      focus
    } = range;
    var isBackward = slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isBackward(range);
    var domAnchor = ReactEditor.toDOMPoint(editor, anchor);
    var domFocus = slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isCollapsed(range) ? domAnchor : ReactEditor.toDOMPoint(editor, focus);
    var domRange = window.document.createRange();
    var [startNode, startOffset] = isBackward ? domFocus : domAnchor;
    var [endNode, endOffset] = isBackward ? domAnchor : domFocus; // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at
    // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and
    // adjust the offset accordingly.

    var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;
    var isStartAtZeroWidth = !!startEl.getAttribute('data-slate-zero-width');
    var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;
    var isEndAtZeroWidth = !!endEl.getAttribute('data-slate-zero-width');
    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);
    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);
    return domRange;
  },

  /**
   * Find a Slate node from a native DOM `element`.
   */
  toSlateNode(editor, domNode) {
    var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;

    if (domEl && !domEl.hasAttribute('data-slate-node')) {
      domEl = domEl.closest("[data-slate-node]");
    }

    var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;

    if (!node) {
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(domEl));
    }

    return node;
  },

  /**
   * Get the target range from a DOM `event`.
   */
  findEventRange(editor, event) {
    if ('nativeEvent' in event) {
      event = event.nativeEvent;
    }

    var {
      clientX: x,
      clientY: y,
      target
    } = event;

    if (x == null || y == null) {
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(event));
    }

    var node = ReactEditor.toSlateNode(editor, event.target);
    var path = ReactEditor.findPath(editor, node); // If the drop target is inside a void node, move it into either the
    // next or previous node, depending on which side the `x` and `y`
    // coordinates are closest to.

    if (slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].isVoid(editor, node)) {
      var rect = target.getBoundingClientRect();
      var isPrev = editor.isInline(node) ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;
      var edge = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].point(editor, path, {
        edge: isPrev ? 'start' : 'end'
      });
      var point = isPrev ? slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].before(editor, edge) : slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].after(editor, edge);

      if (point) {
        var _range = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].range(editor, point);

        return _range;
      }
    } // Else resolve a range from the caret position where the drop occured.


    var domRange;
    var {
      document
    } = window; // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)

    if (document.caretRangeFromPoint) {
      domRange = document.caretRangeFromPoint(x, y);
    } else {
      var position = document.caretPositionFromPoint(x, y);

      if (position) {
        domRange = document.createRange();
        domRange.setStart(position.offsetNode, position.offset);
        domRange.setEnd(position.offsetNode, position.offset);
      }
    }

    if (!domRange) {
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(event));
    } // Resolve a Slate range from the DOM range.


    var range = ReactEditor.toSlateRange(editor, domRange);
    return range;
  },

  /**
   * Find a Slate point from a DOM selection's `domNode` and `domOffset`.
   */
  toSlatePoint(editor, domPoint) {
    var [nearestNode, nearestOffset] = normalizeDOMPoint(domPoint);
    var parentNode = nearestNode.parentNode;
    var textNode = null;
    var offset = 0;

    if (parentNode) {
      var voidNode = parentNode.closest('[data-slate-void="true"]');
      var leafNode = parentNode.closest('[data-slate-leaf]');
      var domNode = null; // Calculate how far into the text node the `nearestNode` is, so that we
      // can determine what the offset relative to the text node is.

      if (leafNode) {
        textNode = leafNode.closest('[data-slate-node="text"]');
        var range = window.document.createRange();
        range.setStart(textNode, 0);
        range.setEnd(nearestNode, nearestOffset);
        var contents = range.cloneContents();
        var removals = [...contents.querySelectorAll('[data-slate-zero-width]'), ...contents.querySelectorAll('[contenteditable=false]')];
        removals.forEach(el => {
          el.parentNode.removeChild(el);
        }); // COMPAT: Edge has a bug where Range.prototype.toString() will
        // convert \n into \r\n. The bug causes a loop when slate-react
        // attempts to reposition its cursor to match the native position. Use
        // textContent.length instead.
        // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/

        offset = contents.textContent.length;
        domNode = textNode;
      } else if (voidNode) {
        // For void nodes, the element with the offset key will be a cousin, not an
        // ancestor, so find it by going down from the nearest void parent.
        leafNode = voidNode.querySelector('[data-slate-leaf]');
        textNode = leafNode.closest('[data-slate-node="text"]');
        domNode = leafNode;
        offset = domNode.textContent.length;
      } // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.


      if (domNode && offset === domNode.textContent.length && parentNode.hasAttribute('data-slate-zero-width')) {
        offset--;
      }
    }

    if (!textNode) {
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(domPoint));
    } // COMPAT: If someone is clicking from one Slate editor into another,
    // the select event fires twice, once for the old editor's `element`
    // first, and then afterwards for the correct `element`. (2017/03/03)


    var slateNode = ReactEditor.toSlateNode(editor, textNode);
    var path = ReactEditor.findPath(editor, slateNode);
    return {
      path,
      offset
    };
  },

  /**
   * Find a Slate range from a DOM range or selection.
   */
  toSlateRange(editor, domRange) {
    var el = domRange instanceof Selection ? domRange.anchorNode : domRange.startContainer;
    var anchorNode;
    var anchorOffset;
    var focusNode;
    var focusOffset;
    var isCollapsed;

    if (el) {
      if (domRange instanceof Selection) {
        anchorNode = domRange.anchorNode;
        anchorOffset = domRange.anchorOffset;
        focusNode = domRange.focusNode;
        focusOffset = domRange.focusOffset;
        isCollapsed = domRange.isCollapsed;
      } else {
        anchorNode = domRange.startContainer;
        anchorOffset = domRange.startOffset;
        focusNode = domRange.endContainer;
        focusOffset = domRange.endOffset;
        isCollapsed = domRange.collapsed;
      }
    }

    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(domRange));
    }

    var anchor = ReactEditor.toSlatePoint(editor, [anchorNode, anchorOffset]);
    var focus = isCollapsed ? anchor : ReactEditor.toSlatePoint(editor, [focusNode, focusOffset]);
    return {
      anchor,
      focus
    };
  }

};

/**
 * A React context for sharing the `focused` state of the editor.
 */

var FocusedContext = Object(react__WEBPACK_IMPORTED_MODULE_0__["createContext"])(false);
/**
 * Get the current `focused` state of the editor.
 */

var useFocused = () => {
  return Object(react__WEBPACK_IMPORTED_MODULE_0__["useContext"])(FocusedContext);
};

/**
 * A React context for sharing the editor object.
 */

var EditorContext = Object(react__WEBPACK_IMPORTED_MODULE_0__["createContext"])(null);
/**
 * Get the current editor object from the React context.
 */

var useEditor = () => {
  var editor = Object(react__WEBPACK_IMPORTED_MODULE_0__["useContext"])(EditorContext);

  if (!editor) {
    throw new Error("The `useEditor` hook must be used inside the <Slate> component's context.");
  }

  return editor;
};

/**
 * A React context for sharing the editor object, in a way that re-renders the
 * context whenever changes occur.
 */

var SlateContext = Object(react__WEBPACK_IMPORTED_MODULE_0__["createContext"])(null);
/**
 * Get the current editor object from the React context.
 */

var useSlate = () => {
  var context = Object(react__WEBPACK_IMPORTED_MODULE_0__["useContext"])(SlateContext);

  if (!context) {
    throw new Error("The `useSlate` hook must be used inside the <SlateProvider> component's context.");
  }

  var [editor] = context;
  return editor;
};

/**
 * A wrapper around the provider to handle `onChange` events, because the editor
 * is a mutable singleton so it won't ever register as "changed" otherwise.
 */

var Slate = props => {
  var {
    editor,
    children,
    onChange,
    value
  } = props,
      rest = _objectWithoutProperties(props, ["editor", "children", "onChange", "value"]);

  var [key, setKey] = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(0);
  var context = Object(react__WEBPACK_IMPORTED_MODULE_0__["useMemo"])(() => {
    editor.children = value;
    Object.assign(editor, rest);
    return [editor];
  }, [key, value, ...Object.values(rest)]);
  var onContextChange = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(() => {
    onChange(editor.children);
    setKey(key + 1);
  }, [key, onChange]);
  EDITOR_TO_ON_CHANGE.set(editor, onContextChange);
  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(() => {
    return () => {
      EDITOR_TO_ON_CHANGE.set(editor, () => {});
    };
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(SlateContext.Provider, {
    value: context
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(EditorContext.Provider, {
    value: editor
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FocusedContext.Provider, {
    value: ReactEditor.isFocused(editor)
  }, children)));
};

/**
 * A React context for sharing the `readOnly` state of the editor.
 */

var ReadOnlyContext = Object(react__WEBPACK_IMPORTED_MODULE_0__["createContext"])(false);
/**
 * Get the current `readOnly` state of the editor.
 */

var useReadOnly = () => {
  return Object(react__WEBPACK_IMPORTED_MODULE_0__["useContext"])(ReadOnlyContext);
};

/**
 * A React context for sharing the `selected` state of an element.
 */

var SelectedContext = Object(react__WEBPACK_IMPORTED_MODULE_0__["createContext"])(false);
/**
 * Get the current `selected` state of an element.
 */

var useSelected = () => {
  return Object(react__WEBPACK_IMPORTED_MODULE_0__["useContext"])(SelectedContext);
};

/**
 * `withReact` adds React and DOM specific behaviors to the editor.
 */

var withReact = editor => {
  var e = editor;
  var {
    apply,
    onChange
  } = e;

  e.apply = op => {
    var matches = [];

    switch (op.type) {
      case 'insert_text':
      case 'remove_text':
      case 'set_node':
        {
          for (var [node, path] of slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].levels(e, {
            at: op.path
          })) {
            var key = ReactEditor.findKey(e, node);
            matches.push([path, key]);
          }

          break;
        }

      case 'insert_node':
      case 'remove_node':
      case 'merge_node':
      case 'split_node':
        {
          for (var [_node, _path] of slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].levels(e, {
            at: slate__WEBPACK_IMPORTED_MODULE_1__["Path"].parent(op.path)
          })) {
            var _key = ReactEditor.findKey(e, _node);

            matches.push([_path, _key]);
          }

          break;
        }
    }

    apply(op);

    for (var [_path2, _key2] of matches) {
      var [_node2] = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].node(e, _path2);
      NODE_TO_KEY.set(_node2, _key2);
    }
  };

  e.setFragmentData = data => {
    var {
      selection
    } = e;

    if (!selection) {
      return;
    }

    var [start, end] = slate__WEBPACK_IMPORTED_MODULE_1__["Range"].edges(selection);
    var startVoid = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].void(e, {
      at: start.path
    });
    var endVoid = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].void(e, {
      at: end.path
    });

    if (slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isCollapsed(selection) && !startVoid) {
      return;
    } // Create a fake selection so that we can add a Base64-encoded copy of the
    // fragment to the HTML, to decode on future pastes.


    var domRange = ReactEditor.toDOMRange(e, selection);
    var contents = domRange.cloneContents();
    var attach = contents.childNodes[0]; // Make sure attach is non-empty, since empty nodes will not get copied.

    contents.childNodes.forEach(node => {
      if (node.textContent && node.textContent.trim() !== '') {
        attach = node;
      }
    }); // COMPAT: If the end node is a void node, we need to move the end of the
    // range from the void node's spacer span, to the end of the void node's
    // content, since the spacer is before void's content in the DOM.

    if (endVoid) {
      var [voidNode] = endVoid;
      var r = domRange.cloneRange();
      var domNode = ReactEditor.toDOMNode(e, voidNode);
      r.setEndAfter(domNode);
      contents = r.cloneContents();
    } // COMPAT: If the start node is a void node, we need to attach the encoded
    // fragment to the void node's content node instead of the spacer, because
    // attaching it to empty `<div>/<span>` nodes will end up having it erased by
    // most browsers. (2018/04/27)


    if (startVoid) {
      attach = contents.querySelector('[data-slate-spacer]');
    } // Remove any zero-width space spans from the cloned DOM so that they don't
    // show up elsewhere when pasted.


    Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(zw => {
      var isNewline = zw.getAttribute('data-slate-zero-width') === 'n';
      zw.textContent = isNewline ? '\n' : '';
    }); // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up
    // in the HTML, and can be used for intra-Slate pasting. If it's a text
    // node, wrap it in a `<span>` so we have something to set an attribute on.

    if (isDOMText(attach)) {
      var span = document.createElement('span'); // COMPAT: In Chrome and Safari, if we don't add the `white-space` style
      // then leading and trailing spaces will be ignored. (2017/09/21)

      span.style.whiteSpace = 'pre';
      span.appendChild(attach);
      contents.appendChild(span);
      attach = span;
    }

    var fragment = e.getFragment();
    var string = JSON.stringify(fragment);
    var encoded = window.btoa(encodeURIComponent(string));
    attach.setAttribute('data-slate-fragment', encoded);
    data.setData('application/x-slate-fragment', encoded); // Add the content to a <div> so that we can get its inner HTML.

    var div = document.createElement('div');
    div.appendChild(contents);
    div.setAttribute('hidden', 'true');
    document.body.appendChild(div);
    data.setData('text/html', div.innerHTML);
    data.setData('text/plain', getPlainText(div));
    document.body.removeChild(div);
  };

  e.insertData = data => {
    var fragment = data.getData('application/x-slate-fragment');

    if (fragment) {
      var decoded = decodeURIComponent(window.atob(fragment));
      var parsed = JSON.parse(decoded);
      slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].insertFragment(e, parsed);
      return;
    }

    var text = data.getData('text/plain');

    if (text) {
      var lines = text.split(/\r\n|\r|\n/);
      var split = false;

      for (var line of lines) {
        if (split) {
          slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].splitNodes(e, {
            always: true
          });
        }

        slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].insertText(e, line);
        split = true;
      }
    }
  };

  e.onChange = () => {
    // COMPAT: React doesn't batch `setState` hook calls, which means that the
    // children and selection can get out of sync for one render pass. So we
    // have to use this unstable API to ensure it batches them. (2019/12/03)
    // https://github.com/facebook/react/issues/14259#issuecomment-439702367
    react_dom__WEBPACK_IMPORTED_MODULE_5___default.a.unstable_batchedUpdates(() => {
      var onContextChange = EDITOR_TO_ON_CHANGE.get(e);

      if (onContextChange) {
        onContextChange();
      }

      onChange();
    });
  };

  return e;
};

/**
 * Leaf content strings.
 */

var String = props => {
  var {
    isLast,
    leaf,
    parent,
    text
  } = props;
  var editor = useEditor();
  var path = ReactEditor.findPath(editor, text);
  var parentPath = slate__WEBPACK_IMPORTED_MODULE_1__["Path"].parent(path); // COMPAT: Render text inside void nodes with a zero-width space.
  // So the node can contain selection but the text is not visible.

  if (editor.isVoid(parent)) {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ZeroWidthString, {
      length: slate__WEBPACK_IMPORTED_MODULE_1__["Node"].string(parent).length
    });
  } // COMPAT: If this is the last text node in an empty block, render a zero-
  // width space that will convert into a line break when copying and pasting
  // to support expected plain text.


  if (leaf.text === '' && parent.children[parent.children.length - 1] === text && !editor.isInline(parent) && slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].string(editor, parentPath) === '') {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ZeroWidthString, {
      isLineBreak: true
    });
  } // COMPAT: If the text is empty, it's because it's on the edge of an inline
  // node, so we render a zero-width space so that the selection can be
  // inserted next to it still.


  if (leaf.text === '') {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ZeroWidthString, null);
  } // COMPAT: Browsers will collapse trailing new lines at the end of blocks,
  // so we need to add an extra trailing new lines to prevent that.


  if (isLast && leaf.text.slice(-1) === '\n') {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(TextString, {
      isTrailing: true,
      text: leaf.text
    });
  }

  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(TextString, {
    text: leaf.text
  });
};
/**
 * Leaf strings with text in them.
 */


var TextString = props => {
  var {
    text,
    isTrailing = false
  } = props;
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
    "data-slate-string": true
  }, text, isTrailing ? '\n' : null);
};
/**
 * Leaf strings without text, render as zero-width strings.
 */


var ZeroWidthString = props => {
  var {
    length = 0,
    isLineBreak = false
  } = props;
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
    "data-slate-zero-width": isLineBreak ? 'n' : 'z',
    "data-slate-length": length
  }, '\uFEFF', isLineBreak ? react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("br", null) : null);
};

/**
 * Individual leaves in a text node with unique formatting.
 */

var Leaf = props => {
  var {
    leaf,
    isLast,
    text,
    parent,
    renderLeaf = props => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(DefaultLeaf, Object.assign({}, props))
  } = props;
  var children = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(String, {
    isLast: isLast,
    leaf: leaf,
    parent: parent,
    text: text
  });

  if (leaf[PLACEHOLDER_SYMBOL]) {
    children = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
      contentEditable: false,
      style: {
        pointerEvents: 'none',
        display: 'inline-block',
        verticalAlign: 'text-top',
        width: '0',
        maxWidth: '100%',
        whiteSpace: 'nowrap',
        opacity: '0.333',
        userSelect: 'none',
        fontStyle: 'normal',
        fontWeight: 'normal',
        textDecoration: 'none'
      }
    }, leaf.placeholder), children);
  } // COMPAT: Having the `data-` attributes on these leaf elements ensures that
  // in certain misbehaving browsers they aren't weirdly cloned/destroyed by
  // contenteditable behaviors. (2019/05/08)


  var attributes = {
    'data-slate-leaf': true
  };
  return renderLeaf({
    attributes,
    children,
    leaf,
    text
  });
};

var MemoizedLeaf = react__WEBPACK_IMPORTED_MODULE_0___default.a.memo(Leaf, (prev, next) => {
  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.text === prev.text && slate__WEBPACK_IMPORTED_MODULE_1__["Text"].matches(next.leaf, prev.leaf);
});
/**
 * The default custom leaf renderer.
 */

var DefaultLeaf = props => {
  var {
    attributes,
    children
  } = props;
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", Object.assign({}, attributes), children);
};

/**
 * Prevent warning on SSR by falling back to useEffect when window is not defined
 */

var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_0__["useLayoutEffect"] : react__WEBPACK_IMPORTED_MODULE_0__["useEffect"];

/**
 * Text.
 */

var Text = props => {
  var {
    decorations,
    isLast,
    parent,
    renderLeaf,
    text
  } = props;
  var editor = useEditor();
  var ref = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(null);
  var leaves = slate__WEBPACK_IMPORTED_MODULE_1__["Text"].decorations(text, decorations);
  var key = ReactEditor.findKey(editor, text);
  var children = [];

  for (var i = 0; i < leaves.length; i++) {
    var leaf = leaves[i];
    children.push(react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(MemoizedLeaf, {
      isLast: isLast && i === leaves.length - 1,
      key: "".concat(key.id, "-").concat(i),
      leaf: leaf,
      text: text,
      parent: parent,
      renderLeaf: renderLeaf
    }));
  } // Update element-related weak maps with the DOM element ref.


  useIsomorphicLayoutEffect(() => {
    if (ref.current) {
      KEY_TO_ELEMENT.set(key, ref.current);
      NODE_TO_ELEMENT.set(text, ref.current);
      ELEMENT_TO_NODE.set(ref.current, text);
    } else {
      KEY_TO_ELEMENT.delete(key);
      NODE_TO_ELEMENT.delete(text);
    }
  });
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
    "data-slate-node": "text",
    ref: ref
  }, children);
};

var MemoizedText = react__WEBPACK_IMPORTED_MODULE_0___default.a.memo(Text, (prev, next) => {
  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.text === prev.text;
});

/**
 * Element.
 */

var Element = props => {
  var {
    decorate,
    decorations,
    element,
    renderElement = p => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(DefaultElement, Object.assign({}, p)),
    renderLeaf,
    selection
  } = props;
  var ref = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(null);
  var editor = useEditor();
  var readOnly = useReadOnly();
  var isInline = editor.isInline(element);
  var key = ReactEditor.findKey(editor, element);
  var children = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Children, {
    decorate: decorate,
    decorations: decorations,
    node: element,
    renderElement: renderElement,
    renderLeaf: renderLeaf,
    selection: selection
  }); // Attributes that the developer must mix into the element in their
  // custom node renderer component.

  var attributes = {
    'data-slate-node': 'element',
    ref
  };

  if (isInline) {
    attributes['data-slate-inline'] = true;
  } // If it's a block node with inline children, add the proper `dir` attribute
  // for text direction.


  if (!isInline && slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].hasInlines(editor, element)) {
    var text = slate__WEBPACK_IMPORTED_MODULE_1__["Node"].string(element);
    var dir = direction__WEBPACK_IMPORTED_MODULE_4___default()(text);

    if (dir === 'rtl') {
      attributes.dir = dir;
    }
  } // If it's a void node, wrap the children in extra void-specific elements.


  if (slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].isVoid(editor, element)) {
    attributes['data-slate-void'] = true;

    if (!readOnly && isInline) {
      attributes.contentEditable = false;
    }

    var Tag = isInline ? 'span' : 'div';
    var [[_text]] = slate__WEBPACK_IMPORTED_MODULE_1__["Node"].texts(element);
    children = readOnly ? null : react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Tag, {
      "data-slate-spacer": true,
      style: {
        height: '0',
        color: 'transparent',
        outline: 'none',
        position: 'absolute'
      }
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(MemoizedText, {
      decorations: [],
      isLast: false,
      parent: element,
      text: _text
    }));
    NODE_TO_INDEX.set(_text, 0);
    NODE_TO_PARENT.set(_text, element);
  } // Update element-related weak maps with the DOM element ref.


  useIsomorphicLayoutEffect(() => {
    if (ref.current) {
      KEY_TO_ELEMENT.set(key, ref.current);
      NODE_TO_ELEMENT.set(element, ref.current);
      ELEMENT_TO_NODE.set(ref.current, element);
    } else {
      KEY_TO_ELEMENT.delete(key);
      NODE_TO_ELEMENT.delete(element);
    }
  });
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(SelectedContext.Provider, {
    value: !!selection
  }, renderElement({
    attributes,
    children,
    element
  }));
};

var MemoizedElement = react__WEBPACK_IMPORTED_MODULE_0___default.a.memo(Element, (prev, next) => {
  return prev.decorate === next.decorate && prev.element === next.element && prev.renderElement === next.renderElement && prev.renderLeaf === next.renderLeaf && isRangeListEqual(prev.decorations, next.decorations) && (prev.selection === next.selection || !!prev.selection && !!next.selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].equals(prev.selection, next.selection));
});
/**
 * The default element renderer.
 */

var DefaultElement = props => {
  var {
    attributes,
    children,
    element
  } = props;
  var editor = useEditor();
  var Tag = editor.isInline(element) ? 'span' : 'div';
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Tag, Object.assign({}, attributes, {
    style: {
      position: 'relative'
    }
  }), children);
};
/**
 * Check if a list of ranges is equal to another.
 *
 * PERF: this requires the two lists to also have the ranges inside them in the
 * same order, but this is an okay constraint for us since decorations are
 * kept in order, and the odd case where they aren't is okay to re-render for.
 */

var isRangeListEqual = (list, another) => {
  if (list.length !== another.length) {
    return false;
  }

  for (var i = 0; i < list.length; i++) {
    var range = list[i];
    var other = another[i];

    if (!slate__WEBPACK_IMPORTED_MODULE_1__["Range"].equals(range, other)) {
      return false;
    }
  }

  return true;
};

/**
 * Children.
 */

var Children = props => {
  var {
    decorate,
    decorations,
    node,
    renderElement,
    renderLeaf,
    selection
  } = props;
  var editor = useEditor();
  var path = ReactEditor.findPath(editor, node);
  var children = [];
  var isLeafBlock = slate__WEBPACK_IMPORTED_MODULE_1__["Element"].isElement(node) && !editor.isInline(node) && slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].hasInlines(editor, node);

  for (var i = 0; i < node.children.length; i++) {
    var p = path.concat(i);
    var n = node.children[i];
    var key = ReactEditor.findKey(editor, n);
    var range = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].range(editor, p);
    var sel = selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].intersection(range, selection);
    var ds = decorate([n, p]);

    for (var dec of decorations) {
      var d = slate__WEBPACK_IMPORTED_MODULE_1__["Range"].intersection(dec, range);

      if (d) {
        ds.push(d);
      }
    }

    if (slate__WEBPACK_IMPORTED_MODULE_1__["Element"].isElement(n)) {
      children.push(react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(MemoizedElement, {
        decorate: decorate,
        decorations: ds,
        element: n,
        key: key.id,
        renderElement: renderElement,
        renderLeaf: renderLeaf,
        selection: sel
      }));
    } else {
      children.push(react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(MemoizedText, {
        decorations: ds,
        key: key.id,
        isLast: isLeafBlock && i === node.children.length - 1,
        parent: node,
        renderLeaf: renderLeaf,
        text: n
      }));
    }

    NODE_TO_INDEX.set(n, i);
    NODE_TO_PARENT.set(n, node);
  }

  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, children);
};

var IS_IOS = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent);
var IS_FIREFOX = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
var IS_SAFARI = typeof navigator !== 'undefined' && /Version\/[\d\.]+.*Safari/.test(navigator.userAgent); // "modern" Edge was released at 79.x

var IS_EDGE_LEGACY = typeof navigator !== 'undefined' && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])/i.test(navigator.userAgent);

/**
 * Hotkey mappings for each platform.
 */

var HOTKEYS = {
  bold: 'mod+b',
  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],
  moveBackward: 'left',
  moveForward: 'right',
  moveWordBackward: 'ctrl+left',
  moveWordForward: 'ctrl+right',
  deleteBackward: 'shift?+backspace',
  deleteForward: 'shift?+delete',
  extendBackward: 'shift+left',
  extendForward: 'shift+right',
  italic: 'mod+i',
  splitBlock: 'shift?+enter',
  undo: 'mod+z'
};
var APPLE_HOTKEYS = {
  moveLineBackward: 'opt+up',
  moveLineForward: 'opt+down',
  moveWordBackward: 'opt+left',
  moveWordForward: 'opt+right',
  deleteBackward: ['ctrl+backspace', 'ctrl+h'],
  deleteForward: ['ctrl+delete', 'ctrl+d'],
  deleteLineBackward: 'cmd+shift?+backspace',
  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],
  deleteWordBackward: 'opt+shift?+backspace',
  deleteWordForward: 'opt+shift?+delete',
  extendLineBackward: 'opt+shift+up',
  extendLineForward: 'opt+shift+down',
  redo: 'cmd+shift+z',
  transposeCharacter: 'ctrl+t'
};
var WINDOWS_HOTKEYS = {
  deleteWordBackward: 'ctrl+shift?+backspace',
  deleteWordForward: 'ctrl+shift?+delete',
  redo: ['ctrl+y', 'ctrl+shift+z']
};
/**
 * Create a platform-aware hotkey checker.
 */

var create = key => {
  var generic = HOTKEYS[key];
  var apple = APPLE_HOTKEYS[key];
  var windows = WINDOWS_HOTKEYS[key];
  var isGeneric = generic && Object(is_hotkey__WEBPACK_IMPORTED_MODULE_6__["isKeyHotkey"])(generic);
  var isApple = apple && Object(is_hotkey__WEBPACK_IMPORTED_MODULE_6__["isKeyHotkey"])(apple);
  var isWindows = windows && Object(is_hotkey__WEBPACK_IMPORTED_MODULE_6__["isKeyHotkey"])(windows);
  return event => {
    if (isGeneric && isGeneric(event)) return true;
    if (IS_APPLE && isApple && isApple(event)) return true;
    if (!IS_APPLE && isWindows && isWindows(event)) return true;
    return false;
  };
};
/**
 * Hotkeys.
 */


var Hotkeys = {
  isBold: create('bold'),
  isCompose: create('compose'),
  isMoveBackward: create('moveBackward'),
  isMoveForward: create('moveForward'),
  isDeleteBackward: create('deleteBackward'),
  isDeleteForward: create('deleteForward'),
  isDeleteLineBackward: create('deleteLineBackward'),
  isDeleteLineForward: create('deleteLineForward'),
  isDeleteWordBackward: create('deleteWordBackward'),
  isDeleteWordForward: create('deleteWordForward'),
  isExtendBackward: create('extendBackward'),
  isExtendForward: create('extendForward'),
  isExtendLineBackward: create('extendLineBackward'),
  isExtendLineForward: create('extendLineForward'),
  isItalic: create('italic'),
  isMoveLineBackward: create('moveLineBackward'),
  isMoveLineForward: create('moveLineForward'),
  isMoveWordBackward: create('moveWordBackward'),
  isMoveWordForward: create('moveWordForward'),
  isRedo: create('redo'),
  isSplitBlock: create('splitBlock'),
  isTransposeCharacter: create('transposeCharacter'),
  isUndo: create('undo')
};

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var HAS_BEFORE_INPUT_SUPPORT = !(IS_FIREFOX || IS_EDGE_LEGACY);
/**
 * Editable.
 */

var Editable = props => {
  var {
    autoFocus,
    decorate = defaultDecorate,
    onDOMBeforeInput: propsOnDOMBeforeInput,
    placeholder,
    readOnly = false,
    renderElement,
    renderLeaf,
    style = {},
    as: Component = 'div'
  } = props,
      attributes = _objectWithoutProperties(props, ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "style", "as"]);

  var editor = useSlate();
  var ref = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(null); // Update internal state on each render.

  IS_READ_ONLY.set(editor, readOnly); // Keep track of some state for the event handler logic.

  var state = Object(react__WEBPACK_IMPORTED_MODULE_0__["useMemo"])(() => ({
    isComposing: false,
    isUpdatingSelection: false,
    latestElement: null
  }), []); // Update element-related weak maps with the DOM element ref.

  useIsomorphicLayoutEffect(() => {
    if (ref.current) {
      EDITOR_TO_ELEMENT.set(editor, ref.current);
      NODE_TO_ELEMENT.set(editor, ref.current);
      ELEMENT_TO_NODE.set(ref.current, editor);
    } else {
      NODE_TO_ELEMENT.delete(editor);
    }
  }); // Whenever the editor updates, make sure the DOM selection state is in sync.

  useIsomorphicLayoutEffect(() => {
    var {
      selection
    } = editor;
    var domSelection = window.getSelection();

    if (state.isComposing || !domSelection || !ReactEditor.isFocused(editor)) {
      return;
    }

    var hasDomSelection = domSelection.type !== 'None'; // If the DOM selection is properly unset, we're done.

    if (!selection && !hasDomSelection) {
      return;
    } // verify that the dom selection is in the editor


    var editorElement = EDITOR_TO_ELEMENT.get(editor);
    var hasDomSelectionInEditor = false;

    if (editorElement.contains(domSelection.anchorNode) && editorElement.contains(domSelection.focusNode)) {
      hasDomSelectionInEditor = true;
    } // If the DOM selection is in the editor and the editor selection is already correct, we're done.


    if (hasDomSelection && hasDomSelectionInEditor && selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].equals(ReactEditor.toSlateRange(editor, domSelection), selection)) {
      return;
    } // Otherwise the DOM selection is out of sync, so update it.


    var el = ReactEditor.toDOMNode(editor, editor);
    state.isUpdatingSelection = true;
    domSelection.removeAllRanges();
    var newDomRange = selection && ReactEditor.toDOMRange(editor, selection);

    if (newDomRange) {
      domSelection.addRange(newDomRange);
      var leafEl = newDomRange.startContainer.parentElement;
      Object(scroll_into_view_if_needed__WEBPACK_IMPORTED_MODULE_3__["default"])(leafEl, {
        scrollMode: 'if-needed',
        boundary: el
      });
    }

    setTimeout(() => {
      // COMPAT: In Firefox, it's not enough to create a range, you also need
      // to focus the contenteditable element too. (2016/11/16)
      if (newDomRange && IS_FIREFOX) {
        el.focus();
      }

      state.isUpdatingSelection = false;
    });
  }); // The autoFocus TextareaHTMLAttribute doesn't do anything on a div, so it
  // needs to be manually focused.

  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(() => {
    if (ref.current && autoFocus) {
      ref.current.focus();
    }
  }, [autoFocus]); // Listen on the native `beforeinput` event to get real "Level 2" events. This
  // is required because React's `beforeinput` is fake and never really attaches
  // to the real event sadly. (2019/11/01)
  // https://github.com/facebook/react/issues/11211

  var onDOMBeforeInput = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
    if (!readOnly && hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {
      var {
        selection
      } = editor;
      var {
        inputType: type
      } = event;
      var data = event.dataTransfer || event.data || undefined; // These two types occur while a user is composing text and can't be
      // cancelled. Let them through and wait for the composition to end.

      if (type === 'insertCompositionText' || type === 'deleteCompositionText') {
        return;
      }

      event.preventDefault(); // COMPAT: For the deleting forward/backward input types we don't want
      // to change the selection because it is the range that will be deleted,
      // and those commands determine that for themselves.

      if (!type.startsWith('delete') || type.startsWith('deleteBy')) {
        var [targetRange] = event.getTargetRanges();

        if (targetRange) {
          var range = ReactEditor.toSlateRange(editor, targetRange);

          if (!selection || !slate__WEBPACK_IMPORTED_MODULE_1__["Range"].equals(selection, range)) {
            slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].select(editor, range);
          }
        }
      } // COMPAT: If the selection is expanded, even if the command seems like
      // a delete forward/backward command it should delete the selection.


      if (selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isExpanded(selection) && type.startsWith('delete')) {
        slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteFragment(editor);
        return;
      }

      switch (type) {
        case 'deleteByComposition':
        case 'deleteByCut':
        case 'deleteByDrag':
          {
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteFragment(editor);
            break;
          }

        case 'deleteContent':
        case 'deleteContentForward':
          {
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteForward(editor);
            break;
          }

        case 'deleteContentBackward':
          {
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteBackward(editor);
            break;
          }

        case 'deleteEntireSoftLine':
          {
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteBackward(editor, {
              unit: 'line'
            });
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteForward(editor, {
              unit: 'line'
            });
            break;
          }

        case 'deleteHardLineBackward':
          {
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteBackward(editor, {
              unit: 'block'
            });
            break;
          }

        case 'deleteSoftLineBackward':
          {
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteBackward(editor, {
              unit: 'line'
            });
            break;
          }

        case 'deleteHardLineForward':
          {
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteForward(editor, {
              unit: 'block'
            });
            break;
          }

        case 'deleteSoftLineForward':
          {
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteForward(editor, {
              unit: 'line'
            });
            break;
          }

        case 'deleteWordBackward':
          {
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteBackward(editor, {
              unit: 'word'
            });
            break;
          }

        case 'deleteWordForward':
          {
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteForward(editor, {
              unit: 'word'
            });
            break;
          }

        case 'insertLineBreak':
        case 'insertParagraph':
          {
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].insertBreak(editor);
            break;
          }

        case 'insertFromComposition':
        case 'insertFromDrop':
        case 'insertFromPaste':
        case 'insertFromYank':
        case 'insertReplacementText':
        case 'insertText':
          {
            if (data instanceof DataTransfer) {
              ReactEditor.insertData(editor, data);
            } else if (typeof data === 'string') {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].insertText(editor, data);
            }

            break;
          }
      }
    }
  }, [readOnly]); // Attach a native DOM event handler for `beforeinput` events, because React's
  // built-in `onBeforeInput` is actually a leaky polyfill that doesn't expose
  // real `beforeinput` events sadly... (2019/11/04)
  // https://github.com/facebook/react/issues/11211

  useIsomorphicLayoutEffect(() => {
    if (ref.current) {
      // @ts-ignore The `beforeinput` event isn't recognized.
      ref.current.addEventListener('beforeinput', onDOMBeforeInput);
    }

    return () => {
      if (ref.current) {
        // @ts-ignore The `beforeinput` event isn't recognized.
        ref.current.removeEventListener('beforeinput', onDOMBeforeInput);
      }
    };
  }, [onDOMBeforeInput]); // Listen on the native `selectionchange` event to be able to update any time
  // the selection changes. This is required because React's `onSelect` is leaky
  // and non-standard so it doesn't fire until after a selection has been
  // released. This causes issues in situations where another change happens
  // while a selection is being dragged.

  var onDOMSelectionChange = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(lodash_throttle__WEBPACK_IMPORTED_MODULE_2___default()(() => {
    if (!readOnly && !state.isComposing && !state.isUpdatingSelection) {
      var {
        activeElement
      } = window.document;
      var el = ReactEditor.toDOMNode(editor, editor);
      var domSelection = window.getSelection();

      if (activeElement === el) {
        state.latestElement = activeElement;
        IS_FOCUSED.set(editor, true);
      } else {
        IS_FOCUSED.delete(editor);
      }

      if (!domSelection) {
        return slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].deselect(editor);
      }

      var {
        anchorNode,
        focusNode
      } = domSelection;
      var anchorNodeSelectable = hasEditableTarget(editor, anchorNode) || isTargetInsideVoid(editor, anchorNode);
      var focusNodeSelectable = hasEditableTarget(editor, focusNode) || isTargetInsideVoid(editor, focusNode);

      if (anchorNodeSelectable && focusNodeSelectable) {
        var range = ReactEditor.toSlateRange(editor, domSelection);
        slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].select(editor, range);
      } else {
        slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].deselect(editor);
      }
    }
  }, 100), [readOnly]); // Attach a native DOM event handler for `selectionchange`, because React's
  // built-in `onSelect` handler doesn't fire for all selection changes. It's a
  // leaky polyfill that only fires on keypresses or clicks. Instead, we want to
  // fire for any change to the selection inside the editor. (2019/11/04)
  // https://github.com/facebook/react/issues/5785

  useIsomorphicLayoutEffect(() => {
    window.document.addEventListener('selectionchange', onDOMSelectionChange);
    return () => {
      window.document.removeEventListener('selectionchange', onDOMSelectionChange);
    };
  }, [onDOMSelectionChange]);
  var decorations = decorate([editor, []]);

  if (placeholder && editor.children.length === 1 && Array.from(slate__WEBPACK_IMPORTED_MODULE_1__["Node"].texts(editor)).length === 1 && slate__WEBPACK_IMPORTED_MODULE_1__["Node"].string(editor) === '') {
    var start = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].start(editor, []);
    decorations.push({
      [PLACEHOLDER_SYMBOL]: true,
      placeholder,
      anchor: start,
      focus: start
    });
  }

  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ReadOnlyContext.Provider, {
    value: readOnly
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Component // COMPAT: The Grammarly Chrome extension works by changing the DOM
  // out from under `contenteditable` elements, which leads to weird
  // behaviors so we have to disable it like editor. (2017/04/24)
  , Object.assign({
    "data-gramm": false,
    role: readOnly ? undefined : 'textbox'
  }, attributes, {
    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
    // have to use hacks to make these replacement-based features work.
    spellCheck: !HAS_BEFORE_INPUT_SUPPORT ? undefined : attributes.spellCheck,
    autoCorrect: !HAS_BEFORE_INPUT_SUPPORT ? undefined : attributes.autoCorrect,
    autoCapitalize: !HAS_BEFORE_INPUT_SUPPORT ? undefined : attributes.autoCapitalize,
    "data-slate-editor": true,
    "data-slate-node": "value",
    contentEditable: readOnly ? undefined : true,
    suppressContentEditableWarning: true,
    ref: ref,
    style: _objectSpread({
      // Prevent the default outline styles.
      outline: 'none',
      // Preserve adjacent whitespace and new lines.
      whiteSpace: 'pre-wrap',
      // Allow words to break if they are too long.
      wordWrap: 'break-word'
    }, style),
    onBeforeInput: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      // COMPAT: Certain browsers don't support the `beforeinput` event, so we
      // fall back to React's leaky polyfill instead just for it. It
      // only works for the `insertText` input type.
      if (!HAS_BEFORE_INPUT_SUPPORT && !readOnly && !isEventHandled(event, attributes.onBeforeInput) && hasEditableTarget(editor, event.target)) {
        event.preventDefault();
        var text = event.data;
        slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].insertText(editor, text);
      }
    }, [readOnly]),
    onBlur: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      if (readOnly || state.isUpdatingSelection || !hasEditableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {
        return;
      } // COMPAT: If the current `activeElement` is still the previous
      // one, this is due to the window being blurred when the tab
      // itself becomes unfocused, so we want to abort early to allow to
      // editor to stay focused when the tab becomes focused again.


      if (state.latestElement === window.document.activeElement) {
        return;
      }

      var {
        relatedTarget
      } = event;
      var el = ReactEditor.toDOMNode(editor, editor); // COMPAT: The event should be ignored if the focus is returning
      // to the editor from an embedded editable element (eg. an <input>
      // element inside a void node).

      if (relatedTarget === el) {
        return;
      } // COMPAT: The event should be ignored if the focus is moving from
      // the editor to inside a void node's spacer element.


      if (isDOMElement(relatedTarget) && relatedTarget.hasAttribute('data-slate-spacer')) {
        return;
      } // COMPAT: The event should be ignored if the focus is moving to a
      // non- editable section of an element that isn't a void node (eg.
      // a list item of the check list example).


      if (relatedTarget != null && isDOMNode(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {
        var node = ReactEditor.toSlateNode(editor, relatedTarget);

        if (slate__WEBPACK_IMPORTED_MODULE_1__["Element"].isElement(node) && !editor.isVoid(node)) {
          return;
        }
      }

      IS_FOCUSED.delete(editor);
    }, [readOnly, attributes.onBlur]),
    onClick: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      if (!readOnly && hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && isDOMNode(event.target)) {
        var node = ReactEditor.toSlateNode(editor, event.target);
        var path = ReactEditor.findPath(editor, node);

        var _start = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].start(editor, path);

        var end = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].end(editor, path);
        var startVoid = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].void(editor, {
          at: _start
        });
        var endVoid = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].void(editor, {
          at: end
        });

        if (startVoid && endVoid && slate__WEBPACK_IMPORTED_MODULE_1__["Path"].equals(startVoid[1], endVoid[1])) {
          var range = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].range(editor, _start);
          slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].select(editor, range);
        }
      }
    }, [readOnly, attributes.onClick]),
    onCompositionEnd: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionEnd)) {
        state.isComposing = false; // COMPAT: In Chrome, `beforeinput` events for compositions
        // aren't correct and never fire the "insertFromComposition"
        // type that we need. So instead, insert whenever a composition
        // ends since it will already have been committed to the DOM.

        if (!IS_SAFARI && !IS_FIREFOX && event.data) {
          slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].insertText(editor, event.data);
        }
      }
    }, [attributes.onCompositionEnd]),
    onCompositionStart: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionStart)) {
        state.isComposing = true;
      }
    }, [attributes.onCompositionStart]),
    onCopy: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy)) {
        event.preventDefault();
        ReactEditor.setFragmentData(editor, event.clipboardData);
      }
    }, [attributes.onCopy]),
    onCut: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      if (!readOnly && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut)) {
        event.preventDefault();
        ReactEditor.setFragmentData(editor, event.clipboardData);
        var {
          selection
        } = editor;

        if (selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isExpanded(selection)) {
          slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteFragment(editor);
        }
      }
    }, [readOnly, attributes.onCut]),
    onDragOver: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      if (hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {
        // Only when the target is void, call `preventDefault` to signal
        // that drops are allowed. Editable content is droppable by
        // default, and calling `preventDefault` hides the cursor.
        var node = ReactEditor.toSlateNode(editor, event.target);

        if (slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].isVoid(editor, node)) {
          event.preventDefault();
        }
      }
    }, [attributes.onDragOver]),
    onDragStart: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      if (hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {
        var node = ReactEditor.toSlateNode(editor, event.target);
        var path = ReactEditor.findPath(editor, node);
        var voidMatch = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].void(editor, {
          at: path
        }); // If starting a drag on a void node, make sure it is selected
        // so that it shows up in the selection's fragment.

        if (voidMatch) {
          var range = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].range(editor, path);
          slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].select(editor, range);
        }

        ReactEditor.setFragmentData(editor, event.dataTransfer);
      }
    }, [attributes.onDragStart]),
    onDrop: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      if (hasTarget(editor, event.target) && !readOnly && !isEventHandled(event, attributes.onDrop)) {
        // COMPAT: Certain browsers don't fire `beforeinput` events at all, and
        // Chromium browsers don't properly fire them for files being
        // dropped into a `contenteditable`. (2019/11/26)
        // https://bugs.chromium.org/p/chromium/issues/detail?id=1028668
        if (!HAS_BEFORE_INPUT_SUPPORT || !IS_SAFARI && event.dataTransfer.files.length > 0) {
          event.preventDefault();
          var range = ReactEditor.findEventRange(editor, event);
          var data = event.dataTransfer;
          slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].select(editor, range);
          ReactEditor.insertData(editor, data);
        }
      }
    }, [readOnly, attributes.onDrop]),
    onFocus: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      if (!readOnly && !state.isUpdatingSelection && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {
        var el = ReactEditor.toDOMNode(editor, editor);
        state.latestElement = window.document.activeElement; // COMPAT: If the editor has nested editable elements, the focus
        // can go to them. In Firefox, this must be prevented because it
        // results in issues with keyboard navigation. (2017/03/30)

        if (IS_FIREFOX && event.target !== el) {
          el.focus();
          return;
        }

        IS_FOCUSED.set(editor, true);
      }
    }, [readOnly, attributes.onFocus]),
    onKeyDown: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      if (!readOnly && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onKeyDown)) {
        var {
          nativeEvent
        } = event;
        var {
          selection
        } = editor; // COMPAT: Since we prevent the default behavior on
        // `beforeinput` events, the browser doesn't think there's ever
        // any history stack to undo or redo, so we have to manage these
        // hotkeys ourselves. (2019/11/06)

        if (Hotkeys.isRedo(nativeEvent)) {
          event.preventDefault();

          if (typeof editor.redo === 'function') {
            editor.redo();
          }

          return;
        }

        if (Hotkeys.isUndo(nativeEvent)) {
          event.preventDefault();

          if (typeof editor.undo === 'function') {
            editor.undo();
          }

          return;
        } // COMPAT: Certain browsers don't handle the selection updates
        // properly. In Chrome, the selection isn't properly extended.
        // And in Firefox, the selection isn't properly collapsed.
        // (2017/10/17)


        if (Hotkeys.isMoveLineBackward(nativeEvent)) {
          event.preventDefault();
          slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].move(editor, {
            unit: 'line',
            reverse: true
          });
          return;
        }

        if (Hotkeys.isMoveLineForward(nativeEvent)) {
          event.preventDefault();
          slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].move(editor, {
            unit: 'line'
          });
          return;
        }

        if (Hotkeys.isExtendLineBackward(nativeEvent)) {
          event.preventDefault();
          slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].move(editor, {
            unit: 'line',
            edge: 'focus',
            reverse: true
          });
          return;
        }

        if (Hotkeys.isExtendLineForward(nativeEvent)) {
          event.preventDefault();
          slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].move(editor, {
            unit: 'line',
            edge: 'focus'
          });
          return;
        } // COMPAT: If a void node is selected, or a zero-width text node
        // adjacent to an inline is selected, we need to handle these
        // hotkeys manually because browsers won't be able to skip over
        // the void node with the zero-width space not being an empty
        // string.


        if (Hotkeys.isMoveBackward(nativeEvent)) {
          event.preventDefault();

          if (selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isCollapsed(selection)) {
            slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].move(editor, {
              reverse: true
            });
          } else {
            slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].collapse(editor, {
              edge: 'start'
            });
          }

          return;
        }

        if (Hotkeys.isMoveForward(nativeEvent)) {
          event.preventDefault();

          if (selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isCollapsed(selection)) {
            slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].move(editor);
          } else {
            slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].collapse(editor, {
              edge: 'end'
            });
          }

          return;
        }

        if (Hotkeys.isMoveWordBackward(nativeEvent)) {
          event.preventDefault();
          slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].move(editor, {
            unit: 'word',
            reverse: true
          });
          return;
        }

        if (Hotkeys.isMoveWordForward(nativeEvent)) {
          event.preventDefault();
          slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].move(editor, {
            unit: 'word'
          });
          return;
        } // COMPAT: Certain browsers don't support the `beforeinput` event, so we
        // fall back to guessing at the input intention for hotkeys.
        // COMPAT: In iOS, some of these hotkeys are handled in the


        if (!HAS_BEFORE_INPUT_SUPPORT) {
          // We don't have a core behavior for these, but they change the
          // DOM if we don't prevent them, so we have to.
          if (Hotkeys.isBold(nativeEvent) || Hotkeys.isItalic(nativeEvent) || Hotkeys.isTransposeCharacter(nativeEvent)) {
            event.preventDefault();
            return;
          }

          if (Hotkeys.isSplitBlock(nativeEvent)) {
            event.preventDefault();
            slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].insertBreak(editor);
            return;
          }

          if (Hotkeys.isDeleteBackward(nativeEvent)) {
            event.preventDefault();

            if (selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isExpanded(selection)) {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteFragment(editor);
            } else {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteBackward(editor);
            }

            return;
          }

          if (Hotkeys.isDeleteForward(nativeEvent)) {
            event.preventDefault();

            if (selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isExpanded(selection)) {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteFragment(editor);
            } else {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteForward(editor);
            }

            return;
          }

          if (Hotkeys.isDeleteLineBackward(nativeEvent)) {
            event.preventDefault();

            if (selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isExpanded(selection)) {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteFragment(editor);
            } else {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteBackward(editor, {
                unit: 'line'
              });
            }

            return;
          }

          if (Hotkeys.isDeleteLineForward(nativeEvent)) {
            event.preventDefault();

            if (selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isExpanded(selection)) {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteFragment(editor);
            } else {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteForward(editor, {
                unit: 'line'
              });
            }

            return;
          }

          if (Hotkeys.isDeleteWordBackward(nativeEvent)) {
            event.preventDefault();

            if (selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isExpanded(selection)) {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteFragment(editor);
            } else {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteBackward(editor, {
                unit: 'word'
              });
            }

            return;
          }

          if (Hotkeys.isDeleteWordForward(nativeEvent)) {
            event.preventDefault();

            if (selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isExpanded(selection)) {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteFragment(editor);
            } else {
              slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].deleteForward(editor, {
                unit: 'word'
              });
            }

            return;
          }
        }
      }
    }, [readOnly, attributes.onKeyDown]),
    onPaste: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(event => {
      // COMPAT: Certain browsers don't support the `beforeinput` event, so we
      // fall back to React's `onPaste` here instead.
      // COMPAT: Firefox, Chrome and Safari are not emitting `beforeinput` events
      // when "paste without formatting" option is used.
      // This unfortunately needs to be handled with paste events instead.
      if (!isEventHandled(event, attributes.onPaste) && (!HAS_BEFORE_INPUT_SUPPORT || isPlainTextOnlyPaste(event.nativeEvent)) && !readOnly && hasEditableTarget(editor, event.target)) {
        event.preventDefault();
        ReactEditor.insertData(editor, event.clipboardData);
      }
    }, [readOnly, attributes.onPaste])
  }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Children, {
    decorate: decorate,
    decorations: decorations,
    node: editor,
    renderElement: renderElement,
    renderLeaf: renderLeaf,
    selection: editor.selection
  })));
};
/**
 * A default memoized decorate function.
 */

var defaultDecorate = () => [];
/**
 * Check if the target is in the editor.
 */


var hasTarget = (editor, target) => {
  return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target);
};
/**
 * Check if the target is editable and in the editor.
 */


var hasEditableTarget = (editor, target) => {
  return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target, {
    editable: true
  });
};
/**
 * Check if the target is inside void and in the editor.
 */


var isTargetInsideVoid = (editor, target) => {
  var slateNode = hasTarget(editor, target) && ReactEditor.toSlateNode(editor, target);
  return slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].isVoid(editor, slateNode);
};
/**
 * Check if an event is overrided by a handler.
 */


var isEventHandled = (event, handler) => {
  if (!handler) {
    return false;
  }

  handler(event);
  return event.isDefaultPrevented() || event.isPropagationStopped();
};
/**
 * Check if a DOM event is overrided by a handler.
 */


var isDOMEventHandled = (event, handler) => {
  if (!handler) {
    return false;
  }

  handler(event);
  return event.defaultPrevented;
};


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "../node_modules/slate/dist/index.es.js":
/*!**********************************************!*\
  !*** ../node_modules/slate/dist/index.es.js ***!
  \**********************************************/
/*! exports provided: Editor, Element, Location, Node, Operation, Path, PathRef, Point, PointRef, Range, RangeRef, Span, Text, Transforms, createEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Editor", function() { return Editor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Element", function() { return Element; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Location", function() { return Location; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Node", function() { return Node; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Operation", function() { return Operation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Path", function() { return Path; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PathRef", function() { return PathRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Point", function() { return Point; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointRef", function() { return PointRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Range", function() { return Range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RangeRef", function() { return RangeRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Span", function() { return Span; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Text", function() { return Text; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transforms", function() { return Transforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEditor", function() { return createEditor; });
/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-plain-object */ "../node_modules/slate/node_modules/is-plain-object/index.js");
/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! immer */ "../node_modules/immer/dist/immer.module.js");
/* harmony import */ var esrever__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! esrever */ "../node_modules/esrever/esrever.js");
/* harmony import */ var esrever__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(esrever__WEBPACK_IMPORTED_MODULE_2__);




function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var DIRTY_PATHS = new WeakMap();
var FLUSHING = new WeakMap();
var NORMALIZING = new WeakMap();
var PATH_REFS = new WeakMap();
var POINT_REFS = new WeakMap();
var RANGE_REFS = new WeakMap();

/**
 * Constants for string distance checking.
 */
var SPACE = /\s/;
var PUNCTUATION = /[\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
var CHAMELEON = /['\u2018\u2019]/;
var SURROGATE_START = 0xd800;
var SURROGATE_END = 0xdfff;
var ZERO_WIDTH_JOINER = 0x200d;
/**
 * Get the distance to the end of the first character in a string of text.
 */

var getCharacterDistance = text => {
  var offset = 0; // prev types:
  // SURR: surrogate pair
  // MOD: modifier (technically also surrogate pair)
  // ZWJ: zero width joiner
  // VAR: variation selector
  // BMP: sequenceable character from basic multilingual plane

  var prev = null;
  var charCode = text.charCodeAt(0);

  while (charCode) {
    if (isSurrogate(charCode)) {
      var modifier = isModifier(charCode, text, offset); // Early returns are the heart of this function, where we decide if previous and current
      // codepoints should form a single character (in terms of how many of them should selection
      // jump over).

      if (prev === 'SURR' || prev === 'BMP') {
        break;
      }

      offset += 2;
      prev = modifier ? 'MOD' : 'SURR';
      charCode = text.charCodeAt(offset); // Absolutely fine to `continue` without any checks because if `charCode` is NaN (which
      // is the case when out of `text` range), next `while` loop won"t execute and we"re done.

      continue;
    }

    if (charCode === ZERO_WIDTH_JOINER) {
      offset += 1;
      prev = 'ZWJ';
      charCode = text.charCodeAt(offset);
      continue;
    }

    if (isBMPEmoji(charCode)) {
      if (prev && prev !== 'ZWJ' && prev !== 'VAR') {
        break;
      }

      offset += 1;
      prev = 'BMP';
      charCode = text.charCodeAt(offset);
      continue;
    }

    if (isVariationSelector(charCode)) {
      if (prev && prev !== 'ZWJ') {
        break;
      }

      offset += 1;
      prev = 'VAR';
      charCode = text.charCodeAt(offset);
      continue;
    } // Modifier 'groups up' with what ever character is before that (even whitespace), need to
    // look ahead.


    if (prev === 'MOD') {
      offset += 1;
      break;
    } // If while loop ever gets here, we're done (e.g latin chars).


    break;
  }

  return offset || 1;
};
/**
 * Get the distance to the end of the first word in a string of text.
 */

var getWordDistance = text => {
  var length = 0;
  var i = 0;
  var started = false;
  var char;

  while (char = text.charAt(i)) {
    var l = getCharacterDistance(char);
    char = text.slice(i, i + l);
    var rest = text.slice(i + l);

    if (isWordCharacter(char, rest)) {
      started = true;
      length += l;
    } else if (!started) {
      length += l;
    } else {
      break;
    }

    i += l;
  }

  return length;
};
/**
 * Check if a character is a word character. The `remaining` argument is used
 * because sometimes you must read subsequent characters to truly determine it.
 */

var isWordCharacter = (char, remaining) => {
  if (SPACE.test(char)) {
    return false;
  } // Chameleons count as word characters as long as they're in a word, so
  // recurse to see if the next one is a word character or not.


  if (CHAMELEON.test(char)) {
    var next = remaining.charAt(0);
    var length = getCharacterDistance(next);
    next = remaining.slice(0, length);
    var rest = remaining.slice(length);

    if (isWordCharacter(next, rest)) {
      return true;
    }
  }

  if (PUNCTUATION.test(char)) {
    return false;
  }

  return true;
};
/**
 * Determines if `code` is a surrogate
 */


var isSurrogate = code => SURROGATE_START <= code && code <= SURROGATE_END;
/**
 * Does `code` form Modifier with next one.
 *
 * https://emojipedia.org/modifiers/
 */


var isModifier = (code, text, offset) => {
  if (code === 0xd83c) {
    var next = text.charCodeAt(offset + 1);
    return next <= 0xdfff && next >= 0xdffb;
  }

  return false;
};
/**
 * Is `code` a Variation Selector.
 *
 * https://codepoints.net/variation_selectors
 */


var isVariationSelector = code => {
  return code <= 0xfe0f && code >= 0xfe00;
};
/**
 * Is `code` one of the BMP codes used in emoji sequences.
 *
 * https://emojipedia.org/emoji-zwj-sequences/
 */


var isBMPEmoji = code => {
  // This requires tiny bit of maintanance, better ideas?
  // Fortunately it only happens if new Unicode Standard
  // is released. Fails gracefully if upkeep lags behind,
  // same way Slate previously behaved with all emojis.
  return code === 0x2764 || // heart ()
  code === 0x2642 || // male ()
  code === 0x2640 || // female ()
  code === 0x2620 || // scull ()
  code === 0x2695 || // medical ()
  code === 0x2708 || // plane ()
  code === 0x25ef // large circle ()
  ;
};

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var Editor = {
  /**
   * Get the ancestor above a location in the document.
   */
  above(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      voids = false,
      mode = 'lowest',
      at = editor.selection,
      match
    } = options;

    if (!at) {
      return;
    }

    var path = Editor.path(editor, at);
    var reverse = mode === 'lowest';

    for (var [n, p] of Editor.levels(editor, {
      at: path,
      voids,
      match,
      reverse
    })) {
      if (!Text.isText(n) && !Path.equals(path, p)) {
        return [n, p];
      }
    }
  },

  /**
   * Add a custom property to the leaf text nodes in the current selection.
   *
   * If the selection is currently collapsed, the marks will be added to the
   * `editor.marks` property instead, and applied when text is inserted next.
   */
  addMark(editor, key, value) {
    editor.addMark(key, value);
  },

  /**
   * Get the point after a location.
   */
  after(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var anchor = Editor.point(editor, at, {
      edge: 'end'
    });
    var focus = Editor.end(editor, []);
    var range = {
      anchor,
      focus
    };
    var {
      distance = 1
    } = options;
    var d = 0;
    var target;

    for (var p of Editor.positions(editor, _objectSpread({}, options, {
      at: range
    }))) {
      if (d > distance) {
        break;
      }

      if (d !== 0) {
        target = p;
      }

      d++;
    }

    return target;
  },

  /**
   * Get the point before a location.
   */
  before(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var anchor = Editor.start(editor, []);
    var focus = Editor.point(editor, at, {
      edge: 'start'
    });
    var range = {
      anchor,
      focus
    };
    var {
      distance = 1
    } = options;
    var d = 0;
    var target;

    for (var p of Editor.positions(editor, _objectSpread({}, options, {
      at: range,
      reverse: true
    }))) {
      if (d > distance) {
        break;
      }

      if (d !== 0) {
        target = p;
      }

      d++;
    }

    return target;
  },

  /**
   * Delete content in the editor backward from the current selection.
   */
  deleteBackward(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      unit = 'character'
    } = options;
    editor.deleteBackward(unit);
  },

  /**
   * Delete content in the editor forward from the current selection.
   */
  deleteForward(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      unit = 'character'
    } = options;
    editor.deleteForward(unit);
  },

  /**
   * Delete the content in the current selection.
   */
  deleteFragment(editor) {
    editor.deleteFragment();
  },

  /**
   * Get the start and end points of a location.
   */
  edges(editor, at) {
    return [Editor.start(editor, at), Editor.end(editor, at)];
  },

  /**
   * Get the end point of a location.
   */
  end(editor, at) {
    return Editor.point(editor, at, {
      edge: 'end'
    });
  },

  /**
   * Get the first node at a location.
   */
  first(editor, at) {
    var path = Editor.path(editor, at, {
      edge: 'start'
    });
    return Editor.node(editor, path);
  },

  /**
   * Get the fragment at a location.
   */
  fragment(editor, at) {
    var range = Editor.range(editor, at);
    var fragment = Node.fragment(editor, range);
    return fragment;
  },

  /**
   * Check if a node has block children.
   */
  hasBlocks(editor, element) {
    return element.children.some(n => Editor.isBlock(editor, n));
  },

  /**
   * Check if a node has inline and text children.
   */
  hasInlines(editor, element) {
    return element.children.some(n => Text.isText(n) || Editor.isInline(editor, n));
  },

  /**
   * Check if a node has text children.
   */
  hasTexts(editor, element) {
    return element.children.every(n => Text.isText(n));
  },

  /**
   * Insert a block break at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertBreak(editor) {
    editor.insertBreak();
  },

  /**
   * Insert a fragment at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertFragment(editor, fragment) {
    editor.insertFragment(fragment);
  },

  /**
   * Insert a node at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertNode(editor, node) {
    editor.insertNode(node);
  },

  /**
   * Insert text at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertText(editor, text) {
    editor.insertText(text);
  },

  /**
   * Check if a value is a block `Element` object.
   */
  isBlock(editor, value) {
    return Element.isElement(value) && !editor.isInline(value);
  },

  /**
   * Check if a value is an `Editor` object.
   */
  isEditor(value) {
    return Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && typeof value.addMark === 'function' && typeof value.apply === 'function' && typeof value.deleteBackward === 'function' && typeof value.deleteForward === 'function' && typeof value.deleteFragment === 'function' && typeof value.insertBreak === 'function' && typeof value.insertFragment === 'function' && typeof value.insertNode === 'function' && typeof value.insertText === 'function' && typeof value.isInline === 'function' && typeof value.isVoid === 'function' && typeof value.normalizeNode === 'function' && typeof value.onChange === 'function' && typeof value.removeMark === 'function' && (value.marks === null || Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);
  },

  /**
   * Check if a point is the end point of a location.
   */
  isEnd(editor, point, at) {
    var end = Editor.end(editor, at);
    return Point.equals(point, end);
  },

  /**
   * Check if a point is an edge of a location.
   */
  isEdge(editor, point, at) {
    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);
  },

  /**
   * Check if an element is empty, accounting for void nodes.
   */
  isEmpty(editor, element) {
    var {
      children
    } = element;
    var [first] = children;
    return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === '' && !editor.isVoid(element);
  },

  /**
   * Check if a value is an inline `Element` object.
   */
  isInline(editor, value) {
    return Element.isElement(value) && editor.isInline(value);
  },

  /**
   * Check if the editor is currently normalizing after each operation.
   */
  isNormalizing(editor) {
    var isNormalizing = NORMALIZING.get(editor);
    return isNormalizing === undefined ? true : isNormalizing;
  },

  /**
   * Check if a point is the start point of a location.
   */
  isStart(editor, point, at) {
    // PERF: If the offset isn't `0` we know it's not the start.
    if (point.offset !== 0) {
      return false;
    }

    var start = Editor.start(editor, at);
    return Point.equals(point, start);
  },

  /**
   * Check if a value is a void `Element` object.
   */
  isVoid(editor, value) {
    return Element.isElement(value) && editor.isVoid(value);
  },

  /**
   * Get the last node at a location.
   */
  last(editor, at) {
    var path = Editor.path(editor, at, {
      edge: 'end'
    });
    return Editor.node(editor, path);
  },

  /**
   * Get the leaf text node at a location.
   */
  leaf(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var path = Editor.path(editor, at, options);
    var node = Node.leaf(editor, path);
    return [node, path];
  },

  /**
   * Iterate through all of the levels at a location.
   */
  *levels(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      at = editor.selection,
      reverse = false,
      voids = false
    } = options;
    var {
      match
    } = options;

    if (match == null) {
      match = () => true;
    }

    if (!at) {
      return;
    }

    var levels = [];
    var path = Editor.path(editor, at);

    for (var [n, p] of Node.levels(editor, path)) {
      if (!match(n)) {
        continue;
      }

      levels.push([n, p]);

      if (!voids && Editor.isVoid(editor, n)) {
        break;
      }
    }

    if (reverse) {
      levels.reverse();
    }

    yield* levels;
  },

  /**
   * Get the marks that would be added to text at the current selection.
   */
  marks(editor) {
    var {
      marks,
      selection
    } = editor;

    if (!selection) {
      return null;
    }

    if (marks) {
      return marks;
    }

    if (Range.isExpanded(selection)) {
      var [match] = Editor.nodes(editor, {
        match: Text.isText
      });

      if (match) {
        var [_node] = match;

        var _rest = _objectWithoutProperties(_node, ["text"]);

        return _rest;
      } else {
        return {};
      }
    }

    var {
      anchor
    } = selection;
    var {
      path
    } = anchor;
    var [node] = Editor.leaf(editor, path);

    if (anchor.offset === 0) {
      var prev = Editor.previous(editor, {
        at: path,
        match: Text.isText
      });
      var block = Editor.above(editor, {
        match: n => Editor.isBlock(editor, n)
      });

      if (prev && block) {
        var [prevNode, prevPath] = prev;
        var [, blockPath] = block;

        if (Path.isAncestor(blockPath, prevPath)) {
          node = prevNode;
        }
      }
    }

    var rest = _objectWithoutProperties(node, ["text"]);

    return rest;
  },

  /**
   * Get the matching node in the branch of the document after a location.
   */
  next(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      mode = 'lowest',
      voids = false
    } = options;
    var {
      match,
      at = editor.selection
    } = options;

    if (!at) {
      return;
    }

    var [, from] = Editor.last(editor, at);
    var [, to] = Editor.last(editor, []);
    var span = [from, to];

    if (Path.isPath(at) && at.length === 0) {
      throw new Error("Cannot get the next node from the root node!");
    }

    if (match == null) {
      if (Path.isPath(at)) {
        var [parent] = Editor.parent(editor, at);

        match = n => parent.children.includes(n);
      } else {
        match = () => true;
      }
    }

    var [, next] = Editor.nodes(editor, {
      at: span,
      match,
      mode,
      voids
    });
    return next;
  },

  /**
   * Get the node at a location.
   */
  node(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var path = Editor.path(editor, at, options);
    var node = Node.get(editor, path);
    return [node, path];
  },

  /**
   * Iterate through all of the nodes in the Editor.
   */
  *nodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      at = editor.selection,
      mode = 'all',
      universal = false,
      reverse = false,
      voids = false
    } = options;
    var {
      match
    } = options;

    if (!match) {
      match = () => true;
    }

    if (!at) {
      return;
    }

    var from;
    var to;

    if (Span.isSpan(at)) {
      from = at[0];
      to = at[1];
    } else {
      var first = Editor.path(editor, at, {
        edge: 'start'
      });
      var last = Editor.path(editor, at, {
        edge: 'end'
      });
      from = reverse ? last : first;
      to = reverse ? first : last;
    }

    var iterable = Node.nodes(editor, {
      reverse,
      from,
      to,
      pass: (_ref) => {
        var [n] = _ref;
        return voids ? false : Editor.isVoid(editor, n);
      }
    });
    var matches = [];
    var hit;

    for (var [node, path] of iterable) {
      var isLower = hit && Path.compare(path, hit[1]) === 0; // In highest mode any node lower than the last hit is not a match.

      if (mode === 'highest' && isLower) {
        continue;
      }

      if (!match(node)) {
        // If we've arrived at a leaf text node that is not lower than the last
        // hit, then we've found a branch that doesn't include a match, which
        // means the match is not universal.
        if (universal && !isLower && Text.isText(node)) {
          return;
        } else {
          continue;
        }
      } // If there's a match and it's lower than the last, update the hit.


      if (mode === 'lowest' && isLower) {
        hit = [node, path];
        continue;
      } // In lowest mode we emit the last hit, once it's guaranteed lowest.


      var emit = mode === 'lowest' ? hit : [node, path];

      if (emit) {
        if (universal) {
          matches.push(emit);
        } else {
          yield emit;
        }
      }

      hit = [node, path];
    } // Since lowest is always emitting one behind, catch up at the end.


    if (mode === 'lowest' && hit) {
      if (universal) {
        matches.push(hit);
      } else {
        yield hit;
      }
    } // Universal defers to ensure that the match occurs in every branch, so we
    // yield all of the matches after iterating.


    if (universal) {
      yield* matches;
    }
  },

  /**
   * Normalize any dirty objects in the editor.
   */
  normalize(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      force = false
    } = options;

    var getDirtyPaths = editor => {
      return DIRTY_PATHS.get(editor) || [];
    };

    if (!Editor.isNormalizing(editor)) {
      return;
    }

    if (force) {
      var allPaths = Array.from(Node.nodes(editor), (_ref2) => {
        var [, p] = _ref2;
        return p;
      });
      DIRTY_PATHS.set(editor, allPaths);
    }

    if (getDirtyPaths(editor).length === 0) {
      return;
    }

    Editor.withoutNormalizing(editor, () => {
      var max = getDirtyPaths(editor).length * 42; // HACK: better way?

      var m = 0;

      while (getDirtyPaths(editor).length !== 0) {
        if (m > max) {
          throw new Error("\n            Could not completely normalize the editor after ".concat(max, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\n          "));
        }

        var path = getDirtyPaths(editor).pop();
        var entry = Editor.node(editor, path);
        editor.normalizeNode(entry);
        m++;
      }
    });
  },

  /**
   * Get the parent node of a location.
   */
  parent(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var path = Editor.path(editor, at, options);
    var parentPath = Path.parent(path);
    var entry = Editor.node(editor, parentPath);
    return entry;
  },

  /**
   * Get the path of a location.
   */
  path(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      depth,
      edge
    } = options;

    if (Path.isPath(at)) {
      if (edge === 'start') {
        var [, firstPath] = Node.first(editor, at);
        at = firstPath;
      } else if (edge === 'end') {
        var [, lastPath] = Node.last(editor, at);
        at = lastPath;
      }
    }

    if (Range.isRange(at)) {
      if (edge === 'start') {
        at = Range.start(at);
      } else if (edge === 'end') {
        at = Range.end(at);
      } else {
        at = Path.common(at.anchor.path, at.focus.path);
      }
    }

    if (Point.isPoint(at)) {
      at = at.path;
    }

    if (depth != null) {
      at = at.slice(0, depth);
    }

    return at;
  },

  /**
   * Create a mutable ref for a `Path` object, which will stay in sync as new
   * operations are applied to the editor.
   */
  pathRef(editor, path) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      affinity = 'forward'
    } = options;
    var ref = {
      current: path,
      affinity,

      unref() {
        var {
          current
        } = ref;
        var pathRefs = Editor.pathRefs(editor);
        pathRefs.delete(ref);
        ref.current = null;
        return current;
      }

    };
    var refs = Editor.pathRefs(editor);
    refs.add(ref);
    return ref;
  },

  /**
   * Get the set of currently tracked path refs of the editor.
   */
  pathRefs(editor) {
    var refs = PATH_REFS.get(editor);

    if (!refs) {
      refs = new Set();
      PATH_REFS.set(editor, refs);
    }

    return refs;
  },

  /**
   * Get the start or end point of a location.
   */
  point(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      edge = 'start'
    } = options;

    if (Path.isPath(at)) {
      var path;

      if (edge === 'end') {
        var [, lastPath] = Node.last(editor, at);
        path = lastPath;
      } else {
        var [, firstPath] = Node.first(editor, at);
        path = firstPath;
      }

      var node = Node.get(editor, path);

      if (!Text.isText(node)) {
        throw new Error("Cannot get the ".concat(edge, " point in the node at path [").concat(at, "] because it has no ").concat(edge, " text node."));
      }

      return {
        path,
        offset: edge === 'end' ? node.text.length : 0
      };
    }

    if (Range.isRange(at)) {
      var [start, end] = Range.edges(at);
      return edge === 'start' ? start : end;
    }

    return at;
  },

  /**
   * Create a mutable ref for a `Point` object, which will stay in sync as new
   * operations are applied to the editor.
   */
  pointRef(editor, point) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      affinity = 'forward'
    } = options;
    var ref = {
      current: point,
      affinity,

      unref() {
        var {
          current
        } = ref;
        var pointRefs = Editor.pointRefs(editor);
        pointRefs.delete(ref);
        ref.current = null;
        return current;
      }

    };
    var refs = Editor.pointRefs(editor);
    refs.add(ref);
    return ref;
  },

  /**
   * Get the set of currently tracked point refs of the editor.
   */
  pointRefs(editor) {
    var refs = POINT_REFS.get(editor);

    if (!refs) {
      refs = new Set();
      POINT_REFS.set(editor, refs);
    }

    return refs;
  },

  /**
   * Iterate through all of the positions in the document where a `Point` can be
   * placed.
   *
   * By default it will move forward by individual offsets at a time,  but you
   * can pass the `unit: 'character'` option to moved forward one character, word,
   * or line at at time.
   *
   * Note: void nodes are treated as a single point, and iteration will not
   * happen inside their content.
   */
  *positions(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      at = editor.selection,
      unit = 'offset',
      reverse: reverse$1 = false
    } = options;

    if (!at) {
      return;
    }

    var range = Editor.range(editor, at);
    var [start, end] = Range.edges(range);
    var first = reverse$1 ? end : start;
    var string = '';
    var available = 0;
    var offset = 0;
    var distance = null;
    var isNewBlock = false;

    var advance = () => {
      if (distance == null) {
        if (unit === 'character') {
          distance = getCharacterDistance(string);
        } else if (unit === 'word') {
          distance = getWordDistance(string);
        } else if (unit === 'line' || unit === 'block') {
          distance = string.length;
        } else {
          distance = 1;
        }

        string = string.slice(distance);
      } // Add or substract the offset.


      offset = reverse$1 ? offset - distance : offset + distance; // Subtract the distance traveled from the available text.

      available = available - distance; // If the available had room to spare, reset the distance so that it will
      // advance again next time. Otherwise, set it to the overflow amount.

      distance = available >= 0 ? null : 0 - available;
    };

    for (var [node, path] of Editor.nodes(editor, {
      at,
      reverse: reverse$1
    })) {
      if (Element.isElement(node)) {
        // Void nodes are a special case, since we don't want to iterate over
        // their content. We instead always just yield their first point.
        if (editor.isVoid(node)) {
          yield Editor.start(editor, path);
          continue;
        }

        if (editor.isInline(node)) {
          continue;
        }

        if (Editor.hasInlines(editor, node)) {
          var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);
          var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);
          var text = Editor.string(editor, {
            anchor: s,
            focus: e
          });
          string = reverse$1 ? Object(esrever__WEBPACK_IMPORTED_MODULE_2__["reverse"])(text) : text;
          isNewBlock = true;
        }
      }

      if (Text.isText(node)) {
        var isFirst = Path.equals(path, first.path);
        available = node.text.length;
        offset = reverse$1 ? available : 0;

        if (isFirst) {
          available = reverse$1 ? first.offset : available - first.offset;
          offset = first.offset;
        }

        if (isFirst || isNewBlock || unit === 'offset') {
          yield {
            path,
            offset
          };
        }

        while (true) {
          // If there's no more string, continue to the next block.
          if (string === '') {
            break;
          } else {
            advance();
          } // If the available space hasn't overflow, we have another point to
          // yield in the current text node.


          if (available >= 0) {
            yield {
              path,
              offset
            };
          } else {
            break;
          }
        }

        isNewBlock = false;
      }
    }
  },

  /**
   * Get the matching node in the branch of the document before a location.
   */
  previous(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      mode = 'lowest',
      voids = false
    } = options;
    var {
      match,
      at = editor.selection
    } = options;

    if (!at) {
      return;
    }

    var [, from] = Editor.first(editor, at);
    var [, to] = Editor.first(editor, []);
    var span = [from, to];

    if (Path.isPath(at) && at.length === 0) {
      throw new Error("Cannot get the previous node from the root node!");
    }

    if (match == null) {
      if (Path.isPath(at)) {
        var [parent] = Editor.parent(editor, at);

        match = n => parent.children.includes(n);
      } else {
        match = () => true;
      }
    }

    var [, previous] = Editor.nodes(editor, {
      reverse: true,
      at: span,
      match,
      mode,
      voids
    });
    return previous;
  },

  /**
   * Get a range of a location.
   */
  range(editor, at, to) {
    if (Range.isRange(at) && !to) {
      return at;
    }

    var start = Editor.start(editor, at);
    var end = Editor.end(editor, to || at);
    return {
      anchor: start,
      focus: end
    };
  },

  /**
   * Create a mutable ref for a `Range` object, which will stay in sync as new
   * operations are applied to the editor.
   */
  rangeRef(editor, range) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      affinity = 'forward'
    } = options;
    var ref = {
      current: range,
      affinity,

      unref() {
        var {
          current
        } = ref;
        var rangeRefs = Editor.rangeRefs(editor);
        rangeRefs.delete(ref);
        ref.current = null;
        return current;
      }

    };
    var refs = Editor.rangeRefs(editor);
    refs.add(ref);
    return ref;
  },

  /**
   * Get the set of currently tracked range refs of the editor.
   */
  rangeRefs(editor) {
    var refs = RANGE_REFS.get(editor);

    if (!refs) {
      refs = new Set();
      RANGE_REFS.set(editor, refs);
    }

    return refs;
  },

  /**
   * Remove a custom property from all of the leaf text nodes in the current
   * selection.
   *
   * If the selection is currently collapsed, the removal will be stored on
   * `editor.marks` and applied to the text inserted next.
   */
  removeMark(editor, key) {
    editor.removeMark(key);
  },

  /**
   * Get the start point of a location.
   */
  start(editor, at) {
    return Editor.point(editor, at, {
      edge: 'start'
    });
  },

  /**
   * Get the text string content of a location.
   *
   * Note: the text of void nodes is presumed to be an empty string, regardless
   * of what their actual content is.
   */
  string(editor, at) {
    var range = Editor.range(editor, at);
    var [start, end] = Range.edges(range);
    var text = '';

    for (var [node, path] of Editor.nodes(editor, {
      at: range,
      match: Text.isText
    })) {
      var t = node.text;

      if (Path.equals(path, end.path)) {
        t = t.slice(0, end.offset);
      }

      if (Path.equals(path, start.path)) {
        t = t.slice(start.offset);
      }

      text += t;
    }

    return text;
  },

  /**
   * Transform the editor by an operation.
   */
  transform(editor, op) {
    editor.children = Object(immer__WEBPACK_IMPORTED_MODULE_1__["createDraft"])(editor.children);
    var selection = editor.selection && Object(immer__WEBPACK_IMPORTED_MODULE_1__["createDraft"])(editor.selection);

    switch (op.type) {
      case 'insert_node':
        {
          var {
            path,
            node
          } = op;
          var parent = Node.parent(editor, path);
          var index = path[path.length - 1];
          parent.children.splice(index, 0, node);

          if (selection) {
            for (var [point, key] of Range.points(selection)) {
              selection[key] = Point.transform(point, op);
            }
          }

          break;
        }

      case 'insert_text':
        {
          var {
            path: _path,
            offset,
            text
          } = op;

          var _node2 = Node.leaf(editor, _path);

          var before = _node2.text.slice(0, offset);

          var after = _node2.text.slice(offset);

          _node2.text = before + text + after;

          if (selection) {
            for (var [_point, _key] of Range.points(selection)) {
              selection[_key] = Point.transform(_point, op);
            }
          }

          break;
        }

      case 'merge_node':
        {
          var {
            path: _path2
          } = op;

          var _node3 = Node.get(editor, _path2);

          var prevPath = Path.previous(_path2);
          var prev = Node.get(editor, prevPath);

          var _parent = Node.parent(editor, _path2);

          var _index = _path2[_path2.length - 1];

          if (Text.isText(_node3) && Text.isText(prev)) {
            prev.text += _node3.text;
          } else if (!Text.isText(_node3) && !Text.isText(prev)) {
            prev.children.push(..._node3.children);
          } else {
            throw new Error("Cannot apply a \"merge_node\" operation at path [".concat(_path2, "] to nodes of different interaces: ").concat(_node3, " ").concat(prev));
          }

          _parent.children.splice(_index, 1);

          if (selection) {
            for (var [_point2, _key2] of Range.points(selection)) {
              selection[_key2] = Point.transform(_point2, op);
            }
          }

          break;
        }

      case 'move_node':
        {
          var {
            path: _path3,
            newPath
          } = op;

          if (Path.isAncestor(_path3, newPath)) {
            throw new Error("Cannot move a path [".concat(_path3, "] to new path [").concat(newPath, "] because the destination is inside itself."));
          }

          var _node4 = Node.get(editor, _path3);

          var _parent2 = Node.parent(editor, _path3);

          var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to
          // the same snapshot in time, there's a mismatch. After either
          // removing the original position, the second step's path can be out
          // of date. So instead of using the `op.newPath` directly, we
          // transform `op.path` to ascertain what the `newPath` would be after
          // the operation was applied.

          _parent2.children.splice(_index2, 1);

          var truePath = Path.transform(_path3, op);
          var newParent = Node.get(editor, Path.parent(truePath));
          var newIndex = truePath[truePath.length - 1];
          newParent.children.splice(newIndex, 0, _node4);

          if (selection) {
            for (var [_point3, _key3] of Range.points(selection)) {
              selection[_key3] = Point.transform(_point3, op);
            }
          }

          break;
        }

      case 'remove_node':
        {
          var {
            path: _path4
          } = op;
          var _index3 = _path4[_path4.length - 1];

          var _parent3 = Node.parent(editor, _path4);

          _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the
          // node that was removed we need to update the range or remove it.


          if (selection) {
            for (var [_point4, _key4] of Range.points(selection)) {
              var result = Point.transform(_point4, op);

              if (selection != null && result != null) {
                selection[_key4] = result;
              } else {
                var _prev = void 0;

                var next = void 0;

                for (var [n, p] of Node.texts(editor)) {
                  if (Path.compare(p, _path4) === -1) {
                    _prev = [n, p];
                  } else {
                    next = [n, p];
                    break;
                  }
                }

                if (_prev) {
                  _point4.path = _prev[1];
                  _point4.offset = _prev[0].text.length;
                } else if (next) {
                  _point4.path = next[1];
                  _point4.offset = 0;
                } else {
                  selection = null;
                }
              }
            }
          }

          break;
        }

      case 'remove_text':
        {
          var {
            path: _path5,
            offset: _offset,
            text: _text2
          } = op;

          var _node5 = Node.leaf(editor, _path5);

          var _before = _node5.text.slice(0, _offset);

          var _after = _node5.text.slice(_offset + _text2.length);

          _node5.text = _before + _after;

          if (selection) {
            for (var [_point5, _key5] of Range.points(selection)) {
              selection[_key5] = Point.transform(_point5, op);
            }
          }

          break;
        }

      case 'set_node':
        {
          var {
            path: _path6,
            newProperties
          } = op;

          if (_path6.length === 0) {
            throw new Error("Cannot set properties on the root node!");
          }

          var _node6 = Node.get(editor, _path6);

          for (var _key6 in newProperties) {
            if (_key6 === 'children' || _key6 === 'text') {
              throw new Error("Cannot set the \"".concat(_key6, "\" property of nodes!"));
            }

            var value = newProperties[_key6];

            if (value == null) {
              delete _node6[_key6];
            } else {
              _node6[_key6] = value;
            }
          }

          break;
        }

      case 'set_selection':
        {
          var {
            newProperties: _newProperties
          } = op;

          if (_newProperties == null) {
            selection = _newProperties;
          } else if (selection == null) {
            if (!Range.isRange(_newProperties)) {
              throw new Error("Cannot apply an incomplete \"set_selection\" operation properties ".concat(JSON.stringify(_newProperties), " when there is no current selection."));
            }

            selection = _newProperties;
          } else {
            Object.assign(selection, _newProperties);
          }

          break;
        }

      case 'split_node':
        {
          var {
            path: _path7,
            position,
            properties
          } = op;

          if (_path7.length === 0) {
            throw new Error("Cannot apply a \"split_node\" operation at path [".concat(_path7, "] because the root node cannot be split."));
          }

          var _node7 = Node.get(editor, _path7);

          var _parent4 = Node.parent(editor, _path7);

          var _index4 = _path7[_path7.length - 1];
          var newNode;

          if (Text.isText(_node7)) {
            var _before2 = _node7.text.slice(0, position);

            var _after2 = _node7.text.slice(position);

            _node7.text = _before2;
            newNode = _objectSpread({}, _node7, {}, properties, {
              text: _after2
            });
          } else {
            var _before3 = _node7.children.slice(0, position);

            var _after3 = _node7.children.slice(position);

            _node7.children = _before3;
            newNode = _objectSpread({}, _node7, {}, properties, {
              children: _after3
            });
          }

          _parent4.children.splice(_index4 + 1, 0, newNode);

          if (selection) {
            for (var [_point6, _key7] of Range.points(selection)) {
              selection[_key7] = Point.transform(_point6, op);
            }
          }

          break;
        }
    }

    editor.children = Object(immer__WEBPACK_IMPORTED_MODULE_1__["finishDraft"])(editor.children);

    if (selection) {
      editor.selection = Object(immer__WEBPACK_IMPORTED_MODULE_1__["isDraft"])(selection) ? Object(immer__WEBPACK_IMPORTED_MODULE_1__["finishDraft"])(selection) : selection;
    } else {
      editor.selection = null;
    }
  },

  /**
   * Convert a range into a non-hanging one.
   */
  unhangRange(editor, range) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      voids = false
    } = options;
    var [start, end] = Range.edges(range); // PERF: exit early if we can guarantee that the range isn't hanging.

    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range)) {
      return range;
    }

    var endBlock = Editor.above(editor, {
      at: end,
      match: n => Editor.isBlock(editor, n)
    });
    var blockPath = endBlock ? endBlock[1] : [];
    var first = Editor.start(editor, []);
    var before = {
      anchor: first,
      focus: end
    };
    var skip = true;

    for (var [node, path] of Editor.nodes(editor, {
      at: before,
      match: Text.isText,
      reverse: true,
      voids
    })) {
      if (skip) {
        skip = false;
        continue;
      }

      if (node.text !== '' || Path.isBefore(path, blockPath)) {
        end = {
          path,
          offset: node.text.length
        };
        break;
      }
    }

    return {
      anchor: start,
      focus: end
    };
  },

  /**
   * Match a void node in the current branch of the editor.
   */
  void(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return Editor.above(editor, _objectSpread({}, options, {
      match: n => Editor.isVoid(editor, n)
    }));
  },

  /**
   * Call a function, deferring normalization until after it completes.
   */
  withoutNormalizing(editor, fn) {
    var value = Editor.isNormalizing(editor);
    NORMALIZING.set(editor, false);
    fn();
    NORMALIZING.set(editor, value);
    Editor.normalize(editor);
  }

};

var Element = {
  /**
   * Check if a value implements the `Element` interface.
   */
  isElement(value) {
    return Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);
  },

  /**
   * Check if a value is an array of `Element` objects.
   */
  isElementList(value) {
    return Array.isArray(value) && (value.length === 0 || Element.isElement(value[0]));
  },

  /**
   * Check if an element matches set of properties.
   *
   * Note: this checks custom properties, and it does not ensure that any
   * children are equivalent.
   */
  matches(element, props) {
    for (var key in props) {
      if (key === 'children') {
        continue;
      }

      if (element[key] !== props[key]) {
        return false;
      }
    }

    return true;
  }

};

var Location = {
  /**
   * Check if a value implements the `Location` interface.
   */
  isLocation(value) {
    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);
  }

};
var Span = {
  /**
   * Check if a value implements the `Span` interface.
   */
  isSpan(value) {
    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);
  }

};

var Node = {
  /**
   * Get the node at a specific path, asserting that it's an ancestor node.
   */
  ancestor(root, path) {
    var node = Node.get(root, path);

    if (Text.isText(node)) {
      throw new Error("Cannot get the ancestor node at path [".concat(path, "] because it refers to a text node instead: ").concat(node));
    }

    return node;
  },

  /**
   * Return an iterable of all the ancestor nodes above a specific path.
   *
   * By default the order is bottom-up, from lowest to highest ancestor in
   * the tree, but you can pass the `reverse: true` option to go top-down.
   */
  *ancestors(root, path) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    for (var p of Path.ancestors(path, options)) {
      var n = Node.ancestor(root, p);
      var entry = [n, p];
      yield entry;
    }
  },

  /**
   * Get the child of a node at a specific index.
   */
  child(root, index) {
    if (Text.isText(root)) {
      throw new Error("Cannot get the child of a text node: ".concat(JSON.stringify(root)));
    }

    var c = root.children[index];

    if (c == null) {
      throw new Error("Cannot get child at index `".concat(index, "` in node: ").concat(JSON.stringify(root)));
    }

    return c;
  },

  /**
   * Iterate over the children of a node at a specific path.
   */
  *children(root, path) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      reverse = false
    } = options;
    var ancestor = Node.ancestor(root, path);
    var {
      children
    } = ancestor;
    var index = reverse ? children.length - 1 : 0;

    while (reverse ? index >= 0 : index < children.length) {
      var child = Node.child(ancestor, index);
      var childPath = path.concat(index);
      yield [child, childPath];
      index = reverse ? index - 1 : index + 1;
    }
  },

  /**
   * Get an entry for the common ancesetor node of two paths.
   */
  common(root, path, another) {
    var p = Path.common(path, another);
    var n = Node.get(root, p);
    return [n, p];
  },

  /**
   * Get the node at a specific path, asserting that it's a descendant node.
   */
  descendant(root, path) {
    var node = Node.get(root, path);

    if (Editor.isEditor(node)) {
      throw new Error("Cannot get the descendant node at path [".concat(path, "] because it refers to the root editor node instead: ").concat(node));
    }

    return node;
  },

  /**
   * Return an iterable of all the descendant node entries inside a root node.
   */
  *descendants(root) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    for (var [node, path] of Node.nodes(root, options)) {
      if (path.length !== 0) {
        // NOTE: we have to coerce here because checking the path's length does
        // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.
        yield [node, path];
      }
    }
  },

  /**
   * Return an iterable of all the element nodes inside a root node. Each iteration
   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the
   * root node is an element it will be included in the iteration as well.
   */
  *elements(root) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    for (var [node, path] of Node.nodes(root, options)) {
      if (Element.isElement(node)) {
        yield [node, path];
      }
    }
  },

  /**
   * Get the first node entry in a root node from a path.
   */
  first(root, path) {
    var p = path.slice();
    var n = Node.get(root, p);

    while (n) {
      if (Text.isText(n) || n.children.length === 0) {
        break;
      } else {
        n = n.children[0];
        p.push(0);
      }
    }

    return [n, p];
  },

  /**
   * Get the sliced fragment represented by a range inside a root node.
   */
  fragment(root, range) {
    if (Text.isText(root)) {
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(JSON.stringify(root)));
    }

    var newRoot = Object(immer__WEBPACK_IMPORTED_MODULE_1__["produce"])(root, r => {
      var [start, end] = Range.edges(range);
      var iterable = Node.nodes(r, {
        reverse: true,
        pass: (_ref) => {
          var [, path] = _ref;
          return !Range.includes(range, path);
        }
      });

      for (var [, path] of iterable) {
        if (!Range.includes(range, path)) {
          var parent = Node.parent(r, path);
          var index = path[path.length - 1];
          parent.children.splice(index, 1);
        }

        if (Path.equals(path, end.path)) {
          var leaf = Node.leaf(r, path);
          leaf.text = leaf.text.slice(0, end.offset);
        }

        if (Path.equals(path, start.path)) {
          var _leaf = Node.leaf(r, path);

          _leaf.text = _leaf.text.slice(start.offset);
        }
      }

      delete r.selection;
    });
    return newRoot.children;
  },

  /**
   * Get the descendant node referred to by a specific path. If the path is an
   * empty array, it refers to the root node itself.
   */
  get(root, path) {
    var node = root;

    for (var i = 0; i < path.length; i++) {
      var p = path[i];

      if (Text.isText(node) || !node.children[p]) {
        throw new Error("Cannot find a descendant at path [".concat(path, "] in node: ").concat(JSON.stringify(root)));
      }

      node = node.children[p];
    }

    return node;
  },

  /**
   * Check if a descendant node exists at a specific path.
   */
  has(root, path) {
    var node = root;

    for (var i = 0; i < path.length; i++) {
      var p = path[i];

      if (Text.isText(node) || !node.children[p]) {
        return false;
      }

      node = node.children[p];
    }

    return true;
  },

  /**
   * Check if a value implements the `Node` interface.
   */
  isNode(value) {
    return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);
  },

  /**
   * Check if a value is a list of `Node` objects.
   */
  isNodeList(value) {
    return Array.isArray(value) && (value.length === 0 || Node.isNode(value[0]));
  },

  /**
   * Get the lash node entry in a root node from a path.
   */
  last(root, path) {
    var p = path.slice();
    var n = Node.get(root, p);

    while (n) {
      if (Text.isText(n) || n.children.length === 0) {
        break;
      } else {
        var i = n.children.length - 1;
        n = n.children[i];
        p.push(i);
      }
    }

    return [n, p];
  },

  /**
   * Get the node at a specific path, ensuring it's a leaf text node.
   */
  leaf(root, path) {
    var node = Node.get(root, path);

    if (!Text.isText(node)) {
      throw new Error("Cannot get the leaf node at path [".concat(path, "] because it refers to a non-leaf node: ").concat(node));
    }

    return node;
  },

  /**
   * Return an iterable of the in a branch of the tree, from a specific path.
   *
   * By default the order is top-down, from lowest to highest node in the tree,
   * but you can pass the `reverse: true` option to go bottom-up.
   */
  *levels(root, path) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    for (var p of Path.levels(path, options)) {
      var n = Node.get(root, p);
      yield [n, p];
    }
  },

  /**
   * Check if a node matches a set of props.
   */
  matches(node, props) {
    return Element.isElement(node) && Element.matches(node, props) || Text.isText(node) && Text.matches(node, props);
  },

  /**
   * Return an iterable of all the node entries of a root node. Each entry is
   * returned as a `[Node, Path]` tuple, with the path referring to the node's
   * position inside the root node.
   */
  *nodes(root) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      pass,
      reverse = false
    } = options;
    var {
      from = [],
      to
    } = options;
    var visited = new Set();
    var p = [];
    var n = root;

    while (true) {
      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {
        break;
      }

      if (!visited.has(n)) {
        yield [n, p];
      } // If we're allowed to go downward and we haven't decsended yet, do.


      if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([n, p]) === false)) {
        visited.add(n);
        var nextIndex = reverse ? n.children.length - 1 : 0;

        if (Path.isAncestor(p, from)) {
          nextIndex = from[p.length];
        }

        p = p.concat(nextIndex);
        n = Node.get(root, p);
        continue;
      } // If we're at the root and we can't go down, we're done.


      if (p.length === 0) {
        break;
      } // If we're going forward...


      if (!reverse) {
        var newPath = Path.next(p);

        if (Node.has(root, newPath)) {
          p = newPath;
          n = Node.get(root, p);
          continue;
        }
      } // If we're going backward...


      if (reverse && p[p.length - 1] !== 0) {
        var _newPath = Path.previous(p);

        p = _newPath;
        n = Node.get(root, p);
        continue;
      } // Otherwise we're going upward...


      p = Path.parent(p);
      n = Node.get(root, p);
      visited.add(n);
    }
  },

  /**
   * Get the parent of a node at a specific path.
   */
  parent(root, path) {
    var parentPath = Path.parent(path);
    var p = Node.get(root, parentPath);

    if (Text.isText(p)) {
      throw new Error("Cannot get the parent of path [".concat(path, "] because it does not exist in the root."));
    }

    return p;
  },

  /**
   * Get the concatenated text string of a node's content.
   *
   * Note that this will not include spaces or line breaks between block nodes.
   * It is not a user-facing string, but a string for performing offset-related
   * computations for a node.
   */
  string(node) {
    if (Text.isText(node)) {
      return node.text;
    } else {
      return node.children.map(Node.string).join('');
    }
  },

  /**
   * Return an iterable of all leaf text nodes in a root node.
   */
  *texts(root) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    for (var [node, path] of Node.nodes(root, options)) {
      if (Text.isText(node)) {
        yield [node, path];
      }
    }
  }

};

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var Operation = {
  /**
   * Check of a value is a `NodeOperation` object.
   */
  isNodeOperation(value) {
    return Operation.isOperation(value) && value.type.endsWith('_node');
  },

  /**
   * Check of a value is an `Operation` object.
   */
  isOperation(value) {
    if (!Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
      return false;
    }

    switch (value.type) {
      case 'insert_node':
        return Path.isPath(value.path) && Node.isNode(value.node);

      case 'insert_text':
        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);

      case 'merge_node':
        return typeof value.position === 'number' && (typeof value.target === 'number' || value.target === null) && Path.isPath(value.path) && Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value.properties);

      case 'move_node':
        return Path.isPath(value.path) && Path.isPath(value.newPath);

      case 'remove_node':
        return Path.isPath(value.path) && Node.isNode(value.node);

      case 'remove_text':
        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);

      case 'set_node':
        return Path.isPath(value.path) && Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value.properties) && Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value.newProperties);

      case 'set_selection':
        return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value.properties) && Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value.newProperties);

      case 'split_node':
        return Path.isPath(value.path) && typeof value.position === 'number' && (typeof value.target === 'number' || value.target === null) && Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value.properties);

      default:
        return false;
    }
  },

  /**
   * Check if a value is a list of `Operation` objects.
   */
  isOperationList(value) {
    return Array.isArray(value) && (value.length === 0 || Operation.isOperation(value[0]));
  },

  /**
   * Check of a value is a `SelectionOperation` object.
   */
  isSelectionOperation(value) {
    return Operation.isOperation(value) && value.type.endsWith('_selection');
  },

  /**
   * Check of a value is a `TextOperation` object.
   */
  isTextOperation(value) {
    return Operation.isOperation(value) && value.type.endsWith('_text');
  },

  /**
   * Invert an operation, returning a new operation that will exactly undo the
   * original when applied.
   */
  inverse(op) {
    switch (op.type) {
      case 'insert_node':
        {
          return _objectSpread$1({}, op, {
            type: 'remove_node'
          });
        }

      case 'insert_text':
        {
          return _objectSpread$1({}, op, {
            type: 'remove_text'
          });
        }

      case 'merge_node':
        {
          return _objectSpread$1({}, op, {
            type: 'split_node',
            path: Path.previous(op.path)
          });
        }

      case 'move_node':
        {
          var {
            newPath,
            path
          } = op; // PERF: in this case the move operation is a no-op anyways.

          if (Path.equals(newPath, path)) {
            return op;
          } // If the move happens completely within a single parent the path and
          // newPath are stable with respect to each other.


          if (Path.isSibling(path, newPath)) {
            return _objectSpread$1({}, op, {
              path: newPath,
              newPath: path
            });
          } // If the move does not happen within a single parent it is possible
          // for the move to impact the true path to the location where the node
          // was removed from and where it was inserted. We have to adjust for this
          // and find the original path. We can accomplish this (only in non-sibling)
          // moves by looking at the impact of the move operation on the node
          // after the original move path.


          var inversePath = Path.transform(path, op);
          var inverseNewPath = Path.transform(Path.next(path), op);
          return _objectSpread$1({}, op, {
            path: inversePath,
            newPath: inverseNewPath
          });
        }

      case 'remove_node':
        {
          return _objectSpread$1({}, op, {
            type: 'insert_node'
          });
        }

      case 'remove_text':
        {
          return _objectSpread$1({}, op, {
            type: 'insert_text'
          });
        }

      case 'set_node':
        {
          var {
            properties,
            newProperties
          } = op;
          return _objectSpread$1({}, op, {
            properties: newProperties,
            newProperties: properties
          });
        }

      case 'set_selection':
        {
          var {
            properties: _properties,
            newProperties: _newProperties
          } = op;

          if (_properties == null) {
            return _objectSpread$1({}, op, {
              properties: _newProperties,
              newProperties: null
            });
          } else if (_newProperties == null) {
            return _objectSpread$1({}, op, {
              properties: null,
              newProperties: _properties
            });
          } else {
            return _objectSpread$1({}, op, {
              properties: _newProperties,
              newProperties: _properties
            });
          }
        }

      case 'split_node':
        {
          return _objectSpread$1({}, op, {
            type: 'merge_node',
            path: Path.next(op.path)
          });
        }
    }
  }

};

var Path = {
  /**
   * Get a list of ancestor paths for a given path.
   *
   * The paths are sorted from deepest to shallowest ancestor. However, if the
   * `reverse: true` option is passed, they are reversed.
   */
  ancestors(path) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      reverse = false
    } = options;
    var paths = Path.levels(path, options);

    if (reverse) {
      paths = paths.slice(1);
    } else {
      paths = paths.slice(0, -1);
    }

    return paths;
  },

  /**
   * Get the common ancestor path of two paths.
   */
  common(path, another) {
    var common = [];

    for (var i = 0; i < path.length && i < another.length; i++) {
      var av = path[i];
      var bv = another[i];

      if (av !== bv) {
        break;
      }

      common.push(av);
    }

    return common;
  },

  /**
   * Compare a path to another, returning an integer indicating whether the path
   * was before, at, or after the other.
   *
   * Note: Two paths of unequal length can still receive a `0` result if one is
   * directly above or below the other. If you want exact matching, use
   * [[Path.equals]] instead.
   */
  compare(path, another) {
    var min = Math.min(path.length, another.length);

    for (var i = 0; i < min; i++) {
      if (path[i] < another[i]) return -1;
      if (path[i] > another[i]) return 1;
    }

    return 0;
  },

  /**
   * Check if a path ends after one of the indexes in another.
   */
  endsAfter(path, another) {
    var i = path.length - 1;
    var as = path.slice(0, i);
    var bs = another.slice(0, i);
    var av = path[i];
    var bv = another[i];
    return Path.equals(as, bs) && av > bv;
  },

  /**
   * Check if a path ends at one of the indexes in another.
   */
  endsAt(path, another) {
    var i = path.length;
    var as = path.slice(0, i);
    var bs = another.slice(0, i);
    return Path.equals(as, bs);
  },

  /**
   * Check if a path ends before one of the indexes in another.
   */
  endsBefore(path, another) {
    var i = path.length - 1;
    var as = path.slice(0, i);
    var bs = another.slice(0, i);
    var av = path[i];
    var bv = another[i];
    return Path.equals(as, bs) && av < bv;
  },

  /**
   * Check if a path is exactly equal to another.
   */
  equals(path, another) {
    return path.length === another.length && path.every((n, i) => n === another[i]);
  },

  /**
   * Check if a path is after another.
   */
  isAfter(path, another) {
    return Path.compare(path, another) === 1;
  },

  /**
   * Check if a path is an ancestor of another.
   */
  isAncestor(path, another) {
    return path.length < another.length && Path.compare(path, another) === 0;
  },

  /**
   * Check if a path is before another.
   */
  isBefore(path, another) {
    return Path.compare(path, another) === -1;
  },

  /**
   * Check if a path is a child of another.
   */
  isChild(path, another) {
    return path.length === another.length + 1 && Path.compare(path, another) === 0;
  },

  /**
   * Check if a path is equal to or an ancestor of another.
   */
  isCommon(path, another) {
    return path.length <= another.length && Path.compare(path, another) === 0;
  },

  /**
   * Check if a path is a descendant of another.
   */
  isDescendant(path, another) {
    return path.length > another.length && Path.compare(path, another) === 0;
  },

  /**
   * Check if a path is the parent of another.
   */
  isParent(path, another) {
    return path.length + 1 === another.length && Path.compare(path, another) === 0;
  },

  /**
   * Check is a value implements the `Path` interface.
   */
  isPath(value) {
    return Array.isArray(value) && (value.length === 0 || typeof value[0] === 'number');
  },

  /**
   * Check if a path is a sibling of another.
   */
  isSibling(path, another) {
    if (path.length !== another.length) {
      return false;
    }

    var as = path.slice(0, -1);
    var bs = another.slice(0, -1);
    var al = path[path.length - 1];
    var bl = another[another.length - 1];
    return al !== bl && Path.equals(as, bs);
  },

  /**
   * Get a list of paths at every level down to a path. Note: this is the same
   * as `Path.ancestors`, but including the path itself.
   *
   * The paths are sorted from shallowest to deepest. However, if the `reverse:
   * true` option is passed, they are reversed.
   */
  levels(path) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      reverse = false
    } = options;
    var list = [];

    for (var i = 0; i <= path.length; i++) {
      list.push(path.slice(0, i));
    }

    if (reverse) {
      list.reverse();
    }

    return list;
  },

  /**
   * Given a path, get the path to the next sibling node.
   */
  next(path) {
    if (path.length === 0) {
      throw new Error("Cannot get the next path of a root path [".concat(path, "], because it has no next index."));
    }

    var last = path[path.length - 1];
    return path.slice(0, -1).concat(last + 1);
  },

  /**
   * Given a path, return a new path referring to the parent node above it.
   */
  parent(path) {
    if (path.length === 0) {
      throw new Error("Cannot get the parent path of the root path [".concat(path, "]."));
    }

    return path.slice(0, -1);
  },

  /**
   * Given a path, get the path to the previous sibling node.
   */
  previous(path) {
    if (path.length === 0) {
      throw new Error("Cannot get the previous path of a root path [".concat(path, "], because it has no previous index."));
    }

    var last = path[path.length - 1];

    if (last <= 0) {
      throw new Error("Cannot get the previous path of a first child path [".concat(path, "] because it would result in a negative index."));
    }

    return path.slice(0, -1).concat(last - 1);
  },

  /**
   * Get a path relative to an ancestor.
   */
  relative(path, ancestor) {
    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {
      throw new Error("Cannot get the relative path of [".concat(path, "] inside ancestor [").concat(ancestor, "], because it is not above or equal to the path."));
    }

    return path.slice(ancestor.length);
  },

  /**
   * Transform a path by an operation.
   */
  transform(path, operation) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return Object(immer__WEBPACK_IMPORTED_MODULE_1__["produce"])(path, p => {
      var {
        affinity = 'forward'
      } = options; // PERF: Exit early if the operation is guaranteed not to have an effect.

      if (path.length === 0) {
        return;
      }

      switch (operation.type) {
        case 'insert_node':
          {
            var {
              path: op
            } = operation;

            if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {
              p[op.length - 1] += 1;
            }

            break;
          }

        case 'remove_node':
          {
            var {
              path: _op
            } = operation;

            if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {
              return null;
            } else if (Path.endsBefore(_op, p)) {
              p[_op.length - 1] -= 1;
            }

            break;
          }

        case 'merge_node':
          {
            var {
              path: _op2,
              position
            } = operation;

            if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {
              p[_op2.length - 1] -= 1;
            } else if (Path.isAncestor(_op2, p)) {
              p[_op2.length - 1] -= 1;
              p[_op2.length] += position;
            }

            break;
          }

        case 'split_node':
          {
            var {
              path: _op3,
              position: _position
            } = operation;

            if (Path.equals(_op3, p)) {
              if (affinity === 'forward') {
                p[p.length - 1] += 1;
              } else if (affinity === 'backward') ; else {
                return null;
              }
            } else if (Path.endsBefore(_op3, p)) {
              p[_op3.length - 1] += 1;
            } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {
              p[_op3.length - 1] += 1;
              p[_op3.length] -= _position;
            }

            break;
          }

        case 'move_node':
          {
            var {
              path: _op4,
              newPath: onp
            } = operation; // If the old and new path are the same, it's a no-op.

            if (Path.equals(_op4, onp)) {
              return;
            }

            if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {
              var copy = onp.slice();

              if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {
                copy[_op4.length - 1] -= 1;
              }

              return copy.concat(p.slice(_op4.length));
            } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {
              if (Path.endsBefore(_op4, p)) {
                p[_op4.length - 1] -= 1;
              } else {
                p[_op4.length - 1] += 1;
              }
            } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {
              if (Path.endsBefore(_op4, p)) {
                p[_op4.length - 1] -= 1;
              }

              p[onp.length - 1] += 1;
            } else if (Path.endsBefore(_op4, p)) {
              if (Path.equals(onp, p)) {
                p[onp.length - 1] += 1;
              }

              p[_op4.length - 1] -= 1;
            }

            break;
          }
      }
    });
  }

};

var PathRef = {
  /**
   * Transform the path ref's current value by an operation.
   */
  transform(ref, op) {
    var {
      current,
      affinity
    } = ref;

    if (current == null) {
      return;
    }

    var path = Path.transform(current, op, {
      affinity
    });
    ref.current = path;

    if (path == null) {
      ref.unref();
    }
  }

};

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var Point = {
  /**
   * Compare a point to another, returning an integer indicating whether the
   * point was before, at, or after the other.
   */
  compare(point, another) {
    var result = Path.compare(point.path, another.path);

    if (result === 0) {
      if (point.offset < another.offset) return -1;
      if (point.offset > another.offset) return 1;
      return 0;
    }

    return result;
  },

  /**
   * Check if a point is after another.
   */
  isAfter(point, another) {
    return Point.compare(point, another) === 1;
  },

  /**
   * Check if a point is before another.
   */
  isBefore(point, another) {
    return Point.compare(point, another) === -1;
  },

  /**
   * Check if a point is exactly equal to another.
   */
  equals(point, another) {
    // PERF: ensure the offsets are equal first since they are cheaper to check.
    return point.offset === another.offset && Path.equals(point.path, another.path);
  },

  /**
   * Check if a value implements the `Point` interface.
   */
  isPoint(value) {
    return Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && typeof value.offset === 'number' && Path.isPath(value.path);
  },

  /**
   * Transform a point by an operation.
   */
  transform(point, op) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return Object(immer__WEBPACK_IMPORTED_MODULE_1__["produce"])(point, p => {
      var {
        affinity = 'forward'
      } = options;
      var {
        path,
        offset
      } = p;

      switch (op.type) {
        case 'insert_node':
        case 'move_node':
          {
            p.path = Path.transform(path, op, options);
            break;
          }

        case 'insert_text':
          {
            if (Path.equals(op.path, path) && op.offset <= offset) {
              p.offset += op.text.length;
            }

            break;
          }

        case 'merge_node':
          {
            if (Path.equals(op.path, path)) {
              p.offset += op.position;
            }

            p.path = Path.transform(path, op, options);
            break;
          }

        case 'remove_text':
          {
            if (Path.equals(op.path, path) && op.offset <= offset) {
              p.offset -= Math.min(offset - op.offset, op.text.length);
            }

            break;
          }

        case 'remove_node':
          {
            if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {
              return null;
            }

            p.path = Path.transform(path, op, options);
            break;
          }

        case 'split_node':
          {
            if (Path.equals(op.path, path)) {
              if (op.position === offset && affinity == null) {
                return null;
              } else if (op.position < offset || op.position === offset && affinity === 'forward') {
                p.offset -= op.position;
                p.path = Path.transform(path, op, _objectSpread$2({}, options, {
                  affinity: 'forward'
                }));
              }
            } else {
              p.path = Path.transform(path, op, options);
            }

            break;
          }
      }
    });
  }

};

var PointRef = {
  /**
   * Transform the point ref's current value by an operation.
   */
  transform(ref, op) {
    var {
      current,
      affinity
    } = ref;

    if (current == null) {
      return;
    }

    var point = Point.transform(current, op, {
      affinity
    });
    ref.current = point;

    if (point == null) {
      ref.unref();
    }
  }

};

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var Range = {
  /**
   * Get the start and end points of a range, in the order in which they appear
   * in the document.
   */
  edges(range) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      reverse = false
    } = options;
    var {
      anchor,
      focus
    } = range;
    return Range.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];
  },

  /**
   * Get the end point of a range.
   */
  end(range) {
    var [, end] = Range.edges(range);
    return end;
  },

  /**
   * Check if a range is exactly equal to another.
   */
  equals(range, another) {
    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);
  },

  /**
   * Check if a range includes a path, a point or part of another range.
   */
  includes(range, target) {
    if (Range.isRange(target)) {
      if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {
        return true;
      }

      var [rs, re] = Range.edges(range);
      var [ts, te] = Range.edges(target);
      return Point.isBefore(rs, ts) && Point.isAfter(re, te);
    }

    var [start, end] = Range.edges(range);
    var isAfterStart = false;
    var isBeforeEnd = false;

    if (Point.isPoint(target)) {
      isAfterStart = Point.compare(target, start) >= 0;
      isBeforeEnd = Point.compare(target, end) <= 0;
    } else {
      isAfterStart = Path.compare(target, start.path) >= 0;
      isBeforeEnd = Path.compare(target, end.path) <= 0;
    }

    return isAfterStart && isBeforeEnd;
  },

  /**
   * Get the intersection of a range with another.
   */
  intersection(range, another) {
    var rest = _objectWithoutProperties(range, ["anchor", "focus"]);

    var [s1, e1] = Range.edges(range);
    var [s2, e2] = Range.edges(another);
    var start = Point.isBefore(s1, s2) ? s2 : s1;
    var end = Point.isBefore(e1, e2) ? e1 : e2;

    if (Point.isBefore(end, start)) {
      return null;
    } else {
      return _objectSpread$3({
        anchor: start,
        focus: end
      }, rest);
    }
  },

  /**
   * Check if a range is backward, meaning that its anchor point appears in the
   * document _after_ its focus point.
   */
  isBackward(range) {
    var {
      anchor,
      focus
    } = range;
    return Point.isAfter(anchor, focus);
  },

  /**
   * Check if a range is collapsed, meaning that both its anchor and focus
   * points refer to the exact same position in the document.
   */
  isCollapsed(range) {
    var {
      anchor,
      focus
    } = range;
    return Point.equals(anchor, focus);
  },

  /**
   * Check if a range is expanded.
   *
   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.
   */
  isExpanded(range) {
    return !Range.isCollapsed(range);
  },

  /**
   * Check if a range is forward.
   *
   * This is the opposite of [[Range.isBackward]] and is provided for legibility.
   */
  isForward(range) {
    return !Range.isBackward(range);
  },

  /**
   * Check if a value implements the [[Range]] interface.
   */
  isRange(value) {
    return Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);
  },

  /**
   * Iterate through all of the point entries in a range.
   */
  *points(range) {
    yield [range.anchor, 'anchor'];
    yield [range.focus, 'focus'];
  },

  /**
   * Get the start point of a range.
   */
  start(range) {
    var [start] = Range.edges(range);
    return start;
  },

  /**
   * Transform a range by an operation.
   */
  transform(range, op, options) {
    var {
      affinity = 'inward'
    } = options;
    var affinityAnchor;
    var affinityFocus;

    if (affinity === 'inward') {
      if (Range.isForward(range)) {
        affinityAnchor = 'forward';
        affinityFocus = 'backward';
      } else {
        affinityAnchor = 'backward';
        affinityFocus = 'forward';
      }
    } else if (affinity === 'outward') {
      if (Range.isForward(range)) {
        affinityAnchor = 'backward';
        affinityFocus = 'forward';
      } else {
        affinityAnchor = 'forward';
        affinityFocus = 'backward';
      }
    } else {
      affinityAnchor = affinity;
      affinityFocus = affinity;
    }

    return Object(immer__WEBPACK_IMPORTED_MODULE_1__["produce"])(range, r => {
      var anchor = Point.transform(r.anchor, op, {
        affinity: affinityAnchor
      });
      var focus = Point.transform(r.focus, op, {
        affinity: affinityFocus
      });

      if (!anchor || !focus) {
        return null;
      }

      r.anchor = anchor;
      r.focus = focus;
    });
  }

};

var RangeRef = {
  /**
   * Transform the range ref's current value by an operation.
   */
  transform(ref, op) {
    var {
      current,
      affinity
    } = ref;

    if (current == null) {
      return;
    }

    var path = Range.transform(current, op, {
      affinity
    });
    ref.current = path;

    if (path == null) {
      ref.unref();
    }
  }

};

function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var Text = {
  /**
   * Check if two text nodes are equal.
   */
  equals(text, another) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      loose = false
    } = options;

    for (var key in text) {
      if (loose && key === 'text') {
        continue;
      }

      if (text[key] !== another[key]) {
        return false;
      }
    }

    for (var _key in another) {
      if (loose && _key === 'text') {
        continue;
      }

      if (text[_key] !== another[_key]) {
        return false;
      }
    }

    return true;
  },

  /**
   * Check if a value implements the `Text` interface.
   */
  isText(value) {
    return Object(is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && typeof value.text === 'string';
  },

  /**
   * Check if a value is a list of `Text` objects.
   */
  isTextList(value) {
    return Array.isArray(value) && (value.length === 0 || Text.isText(value[0]));
  },

  /**
   * Check if an text matches set of properties.
   *
   * Note: this is for matching custom properties, and it does not ensure that
   * the `text` property are two nodes equal.
   */
  matches(text, props) {
    for (var key in props) {
      if (key === 'text') {
        continue;
      }

      if (text[key] !== props[key]) {
        return false;
      }
    }

    return true;
  },

  /**
   * Get the leaves for a text node given decorations.
   */
  decorations(node, decorations) {
    var leaves = [_objectSpread$4({}, node)];

    for (var dec of decorations) {
      var rest = _objectWithoutProperties(dec, ["anchor", "focus"]);

      var [start, end] = Range.edges(dec);
      var next = [];
      var o = 0;

      for (var leaf of leaves) {
        var {
          length
        } = leaf.text;
        var offset = o;
        o += length; // If the range encompases the entire leaf, add the range.

        if (start.offset <= offset && end.offset >= offset + length) {
          Object.assign(leaf, rest);
          next.push(leaf);
          continue;
        } // If the range starts after the leaf, or ends before it, continue.


        if (start.offset > offset + length || end.offset < offset || end.offset === offset && offset !== 0) {
          next.push(leaf);
          continue;
        } // Otherwise we need to split the leaf, at the start, end, or both,
        // and add the range to the middle intersecting section. Do the end
        // split first since we don't need to update the offset that way.


        var middle = leaf;
        var before = void 0;
        var after = void 0;

        if (end.offset < offset + length) {
          var off = end.offset - offset;
          after = _objectSpread$4({}, middle, {
            text: middle.text.slice(off)
          });
          middle = _objectSpread$4({}, middle, {
            text: middle.text.slice(0, off)
          });
        }

        if (start.offset > offset) {
          var _off = start.offset - offset;

          before = _objectSpread$4({}, middle, {
            text: middle.text.slice(0, _off)
          });
          middle = _objectSpread$4({}, middle, {
            text: middle.text.slice(_off)
          });
        }

        Object.assign(middle, rest);

        if (before) {
          next.push(before);
        }

        next.push(middle);

        if (after) {
          next.push(after);
        }
      }

      leaves = next;
    }

    return leaves;
  }

};

function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var GeneralTransforms = {
  /**
   * Transform the editor by an operation.
   */
  transform(editor, op) {
    editor.children = Object(immer__WEBPACK_IMPORTED_MODULE_1__["createDraft"])(editor.children);
    var selection = editor.selection && Object(immer__WEBPACK_IMPORTED_MODULE_1__["createDraft"])(editor.selection);

    switch (op.type) {
      case 'insert_node':
        {
          var {
            path,
            node
          } = op;
          var parent = Node.parent(editor, path);
          var index = path[path.length - 1];
          parent.children.splice(index, 0, node);

          if (selection) {
            for (var [point, key] of Range.points(selection)) {
              selection[key] = Point.transform(point, op);
            }
          }

          break;
        }

      case 'insert_text':
        {
          var {
            path: _path,
            offset,
            text
          } = op;

          var _node = Node.leaf(editor, _path);

          var before = _node.text.slice(0, offset);

          var after = _node.text.slice(offset);

          _node.text = before + text + after;

          if (selection) {
            for (var [_point, _key] of Range.points(selection)) {
              selection[_key] = Point.transform(_point, op);
            }
          }

          break;
        }

      case 'merge_node':
        {
          var {
            path: _path2
          } = op;

          var _node2 = Node.get(editor, _path2);

          var prevPath = Path.previous(_path2);
          var prev = Node.get(editor, prevPath);

          var _parent = Node.parent(editor, _path2);

          var _index = _path2[_path2.length - 1];

          if (Text.isText(_node2) && Text.isText(prev)) {
            prev.text += _node2.text;
          } else if (!Text.isText(_node2) && !Text.isText(prev)) {
            prev.children.push(..._node2.children);
          } else {
            throw new Error("Cannot apply a \"merge_node\" operation at path [".concat(_path2, "] to nodes of different interaces: ").concat(_node2, " ").concat(prev));
          }

          _parent.children.splice(_index, 1);

          if (selection) {
            for (var [_point2, _key2] of Range.points(selection)) {
              selection[_key2] = Point.transform(_point2, op);
            }
          }

          break;
        }

      case 'move_node':
        {
          var {
            path: _path3,
            newPath
          } = op;

          if (Path.isAncestor(_path3, newPath)) {
            throw new Error("Cannot move a path [".concat(_path3, "] to new path [").concat(newPath, "] because the destination is inside itself."));
          }

          var _node3 = Node.get(editor, _path3);

          var _parent2 = Node.parent(editor, _path3);

          var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to
          // the same snapshot in time, there's a mismatch. After either
          // removing the original position, the second step's path can be out
          // of date. So instead of using the `op.newPath` directly, we
          // transform `op.path` to ascertain what the `newPath` would be after
          // the operation was applied.

          _parent2.children.splice(_index2, 1);

          var truePath = Path.transform(_path3, op);
          var newParent = Node.get(editor, Path.parent(truePath));
          var newIndex = truePath[truePath.length - 1];
          newParent.children.splice(newIndex, 0, _node3);

          if (selection) {
            for (var [_point3, _key3] of Range.points(selection)) {
              selection[_key3] = Point.transform(_point3, op);
            }
          }

          break;
        }

      case 'remove_node':
        {
          var {
            path: _path4
          } = op;
          var _index3 = _path4[_path4.length - 1];

          var _parent3 = Node.parent(editor, _path4);

          _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the
          // node that was removed we need to update the range or remove it.


          if (selection) {
            for (var [_point4, _key4] of Range.points(selection)) {
              var result = Point.transform(_point4, op);

              if (selection != null && result != null) {
                selection[_key4] = result;
              } else {
                var _prev = void 0;

                var next = void 0;

                for (var [n, p] of Node.texts(editor)) {
                  if (Path.compare(p, _path4) === -1) {
                    _prev = [n, p];
                  } else {
                    next = [n, p];
                    break;
                  }
                }

                if (_prev) {
                  _point4.path = _prev[1];
                  _point4.offset = _prev[0].text.length;
                } else if (next) {
                  _point4.path = next[1];
                  _point4.offset = 0;
                } else {
                  selection = null;
                }
              }
            }
          }

          break;
        }

      case 'remove_text':
        {
          var {
            path: _path5,
            offset: _offset,
            text: _text
          } = op;

          var _node4 = Node.leaf(editor, _path5);

          var _before = _node4.text.slice(0, _offset);

          var _after = _node4.text.slice(_offset + _text.length);

          _node4.text = _before + _after;

          if (selection) {
            for (var [_point5, _key5] of Range.points(selection)) {
              selection[_key5] = Point.transform(_point5, op);
            }
          }

          break;
        }

      case 'set_node':
        {
          var {
            path: _path6,
            newProperties
          } = op;

          if (_path6.length === 0) {
            throw new Error("Cannot set properties on the root node!");
          }

          var _node5 = Node.get(editor, _path6);

          for (var _key6 in newProperties) {
            if (_key6 === 'children' || _key6 === 'text') {
              throw new Error("Cannot set the \"".concat(_key6, "\" property of nodes!"));
            }

            var value = newProperties[_key6];

            if (value == null) {
              delete _node5[_key6];
            } else {
              _node5[_key6] = value;
            }
          }

          break;
        }

      case 'set_selection':
        {
          var {
            newProperties: _newProperties
          } = op;

          if (_newProperties == null) {
            selection = _newProperties;
          } else if (selection == null) {
            if (!Range.isRange(_newProperties)) {
              throw new Error("Cannot apply an incomplete \"set_selection\" operation properties ".concat(JSON.stringify(_newProperties), " when there is no current selection."));
            }

            selection = _newProperties;
          } else {
            Object.assign(selection, _newProperties);
          }

          break;
        }

      case 'split_node':
        {
          var {
            path: _path7,
            position,
            properties
          } = op;

          if (_path7.length === 0) {
            throw new Error("Cannot apply a \"split_node\" operation at path [".concat(_path7, "] because the root node cannot be split."));
          }

          var _node6 = Node.get(editor, _path7);

          var _parent4 = Node.parent(editor, _path7);

          var _index4 = _path7[_path7.length - 1];
          var newNode;

          if (Text.isText(_node6)) {
            var _before2 = _node6.text.slice(0, position);

            var _after2 = _node6.text.slice(position);

            _node6.text = _before2;
            newNode = _objectSpread$5({}, _node6, {}, properties, {
              text: _after2
            });
          } else {
            var _before3 = _node6.children.slice(0, position);

            var _after3 = _node6.children.slice(position);

            _node6.children = _before3;
            newNode = _objectSpread$5({}, _node6, {}, properties, {
              children: _after3
            });
          }

          _parent4.children.splice(_index4 + 1, 0, newNode);

          if (selection) {
            for (var [_point6, _key7] of Range.points(selection)) {
              selection[_key7] = Point.transform(_point6, op);
            }
          }

          break;
        }
    }

    editor.children = Object(immer__WEBPACK_IMPORTED_MODULE_1__["finishDraft"])(editor.children);

    if (selection) {
      editor.selection = Object(immer__WEBPACK_IMPORTED_MODULE_1__["isDraft"])(selection) ? Object(immer__WEBPACK_IMPORTED_MODULE_1__["finishDraft"])(selection) : selection;
    } else {
      editor.selection = null;
    }
  }

};

function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var NodeTransforms = {
  /**
   * Insert nodes at a specific location in the Editor.
   */
  insertNodes(editor, nodes) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false,
        mode = 'lowest'
      } = options;
      var {
        at,
        match,
        select
      } = options;

      if (Node.isNode(nodes)) {
        nodes = [nodes];
      }

      if (nodes.length === 0) {
        return;
      }

      var [node] = nodes; // By default, use the selection as the target location. But if there is
      // no selection, insert at the end of the document since that is such a
      // common use case when inserting from a non-selected state.

      if (!at) {
        if (editor.selection) {
          at = editor.selection;
        } else if (editor.children.length > 0) {
          at = Editor.end(editor, []);
        } else {
          at = [0];
        }

        select = true;
      }

      if (select == null) {
        select = false;
      }

      if (Range.isRange(at)) {
        if (!hanging) {
          at = Editor.unhangRange(editor, at);
        }

        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var [, end] = Range.edges(at);
          var pointRef = Editor.pointRef(editor, end);
          Transforms.delete(editor, {
            at
          });
          at = pointRef.unref();
        }
      }

      if (Point.isPoint(at)) {
        if (match == null) {
          if (Text.isText(node)) {
            match = n => Text.isText(n);
          } else if (editor.isInline(node)) {
            match = n => Text.isText(n) || Editor.isInline(editor, n);
          } else {
            match = n => Editor.isBlock(editor, n);
          }
        }

        var [entry] = Editor.nodes(editor, {
          at: at.path,
          match,
          mode,
          voids
        });

        if (entry) {
          var [, _matchPath] = entry;
          var pathRef = Editor.pathRef(editor, _matchPath);
          var isAtEnd = Editor.isEnd(editor, at, _matchPath);
          Transforms.splitNodes(editor, {
            at,
            match,
            mode,
            voids
          });
          var path = pathRef.unref();
          at = isAtEnd ? Path.next(path) : path;
        } else {
          return;
        }
      }

      var parentPath = Path.parent(at);
      var index = at[at.length - 1];

      if (!voids && Editor.void(editor, {
        at: parentPath
      })) {
        return;
      }

      for (var _node of nodes) {
        var _path = parentPath.concat(index);

        index++;
        editor.apply({
          type: 'insert_node',
          path: _path,
          node: _node
        });
      }

      if (select) {
        var point = Editor.end(editor, at);

        if (point) {
          Transforms.select(editor, point);
        }
      }
    });
  },

  /**
   * Lift nodes at a specific location upwards in the document tree, splitting
   * their parent in two if necessary.
   */
  liftNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        at = editor.selection,
        mode = 'lowest',
        voids = false
      } = options;
      var {
        match
      } = options;

      if (match == null) {
        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);
      }

      if (!at) {
        return;
      }

      var matches = Editor.nodes(editor, {
        at,
        match,
        mode,
        voids
      });
      var pathRefs = Array.from(matches, (_ref) => {
        var [, p] = _ref;
        return Editor.pathRef(editor, p);
      });

      for (var pathRef of pathRefs) {
        var path = pathRef.unref();

        if (path.length < 2) {
          throw new Error("Cannot lift node at a path [".concat(path, "] because it has a depth of less than `2`."));
        }

        var parentNodeEntry = Editor.node(editor, Path.parent(path));
        var [parent, parentPath] = parentNodeEntry;
        var index = path[path.length - 1];
        var {
          length
        } = parent.children;

        if (length === 1) {
          var toPath = Path.next(parentPath);
          Transforms.moveNodes(editor, {
            at: path,
            to: toPath,
            voids
          });
          Transforms.removeNodes(editor, {
            at: parentPath,
            voids
          });
        } else if (index === 0) {
          Transforms.moveNodes(editor, {
            at: path,
            to: parentPath,
            voids
          });
        } else if (index === length - 1) {
          var _toPath = Path.next(parentPath);

          Transforms.moveNodes(editor, {
            at: path,
            to: _toPath,
            voids
          });
        } else {
          var splitPath = Path.next(path);

          var _toPath2 = Path.next(parentPath);

          Transforms.splitNodes(editor, {
            at: splitPath,
            voids
          });
          Transforms.moveNodes(editor, {
            at: path,
            to: _toPath2,
            voids
          });
        }
      }
    });
  },

  /**
   * Merge a node at a location with the previous node of the same depth,
   * removing any empty containing nodes after the merge if necessary.
   */
  mergeNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        match,
        at = editor.selection
      } = options;
      var {
        hanging = false,
        voids = false,
        mode = 'lowest'
      } = options;

      if (!at) {
        return;
      }

      if (match == null) {
        if (Path.isPath(at)) {
          var [parent] = Editor.parent(editor, at);

          match = n => parent.children.includes(n);
        } else {
          match = n => Editor.isBlock(editor, n);
        }
      }

      if (!hanging && Range.isRange(at)) {
        at = Editor.unhangRange(editor, at);
      }

      if (Range.isRange(at)) {
        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var [, end] = Range.edges(at);
          var pointRef = Editor.pointRef(editor, end);
          Transforms.delete(editor, {
            at
          });
          at = pointRef.unref();

          if (options.at == null) {
            Transforms.select(editor, at);
          }
        }
      }

      var [current] = Editor.nodes(editor, {
        at,
        match,
        voids,
        mode
      });
      var prev = Editor.previous(editor, {
        at,
        match,
        voids,
        mode
      });

      if (!current || !prev) {
        return;
      }

      var [node, path] = current;
      var [prevNode, prevPath] = prev;

      if (path.length === 0 || prevPath.length === 0) {
        return;
      }

      var newPath = Path.next(prevPath);
      var commonPath = Path.common(path, prevPath);
      var isPreviousSibling = Path.isSibling(path, prevPath);
      var levels = Array.from(Editor.levels(editor, {
        at: path
      }), (_ref2) => {
        var [n] = _ref2;
        return n;
      }).slice(commonPath.length).slice(0, -1); // Determine if the merge will leave an ancestor of the path empty as a
      // result, in which case we'll want to remove it after merging.

      var emptyAncestor = Editor.above(editor, {
        at: path,
        mode: 'highest',
        match: n => levels.includes(n) && Element.isElement(n) && n.children.length === 1
      });
      var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);
      var properties;
      var position; // Ensure that the nodes are equivalent, and figure out what the position
      // and extra properties of the merge will be.

      if (Text.isText(node) && Text.isText(prevNode)) {
        var rest = _objectWithoutProperties(node, ["text"]);

        position = prevNode.text.length;
        properties = rest;
      } else if (Element.isElement(node) && Element.isElement(prevNode)) {
        var rest = _objectWithoutProperties(node, ["children"]);

        position = prevNode.children.length;
        properties = rest;
      } else {
        throw new Error("Cannot merge the node at path [".concat(path, "] with the previous sibling because it is not the same kind: ").concat(JSON.stringify(node), " ").concat(JSON.stringify(prevNode)));
      } // If the node isn't already the next sibling of the previous node, move
      // it so that it is before merging.


      if (!isPreviousSibling) {
        Transforms.moveNodes(editor, {
          at: path,
          to: newPath,
          voids
        });
      } // If there was going to be an empty ancestor of the node that was merged,
      // we remove it from the tree.


      if (emptyRef) {
        Transforms.removeNodes(editor, {
          at: emptyRef.current,
          voids
        });
      } // If the target node that we're merging with is empty, remove it instead
      // of merging the two. This is a common rich text editor behavior to
      // prevent losing formatting when deleting entire nodes when you have a
      // hanging selection.


      if (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === '') {
        Transforms.removeNodes(editor, {
          at: prevPath,
          voids
        });
      } else {
        editor.apply({
          type: 'merge_node',
          path: newPath,
          position,
          target: null,
          properties
        });
      }

      if (emptyRef) {
        emptyRef.unref();
      }
    });
  },

  /**
   * Move the nodes at a location to a new location.
   */
  moveNodes(editor, options) {
    Editor.withoutNormalizing(editor, () => {
      var {
        to,
        at = editor.selection,
        mode = 'lowest',
        voids = false
      } = options;
      var {
        match
      } = options;

      if (!at) {
        return;
      }

      if (match == null) {
        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);
      }

      var toRef = Editor.pathRef(editor, to);
      var targets = Editor.nodes(editor, {
        at,
        match,
        mode,
        voids
      });
      var pathRefs = Array.from(targets, (_ref3) => {
        var [, p] = _ref3;
        return Editor.pathRef(editor, p);
      });

      for (var pathRef of pathRefs) {
        var path = pathRef.unref();
        var newPath = toRef.current;

        if (path.length !== 0) {
          editor.apply({
            type: 'move_node',
            path,
            newPath
          });
        }
      }

      toRef.unref();
    });
  },

  /**
   * Remove the nodes at a specific location in the document.
   */
  removeNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false,
        mode = 'lowest'
      } = options;
      var {
        at = editor.selection,
        match
      } = options;

      if (!at) {
        return;
      }

      if (match == null) {
        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);
      }

      if (!hanging && Range.isRange(at)) {
        at = Editor.unhangRange(editor, at);
      }

      var depths = Editor.nodes(editor, {
        at,
        match,
        mode,
        voids
      });
      var pathRefs = Array.from(depths, (_ref4) => {
        var [, p] = _ref4;
        return Editor.pathRef(editor, p);
      });

      for (var pathRef of pathRefs) {
        var path = pathRef.unref();

        if (path) {
          var [node] = Editor.node(editor, path);
          editor.apply({
            type: 'remove_node',
            path,
            node
          });
        }
      }
    });
  },

  /**
   * Set new properties on the nodes at a location.
   */
  setNodes(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        match,
        at = editor.selection
      } = options;
      var {
        hanging = false,
        mode = 'lowest',
        split = false,
        voids = false
      } = options;

      if (!at) {
        return;
      }

      if (match == null) {
        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);
      }

      if (!hanging && Range.isRange(at)) {
        at = Editor.unhangRange(editor, at);
      }

      if (split && Range.isRange(at)) {
        var rangeRef = Editor.rangeRef(editor, at, {
          affinity: 'inward'
        });
        var [start, end] = Range.edges(at);
        var splitMode = mode === 'lowest' ? 'lowest' : 'highest';
        Transforms.splitNodes(editor, {
          at: end,
          match,
          mode: splitMode,
          voids
        });
        Transforms.splitNodes(editor, {
          at: start,
          match,
          mode: splitMode,
          voids
        });
        at = rangeRef.unref();

        if (options.at == null) {
          Transforms.select(editor, at);
        }
      }

      for (var [node, path] of Editor.nodes(editor, {
        at,
        match,
        mode,
        voids
      })) {
        var properties = {};
        var newProperties = {}; // You can't set properties on the editor node.

        if (path.length === 0) {
          continue;
        }

        for (var k in props) {
          if (k === 'children' || k === 'text') {
            continue;
          }

          if (props[k] !== node[k]) {
            properties[k] = node[k];
            newProperties[k] = props[k];
          }
        }

        if (Object.keys(newProperties).length !== 0) {
          editor.apply({
            type: 'set_node',
            path,
            properties,
            newProperties
          });
        }
      }
    });
  },

  /**
   * Split the nodes at a specific location.
   */
  splitNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        mode = 'lowest',
        voids = false
      } = options;
      var {
        match,
        at = editor.selection,
        height = 0,
        always = false
      } = options;

      if (match == null) {
        match = n => Editor.isBlock(editor, n);
      }

      if (Range.isRange(at)) {
        at = deleteRange(editor, at);
      } // If the target is a path, the default height-skipping and position
      // counters need to account for us potentially splitting at a non-leaf.


      if (Path.isPath(at)) {
        var path = at;
        var point = Editor.point(editor, path);
        var [parent] = Editor.parent(editor, path);

        match = n => n === parent;

        height = point.path.length - path.length + 1;
        at = point;
        always = true;
      }

      if (!at) {
        return;
      }

      var beforeRef = Editor.pointRef(editor, at, {
        affinity: 'backward'
      });
      var [highest] = Editor.nodes(editor, {
        at,
        match,
        mode,
        voids
      });

      if (!highest) {
        return;
      }

      var voidMatch = Editor.void(editor, {
        at,
        mode: 'highest'
      });
      var nudge = 0;

      if (!voids && voidMatch) {
        var [voidNode, voidPath] = voidMatch;

        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {
          var after = Editor.after(editor, voidPath);

          if (!after) {
            var text = {
              text: ''
            };
            var afterPath = Path.next(voidPath);
            Transforms.insertNodes(editor, text, {
              at: afterPath,
              voids
            });
            after = Editor.point(editor, afterPath);
          }

          at = after;
          always = true;
        }

        var siblingHeight = at.path.length - voidPath.length;
        height = siblingHeight + 1;
        always = true;
      }

      var afterRef = Editor.pointRef(editor, at);
      var depth = at.path.length - height;
      var [, highestPath] = highest;
      var lowestPath = at.path.slice(0, depth);
      var position = height === 0 ? at.offset : at.path[depth] + nudge;
      var target = null;

      for (var [node, _path2] of Editor.levels(editor, {
        at: lowestPath,
        reverse: true,
        voids
      })) {
        var split = false;

        if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Editor.isVoid(editor, node)) {
          break;
        }

        var _point = beforeRef.current;
        var isEnd = Editor.isEnd(editor, _point, _path2);

        if (always || !beforeRef || !Editor.isEdge(editor, _point, _path2)) {
          split = true;

          var properties = _objectWithoutProperties(node, ["text", "children"]);

          editor.apply({
            type: 'split_node',
            path: _path2,
            position,
            target,
            properties
          });
        }

        target = position;
        position = _path2[_path2.length - 1] + (split || isEnd ? 1 : 0);
      }

      if (options.at == null) {
        var _point2 = afterRef.current || Editor.end(editor, []);

        Transforms.select(editor, _point2);
      }

      beforeRef.unref();
      afterRef.unref();
    });
  },

  /**
   * Unset properties on the nodes at a location.
   */
  unsetNodes(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (!Array.isArray(props)) {
      props = [props];
    }

    var obj = {};

    for (var key of props) {
      obj[key] = null;
    }

    Transforms.setNodes(editor, obj, options);
  },

  /**
   * Unwrap the nodes at a location from a parent node, splitting the parent if
   * necessary to ensure that only the content in the range is unwrapped.
   */
  unwrapNodes(editor, options) {
    Editor.withoutNormalizing(editor, () => {
      var {
        mode = 'lowest',
        split = false,
        voids = false
      } = options;
      var {
        at = editor.selection,
        match
      } = options;

      if (!at) {
        return;
      }

      if (match == null) {
        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);
      }

      if (Path.isPath(at)) {
        at = Editor.range(editor, at);
      }

      var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;
      var matches = Editor.nodes(editor, {
        at,
        match,
        mode,
        voids
      });
      var pathRefs = Array.from(matches, (_ref5) => {
        var [, p] = _ref5;
        return Editor.pathRef(editor, p);
      });

      var _loop = function _loop(pathRef) {
        var path = pathRef.unref();
        var [node] = Editor.node(editor, path);
        var range = Editor.range(editor, path);

        if (split && rangeRef) {
          range = Range.intersection(rangeRef.current, range);
        }

        Transforms.liftNodes(editor, {
          at: range,
          match: n => node.children.includes(n),
          voids
        });
      };

      for (var pathRef of pathRefs) {
        _loop(pathRef);
      }

      if (rangeRef) {
        rangeRef.unref();
      }
    });
  },

  /**
   * Wrap the nodes at a location in a new container node, splitting the edges
   * of the range first to ensure that only the content in the range is wrapped.
   */
  wrapNodes(editor, element) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        mode = 'lowest',
        split = false,
        voids = false
      } = options;
      var {
        match,
        at = editor.selection
      } = options;

      if (!at) {
        return;
      }

      if (match == null) {
        if (Path.isPath(at)) {
          match = matchPath(editor, at);
        } else if (editor.isInline(element)) {
          match = n => Editor.isInline(editor, n) || Text.isText(n);
        } else {
          match = n => Editor.isBlock(editor, n);
        }
      }

      if (split && Range.isRange(at)) {
        var [start, end] = Range.edges(at);
        var rangeRef = Editor.rangeRef(editor, at, {
          affinity: 'inward'
        });
        Transforms.splitNodes(editor, {
          at: end,
          match,
          voids
        });
        Transforms.splitNodes(editor, {
          at: start,
          match,
          voids
        });
        at = rangeRef.unref();

        if (options.at == null) {
          Transforms.select(editor, at);
        }
      }

      var roots = Array.from(Editor.nodes(editor, {
        at,
        match: editor.isInline(element) ? n => Editor.isBlock(editor, n) : n => Editor.isEditor(n),
        mode: 'lowest',
        voids
      }));

      for (var [, rootPath] of roots) {
        var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;

        if (!a) {
          continue;
        }

        var matches = Array.from(Editor.nodes(editor, {
          at: a,
          match,
          mode,
          voids
        }));

        if (matches.length > 0) {
          (function () {
            var [first] = matches;
            var last = matches[matches.length - 1];
            var [, firstPath] = first;
            var [, lastPath] = last;
            var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);
            var range = Editor.range(editor, firstPath, lastPath);
            var commonNodeEntry = Editor.node(editor, commonPath);
            var [commonNode] = commonNodeEntry;
            var depth = commonPath.length + 1;
            var wrapperPath = Path.next(lastPath.slice(0, depth));

            var wrapper = _objectSpread$6({}, element, {
              children: []
            });

            Transforms.insertNodes(editor, wrapper, {
              at: wrapperPath,
              voids
            });
            Transforms.moveNodes(editor, {
              at: range,
              match: n => commonNode.children.includes(n),
              to: wrapperPath.concat(0),
              voids
            });
          })();
        }
      }
    });
  }

};
/**
 * Convert a range into a point by deleting it's content.
 */

var deleteRange = (editor, range) => {
  if (Range.isCollapsed(range)) {
    return range.anchor;
  } else {
    var [, end] = Range.edges(range);
    var pointRef = Editor.pointRef(editor, end);
    Transforms.delete(editor, {
      at: range
    });
    return pointRef.unref();
  }
};

var matchPath = (editor, path) => {
  var [node] = Editor.node(editor, path);
  return n => n === node;
};

function ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var SelectionTransforms = {
  /**
   * Collapse the selection.
   */
  collapse(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      edge = 'anchor'
    } = options;
    var {
      selection
    } = editor;

    if (!selection) {
      return;
    } else if (edge === 'anchor') {
      Transforms.select(editor, selection.anchor);
    } else if (edge === 'focus') {
      Transforms.select(editor, selection.focus);
    } else if (edge === 'start') {
      var [start] = Range.edges(selection);
      Transforms.select(editor, start);
    } else if (edge === 'end') {
      var [, end] = Range.edges(selection);
      Transforms.select(editor, end);
    }
  },

  /**
   * Unset the selection.
   */
  deselect(editor) {
    var {
      selection
    } = editor;

    if (selection) {
      editor.apply({
        type: 'set_selection',
        properties: selection,
        newProperties: null
      });
    }
  },

  /**
   * Move the selection's point forward or backward.
   */
  move(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      selection
    } = editor;
    var {
      distance = 1,
      unit = 'character',
      reverse = false
    } = options;
    var {
      edge = null
    } = options;

    if (!selection) {
      return;
    }

    if (edge === 'start') {
      edge = Range.isBackward(selection) ? 'focus' : 'anchor';
    }

    if (edge === 'end') {
      edge = Range.isBackward(selection) ? 'anchor' : 'focus';
    }

    var {
      anchor,
      focus
    } = selection;
    var opts = {
      distance,
      unit
    };
    var props = {};

    if (edge == null || edge === 'anchor') {
      var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);

      if (point) {
        props.anchor = point;
      }
    }

    if (edge == null || edge === 'focus') {
      var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);

      if (_point) {
        props.focus = _point;
      }
    }

    Transforms.setSelection(editor, props);
  },

  /**
   * Set the selection to a new value.
   */
  select(editor, target) {
    var {
      selection
    } = editor;
    target = Editor.range(editor, target);

    if (selection) {
      Transforms.setSelection(editor, target);
      return;
    }

    if (!Range.isRange(target)) {
      throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(JSON.stringify(target)));
    }

    editor.apply({
      type: 'set_selection',
      properties: selection,
      newProperties: target
    });
  },

  /**
   * Set new properties on one of the selection's points.
   */
  setPoint(editor, props, options) {
    var {
      selection
    } = editor;
    var {
      edge = 'both'
    } = options;

    if (!selection) {
      return;
    }

    if (edge === 'start') {
      edge = Range.isBackward(selection) ? 'focus' : 'anchor';
    }

    if (edge === 'end') {
      edge = Range.isBackward(selection) ? 'anchor' : 'focus';
    }

    var {
      anchor,
      focus
    } = selection;
    var point = edge === 'anchor' ? anchor : focus;
    Transforms.setSelection(editor, {
      [edge === 'anchor' ? 'anchor' : 'focus']: _objectSpread$7({}, point, {}, props)
    });
  },

  /**
   * Set new properties on the selection.
   */
  setSelection(editor, props) {
    var {
      selection
    } = editor;
    var oldProps = {};
    var newProps = {};

    if (!selection) {
      return;
    }

    for (var k in props) {
      if (k === 'anchor' && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === 'focus' && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== 'anchor' && k !== 'focus' && props[k] !== selection[k]) {
        oldProps[k] = selection[k];
        newProps[k] = props[k];
      }
    }

    if (Object.keys(oldProps).length > 0) {
      editor.apply({
        type: 'set_selection',
        properties: oldProps,
        newProperties: newProps
      });
    }
  }

};

var TextTransforms = {
  /**
   * Delete content in the editor.
   */
  delete(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        reverse = false,
        unit = 'character',
        distance = 1,
        voids = false
      } = options;
      var {
        at = editor.selection,
        hanging = false
      } = options;

      if (!at) {
        return;
      }

      if (Range.isRange(at) && Range.isCollapsed(at)) {
        at = at.anchor;
      }

      if (Point.isPoint(at)) {
        var furthestVoid = Editor.void(editor, {
          at,
          mode: 'highest'
        });

        if (!voids && furthestVoid) {
          var [, voidPath] = furthestVoid;
          at = voidPath;
        } else {
          var opts = {
            unit,
            distance
          };
          var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);
          at = {
            anchor: at,
            focus: target
          };
          hanging = true;
        }
      }

      if (Path.isPath(at)) {
        Transforms.removeNodes(editor, {
          at,
          voids
        });
        return;
      }

      if (Range.isCollapsed(at)) {
        return;
      }

      if (!hanging) {
        at = Editor.unhangRange(editor, at, {
          voids
        });
      }

      var [start, end] = Range.edges(at);
      var startBlock = Editor.above(editor, {
        match: n => Editor.isBlock(editor, n),
        at: start,
        voids
      });
      var endBlock = Editor.above(editor, {
        match: n => Editor.isBlock(editor, n),
        at: end,
        voids
      });
      var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);
      var isSingleText = Path.equals(start.path, end.path);
      var startVoid = voids ? null : Editor.void(editor, {
        at: start,
        mode: 'highest'
      });
      var endVoid = voids ? null : Editor.void(editor, {
        at: end,
        mode: 'highest'
      }); // If the start or end points are inside an inline void, nudge them out.

      if (startVoid) {
        var before = Editor.before(editor, start);

        if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {
          start = before;
        }
      }

      if (endVoid) {
        var after = Editor.after(editor, end);

        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {
          end = after;
        }
      } // Get the highest nodes that are completely inside the range, as well as
      // the start and end nodes.


      var matches = [];
      var lastPath;

      for (var entry of Editor.nodes(editor, {
        at,
        voids
      })) {
        var [node, path] = entry;

        if (lastPath && Path.compare(path, lastPath) === 0) {
          continue;
        }

        if (!voids && Editor.isVoid(editor, node) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) {
          matches.push(entry);
          lastPath = path;
        }
      }

      var pathRefs = Array.from(matches, (_ref) => {
        var [, p] = _ref;
        return Editor.pathRef(editor, p);
      });
      var startRef = Editor.pointRef(editor, start);
      var endRef = Editor.pointRef(editor, end);

      if (!isSingleText && !startVoid) {
        var _point = startRef.current;
        var [_node] = Editor.leaf(editor, _point);
        var {
          path: _path
        } = _point;
        var {
          offset
        } = start;

        var text = _node.text.slice(offset);

        editor.apply({
          type: 'remove_text',
          path: _path,
          offset,
          text
        });
      }

      for (var pathRef of pathRefs) {
        var _path2 = pathRef.unref();

        Transforms.removeNodes(editor, {
          at: _path2,
          voids
        });
      }

      if (!endVoid) {
        var _point2 = endRef.current;
        var [_node2] = Editor.leaf(editor, _point2);
        var {
          path: _path3
        } = _point2;

        var _offset = isSingleText ? start.offset : 0;

        var _text = _node2.text.slice(_offset, end.offset);

        editor.apply({
          type: 'remove_text',
          path: _path3,
          offset: _offset,
          text: _text
        });
      }

      if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {
        Transforms.mergeNodes(editor, {
          at: endRef.current,
          hanging: true,
          voids
        });
      }

      var point = endRef.unref() || startRef.unref();

      if (options.at == null && point) {
        Transforms.select(editor, point);
      }
    });
  },

  /**
   * Insert a fragment at a specific location in the editor.
   */
  insertFragment(editor, fragment) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false
      } = options;
      var {
        at = editor.selection
      } = options;

      if (!fragment.length) {
        return;
      }

      if (!at) {
        return;
      } else if (Range.isRange(at)) {
        if (!hanging) {
          at = Editor.unhangRange(editor, at);
        }

        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var [, end] = Range.edges(at);

          if (!voids && Editor.void(editor, {
            at: end
          })) {
            return;
          }

          var pointRef = Editor.pointRef(editor, end);
          Transforms.delete(editor, {
            at
          });
          at = pointRef.unref();
        }
      } else if (Path.isPath(at)) {
        at = Editor.start(editor, at);
      }

      if (!voids && Editor.void(editor, {
        at
      })) {
        return;
      } // If the insert point is at the edge of an inline node, move it outside
      // instead since it will need to be split otherwise.


      var inlineElementMatch = Editor.above(editor, {
        at,
        match: n => Editor.isInline(editor, n),
        mode: 'highest',
        voids
      });

      if (inlineElementMatch) {
        var [, _inlinePath] = inlineElementMatch;

        if (Editor.isEnd(editor, at, _inlinePath)) {
          var after = Editor.after(editor, _inlinePath);
          at = after;
        } else if (Editor.isStart(editor, at, _inlinePath)) {
          var before = Editor.before(editor, _inlinePath);
          at = before;
        }
      }

      var blockMatch = Editor.above(editor, {
        match: n => Editor.isBlock(editor, n),
        at,
        voids
      });
      var [, blockPath] = blockMatch;
      var isBlockStart = Editor.isStart(editor, at, blockPath);
      var isBlockEnd = Editor.isEnd(editor, at, blockPath);
      var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;
      var mergeEnd = !isBlockEnd;
      var [, firstPath] = Node.first({
        children: fragment
      }, []);
      var [, lastPath] = Node.last({
        children: fragment
      }, []);
      var matches = [];

      var matcher = (_ref2) => {
        var [n, p] = _ref2;

        if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {
          return false;
        }

        if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {
          return false;
        }

        return true;
      };

      for (var entry of Node.nodes({
        children: fragment
      }, {
        pass: matcher
      })) {
        if (entry[1].length > 0 && matcher(entry)) {
          matches.push(entry);
        }
      }

      var starts = [];
      var middles = [];
      var ends = [];
      var starting = true;
      var hasBlocks = false;

      for (var [node] of matches) {
        if (Element.isElement(node) && !editor.isInline(node)) {
          starting = false;
          hasBlocks = true;
          middles.push(node);
        } else if (starting) {
          starts.push(node);
        } else {
          ends.push(node);
        }
      }

      var [inlineMatch] = Editor.nodes(editor, {
        at,
        match: n => Text.isText(n) || Editor.isInline(editor, n),
        mode: 'highest',
        voids
      });
      var [, inlinePath] = inlineMatch;
      var isInlineStart = Editor.isStart(editor, at, inlinePath);
      var isInlineEnd = Editor.isEnd(editor, at, inlinePath);
      var middleRef = Editor.pathRef(editor, isBlockEnd ? Path.next(blockPath) : blockPath);
      var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);
      Transforms.splitNodes(editor, {
        at,
        match: n => hasBlocks ? Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n),
        mode: hasBlocks ? 'lowest' : 'highest',
        voids
      });
      var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);
      Transforms.insertNodes(editor, starts, {
        at: startRef.current,
        match: n => Text.isText(n) || Editor.isInline(editor, n),
        mode: 'highest',
        voids
      });
      Transforms.insertNodes(editor, middles, {
        at: middleRef.current,
        match: n => Editor.isBlock(editor, n),
        mode: 'lowest',
        voids
      });
      Transforms.insertNodes(editor, ends, {
        at: endRef.current,
        match: n => Text.isText(n) || Editor.isInline(editor, n),
        mode: 'highest',
        voids
      });

      if (!options.at) {
        var path;

        if (ends.length > 0) {
          path = Path.previous(endRef.current);
        } else if (middles.length > 0) {
          path = Path.previous(middleRef.current);
        } else {
          path = Path.previous(startRef.current);
        }

        var _end = Editor.end(editor, path);

        Transforms.select(editor, _end);
      }

      startRef.unref();
      middleRef.unref();
      endRef.unref();
    });
  },

  /**
   * Insert a string of text in the Editor.
   */
  insertText(editor, text) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        voids = false
      } = options;
      var {
        at = editor.selection
      } = options;

      if (!at) {
        return;
      }

      if (Path.isPath(at)) {
        at = Editor.range(editor, at);
      }

      if (Range.isRange(at)) {
        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var end = Range.end(at);

          if (!voids && Editor.void(editor, {
            at: end
          })) {
            return;
          }

          var pointRef = Editor.pointRef(editor, end);
          Transforms.delete(editor, {
            at,
            voids
          });
          at = pointRef.unref();
          Transforms.setSelection(editor, {
            anchor: at,
            focus: at
          });
        }
      }

      if (!voids && Editor.void(editor, {
        at
      })) {
        return;
      }

      var {
        path,
        offset
      } = at;
      editor.apply({
        type: 'insert_text',
        path,
        offset,
        text
      });
    });
  }

};

function ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var Transforms = _objectSpread$8({}, GeneralTransforms, {}, NodeTransforms, {}, SelectionTransforms, {}, TextTransforms);

function ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$9(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$9(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * Create a new Slate `Editor` object.
 */

var createEditor = () => {
  var editor = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isInline: () => false,
    isVoid: () => false,
    onChange: () => {},
    apply: op => {
      for (var ref of Editor.pathRefs(editor)) {
        PathRef.transform(ref, op);
      }

      for (var _ref of Editor.pointRefs(editor)) {
        PointRef.transform(_ref, op);
      }

      for (var _ref2 of Editor.rangeRefs(editor)) {
        RangeRef.transform(_ref2, op);
      }

      var set = new Set();
      var dirtyPaths = [];

      var add = path => {
        if (path) {
          var key = path.join(',');

          if (!set.has(key)) {
            set.add(key);
            dirtyPaths.push(path);
          }
        }
      };

      var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];
      var newDirtyPaths = getDirtyPaths(op);

      for (var path of oldDirtyPaths) {
        var newPath = Path.transform(path, op);
        add(newPath);
      }

      for (var _path of newDirtyPaths) {
        add(_path);
      }

      DIRTY_PATHS.set(editor, dirtyPaths);
      Editor.transform(editor, op);
      editor.operations.push(op);
      Editor.normalize(editor); // Clear any formats applied to the cursor if the selection changes.

      if (op.type === 'set_selection') {
        editor.marks = null;
      }

      if (!FLUSHING.get(editor)) {
        FLUSHING.set(editor, true);
        Promise.resolve().then(() => {
          FLUSHING.set(editor, false);
          editor.onChange();
          editor.operations = [];
        });
      }
    },
    addMark: (key, value) => {
      var {
        selection
      } = editor;

      if (selection) {
        if (Range.isExpanded(selection)) {
          Transforms.setNodes(editor, {
            [key]: value
          }, {
            match: Text.isText,
            split: true
          });
        } else {
          var marks = _objectSpread$9({}, Editor.marks(editor) || {}, {
            [key]: value
          });

          editor.marks = marks;
          editor.onChange();
        }
      }
    },
    deleteBackward: unit => {
      var {
        selection
      } = editor;

      if (selection && Range.isCollapsed(selection)) {
        Transforms.delete(editor, {
          unit,
          reverse: true
        });
      }
    },
    deleteForward: unit => {
      var {
        selection
      } = editor;

      if (selection && Range.isCollapsed(selection)) {
        Transforms.delete(editor, {
          unit
        });
      }
    },
    deleteFragment: () => {
      var {
        selection
      } = editor;

      if (selection && Range.isExpanded(selection)) {
        Transforms.delete(editor);
      }
    },
    getFragment: () => {
      var {
        selection
      } = editor;

      if (selection) {
        return Node.fragment(editor, selection);
      }

      return [];
    },
    insertBreak: () => {
      Transforms.splitNodes(editor, {
        always: true
      });
    },
    insertFragment: fragment => {
      Transforms.insertFragment(editor, fragment);
    },
    insertNode: node => {
      Transforms.insertNodes(editor, node);
    },
    insertText: text => {
      var {
        selection,
        marks
      } = editor;

      if (selection) {
        // If the cursor is at the end of an inline, move it outside of
        // the inline before inserting
        if (Range.isCollapsed(selection)) {
          var inline = Editor.above(editor, {
            match: n => Editor.isInline(editor, n),
            mode: 'highest'
          });

          if (inline) {
            var [, inlinePath] = inline;

            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {
              var point = Editor.after(editor, inlinePath);
              Transforms.setSelection(editor, {
                anchor: point,
                focus: point
              });
            }
          }
        }

        if (marks) {
          var node = _objectSpread$9({
            text
          }, marks);

          Transforms.insertNodes(editor, node);
        } else {
          Transforms.insertText(editor, text);
        }

        editor.marks = null;
      }
    },
    normalizeNode: entry => {
      var [node, path] = entry; // There are no core normalizations for text nodes.

      if (Text.isText(node)) {
        return;
      } // Ensure that block and inline nodes have at least one text child.


      if (Element.isElement(node) && node.children.length === 0) {
        var child = {
          text: ''
        };
        Transforms.insertNodes(editor, child, {
          at: path.concat(0),
          voids: true
        });
        return;
      } // Determine whether the node should have block or inline children.


      var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0])); // Since we'll be applying operations while iterating, keep track of an
      // index that accounts for any added/removed nodes.

      var n = 0;

      for (var i = 0; i < node.children.length; i++, n++) {
        var _child = node.children[i];
        var prev = node.children[i - 1];
        var isLast = i === node.children.length - 1;
        var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child); // Only allow block nodes in the top-level children and parent blocks
        // that only contain block nodes. Similarly, only allow inline nodes in
        // other inline nodes, or parent blocks that only contain inlines and
        // text.

        if (isInlineOrText !== shouldHaveInlines) {
          Transforms.removeNodes(editor, {
            at: path.concat(n),
            voids: true
          });
          n--;
        } else if (Element.isElement(_child)) {
          // Ensure that inline nodes are surrounded by text nodes.
          if (editor.isInline(_child)) {
            if (prev == null || !Text.isText(prev)) {
              var newChild = {
                text: ''
              };
              Transforms.insertNodes(editor, newChild, {
                at: path.concat(n),
                voids: true
              });
              n++;
            } else if (isLast) {
              var _newChild = {
                text: ''
              };
              Transforms.insertNodes(editor, _newChild, {
                at: path.concat(n + 1),
                voids: true
              });
              n++;
            }
          }
        } else {
          // Merge adjacent text nodes that are empty or match.
          if (prev != null && Text.isText(prev)) {
            if (Text.equals(_child, prev, {
              loose: true
            })) {
              Transforms.mergeNodes(editor, {
                at: path.concat(n),
                voids: true
              });
              n--;
            } else if (prev.text === '') {
              Transforms.removeNodes(editor, {
                at: path.concat(n - 1),
                voids: true
              });
              n--;
            } else if (isLast && _child.text === '') {
              Transforms.removeNodes(editor, {
                at: path.concat(n),
                voids: true
              });
              n--;
            }
          }
        }
      }
    },
    removeMark: key => {
      var {
        selection
      } = editor;

      if (selection) {
        if (Range.isExpanded(selection)) {
          Transforms.unsetNodes(editor, key, {
            match: Text.isText,
            split: true
          });
        } else {
          var marks = _objectSpread$9({}, Editor.marks(editor) || {});

          delete marks[key];
          editor.marks = marks;
          editor.onChange();
        }
      }
    }
  };
  return editor;
};
/**
 * Get the "dirty" paths generated from an operation.
 */

var getDirtyPaths = op => {
  switch (op.type) {
    case 'insert_text':
    case 'remove_text':
    case 'set_node':
      {
        var {
          path
        } = op;
        return Path.levels(path);
      }

    case 'insert_node':
      {
        var {
          node,
          path: _path2
        } = op;
        var levels = Path.levels(_path2);
        var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), (_ref3) => {
          var [, p] = _ref3;
          return _path2.concat(p);
        });
        return [...levels, ...descendants];
      }

    case 'merge_node':
      {
        var {
          path: _path3
        } = op;
        var ancestors = Path.ancestors(_path3);
        var previousPath = Path.previous(_path3);
        return [...ancestors, previousPath];
      }

    case 'move_node':
      {
        var {
          path: _path4,
          newPath
        } = op;

        if (Path.equals(_path4, newPath)) {
          return [];
        }

        var oldAncestors = [];
        var newAncestors = [];

        for (var ancestor of Path.ancestors(_path4)) {
          var p = Path.transform(ancestor, op);
          oldAncestors.push(p);
        }

        for (var _ancestor of Path.ancestors(newPath)) {
          var _p = Path.transform(_ancestor, op);

          newAncestors.push(_p);
        }

        return [...oldAncestors, ...newAncestors];
      }

    case 'remove_node':
      {
        var {
          path: _path5
        } = op;

        var _ancestors = Path.ancestors(_path5);

        return [..._ancestors];
      }

    case 'split_node':
      {
        var {
          path: _path6
        } = op;

        var _levels = Path.levels(_path6);

        var nextPath = Path.next(_path6);
        return [..._levels, nextPath];
      }

    default:
      {
        return [];
      }
  }
};


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "../node_modules/slate/node_modules/is-plain-object/index.js":
/*!*******************************************************************!*\
  !*** ../node_modules/slate/node_modules/is-plain-object/index.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isPlainObject; });
/* harmony import */ var isobject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! isobject */ "../node_modules/slate/node_modules/isobject/index.js");
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */



function isObjectObject(o) {
  return Object(isobject__WEBPACK_IMPORTED_MODULE_0__["default"])(o) === true
    && Object.prototype.toString.call(o) === '[object Object]';
}

function isPlainObject(o) {
  var ctor,prot;

  if (isObjectObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (typeof ctor !== 'function') return false;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObjectObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
};


/***/ }),

/***/ "../node_modules/slate/node_modules/isobject/index.js":
/*!************************************************************!*\
  !*** ../node_modules/slate/node_modules/isobject/index.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isObject; });
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

function isObject(val) {
  return val != null && typeof val === 'object' && Array.isArray(val) === false;
};


/***/ }),

/***/ "../node_modules/webpack/buildin/global.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../node_modules/webpack/buildin/module.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/module.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./src/components/Icon.js":
/*!********************************!*\
  !*** ./src/components/Icon.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);

var svgIcons = {
  format_bold: '<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path d="M0 0h24v24H0z" fill="none"/><path d="M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H7v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42zM10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z"/></svg>',
  format_italic: '<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path d="M0 0h24v24H0z" fill="none"/><path d="M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z"/></svg>',
  format_underlined: '<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path d="M0 0h24v24H0z" fill="none"/><path d="M12 17c3.31 0 6-2.69 6-6V3h-2.5v8c0 1.93-1.57 3.5-3.5 3.5S8.5 12.93 8.5 11V3H6v8c0 3.31 2.69 6 6 6zm-7 2v2h14v-2H5z"/></svg>',
  format_list_bulleted: '<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M4 10.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0-6c-.83 0-1.5.67-1.5 1.5S3.17 7.5 4 7.5 5.5 6.83 5.5 6 4.83 4.5 4 4.5zm0 12c-.83 0-1.5.68-1.5 1.5s.68 1.5 1.5 1.5 1.5-.68 1.5-1.5-.67-1.5-1.5-1.5zM7 19h14v-2H7v2zm0-6h14v-2H7v2zm0-8v2h14V5H7z"/></svg>',
  format_list_numbered: '<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path d="M0 0h24v24H0z" fill="none"/><path d="M2 17h2v.5H3v1h1v.5H2v1h3v-4H2v1zm1-9h1V4H2v1h1v3zm-1 3h1.8L2 13.1v.9h3v-1H3.2L5 10.9V10H2v1zm5-6v2h14V5H7zm0 14h14v-2H7v2zm0-6h14v-2H7v2z"/></svg>',
  looks_one: '<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path d="M0 0h24v24H0z" fill="none"/><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14h-2V9h-2V7h4v10z"/></svg>'
};
var styles = {
  icon: {
    opacity: 0.7
  }
};

var Icon = function Icon(_ref) {
  var children = _ref.children;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("img", {
    height: 20,
    src: "data:image/svg+xml;utf8,".concat(svgIcons[children]),
    style: styles.icon
  });
};

/* harmony default export */ __webpack_exports__["default"] = (Icon);

/***/ }),

/***/ "./src/components/JsonViewer.js":
/*!**************************************!*\
  !*** ./src/components/JsonViewer.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);

var styles = {
  jsonViewer: {
    padding: 16,
    borderRadius: 4,
    background: 'linen'
  }
};

var JsonViewer = function JsonViewer(_ref) {
  var value = _ref.value;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("pre", {
    style: styles.jsonViewer
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("code", null, JSON.stringify(value, null, 2)));
};

/* harmony default export */ __webpack_exports__["default"] = (JsonViewer);

/***/ }),

/***/ "./src/components/Toolbar.js":
/*!***********************************!*\
  !*** ./src/components/Toolbar.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }


var styles = {
  toolbar: {
    display: 'flex',
    flexDirection: 'row'
  },
  button: {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    height: 30,
    minWidth: 30,
    margin: 5,
    padding: 0,
    border: 'none',
    background: 'transparent',
    borderRadius: 4,
    cursor: 'pointer'
  },
  buttonActive: {
    background: '#f5f5f5'
  },
  separator: {
    margin: '10px 5px',
    borderRight: 'solid thin #eaeaea'
  }
};

var Toolbar = function Toolbar(_ref) {
  var children = _ref.children;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
    style: styles.toolbar
  }, children);
};

Toolbar.Button = function (_ref2) {
  var active = _ref2.active,
      props = _objectWithoutProperties(_ref2, ["active"]);

  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", _extends({}, props, {
    style: _objectSpread(_objectSpread({}, styles.button), active ? styles.buttonActive : undefined)
  }));
};

Toolbar.Separator = function () {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
    style: styles.separator
  });
};

/* harmony default export */ __webpack_exports__["default"] = (Toolbar);

/***/ }),

/***/ "./src/constants.js":
/*!**************************!*\
  !*** ./src/constants.js ***!
  \**************************/
/*! exports provided: BULLETED_LIST, NUMBERED_LIST, LIST_ITEM, MENTION, LINK, HEADING_ONE, HEADING_TWO, PARAGRAPH, BOLD, ITALIC, UNDERLINE, EDITOR_CHANGE, EDITOR_FOCUS, EDITOR_BLUR, EDITOR_LAYOUT */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BULLETED_LIST", function() { return BULLETED_LIST; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NUMBERED_LIST", function() { return NUMBERED_LIST; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LIST_ITEM", function() { return LIST_ITEM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MENTION", function() { return MENTION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LINK", function() { return LINK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HEADING_ONE", function() { return HEADING_ONE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HEADING_TWO", function() { return HEADING_TWO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PARAGRAPH", function() { return PARAGRAPH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BOLD", function() { return BOLD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ITALIC", function() { return ITALIC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNDERLINE", function() { return UNDERLINE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EDITOR_CHANGE", function() { return EDITOR_CHANGE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EDITOR_FOCUS", function() { return EDITOR_FOCUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EDITOR_BLUR", function() { return EDITOR_BLUR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EDITOR_LAYOUT", function() { return EDITOR_LAYOUT; });
// Blocks
var BULLETED_LIST = 'bulleted-list';
var NUMBERED_LIST = 'numbered-list';
var LIST_ITEM = 'list-item';
var MENTION = 'mention';
var LINK = 'link';
var HEADING_ONE = 'heading-one';
var HEADING_TWO = 'heading-two';
var PARAGRAPH = 'paragraph'; // Marks

var BOLD = 'bold';
var ITALIC = 'italic';
var UNDERLINE = 'underline'; // Other events

var EDITOR_CHANGE = 'editor-change';
var EDITOR_FOCUS = 'editor-focus';
var EDITOR_BLUR = 'editor-blur';
var EDITOR_LAYOUT = 'editor-layout';


/***/ }),

/***/ "./src/helpers/apply.js":
/*!******************************!*\
  !*** ./src/helpers/apply.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var apply = function apply() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return function (func) {
    return func.apply(void 0, _toConsumableArray(args));
  };
};

/* harmony default export */ __webpack_exports__["default"] = (apply);

/***/ }),

/***/ "./src/helpers/compose.js":
/*!********************************!*\
  !*** ./src/helpers/compose.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var compose = function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  return function (arg) {
    return funcs.reduceRight(function (composed, f) {
      return f ? f(composed) : composed;
    }, arg);
  };
};

/* harmony default export */ __webpack_exports__["default"] = (compose);

/***/ }),

/***/ "./src/helpers/createPlugin.js":
/*!*************************************!*\
  !*** ./src/helpers/createPlugin.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var createPlugin = function createPlugin(configs) {
  var defaultPlugin = {
    name: '',
    renderLeaf: function renderLeaf(next) {
      return function (props) {
        return next(props);
      };
    },
    renderElement: function renderElement(next) {
      return function (props) {
        return next(props);
      };
    },
    ToolbarButton: function ToolbarButton() {
      return null;
    },
    renderCustom: function renderCustom() {
      return null;
    },
    handleMessage: function handleMessage() {
      return function () {};
    },
    enhanceEditor: function enhanceEditor(editor) {
      return editor;
    }
  };
  return _objectSpread(_objectSpread({}, defaultPlugin), configs);
};

/* harmony default export */ __webpack_exports__["default"] = (createPlugin);

/***/ }),

/***/ "./src/helpers/elementHelpers.js":
/*!***************************************!*\
  !*** ./src/helpers/elementHelpers.js ***!
  \***************************************/
/*! exports provided: isBlockActive, isList, renderDefaultElement, makeRenderElement, composeRenderElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBlockActive", function() { return isBlockActive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isList", function() { return isList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderDefaultElement", function() { return renderDefaultElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeRenderElement", function() { return makeRenderElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "composeRenderElement", function() { return composeRenderElement; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ "../node_modules/slate/dist/index.es.js");
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./compose */ "./src/helpers/compose.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants */ "./src/constants.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }






var isBlockActive = function isBlockActive(editor, format) {
  var _Editor$nodes = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].nodes(editor, {
    match: function match(n) {
      return n.type === format;
    }
  }),
      _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),
      match = _Editor$nodes2[0];

  return !!match;
};

var isList = function isList(node) {
  return [_constants__WEBPACK_IMPORTED_MODULE_3__["BULLETED_LIST"], _constants__WEBPACK_IMPORTED_MODULE_3__["NUMBERED_LIST"]].includes(node.type);
};

var DefaultElement = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.forwardRef(function (props, ref) {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("p", _extends({
    ref: ref,
    style: {
      margin: 0,
      lineHeight: 1.5
    }
  }, props));
});

var renderDefaultElement = function renderDefaultElement(_ref) {
  var attributes = _ref.attributes,
      children = _ref.children;

  /*#__PURE__*/
  react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(DefaultElement, attributes, children);
};

var makeRenderElement = function makeRenderElement(block, CustomElement) {
  return function (next) {
    return function (props) {
      if (props.element.type === block) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(CustomElement, props);
      }

      return next(props);
    };
  };
};

var composeRenderElement = function composeRenderElement(plugins) {
  return _compose__WEBPACK_IMPORTED_MODULE_2__["default"].apply(void 0, _toConsumableArray(plugins.map(function (plugin) {
    return plugin.renderElement;
  })))(renderDefaultElement);
};



/***/ }),

/***/ "./src/helpers/flow.js":
/*!*****************************!*\
  !*** ./src/helpers/flow.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var flow = function flow() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  return function (arg) {
    return funcs.reduce(function (composed, f) {
      return f ? f(composed) : composed;
    }, arg);
  };
};

/* harmony default export */ __webpack_exports__["default"] = (flow);

/***/ }),

/***/ "./src/helpers/get.js":
/*!****************************!*\
  !*** ./src/helpers/get.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var get = function get(path) {
  return function (object) {
    return object[path];
  };
};

/* harmony default export */ __webpack_exports__["default"] = (get);

/***/ }),

/***/ "./src/helpers/getUrl.js":
/*!*******************************!*\
  !*** ./src/helpers/getUrl.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! slate */ "../node_modules/slate/dist/index.es.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./src/constants.js");


/* harmony default export */ __webpack_exports__["default"] = (function (node) {
  if ((node === null || node === void 0 ? void 0 : node.type) !== _constants__WEBPACK_IMPORTED_MODULE_1__["LINK"]) return null;
  return slate__WEBPACK_IMPORTED_MODULE_0__["Node"].string(node);
});

/***/ }),

/***/ "./src/helpers/index.js":
/*!******************************!*\
  !*** ./src/helpers/index.js ***!
  \******************************/
/*! exports provided: compose, flow, map, get, apply, createPlugin, withId, getUrl, isEmptyContent, useForceUpdate, useAndroidHack, isMarkActive, toggleMark, renderDefaultLeaf, makeRenderLeaf, composeRenderLeaf, isBlockActive, isList, renderDefaultElement, makeRenderElement, composeRenderElement, addMessageListener, postMessage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compose */ "./src/helpers/compose.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return _compose__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _flow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./flow */ "./src/helpers/flow.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flow", function() { return _flow__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map */ "./src/helpers/map.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "map", function() { return _map__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get */ "./src/helpers/get.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "get", function() { return _get__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _apply__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./apply */ "./src/helpers/apply.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "apply", function() { return _apply__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _createPlugin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./createPlugin */ "./src/helpers/createPlugin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createPlugin", function() { return _createPlugin__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _withId__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./withId */ "./src/helpers/withId.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withId", function() { return _withId__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _getUrl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./getUrl */ "./src/helpers/getUrl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getUrl", function() { return _getUrl__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _isEmptyContent__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./isEmptyContent */ "./src/helpers/isEmptyContent.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isEmptyContent", function() { return _isEmptyContent__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _useForceUpdate__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./useForceUpdate */ "./src/helpers/useForceUpdate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useForceUpdate", function() { return _useForceUpdate__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _useAndroidHack__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./useAndroidHack */ "./src/helpers/useAndroidHack.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useAndroidHack", function() { return _useAndroidHack__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _leafHelpers__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./leafHelpers */ "./src/helpers/leafHelpers.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMarkActive", function() { return _leafHelpers__WEBPACK_IMPORTED_MODULE_11__["isMarkActive"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toggleMark", function() { return _leafHelpers__WEBPACK_IMPORTED_MODULE_11__["toggleMark"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "renderDefaultLeaf", function() { return _leafHelpers__WEBPACK_IMPORTED_MODULE_11__["renderDefaultLeaf"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "makeRenderLeaf", function() { return _leafHelpers__WEBPACK_IMPORTED_MODULE_11__["makeRenderLeaf"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "composeRenderLeaf", function() { return _leafHelpers__WEBPACK_IMPORTED_MODULE_11__["composeRenderLeaf"]; });

/* harmony import */ var _elementHelpers__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./elementHelpers */ "./src/helpers/elementHelpers.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBlockActive", function() { return _elementHelpers__WEBPACK_IMPORTED_MODULE_12__["isBlockActive"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isList", function() { return _elementHelpers__WEBPACK_IMPORTED_MODULE_12__["isList"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "renderDefaultElement", function() { return _elementHelpers__WEBPACK_IMPORTED_MODULE_12__["renderDefaultElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "makeRenderElement", function() { return _elementHelpers__WEBPACK_IMPORTED_MODULE_12__["makeRenderElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "composeRenderElement", function() { return _elementHelpers__WEBPACK_IMPORTED_MODULE_12__["composeRenderElement"]; });

/* harmony import */ var _messageHelpers__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./messageHelpers */ "./src/helpers/messageHelpers.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addMessageListener", function() { return _messageHelpers__WEBPACK_IMPORTED_MODULE_13__["addMessageListener"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "postMessage", function() { return _messageHelpers__WEBPACK_IMPORTED_MODULE_13__["postMessage"]; });
















/***/ }),

/***/ "./src/helpers/isEmptyContent.js":
/*!***************************************!*\
  !*** ./src/helpers/isEmptyContent.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// This does not include validation
// https://docs.slatejs.org/concepts/10-normalizing#built-in-constraints
/* harmony default export */ __webpack_exports__["default"] = (function (content) {
  var _content$, _content$2, _content$2$children, _content$3, _content$3$children$;

  return (content === null || content === void 0 ? void 0 : content.length) === 1 && ((_content$ = content[0]) === null || _content$ === void 0 ? void 0 : _content$.type) === 'paragraph' && ((_content$2 = content[0]) === null || _content$2 === void 0 ? void 0 : (_content$2$children = _content$2.children) === null || _content$2$children === void 0 ? void 0 : _content$2$children.length) === 1 && ((_content$3 = content[0]) === null || _content$3 === void 0 ? void 0 : (_content$3$children$ = _content$3.children[0]) === null || _content$3$children$ === void 0 ? void 0 : _content$3$children$.text) === '';
});

/***/ }),

/***/ "./src/helpers/leafHelpers.js":
/*!************************************!*\
  !*** ./src/helpers/leafHelpers.js ***!
  \************************************/
/*! exports provided: isMarkActive, toggleMark, renderDefaultLeaf, makeRenderLeaf, composeRenderLeaf */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMarkActive", function() { return isMarkActive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toggleMark", function() { return toggleMark; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderDefaultLeaf", function() { return renderDefaultLeaf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeRenderLeaf", function() { return makeRenderLeaf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "composeRenderLeaf", function() { return composeRenderLeaf; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ "../node_modules/slate/dist/index.es.js");
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./compose */ "./src/helpers/compose.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var isMarkActive = function isMarkActive(editor, format) {
  var marks = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].marks(editor);
  return marks ? marks[format] === true : false;
};

var toggleMark = function toggleMark(editor, format) {
  var isActive = isMarkActive(editor, format);

  if (isActive) {
    slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].removeMark(editor, format);
  } else {
    slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].addMark(editor, format, true);
  }
};

var DefaultLeaf = 'span';

var renderDefaultLeaf = function renderDefaultLeaf(_ref) {
  var attributes = _ref.attributes,
      children = _ref.children;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(DefaultLeaf, attributes, children);
};

var makeRenderLeaf = function makeRenderLeaf(mark, CustomLeaf) {
  return function (next) {
    return function (props) {
      if (props.leaf[mark]) {
        var children = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(CustomLeaf, props);
        return next(_objectSpread(_objectSpread({}, props), {}, {
          children: children
        }));
      }

      return next(props);
    };
  };
};

var composeRenderLeaf = function composeRenderLeaf(plugins) {
  return _compose__WEBPACK_IMPORTED_MODULE_2__["default"].apply(void 0, _toConsumableArray(plugins.map(function (plugin) {
    return plugin.renderLeaf;
  })))(renderDefaultLeaf);
};



/***/ }),

/***/ "./src/helpers/map.js":
/*!****************************!*\
  !*** ./src/helpers/map.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var map = function map(iteratee) {
  return function (collection) {
    return collection.map(iteratee);
  };
};

/* harmony default export */ __webpack_exports__["default"] = (map);

/***/ }),

/***/ "./src/helpers/messageHelpers.js":
/*!***************************************!*\
  !*** ./src/helpers/messageHelpers.js ***!
  \***************************************/
/*! exports provided: addMessageListener, postMessage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addMessageListener", function() { return addMessageListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "postMessage", function() { return postMessage; });
var messagePrefix = '@hero-editor';

var addMessageListener = function addMessageListener(type, callback) {
  return function (editor) {
    var listener = function listener(event) {
      if (event.data.type === "".concat(messagePrefix, "/").concat(editor.id, "/").concat(type)) {
        callback({
          editor: editor,
          data: event.data.data
        });
      }
    };

    window.addEventListener('message', listener);
    return function () {
      return window.removeEventListener('message', listener);
    };
  };
};

var postMessage = function postMessage(type, data, editor) {
  var _window$ReactNativeWe;

  var message = {
    type: "".concat(messagePrefix, "/").concat(editor.id, "/").concat(type),
    data: data
  };
  window.postMessage(message, '*');
  (_window$ReactNativeWe = window.ReactNativeWebView) === null || _window$ReactNativeWe === void 0 ? void 0 : _window$ReactNativeWe.postMessage(JSON.stringify(message));
};



/***/ }),

/***/ "./src/helpers/useAndroidHack.js":
/*!***************************************!*\
  !*** ./src/helpers/useAndroidHack.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ "../node_modules/slate/dist/index.es.js");
/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! slate-react */ "../node_modules/slate-react/dist/index.es.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// https://github.com/ianstormtaylor/slate/issues/3470#issuecomment-639431390




var useAndroidHack = function useAndroidHack(editor) {
  var lastComposeData = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(null);
  var onDOMBeforeInput = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(function (e) {
    switch (e.inputType) {
      case 'insertCompositionText':
        {
          // We need to push each composition event so we can apply it when finished
          if (!lastComposeData.current) {
            lastComposeData.current = [];
          }

          try {
            var _selection$anchorNode;

            // We need to convert the selection right away, as the window.getSelection() will change with the window
            var selection = window.getSelection();
            var sel = slate_react__WEBPACK_IMPORTED_MODULE_2__["ReactEditor"].toSlateRange(editor, selection); // The offsets may not match because the composition text might be far ahead etc...

            sel.anchor.offset = selection.anchorOffset;
            sel.focus.offset = selection.focusOffset;
            lastComposeData.current.push({
              selection: sel,
              value: e.data,
              node: selection === null || selection === void 0 ? void 0 : selection.anchorNode,
              elementNode: selection === null || selection === void 0 ? void 0 : (_selection$anchorNode = selection.anchorNode) === null || _selection$anchorNode === void 0 ? void 0 : _selection$anchorNode.parentElement.closest('[data-slate-node="element"]')
            });
          } catch (_unused) {
            lastComposeData.current = null;
          }

          break;
        }

      case 'insertFromComposition':
      case 'deleteByComposition':
        // If we get this event we don't need to apply any sort of fix, this is the correct event to handle things
        lastComposeData.current = null;
        break;

      default:
        break;
    }
  }, [editor]);
  var onCompositionEnd = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(function (e) {
    var current = lastComposeData.current;

    if (current) {
      // Store the current selection so we can move back once we have finished applying queued changes
      // Convert to slate range straight away as the selection can get messed up due to element fixing code
      var _window$getSelection = window.getSelection(),
          anchorNode = _window$getSelection.anchorNode,
          anchorOffset = _window$getSelection.anchorOffset,
          focusNode = _window$getSelection.focusNode,
          focusOffset = _window$getSelection.focusOffset,
          isCollapsed = _window$getSelection.isCollapsed; // Apply each of the changes


      var _iterator = _createForOfIteratorHelper(current),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var c = _step.value;
          var selection = c.selection,
              value = c.value,
              node = c.node,
              elementNode = c.elementNode;
          slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].select(editor, selection);
          slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].insertText(editor, value);

          if (value) {
            // HACK #1 - when a new line is created slate creates a zero-width
            // but actually it will be filled in, this causes slate crashes
            // Have to recreate a full element instead of an empty element in slate
            var el = node.parentElement;

            if (el && el.hasAttribute('data-slate-zero-width')) {
              el.removeAttribute('data-slate-length');
              el.removeAttribute('data-slate-zero-width');
              el.setAttribute('data-slate-string', 'true');
              el.innerText = value;
              var _editor$selection$anc = editor.selection.anchor,
                  path = _editor$selection$anc.path,
                  offset = _editor$selection$anc.offset;
              var p = {
                path: path,
                offset: offset - 1
              };
              slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].select(editor, {
                anchor: p,
                focus: p
              });
            }
          } else {
            // HACK #2 - when an element is made empty during compose
            // the element is removed from dom, need to add it back
            // as a zero-width element to match
            var textNode = node.parentElement.closest('[data-slate-node="text"]');
            var _el = node.parentElement;

            if (elementNode && textNode && _el && elementNode.children.length === 1 && elementNode.children[0].nodeName === 'BR') {
              _el.innerHTML = '&#65279;';

              _el.setAttribute('data-slate-length', '0');

              _el.setAttribute('data-slate-zero-width', 'n');

              _el.removeAttribute('data-slate-string');

              elementNode.replaceChild(textNode, elementNode.children[0]);
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      lastComposeData.current = null; // Move back to existing selection

      try {
        var ss = slate_react__WEBPACK_IMPORTED_MODULE_2__["ReactEditor"].toSlateRange(editor, {
          startContainer: anchorNode,
          startOffset: anchorOffset,
          endContainer: focusNode,
          endOffset: focusOffset,
          collapsed: isCollapsed
        }); // Small fixup again

        ss.anchor.offset = anchorOffset;
        ss.focus.offset = focusOffset;
        slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].select(editor, ss); // Reset the dom selection as well... this can get out of alignment

        var sel = window.getSelection();
        sel.removeAllRanges();
        var newDomRange = slate_react__WEBPACK_IMPORTED_MODULE_2__["ReactEditor"].toDOMRange(editor, ss);

        if (newDomRange) {
          sel.addRange(newDomRange);
        }
      } catch (_unused2) {}
    } // Prevent slate from doing anything
    // This prevents the hack that is currently in onCompositionEnd that doesn't work


    e.data = null;
  }, [editor]);
  return {
    onCompositionEnd: onCompositionEnd,
    onDOMBeforeInput: onDOMBeforeInput
  };
};

/* harmony default export */ __webpack_exports__["default"] = (useAndroidHack);

/***/ }),

/***/ "./src/helpers/useForceUpdate.js":
/*!***************************************!*\
  !*** ./src/helpers/useForceUpdate.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }



var useForceUpdate = function useForceUpdate() {
  var prev = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(0);

  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(0),
      _useState2 = _slicedToArray(_useState, 2),
      curr = _useState2[0],
      setCurr = _useState2[1];

  var isForceUpdated = prev.current !== curr;
  prev.current = curr;
  return {
    isForceUpdated: isForceUpdated,
    forceUpdate: function forceUpdate() {
      return setCurr(curr + 1);
    }
  };
};

/* harmony default export */ __webpack_exports__["default"] = (useForceUpdate);

/***/ }),

/***/ "./src/helpers/why.js":
/*!****************************!*\
  !*** ./src/helpers/why.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// lmao
var y = function y(f) {
  return function (g) {
    return function () {
      return f(g(g)).apply(void 0, arguments);
    };
  }(function (g) {
    return function () {
      return f(g(g)).apply(void 0, arguments);
    };
  });
};

/* harmony default export */ __webpack_exports__["default"] = (y);

/***/ }),

/***/ "./src/helpers/withId.js":
/*!*******************************!*\
  !*** ./src/helpers/withId.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var withId = function withId(id) {
  return function (editor) {
    editor.id = id;
    return editor;
  };
};

/* harmony default export */ __webpack_exports__["default"] = (withId);

/***/ }),

/***/ "./src/lib.js":
/*!********************!*\
  !*** ./src/lib.js ***!
  \********************/
/*! exports provided: bold, italic, underline, logger, bulletedList, numberedList, listItem, mention, editorPlaceholder, link, cursorTracker, headingOne, JsonViewer, Toolbar, plainSerializer, makeReactTransformer, defaultReactTransformer, isEmptyContent, getUrl, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ "../node_modules/slate/dist/index.es.js");
/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! slate-react */ "../node_modules/slate-react/dist/index.es.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers */ "./src/helpers/index.js");
/* harmony import */ var _components_Toolbar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/Toolbar */ "./src/components/Toolbar.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants */ "./src/constants.js");
/* harmony import */ var _plugins__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./plugins */ "./src/plugins/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bold", function() { return _plugins__WEBPACK_IMPORTED_MODULE_6__["bold"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "italic", function() { return _plugins__WEBPACK_IMPORTED_MODULE_6__["italic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "underline", function() { return _plugins__WEBPACK_IMPORTED_MODULE_6__["underline"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logger", function() { return _plugins__WEBPACK_IMPORTED_MODULE_6__["logger"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bulletedList", function() { return _plugins__WEBPACK_IMPORTED_MODULE_6__["bulletedList"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "numberedList", function() { return _plugins__WEBPACK_IMPORTED_MODULE_6__["numberedList"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "listItem", function() { return _plugins__WEBPACK_IMPORTED_MODULE_6__["listItem"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mention", function() { return _plugins__WEBPACK_IMPORTED_MODULE_6__["mention"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "editorPlaceholder", function() { return _plugins__WEBPACK_IMPORTED_MODULE_6__["editorPlaceholder"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "link", function() { return _plugins__WEBPACK_IMPORTED_MODULE_6__["link"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cursorTracker", function() { return _plugins__WEBPACK_IMPORTED_MODULE_6__["cursorTracker"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "headingOne", function() { return _plugins__WEBPACK_IMPORTED_MODULE_6__["headingOne"]; });

/* harmony import */ var _components_JsonViewer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/JsonViewer */ "./src/components/JsonViewer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "JsonViewer", function() { return _components_JsonViewer__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Toolbar", function() { return _components_Toolbar__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _serializers_plain__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./serializers/plain */ "./src/serializers/plain.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "plainSerializer", function() { return _serializers_plain__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _transformers_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./transformers/react */ "./src/transformers/react.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "makeReactTransformer", function() { return _transformers_react__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaultReactTransformer", function() { return _transformers_react__WEBPACK_IMPORTED_MODULE_9__["defaultReactTransformer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isEmptyContent", function() { return _helpers__WEBPACK_IMPORTED_MODULE_3__["isEmptyContent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getUrl", function() { return _helpers__WEBPACK_IMPORTED_MODULE_3__["getUrl"]; });

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }







var styles = {
  editorWrapper: {
    fontFamily: 'sans-serif',
    border: 'solid thin #eaeaea',
    borderRadius: 4
  },
  editableWrapper: {
    position: 'relative'
  },
  editable: {
    padding: 16
  }
};

var getCustomElements = function getCustomElements(editor) {
  return Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["map"])(Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["flow"])(Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["get"])('renderCustom'), Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["apply"])([editor])));
};

var addMessageListeners = function addMessageListeners(editor) {
  return Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["map"])(Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["flow"])(Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["get"])('handleMessage'), Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["apply"])([editor])));
};

var getToolbarButtons = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["map"])(function (_ref) {
  var name = _ref.name,
      ToolbarButton = _ref.ToolbarButton;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ToolbarButton, {
    key: name
  });
});

var noop = function noop() {};

var HeroEditor = function HeroEditor(_ref2) {
  var id = _ref2.id,
      _ref2$showToolbar = _ref2.showToolbar,
      showToolbar = _ref2$showToolbar === void 0 ? true : _ref2$showToolbar,
      _ref2$autoFocus = _ref2.autoFocus,
      autoFocus = _ref2$autoFocus === void 0 ? false : _ref2$autoFocus,
      _ref2$plugins = _ref2.plugins,
      plugins = _ref2$plugins === void 0 ? [] : _ref2$plugins,
      placeholder = _ref2.placeholder,
      value = _ref2.value,
      _onChange = _ref2.onChange,
      _ref2$onFocus = _ref2.onFocus,
      _onFocus = _ref2$onFocus === void 0 ? noop : _ref2$onFocus,
      _ref2$onBlur = _ref2.onBlur,
      _onBlur = _ref2$onBlur === void 0 ? noop : _ref2$onBlur,
      _ref2$onLayout = _ref2.onLayout,
      onLayout = _ref2$onLayout === void 0 ? noop : _ref2$onLayout,
      wrapperStyle = _ref2.wrapperStyle,
      editableStyle = _ref2.editableStyle,
      _ref2$isAndroid = _ref2.isAndroid,
      isAndroid = _ref2$isAndroid === void 0 ? false : _ref2$isAndroid;

  var wrapper = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(null);
  var wrapperLayout = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])({
    width: 0,
    height: 0
  });
  var editor = Object(react__WEBPACK_IMPORTED_MODULE_0__["useMemo"])(function () {
    return _helpers__WEBPACK_IMPORTED_MODULE_3__["flow"].apply(void 0, [slate__WEBPACK_IMPORTED_MODULE_1__["createEditor"], slate_react__WEBPACK_IMPORTED_MODULE_2__["withReact"], Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["withId"])(id)].concat(_toConsumableArray(Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["map"])(Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["get"])('enhanceEditor'))(plugins))))();
  }, []);
  var renderLeaf = Object(react__WEBPACK_IMPORTED_MODULE_0__["useMemo"])(function () {
    return Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["composeRenderLeaf"])(plugins);
  }, [plugins]);
  var renderElement = Object(react__WEBPACK_IMPORTED_MODULE_0__["useMemo"])(function () {
    return Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["composeRenderElement"])(plugins);
  }, [plugins]);
  var renderCustom = Object(react__WEBPACK_IMPORTED_MODULE_0__["useMemo"])(function () {
    return function () {
      return getCustomElements(editor)(plugins);
    };
  }, [plugins, value]);
  var toolBarButtons = Object(react__WEBPACK_IMPORTED_MODULE_0__["useMemo"])(function () {
    return getToolbarButtons(plugins);
  }, [plugins]);
  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    var removeHandlers = addMessageListeners(editor)(plugins);
    return function () {
      return removeHandlers.forEach(function (removeHandler) {
        return removeHandler();
      });
    };
  }, [plugins]);
  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    var _wrapper$current, _wrapper$current2;

    var width = (_wrapper$current = wrapper.current) === null || _wrapper$current === void 0 ? void 0 : _wrapper$current.offsetWidth;
    var height = (_wrapper$current2 = wrapper.current) === null || _wrapper$current2 === void 0 ? void 0 : _wrapper$current2.offsetHeight;

    if (width !== wrapperLayout.current.width || height !== wrapperLayout.current.height) {
      wrapperLayout.current = {
        width: width,
        height: height
      };
      onLayout(wrapperLayout.current);
      Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["postMessage"])(_constants__WEBPACK_IMPORTED_MODULE_5__["EDITOR_LAYOUT"], wrapperLayout.current, editor);
    }
  }, [value]); // Hack for Slate 0.58 on Android

  var onCompositionEnd, onDOMBeforeInput;

  if (isAndroid) {
    var _useAndroidHack = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["useAndroidHack"])(editor);

    onCompositionEnd = _useAndroidHack.onCompositionEnd;
    onDOMBeforeInput = _useAndroidHack.onDOMBeforeInput;
  }

  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
    ref: wrapper,
    className: "hero-editor--wrapper",
    style: _objectSpread(_objectSpread({}, styles.editorWrapper), wrapperStyle)
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(slate_react__WEBPACK_IMPORTED_MODULE_2__["Slate"], {
    editor: editor,
    value: value,
    onChange: function onChange(value) {
      _onChange(value);

      Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["postMessage"])(_constants__WEBPACK_IMPORTED_MODULE_5__["EDITOR_CHANGE"], {
        value: value
      }, editor);
    }
  }, showToolbar ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Toolbar__WEBPACK_IMPORTED_MODULE_4__["default"], null, toolBarButtons) : null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
    style: styles.editableWrapper
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(slate_react__WEBPACK_IMPORTED_MODULE_2__["Editable"], {
    className: "hero-editor--editable",
    placeholder: placeholder,
    spellCheck: true,
    onCompositionEnd: onCompositionEnd,
    onDOMBeforeInput: onDOMBeforeInput,
    autoFocus: autoFocus,
    renderLeaf: renderLeaf,
    renderElement: renderElement,
    onFocus: function onFocus(e) {
      _onFocus(e);

      Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["postMessage"])(_constants__WEBPACK_IMPORTED_MODULE_5__["EDITOR_FOCUS"], {}, editor);
    },
    onBlur: function onBlur(e) {
      _onBlur(e);

      Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["postMessage"])(_constants__WEBPACK_IMPORTED_MODULE_5__["EDITOR_BLUR"], {}, editor);
    },
    style: _objectSpread(_objectSpread({}, styles.editable), editableStyle)
  }), renderCustom())));
};








/* harmony default export */ __webpack_exports__["default"] = (HeroEditor);

/***/ }),

/***/ "./src/plugins/bold.js":
/*!*****************************!*\
  !*** ./src/plugins/bold.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate-react */ "../node_modules/slate-react/dist/index.es.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers */ "./src/helpers/index.js");
/* harmony import */ var _components_Toolbar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/Toolbar */ "./src/components/Toolbar.js");
/* harmony import */ var _components_Icon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/Icon */ "./src/components/Icon.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants */ "./src/constants.js");






var renderLeaf = Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["makeRenderLeaf"])(_constants__WEBPACK_IMPORTED_MODULE_5__["BOLD"], function (_ref) {
  var children = _ref.children;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("strong", null, children);
});
var handleMessage = Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["addMessageListener"])(_constants__WEBPACK_IMPORTED_MODULE_5__["BOLD"], function (_ref2) {
  var editor = _ref2.editor;
  Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["toggleMark"])(editor, _constants__WEBPACK_IMPORTED_MODULE_5__["BOLD"]);
});

var ToolbarButton = function ToolbarButton() {
  var editor = Object(slate_react__WEBPACK_IMPORTED_MODULE_1__["useSlate"])();
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Toolbar__WEBPACK_IMPORTED_MODULE_3__["default"].Button, {
    active: Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["isMarkActive"])(editor, _constants__WEBPACK_IMPORTED_MODULE_5__["BOLD"]),
    onMouseDown: function onMouseDown(event) {
      event.preventDefault();
      Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["postMessage"])(_constants__WEBPACK_IMPORTED_MODULE_5__["BOLD"], {}, editor);
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_4__["default"], null, "format_bold"));
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["createPlugin"])({
    name: _constants__WEBPACK_IMPORTED_MODULE_5__["BOLD"],
    renderLeaf: renderLeaf,
    handleMessage: handleMessage,
    ToolbarButton: ToolbarButton
  });
});

/***/ }),

/***/ "./src/plugins/bulletedList.js":
/*!*************************************!*\
  !*** ./src/plugins/bulletedList.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ "../node_modules/slate/dist/index.es.js");
/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! slate-react */ "../node_modules/slate-react/dist/index.es.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers */ "./src/helpers/index.js");
/* harmony import */ var _components_Toolbar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/Toolbar */ "./src/components/Toolbar.js");
/* harmony import */ var _components_Icon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/Icon */ "./src/components/Icon.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../constants */ "./src/constants.js");







var renderElement = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["makeRenderElement"])(_constants__WEBPACK_IMPORTED_MODULE_6__["BULLETED_LIST"], function (_ref) {
  var attributes = _ref.attributes,
      children = _ref.children;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("ul", attributes, children);
});
var handleMessage = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["addMessageListener"])(_constants__WEBPACK_IMPORTED_MODULE_6__["BULLETED_LIST"], function (_ref2) {
  var editor = _ref2.editor;
  var isActive = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["isBlockActive"])(editor, _constants__WEBPACK_IMPORTED_MODULE_6__["BULLETED_LIST"]); // Unwrap all the items of any list

  slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].unwrapNodes(editor, {
    match: _helpers__WEBPACK_IMPORTED_MODULE_3__["isList"],
    split: true
  });

  if (isActive) {
    slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].setNodes(editor, {
      type: 'paragraph'
    });
  } else {
    slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].setNodes(editor, {
      type: _constants__WEBPACK_IMPORTED_MODULE_6__["LIST_ITEM"]
    });
    slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].wrapNodes(editor, {
      type: _constants__WEBPACK_IMPORTED_MODULE_6__["BULLETED_LIST"],
      children: []
    });
  }
});

var ToolbarButton = function ToolbarButton() {
  var editor = Object(slate_react__WEBPACK_IMPORTED_MODULE_2__["useSlate"])();
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Toolbar__WEBPACK_IMPORTED_MODULE_4__["default"].Button, {
    active: Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["isBlockActive"])(editor, _constants__WEBPACK_IMPORTED_MODULE_6__["BULLETED_LIST"]),
    onMouseDown: function onMouseDown(event) {
      event.preventDefault();
      Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["postMessage"])(_constants__WEBPACK_IMPORTED_MODULE_6__["BULLETED_LIST"], {}, editor);
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_5__["default"], null, "format_list_bulleted"));
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["createPlugin"])({
    name: _constants__WEBPACK_IMPORTED_MODULE_6__["BULLETED_LIST"],
    renderElement: renderElement,
    handleMessage: handleMessage,
    ToolbarButton: ToolbarButton
  });
});

/***/ }),

/***/ "./src/plugins/cursorTracker.js":
/*!**************************************!*\
  !*** ./src/plugins/cursorTracker.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! slate-react */ "../node_modules/slate-react/dist/index.es.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers */ "./src/helpers/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants */ "./src/constants.js");



var handleMessage = Object(_helpers__WEBPACK_IMPORTED_MODULE_1__["addMessageListener"])(_constants__WEBPACK_IMPORTED_MODULE_2__["EDITOR_CHANGE"], function (_ref) {
  var editor = _ref.editor;
  var selection = editor.selection;

  if (selection) {
    var domRange = slate_react__WEBPACK_IMPORTED_MODULE_0__["ReactEditor"].toDOMRange(editor, selection);
    var rangeRect = domRange.getBoundingClientRect();
    Object(_helpers__WEBPACK_IMPORTED_MODULE_1__["postMessage"])('cursor-change', {
      offset: undefined,
      position: {
        top: rangeRect.top,
        left: rangeRect.left
      }
    }, editor);
  }
});
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_helpers__WEBPACK_IMPORTED_MODULE_1__["createPlugin"])({
    name: 'cursor-tracker',
    handleMessage: handleMessage
  });
});

/***/ }),

/***/ "./src/plugins/editorPlaceholder.js":
/*!******************************************!*\
  !*** ./src/plugins/editorPlaceholder.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers */ "./src/helpers/index.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var styles = {
  placeholder: {
    boxSizing: 'border-box',
    position: 'absolute',
    top: 0,
    left: 0,
    width: '100%',
    padding: 16,
    lineHeight: 1.5,
    color: 'lightgrey',
    pointerEvents: 'none'
  }
};
var CACHE_TTL = 50;

var isDefined = function isDefined(ref) {
  return typeof ref.current !== 'undefined';
};

var EditorPlaceholder = function EditorPlaceholder(_ref) {
  var value = _ref.value,
      editor = _ref.editor,
      style = _ref.style;
  var cache = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(undefined);

  var _useForceUpdate = Object(_helpers__WEBPACK_IMPORTED_MODULE_1__["useForceUpdate"])(),
      isForceUpdated = _useForceUpdate.isForceUpdated,
      forceUpdate = _useForceUpdate.forceUpdate;

  var createPlaceholder = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(function () {
    var isEmpty = Object(_helpers__WEBPACK_IMPORTED_MODULE_1__["isEmptyContent"])(editor.children);

    var mergedStyle = _objectSpread(_objectSpread({}, styles.placeholder), style);

    return isEmpty ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      style: mergedStyle
    }, value) : null;
  }, []);
  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    if (isDefined(cache)) {
      var timerId = setTimeout(function () {
        cache.current = undefined;
        if (!isForceUpdated) forceUpdate();
      }, CACHE_TTL);
      return function () {
        return clearTimeout(timerId);
      };
    }
  });
  if (isDefined(cache)) return cache.current;
  cache.current = createPlaceholder();
  return cache.current;
};

/* harmony default export */ __webpack_exports__["default"] = (function (_ref2) {
  var value = _ref2.value,
      style = _ref2.style;
  return Object(_helpers__WEBPACK_IMPORTED_MODULE_1__["createPlugin"])({
    name: 'editor-placeholder',
    renderCustom: function renderCustom(editor) {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(EditorPlaceholder, {
        key: "editor-placeholder",
        value: value,
        editor: editor,
        style: style
      });
    }
  });
});

/***/ }),

/***/ "./src/plugins/headingOne.js":
/*!***********************************!*\
  !*** ./src/plugins/headingOne.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ "../node_modules/slate/dist/index.es.js");
/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! slate-react */ "../node_modules/slate-react/dist/index.es.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers */ "./src/helpers/index.js");
/* harmony import */ var _components_Toolbar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/Toolbar */ "./src/components/Toolbar.js");
/* harmony import */ var _components_Icon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/Icon */ "./src/components/Icon.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../constants */ "./src/constants.js");







var renderElement = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["makeRenderElement"])(_constants__WEBPACK_IMPORTED_MODULE_6__["HEADING_ONE"], function (_ref) {
  var attributes = _ref.attributes,
      children = _ref.children;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("h1", attributes, children);
});
var handleMessage = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["addMessageListener"])(_constants__WEBPACK_IMPORTED_MODULE_6__["HEADING_ONE"], function (_ref2) {
  var editor = _ref2.editor;
  var isActive = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["isBlockActive"])(editor, _constants__WEBPACK_IMPORTED_MODULE_6__["HEADING_ONE"]); // Unwrap all the items of any list

  slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].unwrapNodes(editor, {
    match: _helpers__WEBPACK_IMPORTED_MODULE_3__["isList"],
    split: true
  });
  slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].setNodes(editor, {
    type: isActive ? 'paragraph' : _constants__WEBPACK_IMPORTED_MODULE_6__["HEADING_ONE"]
  });
});

var ToolbarButton = function ToolbarButton() {
  var editor = Object(slate_react__WEBPACK_IMPORTED_MODULE_2__["useSlate"])();
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Toolbar__WEBPACK_IMPORTED_MODULE_4__["default"].Button, {
    active: Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["isBlockActive"])(editor, _constants__WEBPACK_IMPORTED_MODULE_6__["HEADING_ONE"]),
    onMouseDown: function onMouseDown(event) {
      event.preventDefault();
      Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["postMessage"])(_constants__WEBPACK_IMPORTED_MODULE_6__["HEADING_ONE"], {}, editor);
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_5__["default"], null, "looks_one"));
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["createPlugin"])({
    name: _constants__WEBPACK_IMPORTED_MODULE_6__["HEADING_ONE"],
    renderElement: renderElement,
    handleMessage: handleMessage,
    ToolbarButton: ToolbarButton
  });
});

/***/ }),

/***/ "./src/plugins/index.js":
/*!******************************!*\
  !*** ./src/plugins/index.js ***!
  \******************************/
/*! exports provided: bold, italic, underline, logger, bulletedList, numberedList, listItem, mention, editorPlaceholder, link, cursorTracker, headingOne */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _bold__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bold */ "./src/plugins/bold.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bold", function() { return _bold__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _italic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./italic */ "./src/plugins/italic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "italic", function() { return _italic__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _underline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./underline */ "./src/plugins/underline.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "underline", function() { return _underline__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./logger */ "./src/plugins/logger.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logger", function() { return _logger__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _bulletedList__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bulletedList */ "./src/plugins/bulletedList.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bulletedList", function() { return _bulletedList__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _numberedList__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./numberedList */ "./src/plugins/numberedList.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "numberedList", function() { return _numberedList__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _listItem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./listItem */ "./src/plugins/listItem.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "listItem", function() { return _listItem__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _mention__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mention */ "./src/plugins/mention.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mention", function() { return _mention__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _editorPlaceholder__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./editorPlaceholder */ "./src/plugins/editorPlaceholder.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "editorPlaceholder", function() { return _editorPlaceholder__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _link__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./link */ "./src/plugins/link.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "link", function() { return _link__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _cursorTracker__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./cursorTracker */ "./src/plugins/cursorTracker.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cursorTracker", function() { return _cursorTracker__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _headingOne__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./headingOne */ "./src/plugins/headingOne.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "headingOne", function() { return _headingOne__WEBPACK_IMPORTED_MODULE_11__["default"]; });














/***/ }),

/***/ "./src/plugins/italic.js":
/*!*******************************!*\
  !*** ./src/plugins/italic.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate-react */ "../node_modules/slate-react/dist/index.es.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers */ "./src/helpers/index.js");
/* harmony import */ var _components_Toolbar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/Toolbar */ "./src/components/Toolbar.js");
/* harmony import */ var _components_Icon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/Icon */ "./src/components/Icon.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants */ "./src/constants.js");






var renderLeaf = Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["makeRenderLeaf"])(_constants__WEBPACK_IMPORTED_MODULE_5__["ITALIC"], function (_ref) {
  var children = _ref.children;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("em", null, children);
});
var handleMessage = Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["addMessageListener"])(_constants__WEBPACK_IMPORTED_MODULE_5__["ITALIC"], function (_ref2) {
  var editor = _ref2.editor;
  Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["toggleMark"])(editor, _constants__WEBPACK_IMPORTED_MODULE_5__["ITALIC"]);
});

var ToolbarButton = function ToolbarButton() {
  var editor = Object(slate_react__WEBPACK_IMPORTED_MODULE_1__["useSlate"])();
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Toolbar__WEBPACK_IMPORTED_MODULE_3__["default"].Button, {
    active: Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["isMarkActive"])(editor, _constants__WEBPACK_IMPORTED_MODULE_5__["ITALIC"]),
    onMouseDown: function onMouseDown(event) {
      event.preventDefault();
      Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["postMessage"])(_constants__WEBPACK_IMPORTED_MODULE_5__["ITALIC"], {}, editor);
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_4__["default"], null, "format_italic"));
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["createPlugin"])({
    name: _constants__WEBPACK_IMPORTED_MODULE_5__["ITALIC"],
    renderLeaf: renderLeaf,
    handleMessage: handleMessage,
    ToolbarButton: ToolbarButton
  });
});

/***/ }),

/***/ "./src/plugins/link.js":
/*!*****************************!*\
  !*** ./src/plugins/link.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var is_url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! is-url */ "../node_modules/is-url/index.js");
/* harmony import */ var is_url__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(is_url__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! slate */ "../node_modules/slate/dist/index.es.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers */ "./src/helpers/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants */ "./src/constants.js");
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }







var getUrl = function getUrl(element) {
  return element.children.reduce(function (url, node) {
    return url + node.text;
  }, '');
};

var LinkElement = function LinkElement(_ref) {
  var attributes = _ref.attributes,
      children = _ref.children,
      element = _ref.element;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", _extends({}, attributes, {
    href: getUrl(element)
  }), children);
};

var renderElement = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["makeRenderElement"])(_constants__WEBPACK_IMPORTED_MODULE_4__["LINK"], LinkElement);
var handleMessage = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["addMessageListener"])(_constants__WEBPACK_IMPORTED_MODULE_4__["LINK"], function (_ref2) {
  var editor = _ref2.editor,
      url = _ref2.data.url;
  slate__WEBPACK_IMPORTED_MODULE_2__["Transforms"].insertNodes(editor, {
    type: _constants__WEBPACK_IMPORTED_MODULE_4__["LINK"],
    data: {
      url: url
    },
    children: [{
      text: url
    }]
  });
});

var enhanceEditor = function enhanceEditor(editor) {
  var isInline = editor.isInline,
      insertData = editor.insertData;

  editor.isInline = function (element) {
    return element.type === _constants__WEBPACK_IMPORTED_MODULE_4__["LINK"] ? true : isInline(element);
  };

  editor.insertData = function (data) {
    var text = data.getData('text/plain');

    if (text && is_url__WEBPACK_IMPORTED_MODULE_1___default()(text)) {
      Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["postMessage"])(_constants__WEBPACK_IMPORTED_MODULE_4__["LINK"], {
        url: text
      }, editor);
    } else {
      insertData(data);
    }
  };

  return editor;
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["createPlugin"])({
    name: _constants__WEBPACK_IMPORTED_MODULE_4__["LINK"],
    renderElement: renderElement,
    handleMessage: handleMessage,
    enhanceEditor: enhanceEditor
  });
});

/***/ }),

/***/ "./src/plugins/listItem.js":
/*!*********************************!*\
  !*** ./src/plugins/listItem.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers */ "./src/helpers/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants */ "./src/constants.js");



var renderElement = Object(_helpers__WEBPACK_IMPORTED_MODULE_1__["makeRenderElement"])(_constants__WEBPACK_IMPORTED_MODULE_2__["LIST_ITEM"], function (_ref) {
  var attributes = _ref.attributes,
      children = _ref.children;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", attributes, children);
});
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_helpers__WEBPACK_IMPORTED_MODULE_1__["createPlugin"])({
    name: _constants__WEBPACK_IMPORTED_MODULE_2__["LIST_ITEM"],
    renderElement: renderElement
  });
});

/***/ }),

/***/ "./src/plugins/logger.js":
/*!*******************************!*\
  !*** ./src/plugins/logger.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers */ "./src/helpers/index.js");

var name = 'logger';

var isEmpty = function isEmpty(object) {
  return object && Object.keys(object).length < 1;
};

var handleMessage = function handleMessage() {
  var listener = function listener(event) {
    var _event$data$type;

    if ((_event$data$type = event.data.type) === null || _event$data$type === void 0 ? void 0 : _event$data$type.startsWith('@hero-editor')) {
      var groupMethod = isEmpty(event.data.data) ? 'groupCollapsed' : 'group';
      console[groupMethod]("%c ".concat(event.data.type, " "), 'color: limegreen;');
      console.log({
        data: event.data.data,
        event: event
      });
      console.groupEnd();
    }
  };

  window.addEventListener('message', listener);
  return function () {
    return window.removeEventListener('message', listener);
  };
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_helpers__WEBPACK_IMPORTED_MODULE_0__["createPlugin"])({
    name: name,
    handleMessage: handleMessage
  });
});

/***/ }),

/***/ "./src/plugins/mention.js":
/*!********************************!*\
  !*** ./src/plugins/mention.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ "../node_modules/slate/dist/index.es.js");
/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! slate-react */ "../node_modules/slate-react/dist/index.es.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers */ "./src/helpers/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants */ "./src/constants.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }







var MentionElement = function MentionElement(_ref) {
  var attributes = _ref.attributes,
      children = _ref.children,
      element = _ref.element;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", _extends({}, attributes, {
    contentEditable: false,
    style: {
      padding: '2px 4px',
      background: '#eeeeee',
      borderRadius: 4
    }
  }), "@", element.data.name, children);
};

var renderElement = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["makeRenderElement"])(_constants__WEBPACK_IMPORTED_MODULE_4__["MENTION"], MentionElement);

var handleMessage = function handleMessage(editor) {
  var removeEditorChangeListener = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["addMessageListener"])(_constants__WEBPACK_IMPORTED_MODULE_4__["EDITOR_CHANGE"], function (_ref2) {
    var editor = _ref2.editor;
    var selection = editor.selection;

    if (selection && slate__WEBPACK_IMPORTED_MODULE_1__["Range"].isCollapsed(selection)) {
      var _Range$edges = slate__WEBPACK_IMPORTED_MODULE_1__["Range"].edges(selection),
          _Range$edges2 = _slicedToArray(_Range$edges, 1),
          start = _Range$edges2[0];

      var wordBefore = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].before(editor, start, {
        unit: 'word'
      });
      var before = wordBefore && slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].before(editor, wordBefore);
      var beforeRange = before && slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].range(editor, before, start);
      var beforeText = beforeRange && slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].string(editor, beforeRange);
      var beforeMatch = beforeText && beforeText.match(/^@(\w+)$/);
      var after = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].after(editor, start);
      var afterRange = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].range(editor, start, after);
      var afterText = slate__WEBPACK_IMPORTED_MODULE_1__["Editor"].string(editor, afterRange);
      var afterMatch = afterText.match(/^(\s|$)/);

      if (beforeMatch && afterMatch) {
        Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["postMessage"])('mention-search', {
          target: beforeRange,
          search: beforeMatch[1]
        }, editor);
      } else {
        Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["postMessage"])('mention-search', {
          target: null,
          search: ''
        }, editor);
      }
    }
  })(editor);
  var removeMentionApplyListener = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["addMessageListener"])('mention-apply', function (_ref3) {
    var editor = _ref3.editor,
        data = _ref3.data;
    var id = data.id,
        name = data.name,
        meta = data.meta,
        target = data.target;
    slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].select(editor, target);
    var mention = {
      type: _constants__WEBPACK_IMPORTED_MODULE_4__["MENTION"],
      data: {
        id: id,
        name: name,
        meta: meta
      },
      children: [{
        text: ''
      }]
    };
    slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].insertNodes(editor, mention);
    slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].move(editor);
  })(editor);
  return function () {
    removeEditorChangeListener();
    removeMentionApplyListener();
  };
};

var MentionListWrapper = function MentionListWrapper(_ref4) {
  var renderMentionList = _ref4.renderMentionList;

  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(''),
      _useState2 = _slicedToArray(_useState, 2),
      search = _useState2[0],
      setSearch = _useState2[1];

  var _useState3 = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(null),
      _useState4 = _slicedToArray(_useState3, 2),
      target = _useState4[0],
      setTarget = _useState4[1];

  var wrapper = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(null);
  var editor = Object(slate_react__WEBPACK_IMPORTED_MODULE_2__["useSlate"])();
  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    var removeMentionSearchListener = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["addMessageListener"])('mention-search', function (_ref5) {
      var data = _ref5.data;
      var wrapperEl = wrapper.current;

      if (data.target) {
        var domRange = slate_react__WEBPACK_IMPORTED_MODULE_2__["ReactEditor"].toDOMRange(editor, data.target);
        var rangeRect = domRange.getBoundingClientRect();
        var editorRect = wrapperEl.parentElement.getBoundingClientRect();
        wrapperEl.style.display = 'block';
        wrapperEl.style.top = "".concat(rangeRect.top - editorRect.top + 20, "px");
        wrapperEl.style.left = "".concat(rangeRect.left - editorRect.left, "px");
      } else {
        wrapperEl.style.display = 'none';
      }

      setSearch(data.search);
      setTarget(data.target);
    })(editor);
    return function () {
      return removeMentionSearchListener();
    };
  }, []);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
    ref: wrapper,
    style: {
      position: 'absolute',
      zIndex: 1,
      display: 'none'
    }
  }, renderMentionList(search, function (_ref6) {
    var id = _ref6.id,
        name = _ref6.name,
        meta = _ref6.meta;
    Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["postMessage"])('mention-apply', {
      id: id,
      name: name,
      meta: meta,
      target: target
    }, editor);
  }));
};

var enhanceEditor = function enhanceEditor(editor) {
  var isInline = editor.isInline,
      isVoid = editor.isVoid;

  editor.isInline = function (element) {
    return element.type === _constants__WEBPACK_IMPORTED_MODULE_4__["MENTION"] ? true : isInline(element);
  };

  editor.isVoid = function (element) {
    return element.type === _constants__WEBPACK_IMPORTED_MODULE_4__["MENTION"] ? true : isVoid(element);
  };

  return editor;
};

/* harmony default export */ __webpack_exports__["default"] = (function (_ref7) {
  var renderMentionList = _ref7.renderMentionList;
  return Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["createPlugin"])({
    name: _constants__WEBPACK_IMPORTED_MODULE_4__["MENTION"],
    renderElement: renderElement,
    renderCustom: function renderCustom() {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(MentionListWrapper, {
        key: _constants__WEBPACK_IMPORTED_MODULE_4__["MENTION"],
        renderMentionList: renderMentionList
      });
    },
    handleMessage: handleMessage,
    enhanceEditor: enhanceEditor
  });
});

/***/ }),

/***/ "./src/plugins/numberedList.js":
/*!*************************************!*\
  !*** ./src/plugins/numberedList.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ "../node_modules/slate/dist/index.es.js");
/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! slate-react */ "../node_modules/slate-react/dist/index.es.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers */ "./src/helpers/index.js");
/* harmony import */ var _components_Toolbar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/Toolbar */ "./src/components/Toolbar.js");
/* harmony import */ var _components_Icon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/Icon */ "./src/components/Icon.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../constants */ "./src/constants.js");







var renderElement = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["makeRenderElement"])(_constants__WEBPACK_IMPORTED_MODULE_6__["NUMBERED_LIST"], function (_ref) {
  var attributes = _ref.attributes,
      children = _ref.children;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("ol", attributes, children);
});
var handleMessage = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["addMessageListener"])(_constants__WEBPACK_IMPORTED_MODULE_6__["NUMBERED_LIST"], function (_ref2) {
  var editor = _ref2.editor;
  var isActive = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["isBlockActive"])(editor, _constants__WEBPACK_IMPORTED_MODULE_6__["NUMBERED_LIST"]); // Unwrap all the items of any list

  slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].unwrapNodes(editor, {
    match: _helpers__WEBPACK_IMPORTED_MODULE_3__["isList"],
    split: true
  });

  if (isActive) {
    slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].setNodes(editor, {
      type: 'paragraph'
    });
  } else {
    slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].setNodes(editor, {
      type: _constants__WEBPACK_IMPORTED_MODULE_6__["LIST_ITEM"]
    });
    slate__WEBPACK_IMPORTED_MODULE_1__["Transforms"].wrapNodes(editor, {
      type: _constants__WEBPACK_IMPORTED_MODULE_6__["NUMBERED_LIST"],
      children: []
    });
  }
});

var ToolbarButton = function ToolbarButton() {
  var editor = Object(slate_react__WEBPACK_IMPORTED_MODULE_2__["useSlate"])();
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Toolbar__WEBPACK_IMPORTED_MODULE_4__["default"].Button, {
    active: Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["isBlockActive"])(editor, _constants__WEBPACK_IMPORTED_MODULE_6__["NUMBERED_LIST"]),
    onMouseDown: function onMouseDown(event) {
      event.preventDefault();
      Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["postMessage"])(_constants__WEBPACK_IMPORTED_MODULE_6__["NUMBERED_LIST"], {}, editor);
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_5__["default"], null, "format_list_numbered"));
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["createPlugin"])({
    name: _constants__WEBPACK_IMPORTED_MODULE_6__["NUMBERED_LIST"],
    renderElement: renderElement,
    handleMessage: handleMessage,
    ToolbarButton: ToolbarButton
  });
});

/***/ }),

/***/ "./src/plugins/underline.js":
/*!**********************************!*\
  !*** ./src/plugins/underline.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate-react */ "../node_modules/slate-react/dist/index.es.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers */ "./src/helpers/index.js");
/* harmony import */ var _components_Toolbar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/Toolbar */ "./src/components/Toolbar.js");
/* harmony import */ var _components_Icon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/Icon */ "./src/components/Icon.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants */ "./src/constants.js");






var renderLeaf = Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["makeRenderLeaf"])(_constants__WEBPACK_IMPORTED_MODULE_5__["UNDERLINE"], function (_ref) {
  var children = _ref.children;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("u", null, children);
});
var handleMessage = Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["addMessageListener"])(_constants__WEBPACK_IMPORTED_MODULE_5__["UNDERLINE"], function (_ref2) {
  var editor = _ref2.editor;
  Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["toggleMark"])(editor, _constants__WEBPACK_IMPORTED_MODULE_5__["UNDERLINE"]);
});

var ToolbarButton = function ToolbarButton() {
  var editor = Object(slate_react__WEBPACK_IMPORTED_MODULE_1__["useSlate"])();
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Toolbar__WEBPACK_IMPORTED_MODULE_3__["default"].Button, {
    active: Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["isMarkActive"])(editor, _constants__WEBPACK_IMPORTED_MODULE_5__["UNDERLINE"]),
    onMouseDown: function onMouseDown(event) {
      event.preventDefault();
      Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["postMessage"])(_constants__WEBPACK_IMPORTED_MODULE_5__["UNDERLINE"], {}, editor);
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_4__["default"], null, "format_underlined")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Toolbar__WEBPACK_IMPORTED_MODULE_3__["default"].Separator, null));
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["createPlugin"])({
    name: _constants__WEBPACK_IMPORTED_MODULE_5__["UNDERLINE"],
    renderLeaf: renderLeaf,
    handleMessage: handleMessage,
    ToolbarButton: ToolbarButton
  });
});

/***/ }),

/***/ "./src/serializers/plain.js":
/*!**********************************!*\
  !*** ./src/serializers/plain.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! slate */ "../node_modules/slate/dist/index.es.js");
 // TODO: wip

var plainSerializer = function plainSerializer(nodes) {
  return nodes.map(function (n) {
    return slate__WEBPACK_IMPORTED_MODULE_0__["Node"].string(n);
  }).join('\n');
};

/* harmony default export */ __webpack_exports__["default"] = (plainSerializer);

/***/ }),

/***/ "./src/transformers/react.js":
/*!***********************************!*\
  !*** ./src/transformers/react.js ***!
  \***********************************/
/*! exports provided: default, makeReactTransformer, defaultReactTransformer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeReactTransformer", function() { return makeReactTransformer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultReactTransformer", function() { return defaultReactTransformer; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ "../node_modules/slate/dist/index.es.js");
/* harmony import */ var _helpers_why__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/why */ "./src/helpers/why.js");



var isRoot = Array.isArray;

var makeReactTransformer = function makeReactTransformer(rules) {
  return Object(_helpers_why__WEBPACK_IMPORTED_MODULE_2__["default"])(function (reactTransformer) {
    return function (node, key) {
      if (isRoot(node)) return node.map(reactTransformer);
      if (slate__WEBPACK_IMPORTED_MODULE_1__["Text"].isText(node)) return rules.leaf(node, key);
      var children = node.children.map(reactTransformer);
      return rules.element(node, children, key);
    };
  });
};

var defaultRules = {
  leaf: function leaf(node, key) {
    var children = node.text;
    if (node.bold) children = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("strong", {
      key: key
    }, children);
    if (node.italic) children = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("em", {
      key: key
    }, children);
    if (node.underline) children = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("u", {
      key: key
    }, children);
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
      key: key
    }, children);
  },
  element: function element(node, children, key) {
    switch (node.type) {
      case 'paragraph':
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("p", {
          key: key,
          style: {
            margin: 0,
            lineHeight: 1.5,
            minHeight: '1.5em'
          }
        }, children);

      case 'link':
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", {
          key: key,
          href: slate__WEBPACK_IMPORTED_MODULE_1__["Node"].string(node),
          target: "_blank"
        }, children);

      case 'mention':
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
          key: key,
          style: {
            padding: '2px 4px',
            background: '#eeeeee',
            borderRadius: 4
          }
        }, "@", node.data.name);

      case 'bulleted-list':
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("ul", {
          key: key
        }, children);

      case 'numbered-list':
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("ol", {
          key: key
        }, children);

      case 'list-item':
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", {
          key: key
        }, children);

      default:
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
          key: key
        }, children);
    }
  }
};
var defaultReactTransformer = makeReactTransformer(defaultRules);
/* harmony default export */ __webpack_exports__["default"] = (makeReactTransformer);


/***/ }),

/***/ "react":
/*!**************************************************************************************!*\
  !*** external {"root":"React","commonjs2":"react","commonjs":"react","amd":"react"} ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_react__;

/***/ }),

/***/ "react-dom":
/*!*****************************************************************************************************!*\
  !*** external {"root":"ReactDOM","commonjs2":"react-dom","commonjs":"react-dom","amd":"react-dom"} ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_react_dom__;

/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvbXB1dGUtc2Nyb2xsLWludG8tdmlldy9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2RpcmVjdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzcmV2ZXIvZXNyZXZlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2ltbWVyL2Rpc3QvaW1tZXIubW9kdWxlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaXMtaG90a2V5L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2lzLXVybC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL2RlYm91bmNlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9ub3cuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdGhyb3R0bGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9OdW1iZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9zY3JvbGwtaW50by12aWV3LWlmLW5lZWRlZC9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3NsYXRlLXJlYWN0L2Rpc3QvaW5kZXguZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9zbGF0ZS9kaXN0L2luZGV4LmVzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvc2xhdGUvbm9kZV9tb2R1bGVzL2lzLXBsYWluLW9iamVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3NsYXRlL25vZGVfbW9kdWxlcy9pc29iamVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0ljb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvSnNvblZpZXdlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Ub29sYmFyLmpzIiwid2VicGFjazovLy8uL3NyYy9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlbHBlcnMvYXBwbHkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlbHBlcnMvY29tcG9zZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaGVscGVycy9jcmVhdGVQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlbHBlcnMvZWxlbWVudEhlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlbHBlcnMvZmxvdy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaGVscGVycy9nZXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlbHBlcnMvZ2V0VXJsLmpzIiwid2VicGFjazovLy8uL3NyYy9oZWxwZXJzL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9oZWxwZXJzL2lzRW1wdHlDb250ZW50LmpzIiwid2VicGFjazovLy8uL3NyYy9oZWxwZXJzL2xlYWZIZWxwZXJzLmpzIiwid2VicGFjazovLy8uL3NyYy9oZWxwZXJzL21hcC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaGVscGVycy9tZXNzYWdlSGVscGVycy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaGVscGVycy91c2VBbmRyb2lkSGFjay5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaGVscGVycy91c2VGb3JjZVVwZGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaGVscGVycy93aHkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlbHBlcnMvd2l0aElkLmpzIiwid2VicGFjazovLy8uL3NyYy9saWIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BsdWdpbnMvYm9sZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGx1Z2lucy9idWxsZXRlZExpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BsdWdpbnMvY3Vyc29yVHJhY2tlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGx1Z2lucy9lZGl0b3JQbGFjZWhvbGRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGx1Z2lucy9oZWFkaW5nT25lLmpzIiwid2VicGFjazovLy8uL3NyYy9wbHVnaW5zL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9wbHVnaW5zL2l0YWxpYy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGx1Z2lucy9saW5rLmpzIiwid2VicGFjazovLy8uL3NyYy9wbHVnaW5zL2xpc3RJdGVtLmpzIiwid2VicGFjazovLy8uL3NyYy9wbHVnaW5zL2xvZ2dlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGx1Z2lucy9tZW50aW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9wbHVnaW5zL251bWJlcmVkTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGx1Z2lucy91bmRlcmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NlcmlhbGl6ZXJzL3BsYWluLmpzIiwid2VicGFjazovLy8uL3NyYy90cmFuc2Zvcm1lcnMvcmVhY3QuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcInJvb3RcIjpcIlJlYWN0XCIsXCJjb21tb25qczJcIjpcInJlYWN0XCIsXCJjb21tb25qc1wiOlwicmVhY3RcIixcImFtZFwiOlwicmVhY3RcIn0iLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcInJvb3RcIjpcIlJlYWN0RE9NXCIsXCJjb21tb25qczJcIjpcInJlYWN0LWRvbVwiLFwiY29tbW9uanNcIjpcInJlYWN0LWRvbVwiLFwiYW1kXCI6XCJyZWFjdC1kb21cIn0iXSwibmFtZXMiOlsic3ZnSWNvbnMiLCJmb3JtYXRfYm9sZCIsImZvcm1hdF9pdGFsaWMiLCJmb3JtYXRfdW5kZXJsaW5lZCIsImZvcm1hdF9saXN0X2J1bGxldGVkIiwiZm9ybWF0X2xpc3RfbnVtYmVyZWQiLCJsb29rc19vbmUiLCJzdHlsZXMiLCJpY29uIiwib3BhY2l0eSIsIkljb24iLCJjaGlsZHJlbiIsImpzb25WaWV3ZXIiLCJwYWRkaW5nIiwiYm9yZGVyUmFkaXVzIiwiYmFja2dyb3VuZCIsIkpzb25WaWV3ZXIiLCJ2YWx1ZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0b29sYmFyIiwiZGlzcGxheSIsImZsZXhEaXJlY3Rpb24iLCJidXR0b24iLCJhbGlnbkl0ZW1zIiwianVzdGlmeUNvbnRlbnQiLCJoZWlnaHQiLCJtaW5XaWR0aCIsIm1hcmdpbiIsImJvcmRlciIsImN1cnNvciIsImJ1dHRvbkFjdGl2ZSIsInNlcGFyYXRvciIsImJvcmRlclJpZ2h0IiwiVG9vbGJhciIsIkJ1dHRvbiIsImFjdGl2ZSIsInByb3BzIiwidW5kZWZpbmVkIiwiU2VwYXJhdG9yIiwiQlVMTEVURURfTElTVCIsIk5VTUJFUkVEX0xJU1QiLCJMSVNUX0lURU0iLCJNRU5USU9OIiwiTElOSyIsIkhFQURJTkdfT05FIiwiSEVBRElOR19UV08iLCJQQVJBR1JBUEgiLCJCT0xEIiwiSVRBTElDIiwiVU5ERVJMSU5FIiwiRURJVE9SX0NIQU5HRSIsIkVESVRPUl9GT0NVUyIsIkVESVRPUl9CTFVSIiwiRURJVE9SX0xBWU9VVCIsImFwcGx5IiwiYXJncyIsImZ1bmMiLCJjb21wb3NlIiwiZnVuY3MiLCJhcmciLCJyZWR1Y2VSaWdodCIsImNvbXBvc2VkIiwiZiIsImNyZWF0ZVBsdWdpbiIsImNvbmZpZ3MiLCJkZWZhdWx0UGx1Z2luIiwibmFtZSIsInJlbmRlckxlYWYiLCJuZXh0IiwicmVuZGVyRWxlbWVudCIsIlRvb2xiYXJCdXR0b24iLCJyZW5kZXJDdXN0b20iLCJoYW5kbGVNZXNzYWdlIiwiZW5oYW5jZUVkaXRvciIsImVkaXRvciIsImlzQmxvY2tBY3RpdmUiLCJmb3JtYXQiLCJFZGl0b3IiLCJub2RlcyIsIm1hdGNoIiwibiIsInR5cGUiLCJpc0xpc3QiLCJub2RlIiwiaW5jbHVkZXMiLCJEZWZhdWx0RWxlbWVudCIsIlJlYWN0IiwiZm9yd2FyZFJlZiIsInJlZiIsImxpbmVIZWlnaHQiLCJyZW5kZXJEZWZhdWx0RWxlbWVudCIsImF0dHJpYnV0ZXMiLCJtYWtlUmVuZGVyRWxlbWVudCIsImJsb2NrIiwiQ3VzdG9tRWxlbWVudCIsImVsZW1lbnQiLCJjb21wb3NlUmVuZGVyRWxlbWVudCIsInBsdWdpbnMiLCJtYXAiLCJwbHVnaW4iLCJmbG93IiwicmVkdWNlIiwiZ2V0IiwicGF0aCIsIm9iamVjdCIsIk5vZGUiLCJzdHJpbmciLCJjb250ZW50IiwibGVuZ3RoIiwidGV4dCIsImlzTWFya0FjdGl2ZSIsIm1hcmtzIiwidG9nZ2xlTWFyayIsImlzQWN0aXZlIiwicmVtb3ZlTWFyayIsImFkZE1hcmsiLCJEZWZhdWx0TGVhZiIsInJlbmRlckRlZmF1bHRMZWFmIiwibWFrZVJlbmRlckxlYWYiLCJtYXJrIiwiQ3VzdG9tTGVhZiIsImxlYWYiLCJjb21wb3NlUmVuZGVyTGVhZiIsIml0ZXJhdGVlIiwiY29sbGVjdGlvbiIsIm1lc3NhZ2VQcmVmaXgiLCJhZGRNZXNzYWdlTGlzdGVuZXIiLCJjYWxsYmFjayIsImxpc3RlbmVyIiwiZXZlbnQiLCJkYXRhIiwiaWQiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInBvc3RNZXNzYWdlIiwibWVzc2FnZSIsIlJlYWN0TmF0aXZlV2ViVmlldyIsInVzZUFuZHJvaWRIYWNrIiwibGFzdENvbXBvc2VEYXRhIiwidXNlUmVmIiwib25ET01CZWZvcmVJbnB1dCIsInVzZUNhbGxiYWNrIiwiZSIsImlucHV0VHlwZSIsImN1cnJlbnQiLCJzZWxlY3Rpb24iLCJnZXRTZWxlY3Rpb24iLCJzZWwiLCJSZWFjdEVkaXRvciIsInRvU2xhdGVSYW5nZSIsImFuY2hvciIsIm9mZnNldCIsImFuY2hvck9mZnNldCIsImZvY3VzIiwiZm9jdXNPZmZzZXQiLCJwdXNoIiwiYW5jaG9yTm9kZSIsImVsZW1lbnROb2RlIiwicGFyZW50RWxlbWVudCIsImNsb3Nlc3QiLCJvbkNvbXBvc2l0aW9uRW5kIiwiZm9jdXNOb2RlIiwiaXNDb2xsYXBzZWQiLCJjIiwiVHJhbnNmb3JtcyIsInNlbGVjdCIsIlNsYXRlRWRpdG9yIiwiaW5zZXJ0VGV4dCIsImVsIiwiaGFzQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiaW5uZXJUZXh0IiwicCIsInRleHROb2RlIiwibm9kZU5hbWUiLCJpbm5lckhUTUwiLCJyZXBsYWNlQ2hpbGQiLCJzcyIsInN0YXJ0Q29udGFpbmVyIiwic3RhcnRPZmZzZXQiLCJlbmRDb250YWluZXIiLCJlbmRPZmZzZXQiLCJjb2xsYXBzZWQiLCJyZW1vdmVBbGxSYW5nZXMiLCJuZXdEb21SYW5nZSIsInRvRE9NUmFuZ2UiLCJhZGRSYW5nZSIsInVzZUZvcmNlVXBkYXRlIiwicHJldiIsInVzZVN0YXRlIiwiY3VyciIsInNldEN1cnIiLCJpc0ZvcmNlVXBkYXRlZCIsImZvcmNlVXBkYXRlIiwieSIsImciLCJ3aXRoSWQiLCJlZGl0b3JXcmFwcGVyIiwiZm9udEZhbWlseSIsImVkaXRhYmxlV3JhcHBlciIsInBvc2l0aW9uIiwiZWRpdGFibGUiLCJnZXRDdXN0b21FbGVtZW50cyIsImFkZE1lc3NhZ2VMaXN0ZW5lcnMiLCJnZXRUb29sYmFyQnV0dG9ucyIsIm5vb3AiLCJIZXJvRWRpdG9yIiwic2hvd1Rvb2xiYXIiLCJhdXRvRm9jdXMiLCJwbGFjZWhvbGRlciIsIm9uQ2hhbmdlIiwib25Gb2N1cyIsIm9uQmx1ciIsIm9uTGF5b3V0Iiwid3JhcHBlclN0eWxlIiwiZWRpdGFibGVTdHlsZSIsImlzQW5kcm9pZCIsIndyYXBwZXIiLCJ3cmFwcGVyTGF5b3V0Iiwid2lkdGgiLCJ1c2VNZW1vIiwiY3JlYXRlRWRpdG9yIiwid2l0aFJlYWN0IiwidG9vbEJhckJ1dHRvbnMiLCJ1c2VFZmZlY3QiLCJyZW1vdmVIYW5kbGVycyIsImZvckVhY2giLCJyZW1vdmVIYW5kbGVyIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJ1c2VTbGF0ZSIsInByZXZlbnREZWZhdWx0IiwidW53cmFwTm9kZXMiLCJzcGxpdCIsInNldE5vZGVzIiwid3JhcE5vZGVzIiwiZG9tUmFuZ2UiLCJyYW5nZVJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0b3AiLCJsZWZ0IiwiYm94U2l6aW5nIiwiY29sb3IiLCJwb2ludGVyRXZlbnRzIiwiQ0FDSEVfVFRMIiwiaXNEZWZpbmVkIiwiRWRpdG9yUGxhY2Vob2xkZXIiLCJzdHlsZSIsImNhY2hlIiwiY3JlYXRlUGxhY2Vob2xkZXIiLCJpc0VtcHR5IiwiaXNFbXB0eUNvbnRlbnQiLCJtZXJnZWRTdHlsZSIsInRpbWVySWQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiZ2V0VXJsIiwidXJsIiwiTGlua0VsZW1lbnQiLCJpbnNlcnROb2RlcyIsImlzSW5saW5lIiwiaW5zZXJ0RGF0YSIsImdldERhdGEiLCJpc1VybCIsIk9iamVjdCIsImtleXMiLCJzdGFydHNXaXRoIiwiZ3JvdXBNZXRob2QiLCJjb25zb2xlIiwibG9nIiwiZ3JvdXBFbmQiLCJNZW50aW9uRWxlbWVudCIsInJlbW92ZUVkaXRvckNoYW5nZUxpc3RlbmVyIiwiUmFuZ2UiLCJlZGdlcyIsInN0YXJ0Iiwid29yZEJlZm9yZSIsImJlZm9yZSIsInVuaXQiLCJiZWZvcmVSYW5nZSIsInJhbmdlIiwiYmVmb3JlVGV4dCIsImJlZm9yZU1hdGNoIiwiYWZ0ZXIiLCJhZnRlclJhbmdlIiwiYWZ0ZXJUZXh0IiwiYWZ0ZXJNYXRjaCIsInRhcmdldCIsInNlYXJjaCIsInJlbW92ZU1lbnRpb25BcHBseUxpc3RlbmVyIiwibWV0YSIsIm1lbnRpb24iLCJtb3ZlIiwiTWVudGlvbkxpc3RXcmFwcGVyIiwicmVuZGVyTWVudGlvbkxpc3QiLCJzZXRTZWFyY2giLCJzZXRUYXJnZXQiLCJyZW1vdmVNZW50aW9uU2VhcmNoTGlzdGVuZXIiLCJ3cmFwcGVyRWwiLCJlZGl0b3JSZWN0IiwiekluZGV4IiwiaXNWb2lkIiwicGxhaW5TZXJpYWxpemVyIiwiam9pbiIsImlzUm9vdCIsIkFycmF5IiwiaXNBcnJheSIsIm1ha2VSZWFjdFRyYW5zZm9ybWVyIiwicnVsZXMiLCJyZWFjdFRyYW5zZm9ybWVyIiwia2V5IiwiVGV4dCIsImlzVGV4dCIsImRlZmF1bHRSdWxlcyIsImJvbGQiLCJpdGFsaWMiLCJ1bmRlcmxpbmUiLCJtaW5IZWlnaHQiLCJkZWZhdWx0UmVhY3RUcmFuc2Zvcm1lciJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87UUNWQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZSxzRUFBTyxFQUFDO0FBQ3FOO0FBQzVPOzs7Ozs7Ozs7Ozs7OztBQ24wRGE7O0FBRWI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsY0FBYztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQsZ0VBQWdFO0FBQzFIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Qjs7Ozs7Ozs7Ozs7O0FDblBBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMENBQTBDLEdBQUc7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDOUNBLFdBQVcsbUJBQU8sQ0FBQyxnREFBUzs7QUFFNUI7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDTEEsYUFBYSxtQkFBTyxDQUFDLG9EQUFXO0FBQ2hDLGdCQUFnQixtQkFBTyxDQUFDLDBEQUFjO0FBQ3RDLHFCQUFxQixtQkFBTyxDQUFDLG9FQUFtQjs7QUFFaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUMzQkE7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ0hBLGFBQWEsbUJBQU8sQ0FBQyxvREFBVzs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDN0NBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNyQkEsaUJBQWlCLG1CQUFPLENBQUMsNERBQWU7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDUkEsZUFBZSxtQkFBTyxDQUFDLHNEQUFZO0FBQ25DLFVBQVUsbUJBQU8sQ0FBQyw0Q0FBTztBQUN6QixlQUFlLG1CQUFPLENBQUMsc0RBQVk7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU8sWUFBWTtBQUM5QixXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSw4Q0FBOEMsa0JBQWtCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQzlMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDNUJBLGlCQUFpQixtQkFBTyxDQUFDLDREQUFlO0FBQ3hDLG1CQUFtQixtQkFBTyxDQUFDLDhEQUFnQjs7QUFFM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQzVCQSxXQUFXLG1CQUFPLENBQUMsZ0RBQVM7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDdEJBLGVBQWUsbUJBQU8sQ0FBQyxzREFBWTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsc0RBQVk7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU8sWUFBWTtBQUM5QixXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG9CQUFvQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7Ozs7Ozs7Ozs7OztBQ3BFQSxlQUFlLG1CQUFPLENBQUMsc0RBQVk7QUFDbkMsZUFBZSxtQkFBTyxDQUFDLHNEQUFZOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDakVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7Ozs7Ozs7Ozs7Ozs7QUN2THRDO0FBQUE7QUFBK0M7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW9ELHdFQUFPO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qix3RUFBTztBQUNoQzs7QUFFZSw2RUFBYyxFOzs7Ozs7Ozs7Ozs7QUMvRDdCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUE2SDtBQUNmO0FBQ3ZFO0FBQ2lCO0FBQ25CO0FBQ0o7QUFDTzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLDZCQUE2QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSw0Q0FBTTtBQUNsQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFF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QUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7O0FBRWxEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7O0FBR1AsaUVBQWlFOztBQUVqRSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQkFBK0IsdURBQU87QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseURBQVc7QUFDakMsd0NBQXdDLHlEQUFXOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IscURBQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztB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QTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscURBQU87QUFDbEI7QUFDQTtBQUNBLE9BQU8sV0FBVzs7QUFFbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTs7QUFFMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTyx3Q0FBd0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELDhEQUE4RCxnRUFBZ0UsRUFBRSxFQUFFLGdDQUFnQyxFQUFFLGFBQWE7O0FBRXJWLGtDQUFrQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEseURBQXlELDJDQUEyQyxFQUFFLEVBQUUsRUFBRSw2Q0FBNkMsMkVBQTJFLEVBQUUsT0FBTyxtREFBbUQsa0ZBQWtGLEVBQUUsRUFBRSxFQUFFLEVBQUUsZUFBZTtBQUMxaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtFQUFrRSxXQUFXO0FBQzdFLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPLEVBQUU7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCx3Q0FBd0MsNEJBQTRCOztBQUVwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkk7QUFDN0k7Ozs7Ozs7Ozs7Ozs7QUM1aExBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0M7O0FB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QUFQOztBQUVGLFdBQUssZUFBTDtBQUNFLDRCQUFPO0FBQUksYUFBRyxFQUFFOFM7QUFBVCxXQUFlOVMsUUFBZixDQUFQOztBQUVGLFdBQUssV0FBTDtBQUNFLDRCQUFPO0FBQUksYUFBRyxFQUFFOFM7QUFBVCxXQUFlOVMsUUFBZixDQUFQOztBQUVGO0FBQ0UsNEJBQU87QUFBSyxhQUFHLEVBQUU4UztBQUFWLFdBQWdCOVMsUUFBaEIsQ0FBUDtBQTFDSjtBQTRDRDtBQTFEa0IsQ0FBckI7QUE2REEsSUFBTXNULHVCQUF1QixHQUFHWCxvQkFBb0IsQ0FBQ00sWUFBRCxDQUFwRDtBQUVlTixtRkFBZjs7Ozs7Ozs7Ozs7O0FDaEZBLG1EOzs7Ozs7Ozs7OztBQ0FBLHVEIiwiZmlsZSI6ImxpYi5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpLCByZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcInJlYWN0XCIsIFwicmVhY3QtZG9tXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBmYWN0b3J5KHJlcXVpcmUoXCJyZWFjdFwiKSwgcmVxdWlyZShcInJlYWN0LWRvbVwiKSkgOiBmYWN0b3J5KHJvb3RbXCJSZWFjdFwiXSwgcm9vdFtcIlJlYWN0RE9NXCJdKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHdpbmRvdywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9yZWFjdF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX3JlYWN0X2RvbV9fKSB7XG5yZXR1cm4gIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvbGliLmpzXCIpO1xuIiwiZnVuY3Rpb24gaXNFbGVtZW50KGVsKSB7XG4gIHJldHVybiBlbCAhPSBudWxsICYmIHR5cGVvZiBlbCA9PT0gJ29iamVjdCcgJiYgZWwubm9kZVR5cGUgPT09IDE7XG59XG5cbmZ1bmN0aW9uIGNhbk92ZXJmbG93KG92ZXJmbG93LCBza2lwT3ZlcmZsb3dIaWRkZW5FbGVtZW50cykge1xuICBpZiAoc2tpcE92ZXJmbG93SGlkZGVuRWxlbWVudHMgJiYgb3ZlcmZsb3cgPT09ICdoaWRkZW4nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG92ZXJmbG93ICE9PSAndmlzaWJsZScgJiYgb3ZlcmZsb3cgIT09ICdjbGlwJztcbn1cblxuZnVuY3Rpb24gZ2V0RnJhbWVFbGVtZW50KGVsKSB7XG4gIGlmICghZWwub3duZXJEb2N1bWVudCB8fCAhZWwub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZWwub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5mcmFtZUVsZW1lbnQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0hpZGRlbkJ5RnJhbWUoZWwpIHtcbiAgdmFyIGZyYW1lID0gZ2V0RnJhbWVFbGVtZW50KGVsKTtcblxuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGZyYW1lLmNsaWVudEhlaWdodCA8IGVsLnNjcm9sbEhlaWdodCB8fCBmcmFtZS5jbGllbnRXaWR0aCA8IGVsLnNjcm9sbFdpZHRoO1xufVxuXG5mdW5jdGlvbiBpc1Njcm9sbGFibGUoZWwsIHNraXBPdmVyZmxvd0hpZGRlbkVsZW1lbnRzKSB7XG4gIGlmIChlbC5jbGllbnRIZWlnaHQgPCBlbC5zY3JvbGxIZWlnaHQgfHwgZWwuY2xpZW50V2lkdGggPCBlbC5zY3JvbGxXaWR0aCkge1xuICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpO1xuICAgIHJldHVybiBjYW5PdmVyZmxvdyhzdHlsZS5vdmVyZmxvd1ksIHNraXBPdmVyZmxvd0hpZGRlbkVsZW1lbnRzKSB8fCBjYW5PdmVyZmxvdyhzdHlsZS5vdmVyZmxvd1gsIHNraXBPdmVyZmxvd0hpZGRlbkVsZW1lbnRzKSB8fCBpc0hpZGRlbkJ5RnJhbWUoZWwpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhbGlnbk5lYXJlc3Qoc2Nyb2xsaW5nRWRnZVN0YXJ0LCBzY3JvbGxpbmdFZGdlRW5kLCBzY3JvbGxpbmdTaXplLCBzY3JvbGxpbmdCb3JkZXJTdGFydCwgc2Nyb2xsaW5nQm9yZGVyRW5kLCBlbGVtZW50RWRnZVN0YXJ0LCBlbGVtZW50RWRnZUVuZCwgZWxlbWVudFNpemUpIHtcbiAgaWYgKGVsZW1lbnRFZGdlU3RhcnQgPCBzY3JvbGxpbmdFZGdlU3RhcnQgJiYgZWxlbWVudEVkZ2VFbmQgPiBzY3JvbGxpbmdFZGdlRW5kIHx8IGVsZW1lbnRFZGdlU3RhcnQgPiBzY3JvbGxpbmdFZGdlU3RhcnQgJiYgZWxlbWVudEVkZ2VFbmQgPCBzY3JvbGxpbmdFZGdlRW5kKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoZWxlbWVudEVkZ2VTdGFydCA8PSBzY3JvbGxpbmdFZGdlU3RhcnQgJiYgZWxlbWVudFNpemUgPD0gc2Nyb2xsaW5nU2l6ZSB8fCBlbGVtZW50RWRnZUVuZCA+PSBzY3JvbGxpbmdFZGdlRW5kICYmIGVsZW1lbnRTaXplID49IHNjcm9sbGluZ1NpemUpIHtcbiAgICByZXR1cm4gZWxlbWVudEVkZ2VTdGFydCAtIHNjcm9sbGluZ0VkZ2VTdGFydCAtIHNjcm9sbGluZ0JvcmRlclN0YXJ0O1xuICB9XG5cbiAgaWYgKGVsZW1lbnRFZGdlRW5kID4gc2Nyb2xsaW5nRWRnZUVuZCAmJiBlbGVtZW50U2l6ZSA8IHNjcm9sbGluZ1NpemUgfHwgZWxlbWVudEVkZ2VTdGFydCA8IHNjcm9sbGluZ0VkZ2VTdGFydCAmJiBlbGVtZW50U2l6ZSA+IHNjcm9sbGluZ1NpemUpIHtcbiAgICByZXR1cm4gZWxlbWVudEVkZ2VFbmQgLSBzY3JvbGxpbmdFZGdlRW5kICsgc2Nyb2xsaW5nQm9yZGVyRW5kO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zKSB7XG4gIHZhciBzY3JvbGxNb2RlID0gb3B0aW9ucy5zY3JvbGxNb2RlLFxuICAgICAgYmxvY2sgPSBvcHRpb25zLmJsb2NrLFxuICAgICAgaW5saW5lID0gb3B0aW9ucy5pbmxpbmUsXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICBza2lwT3ZlcmZsb3dIaWRkZW5FbGVtZW50cyA9IG9wdGlvbnMuc2tpcE92ZXJmbG93SGlkZGVuRWxlbWVudHM7XG4gIHZhciBjaGVja0JvdW5kYXJ5ID0gdHlwZW9mIGJvdW5kYXJ5ID09PSAnZnVuY3Rpb24nID8gYm91bmRhcnkgOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBub2RlICE9PSBib3VuZGFyeTtcbiAgfTtcblxuICBpZiAoIWlzRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0YXJnZXQnKTtcbiAgfVxuXG4gIHZhciBzY3JvbGxpbmdFbGVtZW50ID0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBmcmFtZXMgPSBbXTtcbiAgdmFyIGN1cnNvciA9IHRhcmdldDtcblxuICB3aGlsZSAoaXNFbGVtZW50KGN1cnNvcikgJiYgY2hlY2tCb3VuZGFyeShjdXJzb3IpKSB7XG4gICAgY3Vyc29yID0gY3Vyc29yLnBhcmVudE5vZGU7XG5cbiAgICBpZiAoY3Vyc29yID09PSBzY3JvbGxpbmdFbGVtZW50KSB7XG4gICAgICBmcmFtZXMucHVzaChjdXJzb3IpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGN1cnNvciA9PT0gZG9jdW1lbnQuYm9keSAmJiBpc1Njcm9sbGFibGUoY3Vyc29yKSAmJiAhaXNTY3JvbGxhYmxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChpc1Njcm9sbGFibGUoY3Vyc29yLCBza2lwT3ZlcmZsb3dIaWRkZW5FbGVtZW50cykpIHtcbiAgICAgIGZyYW1lcy5wdXNoKGN1cnNvcik7XG4gICAgfVxuICB9XG5cbiAgdmFyIHZpZXdwb3J0V2lkdGggPSB3aW5kb3cudmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC53aWR0aCA6IGlubmVyV2lkdGg7XG4gIHZhciB2aWV3cG9ydEhlaWdodCA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCA/IHZpc3VhbFZpZXdwb3J0LmhlaWdodCA6IGlubmVySGVpZ2h0O1xuICB2YXIgdmlld3BvcnRYID0gd2luZG93LnNjcm9sbFggfHwgcGFnZVhPZmZzZXQ7XG4gIHZhciB2aWV3cG9ydFkgPSB3aW5kb3cuc2Nyb2xsWSB8fCBwYWdlWU9mZnNldDtcblxuICB2YXIgX3RhcmdldCRnZXRCb3VuZGluZ0NsID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgdGFyZ2V0SGVpZ2h0ID0gX3RhcmdldCRnZXRCb3VuZGluZ0NsLmhlaWdodCxcbiAgICAgIHRhcmdldFdpZHRoID0gX3RhcmdldCRnZXRCb3VuZGluZ0NsLndpZHRoLFxuICAgICAgdGFyZ2V0VG9wID0gX3RhcmdldCRnZXRCb3VuZGluZ0NsLnRvcCxcbiAgICAgIHRhcmdldFJpZ2h0ID0gX3RhcmdldCRnZXRCb3VuZGluZ0NsLnJpZ2h0LFxuICAgICAgdGFyZ2V0Qm90dG9tID0gX3RhcmdldCRnZXRCb3VuZGluZ0NsLmJvdHRvbSxcbiAgICAgIHRhcmdldExlZnQgPSBfdGFyZ2V0JGdldEJvdW5kaW5nQ2wubGVmdDtcblxuICB2YXIgdGFyZ2V0QmxvY2sgPSBibG9jayA9PT0gJ3N0YXJ0JyB8fCBibG9jayA9PT0gJ25lYXJlc3QnID8gdGFyZ2V0VG9wIDogYmxvY2sgPT09ICdlbmQnID8gdGFyZ2V0Qm90dG9tIDogdGFyZ2V0VG9wICsgdGFyZ2V0SGVpZ2h0IC8gMjtcbiAgdmFyIHRhcmdldElubGluZSA9IGlubGluZSA9PT0gJ2NlbnRlcicgPyB0YXJnZXRMZWZ0ICsgdGFyZ2V0V2lkdGggLyAyIDogaW5saW5lID09PSAnZW5kJyA/IHRhcmdldFJpZ2h0IDogdGFyZ2V0TGVmdDtcbiAgdmFyIGNvbXB1dGF0aW9ucyA9IFtdO1xuXG4gIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBmcmFtZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgdmFyIGZyYW1lID0gZnJhbWVzW2luZGV4XTtcblxuICAgIHZhciBfZnJhbWUkZ2V0Qm91bmRpbmdDbGkgPSBmcmFtZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgaGVpZ2h0ID0gX2ZyYW1lJGdldEJvdW5kaW5nQ2xpLmhlaWdodCxcbiAgICAgICAgd2lkdGggPSBfZnJhbWUkZ2V0Qm91bmRpbmdDbGkud2lkdGgsXG4gICAgICAgIHRvcCA9IF9mcmFtZSRnZXRCb3VuZGluZ0NsaS50b3AsXG4gICAgICAgIHJpZ2h0ID0gX2ZyYW1lJGdldEJvdW5kaW5nQ2xpLnJpZ2h0LFxuICAgICAgICBib3R0b20gPSBfZnJhbWUkZ2V0Qm91bmRpbmdDbGkuYm90dG9tLFxuICAgICAgICBsZWZ0ID0gX2ZyYW1lJGdldEJvdW5kaW5nQ2xpLmxlZnQ7XG5cbiAgICBpZiAoc2Nyb2xsTW9kZSA9PT0gJ2lmLW5lZWRlZCcgJiYgdGFyZ2V0VG9wID49IDAgJiYgdGFyZ2V0TGVmdCA+PSAwICYmIHRhcmdldEJvdHRvbSA8PSB2aWV3cG9ydEhlaWdodCAmJiB0YXJnZXRSaWdodCA8PSB2aWV3cG9ydFdpZHRoICYmIHRhcmdldFRvcCA+PSB0b3AgJiYgdGFyZ2V0Qm90dG9tIDw9IGJvdHRvbSAmJiB0YXJnZXRMZWZ0ID49IGxlZnQgJiYgdGFyZ2V0UmlnaHQgPD0gcmlnaHQpIHtcbiAgICAgIHJldHVybiBjb21wdXRhdGlvbnM7XG4gICAgfVxuXG4gICAgdmFyIGZyYW1lU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGZyYW1lKTtcbiAgICB2YXIgYm9yZGVyTGVmdCA9IHBhcnNlSW50KGZyYW1lU3R5bGUuYm9yZGVyTGVmdFdpZHRoLCAxMCk7XG4gICAgdmFyIGJvcmRlclRvcCA9IHBhcnNlSW50KGZyYW1lU3R5bGUuYm9yZGVyVG9wV2lkdGgsIDEwKTtcbiAgICB2YXIgYm9yZGVyUmlnaHQgPSBwYXJzZUludChmcmFtZVN0eWxlLmJvcmRlclJpZ2h0V2lkdGgsIDEwKTtcbiAgICB2YXIgYm9yZGVyQm90dG9tID0gcGFyc2VJbnQoZnJhbWVTdHlsZS5ib3JkZXJCb3R0b21XaWR0aCwgMTApO1xuICAgIHZhciBibG9ja1Njcm9sbCA9IDA7XG4gICAgdmFyIGlubGluZVNjcm9sbCA9IDA7XG4gICAgdmFyIHNjcm9sbGJhcldpZHRoID0gJ29mZnNldFdpZHRoJyBpbiBmcmFtZSA/IGZyYW1lLm9mZnNldFdpZHRoIC0gZnJhbWUuY2xpZW50V2lkdGggLSBib3JkZXJMZWZ0IC0gYm9yZGVyUmlnaHQgOiAwO1xuICAgIHZhciBzY3JvbGxiYXJIZWlnaHQgPSAnb2Zmc2V0SGVpZ2h0JyBpbiBmcmFtZSA/IGZyYW1lLm9mZnNldEhlaWdodCAtIGZyYW1lLmNsaWVudEhlaWdodCAtIGJvcmRlclRvcCAtIGJvcmRlckJvdHRvbSA6IDA7XG5cbiAgICBpZiAoc2Nyb2xsaW5nRWxlbWVudCA9PT0gZnJhbWUpIHtcbiAgICAgIGlmIChibG9jayA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBibG9ja1Njcm9sbCA9IHRhcmdldEJsb2NrO1xuICAgICAgfSBlbHNlIGlmIChibG9jayA9PT0gJ2VuZCcpIHtcbiAgICAgICAgYmxvY2tTY3JvbGwgPSB0YXJnZXRCbG9jayAtIHZpZXdwb3J0SGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChibG9jayA9PT0gJ25lYXJlc3QnKSB7XG4gICAgICAgIGJsb2NrU2Nyb2xsID0gYWxpZ25OZWFyZXN0KHZpZXdwb3J0WSwgdmlld3BvcnRZICsgdmlld3BvcnRIZWlnaHQsIHZpZXdwb3J0SGVpZ2h0LCBib3JkZXJUb3AsIGJvcmRlckJvdHRvbSwgdmlld3BvcnRZICsgdGFyZ2V0QmxvY2ssIHZpZXdwb3J0WSArIHRhcmdldEJsb2NrICsgdGFyZ2V0SGVpZ2h0LCB0YXJnZXRIZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmxvY2tTY3JvbGwgPSB0YXJnZXRCbG9jayAtIHZpZXdwb3J0SGVpZ2h0IC8gMjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlubGluZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBpbmxpbmVTY3JvbGwgPSB0YXJnZXRJbmxpbmU7XG4gICAgICB9IGVsc2UgaWYgKGlubGluZSA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgaW5saW5lU2Nyb2xsID0gdGFyZ2V0SW5saW5lIC0gdmlld3BvcnRXaWR0aCAvIDI7XG4gICAgICB9IGVsc2UgaWYgKGlubGluZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgaW5saW5lU2Nyb2xsID0gdGFyZ2V0SW5saW5lIC0gdmlld3BvcnRXaWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlubGluZVNjcm9sbCA9IGFsaWduTmVhcmVzdCh2aWV3cG9ydFgsIHZpZXdwb3J0WCArIHZpZXdwb3J0V2lkdGgsIHZpZXdwb3J0V2lkdGgsIGJvcmRlckxlZnQsIGJvcmRlclJpZ2h0LCB2aWV3cG9ydFggKyB0YXJnZXRJbmxpbmUsIHZpZXdwb3J0WCArIHRhcmdldElubGluZSArIHRhcmdldFdpZHRoLCB0YXJnZXRXaWR0aCk7XG4gICAgICB9XG5cbiAgICAgIGJsb2NrU2Nyb2xsID0gTWF0aC5tYXgoMCwgYmxvY2tTY3JvbGwgKyB2aWV3cG9ydFkpO1xuICAgICAgaW5saW5lU2Nyb2xsID0gTWF0aC5tYXgoMCwgaW5saW5lU2Nyb2xsICsgdmlld3BvcnRYKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGJsb2NrID09PSAnc3RhcnQnKSB7XG4gICAgICAgIGJsb2NrU2Nyb2xsID0gdGFyZ2V0QmxvY2sgLSB0b3AgLSBib3JkZXJUb3A7XG4gICAgICB9IGVsc2UgaWYgKGJsb2NrID09PSAnZW5kJykge1xuICAgICAgICBibG9ja1Njcm9sbCA9IHRhcmdldEJsb2NrIC0gYm90dG9tICsgYm9yZGVyQm90dG9tICsgc2Nyb2xsYmFySGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChibG9jayA9PT0gJ25lYXJlc3QnKSB7XG4gICAgICAgIGJsb2NrU2Nyb2xsID0gYWxpZ25OZWFyZXN0KHRvcCwgYm90dG9tLCBoZWlnaHQsIGJvcmRlclRvcCwgYm9yZGVyQm90dG9tICsgc2Nyb2xsYmFySGVpZ2h0LCB0YXJnZXRCbG9jaywgdGFyZ2V0QmxvY2sgKyB0YXJnZXRIZWlnaHQsIHRhcmdldEhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBibG9ja1Njcm9sbCA9IHRhcmdldEJsb2NrIC0gKHRvcCArIGhlaWdodCAvIDIpICsgc2Nyb2xsYmFySGVpZ2h0IC8gMjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlubGluZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBpbmxpbmVTY3JvbGwgPSB0YXJnZXRJbmxpbmUgLSBsZWZ0IC0gYm9yZGVyTGVmdDtcbiAgICAgIH0gZWxzZSBpZiAoaW5saW5lID09PSAnY2VudGVyJykge1xuICAgICAgICBpbmxpbmVTY3JvbGwgPSB0YXJnZXRJbmxpbmUgLSAobGVmdCArIHdpZHRoIC8gMikgKyBzY3JvbGxiYXJXaWR0aCAvIDI7XG4gICAgICB9IGVsc2UgaWYgKGlubGluZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgaW5saW5lU2Nyb2xsID0gdGFyZ2V0SW5saW5lIC0gcmlnaHQgKyBib3JkZXJSaWdodCArIHNjcm9sbGJhcldpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5saW5lU2Nyb2xsID0gYWxpZ25OZWFyZXN0KGxlZnQsIHJpZ2h0LCB3aWR0aCwgYm9yZGVyTGVmdCwgYm9yZGVyUmlnaHQgKyBzY3JvbGxiYXJXaWR0aCwgdGFyZ2V0SW5saW5lLCB0YXJnZXRJbmxpbmUgKyB0YXJnZXRXaWR0aCwgdGFyZ2V0V2lkdGgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2Nyb2xsTGVmdCA9IGZyYW1lLnNjcm9sbExlZnQsXG4gICAgICAgICAgc2Nyb2xsVG9wID0gZnJhbWUuc2Nyb2xsVG9wO1xuICAgICAgYmxvY2tTY3JvbGwgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzY3JvbGxUb3AgKyBibG9ja1Njcm9sbCwgZnJhbWUuc2Nyb2xsSGVpZ2h0IC0gaGVpZ2h0ICsgc2Nyb2xsYmFySGVpZ2h0KSk7XG4gICAgICBpbmxpbmVTY3JvbGwgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzY3JvbGxMZWZ0ICsgaW5saW5lU2Nyb2xsLCBmcmFtZS5zY3JvbGxXaWR0aCAtIHdpZHRoICsgc2Nyb2xsYmFyV2lkdGgpKTtcbiAgICAgIHRhcmdldEJsb2NrICs9IHNjcm9sbFRvcCAtIGJsb2NrU2Nyb2xsO1xuICAgICAgdGFyZ2V0SW5saW5lICs9IHNjcm9sbExlZnQgLSBpbmxpbmVTY3JvbGw7XG4gICAgfVxuXG4gICAgY29tcHV0YXRpb25zLnB1c2goe1xuICAgICAgZWw6IGZyYW1lLFxuICAgICAgdG9wOiBibG9ja1Njcm9sbCxcbiAgICAgIGxlZnQ6IGlubGluZVNjcm9sbFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGNvbXB1dGF0aW9ucztcbn0pOyIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRpcmVjdGlvblxuXG52YXIgUlRMID0gJ1xcdTA1OTEtXFx1MDdGRlxcdUZCMUQtXFx1RkRGRFxcdUZFNzAtXFx1RkVGQydcbnZhciBMVFIgPVxuICAnQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2JyArXG4gICdcXHUwMEY4LVxcdTAyQjhcXHUwMzAwLVxcdTA1OTBcXHUwODAwLVxcdTFGRkZcXHUyMDBFXFx1MkMwMC1cXHVGQjFDJyArXG4gICdcXHVGRTAwLVxcdUZFNkZcXHVGRUZELVxcdUZGRkYnXG5cbnZhciBydGwgPSBuZXcgUmVnRXhwKCdeW14nICsgTFRSICsgJ10qWycgKyBSVEwgKyAnXScpXG52YXIgbHRyID0gbmV3IFJlZ0V4cCgnXlteJyArIFJUTCArICddKlsnICsgTFRSICsgJ10nKVxuXG5mdW5jdGlvbiBkaXJlY3Rpb24odmFsdWUpIHtcbiAgdmFsdWUgPSBTdHJpbmcodmFsdWUgfHwgJycpXG5cbiAgaWYgKHJ0bC50ZXN0KHZhbHVlKSkge1xuICAgIHJldHVybiAncnRsJ1xuICB9XG5cbiAgaWYgKGx0ci50ZXN0KHZhbHVlKSkge1xuICAgIHJldHVybiAnbHRyJ1xuICB9XG5cbiAgcmV0dXJuICduZXV0cmFsJ1xufVxuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9lc3JldmVyIHYwLjIuMCBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGVzIGBleHBvcnRzYFxuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgXG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHRtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAsIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSxcblx0Ly8gYW5kIHVzZSBpdCBhcyBgcm9vdGBcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgcmVnZXhTeW1ib2xXaXRoQ29tYmluaW5nTWFya3MgPSAvKFtcXDAtXFx1MDJGRlxcdTAzNzAtXFx1MUFBRlxcdTFCMDAtXFx1MURCRlxcdTFFMDAtXFx1MjBDRlxcdTIxMDAtXFx1RDdGRlxcdUUwMDAtXFx1RkUxRlxcdUZFMzAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXSkoW1xcdTAzMDAtXFx1MDM2RlxcdTFBQjAtXFx1MUFGRlxcdTFEQzAtXFx1MURGRlxcdTIwRDAtXFx1MjBGRlxcdUZFMjAtXFx1RkUyRl0rKS9nO1xuXHR2YXIgcmVnZXhTdXJyb2dhdGVQYWlyID0gLyhbXFx1RDgwMC1cXHVEQkZGXSkoW1xcdURDMDAtXFx1REZGRl0pL2c7XG5cblx0dmFyIHJldmVyc2UgPSBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHQvLyBTdGVwIDE6IGRlYWwgd2l0aCBjb21iaW5pbmcgbWFya3MgYW5kIGFzdHJhbCBzeW1ib2xzIChzdXJyb2dhdGUgcGFpcnMpXG5cdFx0c3RyaW5nID0gc3RyaW5nXG5cdFx0XHQvLyBTd2FwIHN5bWJvbHMgd2l0aCB0aGVpciBjb21iaW5pbmcgbWFya3Mgc28gdGhlIGNvbWJpbmluZyBtYXJrcyBnbyBmaXJzdFxuXHRcdFx0LnJlcGxhY2UocmVnZXhTeW1ib2xXaXRoQ29tYmluaW5nTWFya3MsIGZ1bmN0aW9uKCQwLCAkMSwgJDIpIHtcblx0XHRcdFx0Ly8gUmV2ZXJzZSB0aGUgY29tYmluaW5nIG1hcmtzIHNvIHRoZXkgd2lsbCBlbmQgdXAgaW4gdGhlIHNhbWUgb3JkZXJcblx0XHRcdFx0Ly8gbGF0ZXIgb24gKGFmdGVyIGFub3RoZXIgcm91bmQgb2YgcmV2ZXJzaW5nKVxuXHRcdFx0XHRyZXR1cm4gcmV2ZXJzZSgkMikgKyAkMTtcblx0XHRcdH0pXG5cdFx0XHQvLyBTd2FwIGhpZ2ggYW5kIGxvdyBzdXJyb2dhdGVzIHNvIHRoZSBsb3cgc3Vycm9nYXRlcyBnbyBmaXJzdFxuXHRcdFx0LnJlcGxhY2UocmVnZXhTdXJyb2dhdGVQYWlyLCAnJDIkMScpO1xuXHRcdC8vIFN0ZXAgMjogcmV2ZXJzZSB0aGUgY29kZSB1bml0cyBpbiB0aGUgc3RyaW5nXG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdHZhciBpbmRleCA9IHN0cmluZy5sZW5ndGg7XG5cdFx0d2hpbGUgKGluZGV4LS0pIHtcblx0XHRcdHJlc3VsdCArPSBzdHJpbmcuY2hhckF0KGluZGV4KTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgZXNyZXZlciA9IHtcblx0XHQndmVyc2lvbic6ICcwLjIuMCcsXG5cdFx0J3JldmVyc2UnOiByZXZlcnNlXG5cdH07XG5cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZXNyZXZlcjtcblx0XHR9KTtcblx0fVx0ZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlKSB7XG5cdFx0aWYgKGZyZWVNb2R1bGUpIHsgLy8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gZXNyZXZlcjtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yICh2YXIga2V5IGluIGVzcmV2ZXIpIHtcblx0XHRcdFx0ZXNyZXZlci5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gZXNyZXZlcltrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LmVzcmV2ZXIgPSBlc3JldmVyO1xuXHR9XG5cbn0odGhpcykpO1xuIiwiLy8gU2hvdWxkIGJlIG5vIGltcG9ydHMgaGVyZSFcbnZhciBfYTsgLy8gU09tZSB0aGluZ3MgdGhhdCBzaG91bGQgYmUgZXZhbHVhdGVkIGJlZm9yZSBhbGwgZWxzZS4uLlxuXG5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiO1xudmFyIGhhc01hcCA9IHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCI7XG52YXIgaGFzU2V0ID0gdHlwZW9mIFNldCAhPT0gXCJ1bmRlZmluZWRcIjtcbi8qKlxyXG4gKiBUaGUgc2VudGluZWwgdmFsdWUgcmV0dXJuZWQgYnkgcHJvZHVjZXJzIHRvIHJlcGxhY2UgdGhlIGRyYWZ0IHdpdGggdW5kZWZpbmVkLlxyXG4gKi9cblxudmFyIE5PVEhJTkcgPSBoYXNTeW1ib2wgPyBTeW1ib2woXCJpbW1lci1ub3RoaW5nXCIpIDogKF9hID0ge30sIF9hW1wiaW1tZXItbm90aGluZ1wiXSA9IHRydWUsIF9hKTtcbi8qKlxyXG4gKiBUbyBsZXQgSW1tZXIgdHJlYXQgeW91ciBjbGFzcyBpbnN0YW5jZXMgYXMgcGxhaW4gaW1tdXRhYmxlIG9iamVjdHNcclxuICogKGFsYmVpdCB3aXRoIGEgY3VzdG9tIHByb3RvdHlwZSksIHlvdSBtdXN0IGRlZmluZSBlaXRoZXIgYW4gaW5zdGFuY2UgcHJvcGVydHlcclxuICogb3IgYSBzdGF0aWMgcHJvcGVydHkgb24gZWFjaCBvZiB5b3VyIGN1c3RvbSBjbGFzc2VzLlxyXG4gKlxyXG4gKiBPdGhlcndpc2UsIHlvdXIgY2xhc3MgaW5zdGFuY2Ugd2lsbCBuZXZlciBiZSBkcmFmdGVkLCB3aGljaCBtZWFucyBpdCB3b24ndCBiZVxyXG4gKiBzYWZlIHRvIG11dGF0ZSBpbiBhIHByb2R1Y2UgY2FsbGJhY2suXHJcbiAqL1xuXG52YXIgRFJBRlRBQkxFID0gaGFzU3ltYm9sID8gU3ltYm9sKFwiaW1tZXItZHJhZnRhYmxlXCIpIDogXCJfXyRpbW1lcl9kcmFmdGFibGVcIjtcbnZhciBEUkFGVF9TVEFURSA9IGhhc1N5bWJvbCA/IFN5bWJvbChcImltbWVyLXN0YXRlXCIpIDogXCJfXyRpbW1lcl9zdGF0ZVwiO1xudmFyIGl0ZXJhdG9yU3ltYm9sID0gaGFzU3ltYm9sID8gU3ltYm9sLml0ZXJhdG9yIDogXCJAQGl0ZXJhdG9yXCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwge1xuICAgIF9fcHJvdG9fXzogW11cbiAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZC5fX3Byb3RvX18gPSBiO1xuICB9IHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSB7IGlmIChiLmhhc093blByb3BlcnR5KHApKSB7IGRbcF0gPSBiW3BdOyB9IH1cbiAgfTtcblxuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07IC8vIFVnbHkgaGFjayB0byByZXNvbHZlICM1MDIgYW5kIGluaGVyaXQgYnVpbHQgaW4gTWFwIC8gU2V0XG5cblxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblxuICBmdW5jdGlvbiBfXygpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgfVxuXG4gIGQucHJvdG90eXBlID0gKCAvLyBAdHMtaWdub3JlXG4gIF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG5cbnZhciBBcmNodHlwZTtcblxuKGZ1bmN0aW9uIChBcmNodHlwZSkge1xuICBBcmNodHlwZVtBcmNodHlwZVtcIk9iamVjdFwiXSA9IDBdID0gXCJPYmplY3RcIjtcbiAgQXJjaHR5cGVbQXJjaHR5cGVbXCJBcnJheVwiXSA9IDFdID0gXCJBcnJheVwiO1xuICBBcmNodHlwZVtBcmNodHlwZVtcIk1hcFwiXSA9IDJdID0gXCJNYXBcIjtcbiAgQXJjaHR5cGVbQXJjaHR5cGVbXCJTZXRcIl0gPSAzXSA9IFwiU2V0XCI7XG59KShBcmNodHlwZSB8fCAoQXJjaHR5cGUgPSB7fSkpO1xuXG52YXIgUHJveHlUeXBlO1xuXG4oZnVuY3Rpb24gKFByb3h5VHlwZSkge1xuICBQcm94eVR5cGVbUHJveHlUeXBlW1wiUHJveHlPYmplY3RcIl0gPSAwXSA9IFwiUHJveHlPYmplY3RcIjtcbiAgUHJveHlUeXBlW1Byb3h5VHlwZVtcIlByb3h5QXJyYXlcIl0gPSAxXSA9IFwiUHJveHlBcnJheVwiO1xuICBQcm94eVR5cGVbUHJveHlUeXBlW1wiRVM1T2JqZWN0XCJdID0gMl0gPSBcIkVTNU9iamVjdFwiO1xuICBQcm94eVR5cGVbUHJveHlUeXBlW1wiRVM1QXJyYXlcIl0gPSAzXSA9IFwiRVM1QXJyYXlcIjtcbiAgUHJveHlUeXBlW1Byb3h5VHlwZVtcIk1hcFwiXSA9IDRdID0gXCJNYXBcIjtcbiAgUHJveHlUeXBlW1Byb3h5VHlwZVtcIlNldFwiXSA9IDVdID0gXCJTZXRcIjtcbn0pKFByb3h5VHlwZSB8fCAoUHJveHlUeXBlID0ge30pKTtcblxuLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gSW1tZXIgZHJhZnQgKi9cblxuZnVuY3Rpb24gaXNEcmFmdCh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiAhIXZhbHVlW0RSQUZUX1NUQVRFXTtcbn1cbi8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGNhbiBiZSBkcmFmdGVkIGJ5IEltbWVyICovXG5cbmZ1bmN0aW9uIGlzRHJhZnRhYmxlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCAhIXZhbHVlW0RSQUZUQUJMRV0gfHwgISF2YWx1ZS5jb25zdHJ1Y3RvcltEUkFGVEFCTEVdIHx8IGlzTWFwKHZhbHVlKSB8fCBpc1NldCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB7IHJldHVybiBmYWxzZTsgfVxuICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICByZXR1cm4gIXByb3RvIHx8IHByb3RvID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuZnVuY3Rpb24gb3JpZ2luYWwodmFsdWUpIHtcbiAgaWYgKHZhbHVlICYmIHZhbHVlW0RSQUZUX1NUQVRFXSkge1xuICAgIHJldHVybiB2YWx1ZVtEUkFGVF9TVEFURV0uYmFzZTtcbiAgfSAvLyBvdGhlcndpc2UgcmV0dXJuIHVuZGVmaW5lZFxuXG59XG52YXIgb3duS2V5cyA9IHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3Qub3duS2V5cyA/IFJlZmxlY3Qub3duS2V5cyA6IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSBcInVuZGVmaW5lZFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopKTtcbn0gOlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xuZnVuY3Rpb24gZWFjaChvYmosIGl0ZXIpIHtcbiAgaWYgKGdldEFyY2h0eXBlKG9iaikgPT09IEFyY2h0eXBlLk9iamVjdCkge1xuICAgIG93bktleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBpdGVyKGtleSwgb2JqW2tleV0sIG9iaik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xuICAgICAgcmV0dXJuIGl0ZXIoaW5kZXgsIGVudHJ5LCBvYmopO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBpc0VudW1lcmFibGUoYmFzZSwgcHJvcCkge1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcCk7XG4gIHJldHVybiBkZXNjICYmIGRlc2MuZW51bWVyYWJsZSA/IHRydWUgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldEFyY2h0eXBlKHRoaW5nKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICghdGhpbmcpIHsgZGllKCk7IH1cblxuICBpZiAodGhpbmdbRFJBRlRfU1RBVEVdKSB7XG4gICAgc3dpdGNoICh0aGluZ1tEUkFGVF9TVEFURV0udHlwZSkge1xuICAgICAgY2FzZSBQcm94eVR5cGUuRVM1T2JqZWN0OlxuICAgICAgY2FzZSBQcm94eVR5cGUuUHJveHlPYmplY3Q6XG4gICAgICAgIHJldHVybiBBcmNodHlwZS5PYmplY3Q7XG5cbiAgICAgIGNhc2UgUHJveHlUeXBlLkVTNUFycmF5OlxuICAgICAgY2FzZSBQcm94eVR5cGUuUHJveHlBcnJheTpcbiAgICAgICAgcmV0dXJuIEFyY2h0eXBlLkFycmF5O1xuXG4gICAgICBjYXNlIFByb3h5VHlwZS5NYXA6XG4gICAgICAgIHJldHVybiBBcmNodHlwZS5NYXA7XG5cbiAgICAgIGNhc2UgUHJveHlUeXBlLlNldDpcbiAgICAgICAgcmV0dXJuIEFyY2h0eXBlLlNldDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGluZykgPyBBcmNodHlwZS5BcnJheSA6IGlzTWFwKHRoaW5nKSA/IEFyY2h0eXBlLk1hcCA6IGlzU2V0KHRoaW5nKSA/IEFyY2h0eXBlLlNldCA6IEFyY2h0eXBlLk9iamVjdDtcbn1cbmZ1bmN0aW9uIGhhcyh0aGluZywgcHJvcCkge1xuICByZXR1cm4gZ2V0QXJjaHR5cGUodGhpbmcpID09PSBBcmNodHlwZS5NYXAgPyB0aGluZy5oYXMocHJvcCkgOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpbmcsIHByb3ApO1xufVxuZnVuY3Rpb24gZ2V0KHRoaW5nLCBwcm9wKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIGdldEFyY2h0eXBlKHRoaW5nKSA9PT0gQXJjaHR5cGUuTWFwID8gdGhpbmcuZ2V0KHByb3ApIDogdGhpbmdbcHJvcF07XG59XG5mdW5jdGlvbiBzZXQodGhpbmcsIHByb3BPck9sZFZhbHVlLCB2YWx1ZSkge1xuICBzd2l0Y2ggKGdldEFyY2h0eXBlKHRoaW5nKSkge1xuICAgIGNhc2UgQXJjaHR5cGUuTWFwOlxuICAgICAgdGhpbmcuc2V0KHByb3BPck9sZFZhbHVlLCB2YWx1ZSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQXJjaHR5cGUuU2V0OlxuICAgICAgdGhpbmcuZGVsZXRlKHByb3BPck9sZFZhbHVlKTtcbiAgICAgIHRoaW5nLmFkZCh2YWx1ZSk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGluZ1twcm9wT3JPbGRWYWx1ZV0gPSB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBGcm9tOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2M2OTkwNGE1MTFiOTAwMjY2OTM1MTY4MjIzMDYzZGQ4NzcyZGZjNDAvcGFja2FnZXMvZmJqcy9zcmMvY29yZS9zaGFsbG93RXF1YWwuanNcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuZnVuY3Rpb24gaXNNYXAodGFyZ2V0KSB7XG4gIHJldHVybiBoYXNNYXAgJiYgdGFyZ2V0IGluc3RhbmNlb2YgTWFwO1xufVxuZnVuY3Rpb24gaXNTZXQodGFyZ2V0KSB7XG4gIHJldHVybiBoYXNTZXQgJiYgdGFyZ2V0IGluc3RhbmNlb2YgU2V0O1xufVxuZnVuY3Rpb24gbGF0ZXN0KHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5jb3B5IHx8IHN0YXRlLmJhc2U7XG59XG5mdW5jdGlvbiBzaGFsbG93Q29weShiYXNlLCBpbnZva2VHZXR0ZXJzKSB7XG4gIGlmIChpbnZva2VHZXR0ZXJzID09PSB2b2lkIDApIHtcbiAgICBpbnZva2VHZXR0ZXJzID0gZmFsc2U7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShiYXNlKSkgeyByZXR1cm4gYmFzZS5zbGljZSgpOyB9XG4gIHZhciBjbG9uZSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2UpKTtcbiAgb3duS2V5cyhiYXNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoa2V5ID09PSBEUkFGVF9TVEFURSkge1xuICAgICAgcmV0dXJuOyAvLyBOZXZlciBjb3B5IG92ZXIgZHJhZnQgc3RhdGUuXG4gICAgfVxuXG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIGtleSk7XG4gICAgdmFyIHZhbHVlID0gZGVzYy52YWx1ZTtcblxuICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgaWYgKCFpbnZva2VHZXR0ZXJzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkltbWVyIGRyYWZ0cyBjYW5ub3QgaGF2ZSBjb21wdXRlZCBwcm9wZXJ0aWVzXCIpO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IGRlc2MuZ2V0LmNhbGwoYmFzZSk7XG4gICAgfVxuXG4gICAgaWYgKGRlc2MuZW51bWVyYWJsZSkge1xuICAgICAgY2xvbmVba2V5XSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xvbmUsIGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjbG9uZTtcbn1cbmZ1bmN0aW9uIGZyZWV6ZShvYmosIGRlZXApIHtcbiAgaWYgKCFpc0RyYWZ0YWJsZShvYmopIHx8IGlzRHJhZnQob2JqKSB8fCBPYmplY3QuaXNGcm96ZW4ob2JqKSkgeyByZXR1cm47IH1cbiAgdmFyIHR5cGUgPSBnZXRBcmNodHlwZShvYmopO1xuXG4gIGlmICh0eXBlID09PSBBcmNodHlwZS5TZXQpIHtcbiAgICBvYmouYWRkID0gb2JqLmNsZWFyID0gb2JqLmRlbGV0ZSA9IGRvbnRNdXRhdGVGcm96ZW5Db2xsZWN0aW9ucztcbiAgfSBlbHNlIGlmICh0eXBlID09PSBBcmNodHlwZS5NYXApIHtcbiAgICBvYmouc2V0ID0gb2JqLmNsZWFyID0gb2JqLmRlbGV0ZSA9IGRvbnRNdXRhdGVGcm96ZW5Db2xsZWN0aW9ucztcbiAgfVxuXG4gIE9iamVjdC5mcmVlemUob2JqKTtcbiAgaWYgKGRlZXApIHsgZWFjaChvYmosIGZ1bmN0aW9uIChfLCB2YWx1ZSkge1xuICAgIHJldHVybiBmcmVlemUodmFsdWUsIHRydWUpO1xuICB9KTsgfVxufVxuXG5mdW5jdGlvbiBkb250TXV0YXRlRnJvemVuQ29sbGVjdGlvbnMoKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIlRoaXMgb2JqZWN0IGhhcyBiZWVuIGZyb3plbiBhbmQgc2hvdWxkIG5vdCBiZSBtdXRhdGVkXCIpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIaWRkZW5Qcm9wZXJ0eSh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3AsIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG5mdW5jdGlvbiBkaWUoKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGUsIHBsZWFzZSBmaWxlIGEgYnVnXCIpO1xufVxuXG4vKiogRWFjaCBzY29wZSByZXByZXNlbnRzIGEgYHByb2R1Y2VgIGNhbGwuICovXG5cbnZhciBJbW1lclNjb3BlID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW1tZXJTY29wZShwYXJlbnQsIGltbWVyKSB7XG4gICAgdGhpcy5kcmFmdHMgPSBbXTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLmltbWVyID0gaW1tZXI7IC8vIFdoZW5ldmVyIHRoZSBtb2RpZmllZCBkcmFmdCBjb250YWlucyBhIGRyYWZ0IGZyb20gYW5vdGhlciBzY29wZSwgd2VcbiAgICAvLyBuZWVkIHRvIHByZXZlbnQgYXV0by1mcmVlemluZyBzbyB0aGUgdW5vd25lZCBkcmFmdCBjYW4gYmUgZmluYWxpemVkLlxuXG4gICAgdGhpcy5jYW5BdXRvRnJlZXplID0gdHJ1ZTtcbiAgfVxuXG4gIEltbWVyU2NvcGUucHJvdG90eXBlLnVzZVBhdGNoZXMgPSBmdW5jdGlvbiAocGF0Y2hMaXN0ZW5lcikge1xuICAgIGlmIChwYXRjaExpc3RlbmVyKSB7XG4gICAgICB0aGlzLnBhdGNoZXMgPSBbXTtcbiAgICAgIHRoaXMuaW52ZXJzZVBhdGNoZXMgPSBbXTtcbiAgICAgIHRoaXMucGF0Y2hMaXN0ZW5lciA9IHBhdGNoTGlzdGVuZXI7XG4gICAgfVxuICB9O1xuXG4gIEltbWVyU2NvcGUucHJvdG90eXBlLnJldm9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmxlYXZlKCk7XG4gICAgdGhpcy5kcmFmdHMuZm9yRWFjaChyZXZva2UpOyAvLyBAdHMtaWdub3JlXG5cbiAgICB0aGlzLmRyYWZ0cyA9IG51bGw7XG4gIH07XG5cbiAgSW1tZXJTY29wZS5wcm90b3R5cGUubGVhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMgPT09IEltbWVyU2NvcGUuY3VycmVudCkge1xuICAgICAgSW1tZXJTY29wZS5jdXJyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgfVxuICB9O1xuXG4gIEltbWVyU2NvcGUuZW50ZXIgPSBmdW5jdGlvbiAoaW1tZXIpIHtcbiAgICB2YXIgc2NvcGUgPSBuZXcgSW1tZXJTY29wZShJbW1lclNjb3BlLmN1cnJlbnQsIGltbWVyKTtcbiAgICBJbW1lclNjb3BlLmN1cnJlbnQgPSBzY29wZTtcbiAgICByZXR1cm4gc2NvcGU7XG4gIH07XG5cbiAgcmV0dXJuIEltbWVyU2NvcGU7XG59KCk7XG5cbmZ1bmN0aW9uIHJldm9rZShkcmFmdCkge1xuICB2YXIgc3RhdGUgPSBkcmFmdFtEUkFGVF9TVEFURV07XG4gIGlmIChzdGF0ZS50eXBlID09PSBQcm94eVR5cGUuUHJveHlPYmplY3QgfHwgc3RhdGUudHlwZSA9PT0gUHJveHlUeXBlLlByb3h5QXJyYXkpIHsgc3RhdGUucmV2b2tlKCk7IH1lbHNlIHsgc3RhdGUucmV2b2tlZCA9IHRydWU7IH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jlc3VsdChpbW1lciwgcmVzdWx0LCBzY29wZSkge1xuICB2YXIgYmFzZURyYWZ0ID0gc2NvcGUuZHJhZnRzWzBdO1xuICB2YXIgaXNSZXBsYWNlZCA9IHJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIHJlc3VsdCAhPT0gYmFzZURyYWZ0O1xuICBpbW1lci53aWxsRmluYWxpemUoc2NvcGUsIHJlc3VsdCwgaXNSZXBsYWNlZCk7XG5cbiAgaWYgKGlzUmVwbGFjZWQpIHtcbiAgICBpZiAoYmFzZURyYWZ0W0RSQUZUX1NUQVRFXS5tb2RpZmllZCkge1xuICAgICAgc2NvcGUucmV2b2tlKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbiBpbW1lciBwcm9kdWNlciByZXR1cm5lZCBhIG5ldyB2YWx1ZSAqYW5kKiBtb2RpZmllZCBpdHMgZHJhZnQuIEVpdGhlciByZXR1cm4gYSBuZXcgdmFsdWUgKm9yKiBtb2RpZnkgdGhlIGRyYWZ0LlwiKTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgfVxuXG4gICAgaWYgKGlzRHJhZnRhYmxlKHJlc3VsdCkpIHtcbiAgICAgIC8vIEZpbmFsaXplIHRoZSByZXN1bHQgaW4gY2FzZSBpdCBjb250YWlucyAob3IgaXMpIGEgc3Vic2V0IG9mIHRoZSBkcmFmdC5cbiAgICAgIHJlc3VsdCA9IGZpbmFsaXplKGltbWVyLCByZXN1bHQsIHNjb3BlKTtcbiAgICAgIGlmICghc2NvcGUucGFyZW50KSB7IG1heWJlRnJlZXplKGltbWVyLCByZXN1bHQpOyB9XG4gICAgfVxuXG4gICAgaWYgKHNjb3BlLnBhdGNoZXMpIHtcbiAgICAgIHNjb3BlLnBhdGNoZXMucHVzaCh7XG4gICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgcGF0aDogW10sXG4gICAgICAgIHZhbHVlOiByZXN1bHRcbiAgICAgIH0pO1xuICAgICAgc2NvcGUuaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgcGF0aDogW10sXG4gICAgICAgIHZhbHVlOiBiYXNlRHJhZnRbRFJBRlRfU1RBVEVdLmJhc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5hbGl6ZSB0aGUgYmFzZSBkcmFmdC5cbiAgICByZXN1bHQgPSBmaW5hbGl6ZShpbW1lciwgYmFzZURyYWZ0LCBzY29wZSwgW10pO1xuICB9XG5cbiAgc2NvcGUucmV2b2tlKCk7XG5cbiAgaWYgKHNjb3BlLnBhdGNoZXMpIHtcbiAgICBzY29wZS5wYXRjaExpc3RlbmVyKHNjb3BlLnBhdGNoZXMsIHNjb3BlLmludmVyc2VQYXRjaGVzKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQgIT09IE5PVEhJTkcgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGZpbmFsaXplKGltbWVyLCBkcmFmdCwgc2NvcGUsIHBhdGgpIHtcbiAgdmFyIHN0YXRlID0gZHJhZnRbRFJBRlRfU1RBVEVdO1xuXG4gIGlmICghc3RhdGUpIHtcbiAgICBpZiAoT2JqZWN0LmlzRnJvemVuKGRyYWZ0KSkgeyByZXR1cm4gZHJhZnQ7IH1cbiAgICByZXR1cm4gZmluYWxpemVUcmVlKGltbWVyLCBkcmFmdCwgc2NvcGUpO1xuICB9IC8vIE5ldmVyIGZpbmFsaXplIGRyYWZ0cyBvd25lZCBieSBhbm90aGVyIHNjb3BlLlxuXG5cbiAgaWYgKHN0YXRlLnNjb3BlICE9PSBzY29wZSkge1xuICAgIHJldHVybiBkcmFmdDtcbiAgfVxuXG4gIGlmICghc3RhdGUubW9kaWZpZWQpIHtcbiAgICBtYXliZUZyZWV6ZShpbW1lciwgc3RhdGUuYmFzZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHN0YXRlLmJhc2U7XG4gIH1cblxuICBpZiAoIXN0YXRlLmZpbmFsaXplZCkge1xuICAgIHN0YXRlLmZpbmFsaXplZCA9IHRydWU7XG4gICAgZmluYWxpemVUcmVlKGltbWVyLCBzdGF0ZS5kcmFmdCwgc2NvcGUsIHBhdGgpOyAvLyBXZSBjYW5ub3QgcmVhbGx5IGRlbGV0ZSBhbnl0aGluZyBpbnNpZGUgb2YgYSBTZXQuIFdlIGNhbiBvbmx5IHJlcGxhY2UgdGhlIHdob2xlIFNldC5cblxuICAgIGlmIChpbW1lci5vbkRlbGV0ZSAmJiBzdGF0ZS50eXBlICE9PSBQcm94eVR5cGUuU2V0KSB7XG4gICAgICAvLyBUaGUgYGFzc2lnbmVkYCBvYmplY3QgaXMgdW5yZWxpYWJsZSB3aXRoIEVTNSBkcmFmdHMuXG4gICAgICBpZiAoaW1tZXIudXNlUHJveGllcykge1xuICAgICAgICB2YXIgYXNzaWduZWQgPSBzdGF0ZS5hc3NpZ25lZDtcbiAgICAgICAgZWFjaChhc3NpZ25lZCwgZnVuY3Rpb24gKHByb3AsIGV4aXN0cykge1xuICAgICAgICAgIGlmICghZXhpc3RzKSB7IGltbWVyLm9uRGVsZXRlKHN0YXRlLCBwcm9wKTsgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBiYXNlID0gc3RhdGUuYmFzZSxcbiAgICAgICAgICAgIGNvcHlfMSA9IHN0YXRlLmNvcHk7XG4gICAgICAgIGVhY2goYmFzZSwgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICBpZiAoIWhhcyhjb3B5XzEsIHByb3ApKSB7IGltbWVyLm9uRGVsZXRlKHN0YXRlLCBwcm9wKTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW1tZXIub25Db3B5KSB7XG4gICAgICBpbW1lci5vbkNvcHkoc3RhdGUpO1xuICAgIH0gLy8gQXQgdGhpcyBwb2ludCwgYWxsIGRlc2NlbmRhbnRzIG9mIGBzdGF0ZS5jb3B5YCBoYXZlIGJlZW4gZmluYWxpemVkLFxuICAgIC8vIHNvIHdlIGNhbiBiZSBzdXJlIHRoYXQgYHNjb3BlLmNhbkF1dG9GcmVlemVgIGlzIGFjY3VyYXRlLlxuXG5cbiAgICBpZiAoaW1tZXIuYXV0b0ZyZWV6ZSAmJiBzY29wZS5jYW5BdXRvRnJlZXplKSB7XG4gICAgICBmcmVlemUoc3RhdGUuY29weSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChwYXRoICYmIHNjb3BlLnBhdGNoZXMpIHtcbiAgICAgIGdlbmVyYXRlUGF0Y2hlcyhzdGF0ZSwgcGF0aCwgc2NvcGUucGF0Y2hlcywgc2NvcGUuaW52ZXJzZVBhdGNoZXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5jb3B5O1xufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZVRyZWUoaW1tZXIsIHJvb3QsIHNjb3BlLCByb290UGF0aCkge1xuICB2YXIgc3RhdGUgPSByb290W0RSQUZUX1NUQVRFXTtcblxuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUudHlwZSA9PT0gUHJveHlUeXBlLkVTNU9iamVjdCB8fCBzdGF0ZS50eXBlID09PSBQcm94eVR5cGUuRVM1QXJyYXkpIHtcbiAgICAgIC8vIENyZWF0ZSB0aGUgZmluYWwgY29weSwgd2l0aCBhZGRlZCBrZXlzIGFuZCB3aXRob3V0IGRlbGV0ZWQga2V5cy5cbiAgICAgIHN0YXRlLmNvcHkgPSBzaGFsbG93Q29weShzdGF0ZS5kcmFmdCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcm9vdCA9IHN0YXRlLmNvcHk7XG4gIH1cblxuICBlYWNoKHJvb3QsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIGZpbmFsaXplUHJvcGVydHkoaW1tZXIsIHNjb3BlLCByb290LCBzdGF0ZSwgcm9vdCwga2V5LCB2YWx1ZSwgcm9vdFBhdGgpO1xuICB9KTtcbiAgcmV0dXJuIHJvb3Q7XG59XG5cbmZ1bmN0aW9uIGZpbmFsaXplUHJvcGVydHkoaW1tZXIsIHNjb3BlLCByb290LCByb290U3RhdGUsIHBhcmVudFZhbHVlLCBwcm9wLCBjaGlsZFZhbHVlLCByb290UGF0aCkge1xuICBpZiAoY2hpbGRWYWx1ZSA9PT0gcGFyZW50VmFsdWUpIHtcbiAgICB0aHJvdyBFcnJvcihcIkltbWVyIGZvcmJpZHMgY2lyY3VsYXIgcmVmZXJlbmNlc1wiKTtcbiAgfSAvLyBJbiB0aGUgYGZpbmFsaXplVHJlZWAgbWV0aG9kLCBvbmx5IHRoZSBgcm9vdGAgb2JqZWN0IG1heSBiZSBhIGRyYWZ0LlxuXG5cbiAgdmFyIGlzRHJhZnRQcm9wID0gISFyb290U3RhdGUgJiYgcGFyZW50VmFsdWUgPT09IHJvb3Q7XG4gIHZhciBpc1NldE1lbWJlciA9IGlzU2V0KHBhcmVudFZhbHVlKTtcblxuICBpZiAoaXNEcmFmdChjaGlsZFZhbHVlKSkge1xuICAgIHZhciBwYXRoID0gcm9vdFBhdGggJiYgaXNEcmFmdFByb3AgJiYgIWlzU2V0TWVtYmVyICYmIC8vIFNldCBvYmplY3RzIGFyZSBhdG9taWMgc2luY2UgdGhleSBoYXZlIG5vIGtleXMuXG4gICAgIWhhcyhyb290U3RhdGUuYXNzaWduZWQsIHByb3ApIC8vIFNraXAgZGVlcCBwYXRjaGVzIGZvciBhc3NpZ25lZCBrZXlzLlxuICAgID8gcm9vdFBhdGguY29uY2F0KHByb3ApIDogdW5kZWZpbmVkOyAvLyBEcmFmdHMgb3duZWQgYnkgYHNjb3BlYCBhcmUgZmluYWxpemVkIGhlcmUuXG5cbiAgICBjaGlsZFZhbHVlID0gZmluYWxpemUoaW1tZXIsIGNoaWxkVmFsdWUsIHNjb3BlLCBwYXRoKTtcbiAgICBzZXQocGFyZW50VmFsdWUsIHByb3AsIGNoaWxkVmFsdWUpOyAvLyBEcmFmdHMgZnJvbSBhbm90aGVyIHNjb3BlIG11c3QgcHJldmVudCBhdXRvLWZyZWV6aW5nLlxuXG4gICAgaWYgKGlzRHJhZnQoY2hpbGRWYWx1ZSkpIHtcbiAgICAgIHNjb3BlLmNhbkF1dG9GcmVlemUgPSBmYWxzZTtcbiAgICB9XG4gIH0gLy8gVW5jaGFuZ2VkIGRyYWZ0IHByb3BlcnRpZXMgYXJlIGlnbm9yZWQuXG4gIGVsc2UgaWYgKGlzRHJhZnRQcm9wICYmIGlzKGNoaWxkVmFsdWUsIGdldChyb290U3RhdGUuYmFzZSwgcHJvcCkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBTZWFyY2ggbmV3IG9iamVjdHMgZm9yIHVuZmluYWxpemVkIGRyYWZ0cy4gRnJvemVuIG9iamVjdHMgc2hvdWxkIG5ldmVyIGNvbnRhaW4gZHJhZnRzLlxuICAgIC8vIFRPRE86IHRoZSByZWN1cnNpb24gb3ZlciBoZXJlIGxvb2tzIHdlaXJkLCBzaG91bGRuJ3Qgbm9uLWRyYWZ0IHN0dWZmIGhhdmUgaXQncyBvd24gcmVjdXJzaW9uP1xuICAgIC8vIGVzcGVjaWFsbHkgdGhlIHBhc3Npbmcgb24gb2Ygcm9vdCBhbmQgcm9vdFN0YXRlIGRvZXNuJ3QgbWFrZSBzZW5zZS4uLlxuICAgIGVsc2UgaWYgKGlzRHJhZnRhYmxlKGNoaWxkVmFsdWUpKSB7XG4gICAgICAgIGVhY2goY2hpbGRWYWx1ZSwgZnVuY3Rpb24gKGtleSwgZ3JhbmRDaGlsZCkge1xuICAgICAgICAgIHJldHVybiBmaW5hbGl6ZVByb3BlcnR5KGltbWVyLCBzY29wZSwgcm9vdCwgcm9vdFN0YXRlLCBjaGlsZFZhbHVlLCBrZXksIGdyYW5kQ2hpbGQsIHJvb3RQYXRoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc2NvcGUucGFyZW50KSB7IG1heWJlRnJlZXplKGltbWVyLCBjaGlsZFZhbHVlKTsgfVxuICAgICAgfVxuXG4gIGlmIChpc0RyYWZ0UHJvcCAmJiBpbW1lci5vbkFzc2lnbiAmJiAhaXNTZXRNZW1iZXIpIHtcbiAgICBpbW1lci5vbkFzc2lnbihyb290U3RhdGUsIHByb3AsIGNoaWxkVmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlRnJlZXplKGltbWVyLCB2YWx1ZSwgZGVlcCkge1xuICBpZiAoZGVlcCA9PT0gdm9pZCAwKSB7XG4gICAgZGVlcCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKGltbWVyLmF1dG9GcmVlemUgJiYgIWlzRHJhZnQodmFsdWUpKSB7XG4gICAgZnJlZXplKHZhbHVlLCBkZWVwKTtcbiAgfVxufVxuXG4vKipcclxuICogUmV0dXJucyBhIG5ldyBkcmFmdCBvZiB0aGUgYGJhc2VgIG9iamVjdC5cclxuICpcclxuICogVGhlIHNlY29uZCBhcmd1bWVudCBpcyB0aGUgcGFyZW50IGRyYWZ0LXN0YXRlICh1c2VkIGludGVybmFsbHkpLlxyXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlUHJveHkoYmFzZSwgcGFyZW50KSB7XG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShiYXNlKTtcbiAgdmFyIHN0YXRlID0ge1xuICAgIHR5cGU6IGlzQXJyYXkgPyBQcm94eVR5cGUuUHJveHlBcnJheSA6IFByb3h5VHlwZS5Qcm94eU9iamVjdCxcbiAgICAvLyBUcmFjayB3aGljaCBwcm9kdWNlIGNhbGwgdGhpcyBpcyBhc3NvY2lhdGVkIHdpdGguXG4gICAgc2NvcGU6IHBhcmVudCA/IHBhcmVudC5zY29wZSA6IEltbWVyU2NvcGUuY3VycmVudCxcbiAgICAvLyBUcnVlIGZvciBib3RoIHNoYWxsb3cgYW5kIGRlZXAgY2hhbmdlcy5cbiAgICBtb2RpZmllZDogZmFsc2UsXG4gICAgLy8gVXNlZCBkdXJpbmcgZmluYWxpemF0aW9uLlxuICAgIGZpbmFsaXplZDogZmFsc2UsXG4gICAgLy8gVHJhY2sgd2hpY2ggcHJvcGVydGllcyBoYXZlIGJlZW4gYXNzaWduZWQgKHRydWUpIG9yIGRlbGV0ZWQgKGZhbHNlKS5cbiAgICBhc3NpZ25lZDoge30sXG4gICAgLy8gVGhlIHBhcmVudCBkcmFmdCBzdGF0ZS5cbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAvLyBUaGUgYmFzZSBzdGF0ZS5cbiAgICBiYXNlOiBiYXNlLFxuICAgIC8vIFRoZSBiYXNlIHByb3h5LlxuICAgIGRyYWZ0OiBudWxsLFxuICAgIC8vIEFueSBwcm9wZXJ0eSBwcm94aWVzLlxuICAgIGRyYWZ0czoge30sXG4gICAgLy8gVGhlIGJhc2UgY29weSB3aXRoIGFueSB1cGRhdGVkIHZhbHVlcy5cbiAgICBjb3B5OiBudWxsLFxuICAgIC8vIENhbGxlZCBieSB0aGUgYHByb2R1Y2VgIGZ1bmN0aW9uLlxuICAgIHJldm9rZTogbnVsbCxcbiAgICBpc01hbnVhbDogZmFsc2VcbiAgfTsgLy8gdGhlIHRyYXBzIG11c3QgdGFyZ2V0IHNvbWV0aGluZywgYSBiaXQgbGlrZSB0aGUgJ3JlYWwnIGJhc2UuXG4gIC8vIGJ1dCBhbHNvLCB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gZGV0ZXJtaW5lIGZyb20gdGhlIHRhcmdldCB3aGF0IHRoZSByZWxldmFudCBzdGF0ZSBpc1xuICAvLyAodG8gYXZvaWQgY3JlYXRpbmcgdHJhcHMgcGVyIGluc3RhbmNlIHRvIGNhcHR1cmUgdGhlIHN0YXRlIGluIGNsb3N1cmUsXG4gIC8vIGFuZCB0byBhdm9pZCBjcmVhdGluZyB3ZWlyZCBoaWRkZW4gcHJvcGVydGllcyBhcyB3ZWxsKVxuICAvLyBTbyB0aGUgdHJpY2sgaXMgdG8gdXNlICdzdGF0ZScgYXMgdGhlIGFjdHVhbCAndGFyZ2V0JyEgKGFuZCBtYWtlIHN1cmUgd2UgaW50ZXJjZXB0IGV2ZXJ5dGhpbmcpXG4gIC8vIE5vdGUgdGhhdCBpbiB0aGUgY2FzZSBvZiBhbiBhcnJheSwgd2UgcHV0IHRoZSBzdGF0ZSBpbiBhbiBhcnJheSB0byBoYXZlIGJldHRlciBSZWZsZWN0IGRlZmF1bHRzIG9vdGJcblxuICB2YXIgdGFyZ2V0ID0gc3RhdGU7XG4gIHZhciB0cmFwcyA9IG9iamVjdFRyYXBzO1xuXG4gIGlmIChpc0FycmF5KSB7XG4gICAgdGFyZ2V0ID0gW3N0YXRlXTtcbiAgICB0cmFwcyA9IGFycmF5VHJhcHM7XG4gIH0gLy8gVE9ETzogb3B0aW1pemF0aW9uOiBtaWdodCBiZSBmYXN0ZXIsIGNoZWFwZXIgaWYgd2UgY3JlYXRlZCBhIG5vbi1yZXZvY2FibGUgcHJveHlcbiAgLy8gYW5kIGFkbWluaXN0cmF0ZSByZXZva2luZyBvdXJzZWx2ZXNcblxuXG4gIHZhciBfYSA9IFByb3h5LnJldm9jYWJsZSh0YXJnZXQsIHRyYXBzKSxcbiAgICAgIHJldm9rZSA9IF9hLnJldm9rZSxcbiAgICAgIHByb3h5ID0gX2EucHJveHk7XG5cbiAgc3RhdGUuZHJhZnQgPSBwcm94eTtcbiAgc3RhdGUucmV2b2tlID0gcmV2b2tlO1xuICByZXR1cm4gcHJveHk7XG59XG4vKipcclxuICogT2JqZWN0IGRyYWZ0c1xyXG4gKi9cblxudmFyIG9iamVjdFRyYXBzID0ge1xuICBnZXQ6IGZ1bmN0aW9uIChzdGF0ZSwgcHJvcCkge1xuICAgIGlmIChwcm9wID09PSBEUkFGVF9TVEFURSkgeyByZXR1cm4gc3RhdGU7IH1cbiAgICB2YXIgZHJhZnRzID0gc3RhdGUuZHJhZnRzOyAvLyBDaGVjayBmb3IgZXhpc3RpbmcgZHJhZnQgaW4gdW5tb2RpZmllZCBzdGF0ZS5cblxuICAgIGlmICghc3RhdGUubW9kaWZpZWQgJiYgaGFzKGRyYWZ0cywgcHJvcCkpIHtcbiAgICAgIHJldHVybiBkcmFmdHNbcHJvcF07XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gbGF0ZXN0KHN0YXRlKVtwcm9wXTtcblxuICAgIGlmIChzdGF0ZS5maW5hbGl6ZWQgfHwgIWlzRHJhZnRhYmxlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gLy8gQ2hlY2sgZm9yIGV4aXN0aW5nIGRyYWZ0IGluIG1vZGlmaWVkIHN0YXRlLlxuXG5cbiAgICBpZiAoc3RhdGUubW9kaWZpZWQpIHtcbiAgICAgIC8vIEFzc2lnbmVkIHZhbHVlcyBhcmUgbmV2ZXIgZHJhZnRlZC4gVGhpcyBjYXRjaGVzIGFueSBkcmFmdHMgd2UgY3JlYXRlZCwgdG9vLlxuICAgICAgaWYgKHZhbHVlICE9PSBwZWVrKHN0YXRlLmJhc2UsIHByb3ApKSB7IHJldHVybiB2YWx1ZTsgfSAvLyBTdG9yZSBkcmFmdHMgb24gdGhlIGNvcHkgKHdoZW4gb25lIGV4aXN0cykuXG4gICAgICAvLyBAdHMtaWdub3JlXG5cbiAgICAgIGRyYWZ0cyA9IHN0YXRlLmNvcHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRyYWZ0c1twcm9wXSA9IHN0YXRlLnNjb3BlLmltbWVyLmNyZWF0ZVByb3h5KHZhbHVlLCBzdGF0ZSk7XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gKHN0YXRlLCBwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AgaW4gbGF0ZXN0KHN0YXRlKTtcbiAgfSxcbiAgb3duS2V5czogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyhsYXRlc3Qoc3RhdGUpKTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAoc3RhdGUsIHByb3BcbiAgLyogc3RyaWN0bHkgbm90LCBidXQgaGVscHMgVFMgKi9cbiAgLCB2YWx1ZSkge1xuICAgIGlmICghc3RhdGUubW9kaWZpZWQpIHtcbiAgICAgIHZhciBiYXNlVmFsdWUgPSBwZWVrKHN0YXRlLmJhc2UsIHByb3ApOyAvLyBPcHRpbWl6ZSBiYXNlZCBvbiB2YWx1ZSdzIHRydXRoaW5lc3MuIFRydXRoeSB2YWx1ZXMgYXJlIGd1YXJhbnRlZWQgdG9cbiAgICAgIC8vIG5ldmVyIGJlIHVuZGVmaW5lZCwgc28gd2UgY2FuIGF2b2lkIHRoZSBgaW5gIG9wZXJhdG9yLiBMYXN0bHksIHRydXRoeVxuICAgICAgLy8gdmFsdWVzIG1heSBiZSBkcmFmdHMsIGJ1dCBmYWxzeSB2YWx1ZXMgYXJlIG5ldmVyIGRyYWZ0cy5cblxuICAgICAgdmFyIGlzVW5jaGFuZ2VkID0gdmFsdWUgPyBpcyhiYXNlVmFsdWUsIHZhbHVlKSB8fCB2YWx1ZSA9PT0gc3RhdGUuZHJhZnRzW3Byb3BdIDogaXMoYmFzZVZhbHVlLCB2YWx1ZSkgJiYgcHJvcCBpbiBzdGF0ZS5iYXNlO1xuICAgICAgaWYgKGlzVW5jaGFuZ2VkKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICBwcmVwYXJlQ29weShzdGF0ZSk7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgfVxuXG4gICAgc3RhdGUuYXNzaWduZWRbcHJvcF0gPSB0cnVlOyAvLyBAdHMtaWdub3JlXG5cbiAgICBzdGF0ZS5jb3B5W3Byb3BdID0gdmFsdWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbiAoc3RhdGUsIHByb3ApIHtcbiAgICAvLyBUaGUgYHVuZGVmaW5lZGAgY2hlY2sgaXMgYSBmYXN0IHBhdGggZm9yIHByZS1leGlzdGluZyBrZXlzLlxuICAgIGlmIChwZWVrKHN0YXRlLmJhc2UsIHByb3ApICE9PSB1bmRlZmluZWQgfHwgcHJvcCBpbiBzdGF0ZS5iYXNlKSB7XG4gICAgICBzdGF0ZS5hc3NpZ25lZFtwcm9wXSA9IGZhbHNlO1xuICAgICAgcHJlcGFyZUNvcHkoc3RhdGUpO1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuYXNzaWduZWRbcHJvcF0pIHtcbiAgICAgIC8vIGlmIGFuIG9yaWdpbmFsbHkgbm90IGFzc2lnbmVkIHByb3BlcnR5IHdhcyBkZWxldGVkXG4gICAgICBkZWxldGUgc3RhdGUuYXNzaWduZWRbcHJvcF07XG4gICAgfSAvLyBAdHMtaWdub3JlXG5cblxuICAgIGlmIChzdGF0ZS5jb3B5KSB7IGRlbGV0ZSBzdGF0ZS5jb3B5W3Byb3BdOyB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIE5vdGU6IFdlIG5ldmVyIGNvZXJjZSBgZGVzYy52YWx1ZWAgaW50byBhbiBJbW1lciBkcmFmdCwgYmVjYXVzZSB3ZSBjYW4ndCBtYWtlXG4gIC8vIHRoZSBzYW1lIGd1YXJhbnRlZSBpbiBFUzUgbW9kZS5cbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiAoc3RhdGUsIHByb3ApIHtcbiAgICB2YXIgb3duZXIgPSBsYXRlc3Qoc3RhdGUpO1xuICAgIHZhciBkZXNjID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob3duZXIsIHByb3ApO1xuXG4gICAgaWYgKGRlc2MpIHtcbiAgICAgIGRlc2Mud3JpdGFibGUgPSB0cnVlO1xuICAgICAgZGVzYy5jb25maWd1cmFibGUgPSBzdGF0ZS50eXBlICE9PSBQcm94eVR5cGUuUHJveHlBcnJheSB8fCBwcm9wICE9PSBcImxlbmd0aFwiO1xuICAgIH1cblxuICAgIHJldHVybiBkZXNjO1xuICB9LFxuICBkZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpIGNhbm5vdCBiZSB1c2VkIG9uIGFuIEltbWVyIGRyYWZ0XCIpOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgfSxcbiAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc3RhdGUuYmFzZSk7XG4gIH0sXG4gIHNldFByb3RvdHlwZU9mOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0LnNldFByb3RvdHlwZU9mKCkgY2Fubm90IGJlIHVzZWQgb24gYW4gSW1tZXIgZHJhZnRcIik7IC8vIHByZXR0aWVyLWlnbm9yZVxuICB9XG59O1xuLyoqXHJcbiAqIEFycmF5IGRyYWZ0c1xyXG4gKi9cblxudmFyIGFycmF5VHJhcHMgPSB7fTtcbmVhY2gob2JqZWN0VHJhcHMsIGZ1bmN0aW9uIChrZXksIGZuKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgYXJyYXlUcmFwc1trZXldID0gZnVuY3Rpb24gKCkge1xuICAgIGFyZ3VtZW50c1swXSA9IGFyZ3VtZW50c1swXVswXTtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn0pO1xuXG5hcnJheVRyYXBzLmRlbGV0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKHN0YXRlLCBwcm9wKSB7XG4gIGlmIChpc05hTihwYXJzZUludChwcm9wKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbW1lciBvbmx5IHN1cHBvcnRzIGRlbGV0aW5nIGFycmF5IGluZGljZXNcIik7IC8vIHByZXR0aWVyLWlnbm9yZVxuICB9XG5cbiAgcmV0dXJuIG9iamVjdFRyYXBzLmRlbGV0ZVByb3BlcnR5LmNhbGwodGhpcywgc3RhdGVbMF0sIHByb3ApO1xufTtcblxuYXJyYXlUcmFwcy5zZXQgPSBmdW5jdGlvbiAoc3RhdGUsIHByb3AsIHZhbHVlKSB7XG4gIGlmIChwcm9wICE9PSBcImxlbmd0aFwiICYmIGlzTmFOKHBhcnNlSW50KHByb3ApKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkltbWVyIG9ubHkgc3VwcG9ydHMgc2V0dGluZyBhcnJheSBpbmRpY2VzIGFuZCB0aGUgJ2xlbmd0aCcgcHJvcGVydHlcIik7IC8vIHByZXR0aWVyLWlnbm9yZVxuICB9XG5cbiAgcmV0dXJuIG9iamVjdFRyYXBzLnNldC5jYWxsKHRoaXMsIHN0YXRlWzBdLCBwcm9wLCB2YWx1ZSwgc3RhdGVbMF0pO1xufTtcbi8qKlxyXG4gKiBNYXAgZHJhZnRzXHJcbiAqL1xuLy8gQWNjZXNzIGEgcHJvcGVydHkgd2l0aG91dCBjcmVhdGluZyBhbiBJbW1lciBkcmFmdC5cblxuXG5mdW5jdGlvbiBwZWVrKGRyYWZ0LCBwcm9wKSB7XG4gIHZhciBzdGF0ZSA9IGRyYWZ0W0RSQUZUX1NUQVRFXTtcbiAgdmFyIGRlc2MgPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzdGF0ZSA/IGxhdGVzdChzdGF0ZSkgOiBkcmFmdCwgcHJvcCk7XG4gIHJldHVybiBkZXNjICYmIGRlc2MudmFsdWU7XG59XG5cbmZ1bmN0aW9uIG1hcmtDaGFuZ2VkKHN0YXRlKSB7XG4gIGlmICghc3RhdGUubW9kaWZpZWQpIHtcbiAgICBzdGF0ZS5tb2RpZmllZCA9IHRydWU7XG5cbiAgICBpZiAoc3RhdGUudHlwZSA9PT0gUHJveHlUeXBlLlByb3h5T2JqZWN0IHx8IHN0YXRlLnR5cGUgPT09IFByb3h5VHlwZS5Qcm94eUFycmF5KSB7XG4gICAgICB2YXIgY29weV8xID0gc3RhdGUuY29weSA9IHNoYWxsb3dDb3B5KHN0YXRlLmJhc2UpO1xuICAgICAgZWFjaChzdGF0ZS5kcmFmdHMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29weV8xW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgc3RhdGUuZHJhZnRzID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5wYXJlbnQpIHtcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlLnBhcmVudCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVDb3B5KHN0YXRlKSB7XG4gIGlmICghc3RhdGUuY29weSkge1xuICAgIHN0YXRlLmNvcHkgPSBzaGFsbG93Q29weShzdGF0ZS5iYXNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3aWxsRmluYWxpemVFUzUoc2NvcGUsIHJlc3VsdCwgaXNSZXBsYWNlZCkge1xuICBzY29wZS5kcmFmdHMuZm9yRWFjaChmdW5jdGlvbiAoZHJhZnQpIHtcbiAgICBkcmFmdFtEUkFGVF9TVEFURV0uZmluYWxpemluZyA9IHRydWU7XG4gIH0pO1xuXG4gIGlmICghaXNSZXBsYWNlZCkge1xuICAgIGlmIChzY29wZS5wYXRjaGVzKSB7XG4gICAgICBtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5KHNjb3BlLmRyYWZ0c1swXSk7XG4gICAgfSAvLyBUaGlzIGlzIGZhc3RlciB3aGVuIHdlIGRvbid0IGNhcmUgYWJvdXQgd2hpY2ggYXR0cmlidXRlcyBjaGFuZ2VkLlxuXG5cbiAgICBtYXJrQ2hhbmdlc1N3ZWVwKHNjb3BlLmRyYWZ0cyk7XG4gIH0gLy8gV2hlbiBhIGNoaWxkIGRyYWZ0IGlzIHJldHVybmVkLCBsb29rIGZvciBjaGFuZ2VzLlxuICBlbHNlIGlmIChpc0RyYWZ0KHJlc3VsdCkgJiYgcmVzdWx0W0RSQUZUX1NUQVRFXS5zY29wZSA9PT0gc2NvcGUpIHtcbiAgICAgIG1hcmtDaGFuZ2VzU3dlZXAoc2NvcGUuZHJhZnRzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFUzVQcm94eShiYXNlLCBwYXJlbnQpIHtcbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGJhc2UpO1xuICB2YXIgZHJhZnQgPSBjbG9uZVBvdGVudGlhbERyYWZ0KGJhc2UpO1xuICBlYWNoKGRyYWZ0LCBmdW5jdGlvbiAocHJvcCkge1xuICAgIHByb3h5UHJvcGVydHkoZHJhZnQsIHByb3AsIGlzQXJyYXkgfHwgaXNFbnVtZXJhYmxlKGJhc2UsIHByb3ApKTtcbiAgfSk7XG4gIHZhciBzdGF0ZSA9IHtcbiAgICB0eXBlOiBpc0FycmF5ID8gUHJveHlUeXBlLkVTNUFycmF5IDogUHJveHlUeXBlLkVTNU9iamVjdCxcbiAgICBzY29wZTogcGFyZW50ID8gcGFyZW50LnNjb3BlIDogSW1tZXJTY29wZS5jdXJyZW50LFxuICAgIG1vZGlmaWVkOiBmYWxzZSxcbiAgICBmaW5hbGl6aW5nOiBmYWxzZSxcbiAgICBmaW5hbGl6ZWQ6IGZhbHNlLFxuICAgIGFzc2lnbmVkOiB7fSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBiYXNlOiBiYXNlLFxuICAgIGRyYWZ0OiBkcmFmdCxcbiAgICBjb3B5OiBudWxsLFxuICAgIHJldm9rZWQ6IGZhbHNlLFxuICAgIGlzTWFudWFsOiBmYWxzZVxuICB9O1xuICBjcmVhdGVIaWRkZW5Qcm9wZXJ0eShkcmFmdCwgRFJBRlRfU1RBVEUsIHN0YXRlKTtcbiAgcmV0dXJuIGRyYWZ0O1xufSAvLyBBY2Nlc3MgYSBwcm9wZXJ0eSB3aXRob3V0IGNyZWF0aW5nIGFuIEltbWVyIGRyYWZ0LlxuXG5mdW5jdGlvbiBwZWVrJDEoZHJhZnQsIHByb3ApIHtcbiAgdmFyIHN0YXRlID0gZHJhZnRbRFJBRlRfU1RBVEVdO1xuXG4gIGlmIChzdGF0ZSAmJiAhc3RhdGUuZmluYWxpemluZykge1xuICAgIHN0YXRlLmZpbmFsaXppbmcgPSB0cnVlO1xuICAgIHZhciB2YWx1ZSA9IGRyYWZ0W3Byb3BdO1xuICAgIHN0YXRlLmZpbmFsaXppbmcgPSBmYWxzZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gZHJhZnRbcHJvcF07XG59XG5cbmZ1bmN0aW9uIGdldCQxKHN0YXRlLCBwcm9wKSB7XG4gIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gIHZhciB2YWx1ZSA9IHBlZWskMShsYXRlc3Qoc3RhdGUpLCBwcm9wKTtcbiAgaWYgKHN0YXRlLmZpbmFsaXppbmcpIHsgcmV0dXJuIHZhbHVlOyB9IC8vIENyZWF0ZSBhIGRyYWZ0IGlmIHRoZSB2YWx1ZSBpcyB1bm1vZGlmaWVkLlxuXG4gIGlmICh2YWx1ZSA9PT0gcGVlayQxKHN0YXRlLmJhc2UsIHByb3ApICYmIGlzRHJhZnRhYmxlKHZhbHVlKSkge1xuICAgIHByZXBhcmVDb3B5JDEoc3RhdGUpOyAvLyBAdHMtaWdub3JlXG5cbiAgICByZXR1cm4gc3RhdGUuY29weVtwcm9wXSA9IHN0YXRlLnNjb3BlLmltbWVyLmNyZWF0ZVByb3h5KHZhbHVlLCBzdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHNldCQxKHN0YXRlLCBwcm9wLCB2YWx1ZSkge1xuICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICBzdGF0ZS5hc3NpZ25lZFtwcm9wXSA9IHRydWU7XG5cbiAgaWYgKCFzdGF0ZS5tb2RpZmllZCkge1xuICAgIGlmIChpcyh2YWx1ZSwgcGVlayQxKGxhdGVzdChzdGF0ZSksIHByb3ApKSkgeyByZXR1cm47IH1cbiAgICBtYXJrQ2hhbmdlZEVTNShzdGF0ZSk7XG4gICAgcHJlcGFyZUNvcHkkMShzdGF0ZSk7XG4gIH0gLy8gQHRzLWlnbm9yZVxuXG5cbiAgc3RhdGUuY29weVtwcm9wXSA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBtYXJrQ2hhbmdlZEVTNShzdGF0ZSkge1xuICBpZiAoIXN0YXRlLm1vZGlmaWVkKSB7XG4gICAgc3RhdGUubW9kaWZpZWQgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5wYXJlbnQpIHsgbWFya0NoYW5nZWRFUzUoc3RhdGUucGFyZW50KTsgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVDb3B5JDEoc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5jb3B5KSB7IHN0YXRlLmNvcHkgPSBjbG9uZVBvdGVudGlhbERyYWZ0KHN0YXRlLmJhc2UpOyB9XG59XG5cbmZ1bmN0aW9uIGNsb25lUG90ZW50aWFsRHJhZnQoYmFzZSkge1xuICB2YXIgc3RhdGUgPSBiYXNlICYmIGJhc2VbRFJBRlRfU1RBVEVdO1xuXG4gIGlmIChzdGF0ZSkge1xuICAgIHN0YXRlLmZpbmFsaXppbmcgPSB0cnVlO1xuICAgIHZhciBkcmFmdCA9IHNoYWxsb3dDb3B5KHN0YXRlLmRyYWZ0LCB0cnVlKTtcbiAgICBzdGF0ZS5maW5hbGl6aW5nID0gZmFsc2U7XG4gICAgcmV0dXJuIGRyYWZ0O1xuICB9XG5cbiAgcmV0dXJuIHNoYWxsb3dDb3B5KGJhc2UpO1xufSAvLyBwcm9wZXJ0eSBkZXNjcmlwdG9ycyBhcmUgcmVjeWNsZWQgdG8gbWFrZSBzdXJlIHdlIGRvbid0IGNyZWF0ZSBhIGdldCBhbmQgc2V0IGNsb3N1cmUgcGVyIHByb3BlcnR5LFxuLy8gYnV0IHNoYXJlIHRoZW0gYWxsIGluc3RlYWRcblxuXG52YXIgZGVzY3JpcHRvcnMgPSB7fTtcblxuZnVuY3Rpb24gcHJveHlQcm9wZXJ0eShkcmFmdCwgcHJvcCwgZW51bWVyYWJsZSkge1xuICB2YXIgZGVzYyA9IGRlc2NyaXB0b3JzW3Byb3BdO1xuXG4gIGlmIChkZXNjKSB7XG4gICAgZGVzYy5lbnVtZXJhYmxlID0gZW51bWVyYWJsZTtcbiAgfSBlbHNlIHtcbiAgICBkZXNjcmlwdG9yc1twcm9wXSA9IGRlc2MgPSB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBlbnVtZXJhYmxlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBnZXQkMSh0aGlzW0RSQUZUX1NUQVRFXSwgcHJvcCk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgc2V0JDEodGhpc1tEUkFGVF9TVEFURV0sIHByb3AsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRyYWZ0LCBwcm9wLCBkZXNjKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VW5yZXZva2VkKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5yZXZva2VkID09PSB0cnVlKSB7IHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgYSBwcm94eSB0aGF0IGhhcyBiZWVuIHJldm9rZWQuIERpZCB5b3UgcGFzcyBhbiBvYmplY3QgZnJvbSBpbnNpZGUgYW4gaW1tZXIgZnVuY3Rpb24gdG8gYW4gYXN5bmMgcHJvY2Vzcz8gXCIgKyBKU09OLnN0cmluZ2lmeShsYXRlc3Qoc3RhdGUpKSk7IH1cbn0gLy8gVGhpcyBsb29rcyBleHBlbnNpdmUsIGJ1dCBvbmx5IHByb3hpZXMgYXJlIHZpc2l0ZWQsIGFuZCBvbmx5IG9iamVjdHMgd2l0aG91dCBrbm93biBjaGFuZ2VzIGFyZSBzY2FubmVkLlxuXG5mdW5jdGlvbiBtYXJrQ2hhbmdlc1N3ZWVwKGRyYWZ0cykge1xuICAvLyBUaGUgbmF0dXJhbCBvcmRlciBvZiBkcmFmdHMgaW4gdGhlIGBzY29wZWAgYXJyYXkgaXMgYmFzZWQgb24gd2hlbiB0aGV5XG4gIC8vIHdlcmUgYWNjZXNzZWQuIEJ5IHByb2Nlc3NpbmcgZHJhZnRzIGluIHJldmVyc2UgbmF0dXJhbCBvcmRlciwgd2UgaGF2ZSBhXG4gIC8vIGJldHRlciBjaGFuY2Ugb2YgcHJvY2Vzc2luZyBsZWFmIG5vZGVzIGZpcnN0LiBXaGVuIGEgbGVhZiBub2RlIGlzIGtub3duIHRvXG4gIC8vIGhhdmUgY2hhbmdlZCwgd2UgY2FuIGF2b2lkIGFueSB0cmF2ZXJzYWwgb2YgaXRzIGFuY2VzdG9yIG5vZGVzLlxuICBmb3IgKHZhciBpID0gZHJhZnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHN0YXRlID0gZHJhZnRzW2ldW0RSQUZUX1NUQVRFXTtcblxuICAgIGlmICghc3RhdGUubW9kaWZpZWQpIHtcbiAgICAgIHN3aXRjaCAoc3RhdGUudHlwZSkge1xuICAgICAgICBjYXNlIFByb3h5VHlwZS5FUzVBcnJheTpcbiAgICAgICAgICBpZiAoaGFzQXJyYXlDaGFuZ2VzKHN0YXRlKSkgeyBtYXJrQ2hhbmdlZEVTNShzdGF0ZSk7IH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFByb3h5VHlwZS5FUzVPYmplY3Q6XG4gICAgICAgICAgaWYgKGhhc09iamVjdENoYW5nZXMoc3RhdGUpKSB7IG1hcmtDaGFuZ2VkRVM1KHN0YXRlKTsgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5KG9iamVjdCkge1xuICBpZiAoIW9iamVjdCB8fCB0eXBlb2Ygb2JqZWN0ICE9PSBcIm9iamVjdFwiKSB7IHJldHVybjsgfVxuICB2YXIgc3RhdGUgPSBvYmplY3RbRFJBRlRfU1RBVEVdO1xuICBpZiAoIXN0YXRlKSB7IHJldHVybjsgfVxuICB2YXIgYmFzZSA9IHN0YXRlLmJhc2UsXG4gICAgICBkcmFmdCA9IHN0YXRlLmRyYWZ0LFxuICAgICAgYXNzaWduZWQgPSBzdGF0ZS5hc3NpZ25lZCxcbiAgICAgIHR5cGUgPSBzdGF0ZS50eXBlO1xuXG4gIGlmICh0eXBlID09PSBQcm94eVR5cGUuRVM1T2JqZWN0KSB7XG4gICAgLy8gTG9vayBmb3IgYWRkZWQga2V5cy5cbiAgICAvLyBUT0RPOiBsb29rcyBxdWl0ZSBkdXBsaWNhdGUgdG8gaGFzT2JqZWN0Q2hhbmdlcyxcbiAgICAvLyBwcm9iYWJseSB0aGVyZSBpcyBhIGZhc3RlciB3YXkgdG8gZGV0ZWN0IGNoYW5nZXMsIGFzIHN3ZWVwICsgcmVjdXJzZSBzZWVtcyB0byBkbyBzb21lXG4gICAgLy8gdW5uZWNlc3Nhcnkgd29yay5cbiAgICAvLyBhbHNvOiBwcm9iYWJseSB3ZSBjYW4gc3RvcmUgdGhlIGluZm9ybWF0aW9uIHdlIGRldGVjdCBoZXJlLCB0byBzcGVlZCB1cCB0cmVlIGZpbmFsaXphdGlvbiFcbiAgICBlYWNoKGRyYWZ0LCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoa2V5ID09PSBEUkFGVF9TVEFURSkgeyByZXR1cm47IH0gLy8gVGhlIGB1bmRlZmluZWRgIGNoZWNrIGlzIGEgZmFzdCBwYXRoIGZvciBwcmUtZXhpc3Rpbmcga2V5cy5cblxuICAgICAgaWYgKGJhc2Vba2V5XSA9PT0gdW5kZWZpbmVkICYmICFoYXMoYmFzZSwga2V5KSkge1xuICAgICAgICBhc3NpZ25lZFtrZXldID0gdHJ1ZTtcbiAgICAgICAgbWFya0NoYW5nZWRFUzUoc3RhdGUpO1xuICAgICAgfSBlbHNlIGlmICghYXNzaWduZWRba2V5XSkge1xuICAgICAgICAvLyBPbmx5IHVudG91Y2hlZCBwcm9wZXJ0aWVzIHRyaWdnZXIgcmVjdXJzaW9uLlxuICAgICAgICBtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5KGRyYWZ0W2tleV0pO1xuICAgICAgfVxuICAgIH0pOyAvLyBMb29rIGZvciByZW1vdmVkIGtleXMuXG5cbiAgICBlYWNoKGJhc2UsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8vIFRoZSBgdW5kZWZpbmVkYCBjaGVjayBpcyBhIGZhc3QgcGF0aCBmb3IgcHJlLWV4aXN0aW5nIGtleXMuXG4gICAgICBpZiAoZHJhZnRba2V5XSA9PT0gdW5kZWZpbmVkICYmICFoYXMoZHJhZnQsIGtleSkpIHtcbiAgICAgICAgYXNzaWduZWRba2V5XSA9IGZhbHNlO1xuICAgICAgICBtYXJrQ2hhbmdlZEVTNShzdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gUHJveHlUeXBlLkVTNUFycmF5KSB7XG4gICAgaWYgKGhhc0FycmF5Q2hhbmdlcyhzdGF0ZSkpIHtcbiAgICAgIG1hcmtDaGFuZ2VkRVM1KHN0YXRlKTtcbiAgICAgIGFzc2lnbmVkLmxlbmd0aCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGRyYWZ0Lmxlbmd0aCA8IGJhc2UubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gZHJhZnQubGVuZ3RoOyBpIDwgYmFzZS5sZW5ndGg7IGkrKykgeyBhc3NpZ25lZFtpXSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSBiYXNlLmxlbmd0aDsgaSA8IGRyYWZ0Lmxlbmd0aDsgaSsrKSB7IGFzc2lnbmVkW2ldID0gdHJ1ZTsgfVxuICAgIH0gLy8gTWluaW11bSBjb3VudCBpcyBlbm91Z2gsIHRoZSBvdGhlciBwYXJ0cyBoYXMgYmVlbiBwcm9jZXNzZWQuXG5cblxuICAgIHZhciBtaW4gPSBNYXRoLm1pbihkcmFmdC5sZW5ndGgsIGJhc2UubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWluOyBpKyspIHtcbiAgICAgIC8vIE9ubHkgdW50b3VjaGVkIGluZGljZXMgdHJpZ2dlciByZWN1cnNpb24uXG4gICAgICBpZiAoYXNzaWduZWRbaV0gPT09IHVuZGVmaW5lZCkgeyBtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5KGRyYWZ0W2ldKTsgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNPYmplY3RDaGFuZ2VzKHN0YXRlKSB7XG4gIHZhciBiYXNlID0gc3RhdGUuYmFzZSxcbiAgICAgIGRyYWZ0ID0gc3RhdGUuZHJhZnQ7IC8vIFNlYXJjaCBmb3IgYWRkZWQga2V5cyBhbmQgY2hhbmdlZCBrZXlzLiBTdGFydCBhdCB0aGUgYmFjaywgYmVjYXVzZVxuICAvLyBub24tbnVtZXJpYyBrZXlzIGFyZSBvcmRlcmVkIGJ5IHRpbWUgb2YgZGVmaW5pdGlvbiBvbiB0aGUgb2JqZWN0LlxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZHJhZnQpO1xuXG4gIGZvciAodmFyIGkgPSBrZXlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgdmFyIGJhc2VWYWx1ZSA9IGJhc2Vba2V5XTsgLy8gVGhlIGB1bmRlZmluZWRgIGNoZWNrIGlzIGEgZmFzdCBwYXRoIGZvciBwcmUtZXhpc3Rpbmcga2V5cy5cblxuICAgIGlmIChiYXNlVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhaGFzKGJhc2UsIGtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gT25jZSBhIGJhc2Uga2V5IGlzIGRlbGV0ZWQsIGZ1dHVyZSBjaGFuZ2VzIGdvIHVuZGV0ZWN0ZWQsIGJlY2F1c2UgaXRzXG4gICAgLy8gZGVzY3JpcHRvciBpcyBlcmFzZWQuIFRoaXMgYnJhbmNoIGRldGVjdHMgYW55IG1pc3NlZCBjaGFuZ2VzLlxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUgPSBkcmFmdFtrZXldO1xuICAgICAgICB2YXIgc3RhdGVfMSA9IHZhbHVlICYmIHZhbHVlW0RSQUZUX1NUQVRFXTtcblxuICAgICAgICBpZiAoc3RhdGVfMSA/IHN0YXRlXzEuYmFzZSAhPT0gYmFzZVZhbHVlIDogIWlzKHZhbHVlLCBiYXNlVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfSAvLyBBdCB0aGlzIHBvaW50LCBubyBrZXlzIHdlcmUgYWRkZWQgb3IgY2hhbmdlZC5cbiAgLy8gQ29tcGFyZSBrZXkgY291bnQgdG8gZGV0ZXJtaW5lIGlmIGtleXMgd2VyZSBkZWxldGVkLlxuXG5cbiAgcmV0dXJuIGtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiYXNlKS5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGhhc0FycmF5Q2hhbmdlcyhzdGF0ZSkge1xuICB2YXIgZHJhZnQgPSBzdGF0ZS5kcmFmdDtcbiAgaWYgKGRyYWZ0Lmxlbmd0aCAhPT0gc3RhdGUuYmFzZS5sZW5ndGgpIHsgcmV0dXJuIHRydWU7IH0gLy8gU2VlICMxMTZcbiAgLy8gSWYgd2UgZmlyc3Qgc2hvcnRlbiB0aGUgbGVuZ3RoLCBvdXIgYXJyYXkgaW50ZXJjZXB0b3JzIHdpbGwgYmUgcmVtb3ZlZC5cbiAgLy8gSWYgYWZ0ZXIgdGhhdCBuZXcgaXRlbXMgYXJlIGFkZGVkLCByZXN1bHQgaW4gdGhlIHNhbWUgb3JpZ2luYWwgbGVuZ3RoLFxuICAvLyB0aG9zZSBsYXN0IGl0ZW1zIHdpbGwgaGF2ZSBubyBpbnRlcmNlcHRpbmcgcHJvcGVydHkuXG4gIC8vIFNvIGlmIHRoZXJlIGlzIG5vIG93biBkZXNjcmlwdG9yIG9uIHRoZSBsYXN0IHBvc2l0aW9uLCB3ZSBrbm93IHRoYXQgaXRlbXMgd2VyZSByZW1vdmVkIGFuZCBhZGRlZFxuICAvLyBOLkIuOiBzcGxpY2UsIHVuc2hpZnQsIGV0YyBvbmx5IHNoaWZ0IHZhbHVlcyBhcm91bmQsIGJ1dCBub3QgcHJvcCBkZXNjcmlwdG9ycywgc28gd2Ugb25seSBoYXZlIHRvIGNoZWNrXG4gIC8vIHRoZSBsYXN0IG9uZVxuXG4gIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkcmFmdCwgZHJhZnQubGVuZ3RoIC0gMSk7IC8vIGRlc2NyaXB0b3IgY2FuIGJlIG51bGwsIGJ1dCBvbmx5IGZvciBuZXdseSBjcmVhdGVkIHNwYXJzZSBhcnJheXMsIGVnLiBuZXcgQXJyYXkoMTApXG5cbiAgaWYgKGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3IuZ2V0KSB7IHJldHVybiB0cnVlOyB9IC8vIEZvciBhbGwgb3RoZXIgY2FzZXMsIHdlIGRvbid0IGhhdmUgdG8gY29tcGFyZSwgYXMgdGhleSB3b3VsZCBoYXZlIGJlZW4gcGlja2VkIHVwIGJ5IHRoZSBpbmRleCBzZXR0ZXJzXG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgRHJhZnRNYXAgPSBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gIGlmICghX3N1cGVyKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYXAgaXMgbm90IHBvbHlmaWxsZWRcIik7XG4gIH1cblxuICBfX2V4dGVuZHMoRHJhZnRNYXAsIF9zdXBlcik7IC8vIENyZWF0ZSBjbGFzcyBtYW51YWxseSwgY2F1c2UgIzUwMlxuXG5cbiAgZnVuY3Rpb24gRHJhZnRNYXAodGFyZ2V0LCBwYXJlbnQpIHtcbiAgICB0aGlzW0RSQUZUX1NUQVRFXSA9IHtcbiAgICAgIHR5cGU6IFByb3h5VHlwZS5NYXAsXG4gICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgIHNjb3BlOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGUgOiBJbW1lclNjb3BlLmN1cnJlbnQsXG4gICAgICBtb2RpZmllZDogZmFsc2UsXG4gICAgICBmaW5hbGl6ZWQ6IGZhbHNlLFxuICAgICAgY29weTogdW5kZWZpbmVkLFxuICAgICAgYXNzaWduZWQ6IHVuZGVmaW5lZCxcbiAgICAgIGJhc2U6IHRhcmdldCxcbiAgICAgIGRyYWZ0OiB0aGlzLFxuICAgICAgaXNNYW51YWw6IGZhbHNlLFxuICAgICAgcmV2b2tlZDogZmFsc2VcbiAgICB9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIHAgPSBEcmFmdE1hcC5wcm90b3R5cGU7IC8vIFRPRE86IHNtYWxsZXIgYnVpbGQgc2l6ZSBpZiB3ZSBjcmVhdGUgYSB1dGlsIGZvciBPYmplY3QuZGVmaW5lUHJvcGVydHlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocCwgXCJzaXplXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLnNpemU7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcblxuICBwLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5oYXMoa2V5KTtcbiAgfTtcblxuICBwLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcblxuICAgIGlmIChsYXRlc3Qoc3RhdGUpLmdldChrZXkpICE9PSB2YWx1ZSkge1xuICAgICAgcHJlcGFyZUNvcHkkMihzdGF0ZSk7XG4gICAgICBzdGF0ZS5zY29wZS5pbW1lci5tYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICBzdGF0ZS5hc3NpZ25lZC5zZXQoa2V5LCB0cnVlKTtcbiAgICAgIHN0YXRlLmNvcHkuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgc3RhdGUuYXNzaWduZWQuc2V0KGtleSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcC5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCF0aGlzLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICBwcmVwYXJlQ29weSQyKHN0YXRlKTtcbiAgICBzdGF0ZS5zY29wZS5pbW1lci5tYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgc3RhdGUuYXNzaWduZWQuc2V0KGtleSwgZmFsc2UpO1xuICAgIHN0YXRlLmNvcHkuZGVsZXRlKGtleSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcC5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgIHByZXBhcmVDb3B5JDIoc3RhdGUpO1xuICAgIHN0YXRlLnNjb3BlLmltbWVyLm1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICBzdGF0ZS5hc3NpZ25lZCA9IG5ldyBNYXAoKTtcbiAgICByZXR1cm4gc3RhdGUuY29weS5jbGVhcigpO1xuICB9O1xuXG4gIHAuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYiwgdGhpc0FyZykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICBsYXRlc3Qoc3RhdGUpLmZvckVhY2goZnVuY3Rpb24gKF92YWx1ZSwga2V5LCBfbWFwKSB7XG4gICAgICBjYi5jYWxsKHRoaXNBcmcsIF90aGlzLmdldChrZXkpLCBrZXksIF90aGlzKTtcbiAgICB9KTtcbiAgfTtcblxuICBwLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgIHZhciB2YWx1ZSA9IGxhdGVzdChzdGF0ZSkuZ2V0KGtleSk7XG5cbiAgICBpZiAoc3RhdGUuZmluYWxpemVkIHx8ICFpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgIT09IHN0YXRlLmJhc2UuZ2V0KGtleSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTsgLy8gZWl0aGVyIGFscmVhZHkgZHJhZnRlZCBvciByZWFzc2lnbmVkXG4gICAgfSAvLyBkZXNwaXRlIHdoYXQgaXQgbG9va3MsIHRoaXMgY3JlYXRlcyBhIGRyYWZ0IG9ubHkgb25jZSwgc2VlIGFib3ZlIGNvbmRpdGlvblxuXG5cbiAgICB2YXIgZHJhZnQgPSBzdGF0ZS5zY29wZS5pbW1lci5jcmVhdGVQcm94eSh2YWx1ZSwgc3RhdGUpO1xuICAgIHByZXBhcmVDb3B5JDIoc3RhdGUpO1xuICAgIHN0YXRlLmNvcHkuc2V0KGtleSwgZHJhZnQpO1xuICAgIHJldHVybiBkcmFmdDtcbiAgfTtcblxuICBwLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkua2V5cygpO1xuICB9O1xuXG4gIHAudmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLmtleXMoKTtcbiAgICByZXR1cm4gX2EgPSB7fSwgX2FbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnZhbHVlcygpO1xuICAgIH0sIF9hLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgciA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICAgIGlmIChyLmRvbmUpIHsgcmV0dXJuIHI7IH1cblxuICAgICAgdmFyIHZhbHVlID0gX3RoaXMuZ2V0KHIudmFsdWUpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9O1xuICAgIH0sIF9hO1xuICB9O1xuXG4gIHAuZW50cmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2E7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5rZXlzKCk7XG4gICAgcmV0dXJuIF9hID0ge30sIF9hW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5lbnRyaWVzKCk7XG4gICAgfSwgX2EubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICAgICAgaWYgKHIuZG9uZSkgeyByZXR1cm4gcjsgfVxuXG4gICAgICB2YXIgdmFsdWUgPSBfdGhpcy5nZXQoci52YWx1ZSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogW3IudmFsdWUsIHZhbHVlXVxuICAgICAgfTtcbiAgICB9LCBfYTtcbiAgfTtcblxuICBwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gIH07XG5cbiAgcmV0dXJuIERyYWZ0TWFwO1xufShNYXApO1xuXG5mdW5jdGlvbiBwcm94eU1hcCh0YXJnZXQsIHBhcmVudCkge1xuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiBuZXcgRHJhZnRNYXAodGFyZ2V0LCBwYXJlbnQpO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlQ29weSQyKHN0YXRlKSB7XG4gIGlmICghc3RhdGUuY29weSkge1xuICAgIHN0YXRlLmFzc2lnbmVkID0gbmV3IE1hcCgpO1xuICAgIHN0YXRlLmNvcHkgPSBuZXcgTWFwKHN0YXRlLmJhc2UpO1xuICB9XG59XG5cbnZhciBEcmFmdFNldCA9IGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgaWYgKCFfc3VwZXIpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNldCBpcyBub3QgcG9seWZpbGxlZFwiKTtcbiAgfVxuXG4gIF9fZXh0ZW5kcyhEcmFmdFNldCwgX3N1cGVyKTsgLy8gQ3JlYXRlIGNsYXNzIG1hbnVhbGx5LCBjYXVzZSAjNTAyXG5cblxuICBmdW5jdGlvbiBEcmFmdFNldCh0YXJnZXQsIHBhcmVudCkge1xuICAgIHRoaXNbRFJBRlRfU1RBVEVdID0ge1xuICAgICAgdHlwZTogUHJveHlUeXBlLlNldCxcbiAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgc2NvcGU6IHBhcmVudCA/IHBhcmVudC5zY29wZSA6IEltbWVyU2NvcGUuY3VycmVudCxcbiAgICAgIG1vZGlmaWVkOiBmYWxzZSxcbiAgICAgIGZpbmFsaXplZDogZmFsc2UsXG4gICAgICBjb3B5OiB1bmRlZmluZWQsXG4gICAgICBiYXNlOiB0YXJnZXQsXG4gICAgICBkcmFmdDogdGhpcyxcbiAgICAgIGRyYWZ0czogbmV3IE1hcCgpLFxuICAgICAgcmV2b2tlZDogZmFsc2UsXG4gICAgICBpc01hbnVhbDogZmFsc2VcbiAgICB9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIHAgPSBEcmFmdFNldC5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcInNpemVcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkuc2l6ZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuXG4gIHAuaGFzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTsgLy8gYml0IG9mIHRyaWNrZXJ5IGhlcmUsIHRvIGJlIGFibGUgdG8gcmVjb2duaXplIGJvdGggdGhlIHZhbHVlLCBhbmQgdGhlIGRyYWZ0IG9mIGl0cyB2YWx1ZVxuXG4gICAgaWYgKCFzdGF0ZS5jb3B5KSB7XG4gICAgICByZXR1cm4gc3RhdGUuYmFzZS5oYXModmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5jb3B5Lmhhcyh2YWx1ZSkpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBpZiAoc3RhdGUuZHJhZnRzLmhhcyh2YWx1ZSkgJiYgc3RhdGUuY29weS5oYXMoc3RhdGUuZHJhZnRzLmdldCh2YWx1ZSkpKSB7IHJldHVybiB0cnVlOyB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHAuYWRkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcblxuICAgIGlmIChzdGF0ZS5jb3B5KSB7XG4gICAgICBzdGF0ZS5jb3B5LmFkZCh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICghc3RhdGUuYmFzZS5oYXModmFsdWUpKSB7XG4gICAgICBwcmVwYXJlQ29weSQzKHN0YXRlKTtcbiAgICAgIHN0YXRlLnNjb3BlLmltbWVyLm1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgIHN0YXRlLmNvcHkuYWRkKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBwLmRlbGV0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICBwcmVwYXJlQ29weSQzKHN0YXRlKTtcbiAgICBzdGF0ZS5zY29wZS5pbW1lci5tYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgcmV0dXJuIHN0YXRlLmNvcHkuZGVsZXRlKHZhbHVlKSB8fCAoc3RhdGUuZHJhZnRzLmhhcyh2YWx1ZSkgPyBzdGF0ZS5jb3B5LmRlbGV0ZShzdGF0ZS5kcmFmdHMuZ2V0KHZhbHVlKSkgOlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZmFsc2UpO1xuICB9O1xuXG4gIHAuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICBwcmVwYXJlQ29weSQzKHN0YXRlKTtcbiAgICBzdGF0ZS5zY29wZS5pbW1lci5tYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgcmV0dXJuIHN0YXRlLmNvcHkuY2xlYXIoKTtcbiAgfTtcblxuICBwLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgIHByZXBhcmVDb3B5JDMoc3RhdGUpO1xuICAgIHJldHVybiBzdGF0ZS5jb3B5LnZhbHVlcygpO1xuICB9O1xuXG4gIHAuZW50cmllcyA9IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICBwcmVwYXJlQ29weSQzKHN0YXRlKTtcbiAgICByZXR1cm4gc3RhdGUuY29weS5lbnRyaWVzKCk7XG4gIH07XG5cbiAgcC5rZXlzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xuICB9O1xuXG4gIHBbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xuICB9O1xuXG4gIHAuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goY2IsIHRoaXNBcmcpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLnZhbHVlcygpO1xuICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG5cbiAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICBjYi5jYWxsKHRoaXNBcmcsIHJlc3VsdC52YWx1ZSwgcmVzdWx0LnZhbHVlLCB0aGlzKTtcbiAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIERyYWZ0U2V0O1xufShTZXQpO1xuXG5mdW5jdGlvbiBwcm94eVNldCh0YXJnZXQsIHBhcmVudCkge1xuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiBuZXcgRHJhZnRTZXQodGFyZ2V0LCBwYXJlbnQpO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlQ29weSQzKHN0YXRlKSB7XG4gIGlmICghc3RhdGUuY29weSkge1xuICAgIC8vIGNyZWF0ZSBkcmFmdHMgZm9yIGFsbCBlbnRyaWVzIHRvIHByZXNlcnZlIGluc2VydGlvbiBvcmRlclxuICAgIHN0YXRlLmNvcHkgPSBuZXcgU2V0KCk7XG4gICAgc3RhdGUuYmFzZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKGlzRHJhZnRhYmxlKHZhbHVlKSkge1xuICAgICAgICB2YXIgZHJhZnQgPSBzdGF0ZS5zY29wZS5pbW1lci5jcmVhdGVQcm94eSh2YWx1ZSwgc3RhdGUpO1xuICAgICAgICBzdGF0ZS5kcmFmdHMuc2V0KHZhbHVlLCBkcmFmdCk7XG4gICAgICAgIHN0YXRlLmNvcHkuYWRkKGRyYWZ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmNvcHkuYWRkKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVBhdGNoZXMoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICBzd2l0Y2ggKHN0YXRlLnR5cGUpIHtcbiAgICBjYXNlIFByb3h5VHlwZS5Qcm94eU9iamVjdDpcbiAgICBjYXNlIFByb3h5VHlwZS5FUzVPYmplY3Q6XG4gICAgY2FzZSBQcm94eVR5cGUuTWFwOlxuICAgICAgcmV0dXJuIGdlbmVyYXRlUGF0Y2hlc0Zyb21Bc3NpZ25lZChzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKTtcblxuICAgIGNhc2UgUHJveHlUeXBlLkVTNUFycmF5OlxuICAgIGNhc2UgUHJveHlUeXBlLlByb3h5QXJyYXk6XG4gICAgICByZXR1cm4gZ2VuZXJhdGVBcnJheVBhdGNoZXMoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcyk7XG5cbiAgICBjYXNlIFByb3h5VHlwZS5TZXQ6XG4gICAgICByZXR1cm4gZ2VuZXJhdGVTZXRQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQXJyYXlQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgdmFyIF9hLCBfYjtcblxuICB2YXIgYmFzZSA9IHN0YXRlLmJhc2UsXG4gICAgICBhc3NpZ25lZCA9IHN0YXRlLmFzc2lnbmVkLFxuICAgICAgY29weSA9IHN0YXRlLmNvcHk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgaWYgKCFjb3B5KSB7IGRpZSgpOyB9IC8vIFJlZHVjZSBjb21wbGV4aXR5IGJ5IGVuc3VyaW5nIGBiYXNlYCBpcyBuZXZlciBsb25nZXIuXG5cbiAgaWYgKGNvcHkubGVuZ3RoIDwgYmFzZS5sZW5ndGgpIHtcbiAgICBfYSA9IFtjb3B5LCBiYXNlXSwgYmFzZSA9IF9hWzBdLCBjb3B5ID0gX2FbMV07XG4gICAgX2IgPSBbaW52ZXJzZVBhdGNoZXMsIHBhdGNoZXNdLCBwYXRjaGVzID0gX2JbMF0sIGludmVyc2VQYXRjaGVzID0gX2JbMV07XG4gIH1cblxuICB2YXIgZGVsdGEgPSBjb3B5Lmxlbmd0aCAtIGJhc2UubGVuZ3RoOyAvLyBGaW5kIHRoZSBmaXJzdCByZXBsYWNlZCBpbmRleC5cblxuICB2YXIgc3RhcnQgPSAwO1xuXG4gIHdoaWxlIChiYXNlW3N0YXJ0XSA9PT0gY29weVtzdGFydF0gJiYgc3RhcnQgPCBiYXNlLmxlbmd0aCkge1xuICAgICsrc3RhcnQ7XG4gIH0gLy8gRmluZCB0aGUgbGFzdCByZXBsYWNlZCBpbmRleC4gU2VhcmNoIGZyb20gdGhlIGVuZCB0byBvcHRpbWl6ZSBzcGxpY2UgcGF0Y2hlcy5cblxuXG4gIHZhciBlbmQgPSBiYXNlLmxlbmd0aDtcblxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgYmFzZVtlbmQgLSAxXSA9PT0gY29weVtlbmQgKyBkZWx0YSAtIDFdKSB7XG4gICAgLS1lbmQ7XG4gIH0gLy8gUHJvY2VzcyByZXBsYWNlZCBpbmRpY2VzLlxuXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBpZiAoYXNzaWduZWRbaV0gJiYgY29weVtpXSAhPT0gYmFzZVtpXSkge1xuICAgICAgdmFyIHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgdmFsdWU6IGNvcHlbaV1cbiAgICAgIH0pO1xuICAgICAgaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgdmFsdWU6IGJhc2VbaV1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZXBsYWNlQ291bnQgPSBwYXRjaGVzLmxlbmd0aDsgLy8gUHJvY2VzcyBhZGRlZCBpbmRpY2VzLlxuXG4gIGZvciAodmFyIGkgPSBlbmQgKyBkZWx0YSAtIDE7IGkgPj0gZW5kOyAtLWkpIHtcbiAgICB2YXIgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xuICAgIHBhdGNoZXNbcmVwbGFjZUNvdW50ICsgaSAtIGVuZF0gPSB7XG4gICAgICBvcDogXCJhZGRcIixcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICB2YWx1ZTogY29weVtpXVxuICAgIH07XG4gICAgaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICBvcDogXCJyZW1vdmVcIixcbiAgICAgIHBhdGg6IHBhdGhcbiAgICB9KTtcbiAgfVxufSAvLyBUaGlzIGlzIHVzZWQgZm9yIGJvdGggTWFwIG9iamVjdHMgYW5kIG5vcm1hbCBvYmplY3RzLlxuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlUGF0Y2hlc0Zyb21Bc3NpZ25lZChzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XG4gIHZhciBiYXNlID0gc3RhdGUuYmFzZSxcbiAgICAgIGNvcHkgPSBzdGF0ZS5jb3B5O1xuICBlYWNoKHN0YXRlLmFzc2lnbmVkLCBmdW5jdGlvbiAoa2V5LCBhc3NpZ25lZFZhbHVlKSB7XG4gICAgdmFyIG9yaWdWYWx1ZSA9IGdldChiYXNlLCBrZXkpO1xuICAgIHZhciB2YWx1ZSA9IGdldChjb3B5LCBrZXkpO1xuICAgIHZhciBvcCA9ICFhc3NpZ25lZFZhbHVlID8gXCJyZW1vdmVcIiA6IGhhcyhiYXNlLCBrZXkpID8gXCJyZXBsYWNlXCIgOiBcImFkZFwiO1xuICAgIGlmIChvcmlnVmFsdWUgPT09IHZhbHVlICYmIG9wID09PSBcInJlcGxhY2VcIikgeyByZXR1cm47IH1cbiAgICB2YXIgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChrZXkpO1xuICAgIHBhdGNoZXMucHVzaChvcCA9PT0gXCJyZW1vdmVcIiA/IHtcbiAgICAgIG9wOiBvcCxcbiAgICAgIHBhdGg6IHBhdGhcbiAgICB9IDoge1xuICAgICAgb3A6IG9wLFxuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xuICAgIGludmVyc2VQYXRjaGVzLnB1c2gob3AgPT09IFwiYWRkXCIgPyB7XG4gICAgICBvcDogXCJyZW1vdmVcIixcbiAgICAgIHBhdGg6IHBhdGhcbiAgICB9IDogb3AgPT09IFwicmVtb3ZlXCIgPyB7XG4gICAgICBvcDogXCJhZGRcIixcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICB2YWx1ZTogb3JpZ1ZhbHVlXG4gICAgfSA6IHtcbiAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICB2YWx1ZTogb3JpZ1ZhbHVlXG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVNldFBhdGNoZXMoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICB2YXIgYmFzZSA9IHN0YXRlLmJhc2UsXG4gICAgICBjb3B5ID0gc3RhdGUuY29weTtcbiAgdmFyIGkgPSAwO1xuICBiYXNlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKCFjb3B5Lmhhcyh2YWx1ZSkpIHtcbiAgICAgIHZhciBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSk7XG4gICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICBvcDogXCJyZW1vdmVcIixcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICAgIGludmVyc2VQYXRjaGVzLnVuc2hpZnQoe1xuICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpKys7XG4gIH0pO1xuICBpID0gMDtcbiAgY29weS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICghYmFzZS5oYXModmFsdWUpKSB7XG4gICAgICB2YXIgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xuICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgICBpbnZlcnNlUGF0Y2hlcy51bnNoaWZ0KHtcbiAgICAgICAgb3A6IFwicmVtb3ZlXCIsXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaSsrO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYXBwbHlQYXRjaGVzKGRyYWZ0LCBwYXRjaGVzKSB7XG4gIHBhdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAocGF0Y2gpIHtcbiAgICB2YXIgcGF0aCA9IHBhdGNoLnBhdGgsXG4gICAgICAgIG9wID0gcGF0Y2gub3A7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICAgIGlmICghcGF0aC5sZW5ndGgpIHsgZGllKCk7IH1cbiAgICB2YXIgYmFzZSA9IGRyYWZ0O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgYmFzZSA9IGdldChiYXNlLCBwYXRoW2ldKTtcbiAgICAgIGlmICghYmFzZSB8fCB0eXBlb2YgYmFzZSAhPT0gXCJvYmplY3RcIikgeyB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgcGF0Y2gsIHBhdGggZG9lc24ndCByZXNvbHZlOiBcIiArIHBhdGguam9pbihcIi9cIikpOyB9IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIH1cblxuICAgIHZhciB0eXBlID0gZ2V0QXJjaHR5cGUoYmFzZSk7XG4gICAgdmFyIHZhbHVlID0gZGVlcENsb25lUGF0Y2hWYWx1ZShwYXRjaC52YWx1ZSk7IC8vIHVzZWQgdG8gY2xvbmUgcGF0Y2ggdG8gZW5zdXJlIG9yaWdpbmFsIHBhdGNoIGlzIG5vdCBtb2RpZmllZCwgc2VlICM0MTFcblxuICAgIHZhciBrZXkgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG5cbiAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlIFwicmVwbGFjZVwiOlxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIEFyY2h0eXBlLk1hcDpcbiAgICAgICAgICAgIHJldHVybiBiYXNlLnNldChrZXksIHZhbHVlKTtcblxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICAgICAgICBjYXNlIEFyY2h0eXBlLlNldDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2V0cyBjYW5ub3QgaGF2ZSBcInJlcGxhY2VcIiBwYXRjaGVzLicpO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIGlmIHZhbHVlIGlzIGFuIG9iamVjdCwgdGhlbiBpdCdzIGFzc2lnbmVkIGJ5IHJlZmVyZW5jZVxuICAgICAgICAgICAgLy8gaW4gdGhlIGZvbGxvd2luZyBhZGQgb3IgcmVtb3ZlIG9wcywgdGhlIHZhbHVlIGZpZWxkIGluc2lkZSB0aGUgcGF0Y2ggd2lsbCBhbHNvIGJlIG1vZGlmeWVkXG4gICAgICAgICAgICAvLyBzbyB3ZSB1c2UgdmFsdWUgZnJvbSB0aGUgY2xvbmVkIHBhdGNoXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICByZXR1cm4gYmFzZVtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIEFyY2h0eXBlLkFycmF5OlxuICAgICAgICAgICAgcmV0dXJuIGJhc2Uuc3BsaWNlKGtleSwgMCwgdmFsdWUpO1xuXG4gICAgICAgICAgY2FzZSBBcmNodHlwZS5NYXA6XG4gICAgICAgICAgICByZXR1cm4gYmFzZS5zZXQoa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgICBjYXNlIEFyY2h0eXBlLlNldDpcbiAgICAgICAgICAgIHJldHVybiBiYXNlLmFkZCh2YWx1ZSk7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGJhc2Vba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJyZW1vdmVcIjpcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBBcmNodHlwZS5BcnJheTpcbiAgICAgICAgICAgIHJldHVybiBiYXNlLnNwbGljZShrZXksIDEpO1xuXG4gICAgICAgICAgY2FzZSBBcmNodHlwZS5NYXA6XG4gICAgICAgICAgICByZXR1cm4gYmFzZS5kZWxldGUoa2V5KTtcblxuICAgICAgICAgIGNhc2UgQXJjaHR5cGUuU2V0OlxuICAgICAgICAgICAgcmV0dXJuIGJhc2UuZGVsZXRlKHBhdGNoLnZhbHVlKTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlIGJhc2Vba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBwYXRjaCBvcGVyYXRpb246IFwiICsgb3ApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkcmFmdDtcbn1cblxuZnVuY3Rpb24gZGVlcENsb25lUGF0Y2hWYWx1ZShvYmopIHtcbiAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikgeyByZXR1cm4gb2JqOyB9XG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHsgcmV0dXJuIG9iai5tYXAoZGVlcENsb25lUGF0Y2hWYWx1ZSk7IH1cbiAgaWYgKGlzTWFwKG9iaikpIHsgcmV0dXJuIG5ldyBNYXAoQXJyYXkuZnJvbShvYmouZW50cmllcygpKS5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGsgPSBfYVswXSxcbiAgICAgICAgdiA9IF9hWzFdO1xuICAgIHJldHVybiBbaywgZGVlcENsb25lUGF0Y2hWYWx1ZSh2KV07XG4gIH0pKTsgfVxuICBpZiAoaXNTZXQob2JqKSkgeyByZXR1cm4gbmV3IFNldChBcnJheS5mcm9tKG9iaikubWFwKGRlZXBDbG9uZVBhdGNoVmFsdWUpKTsgfVxuICB2YXIgY2xvbmVkID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSk7XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikgeyBjbG9uZWRba2V5XSA9IGRlZXBDbG9uZVBhdGNoVmFsdWUob2JqW2tleV0pOyB9XG5cbiAgcmV0dXJuIGNsb25lZDtcbn1cblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuZnVuY3Rpb24gdmVyaWZ5TWluaWZpZWQoKSB7fVxuXG52YXIgY29uZmlnRGVmYXVsdHMgPSB7XG4gIHVzZVByb3hpZXM6IHR5cGVvZiBQcm94eSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgUHJveHkucmV2b2NhYmxlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiLFxuICBhdXRvRnJlZXplOiB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA6XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHZlcmlmeU1pbmlmaWVkLm5hbWUgPT09IFwidmVyaWZ5TWluaWZpZWRcIixcbiAgb25Bc3NpZ246IG51bGwsXG4gIG9uRGVsZXRlOiBudWxsLFxuICBvbkNvcHk6IG51bGxcbn07XG5cbnZhciBJbW1lciA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEltbWVyKGNvbmZpZykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLnVzZVByb3hpZXMgPSBmYWxzZTtcbiAgICB0aGlzLmF1dG9GcmVlemUgPSBmYWxzZTtcbiAgICBlYWNoKGNvbmZpZ0RlZmF1bHRzLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIF9hLCBfYjsgLy8gQHRzLWlnbm9yZVxuXG5cbiAgICAgIF90aGlzW2tleV0gPSAoX2IgPSAoX2EgPSBjb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtrZXldLCBfYiAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB2YWx1ZSk7XG4gICAgfSk7XG4gICAgdGhpcy5zZXRVc2VQcm94aWVzKHRoaXMudXNlUHJveGllcyk7XG4gICAgdGhpcy5wcm9kdWNlID0gdGhpcy5wcm9kdWNlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5wcm9kdWNlV2l0aFBhdGNoZXMgPSB0aGlzLnByb2R1Y2VXaXRoUGF0Y2hlcy5iaW5kKHRoaXMpO1xuICB9XG4gIC8qKlxyXG4gICAqIFRoZSBgcHJvZHVjZWAgZnVuY3Rpb24gdGFrZXMgYSB2YWx1ZSBhbmQgYSBcInJlY2lwZSBmdW5jdGlvblwiICh3aG9zZVxyXG4gICAqIHJldHVybiB2YWx1ZSBvZnRlbiBkZXBlbmRzIG9uIHRoZSBiYXNlIHN0YXRlKS4gVGhlIHJlY2lwZSBmdW5jdGlvbiBpc1xyXG4gICAqIGZyZWUgdG8gbXV0YXRlIGl0cyBmaXJzdCBhcmd1bWVudCBob3dldmVyIGl0IHdhbnRzLiBBbGwgbXV0YXRpb25zIGFyZVxyXG4gICAqIG9ubHkgZXZlciBhcHBsaWVkIHRvIGEgX19jb3B5X18gb2YgdGhlIGJhc2Ugc3RhdGUuXHJcbiAgICpcclxuICAgKiBQYXNzIG9ubHkgYSBmdW5jdGlvbiB0byBjcmVhdGUgYSBcImN1cnJpZWQgcHJvZHVjZXJcIiB3aGljaCByZWxpZXZlcyB5b3VcclxuICAgKiBmcm9tIHBhc3NpbmcgdGhlIHJlY2lwZSBmdW5jdGlvbiBldmVyeSB0aW1lLlxyXG4gICAqXHJcbiAgICogT25seSBwbGFpbiBvYmplY3RzIGFuZCBhcnJheXMgYXJlIG1hZGUgbXV0YWJsZS4gQWxsIG90aGVyIG9iamVjdHMgYXJlXHJcbiAgICogY29uc2lkZXJlZCB1bmNvcHlhYmxlLlxyXG4gICAqXHJcbiAgICogTm90ZTogVGhpcyBmdW5jdGlvbiBpcyBfX2JvdW5kX18gdG8gaXRzIGBJbW1lcmAgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2FueX0gYmFzZSAtIHRoZSBpbml0aWFsIHN0YXRlXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvZHVjZXIgLSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEgcHJveHkgb2YgdGhlIGJhc2Ugc3RhdGUgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHdoaWNoIGNhbiBiZSBmcmVlbHkgbW9kaWZpZWRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXRjaExpc3RlbmVyIC0gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFsbCB0aGUgcGF0Y2hlcyBwcm9kdWNlZCBoZXJlXHJcbiAgICogQHJldHVybnMge2FueX0gYSBuZXcgc3RhdGUsIG9yIHRoZSBpbml0aWFsIHN0YXRlIGlmIG5vdGhpbmcgd2FzIG1vZGlmaWVkXHJcbiAgICovXG5cblxuICBJbW1lci5wcm90b3R5cGUucHJvZHVjZSA9IGZ1bmN0aW9uIChiYXNlLCByZWNpcGUsIHBhdGNoTGlzdGVuZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzOyAvLyBjdXJyaWVkIGludm9jYXRpb25cblxuXG4gICAgaWYgKHR5cGVvZiBiYXNlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHJlY2lwZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB2YXIgZGVmYXVsdEJhc2VfMSA9IHJlY2lwZTtcbiAgICAgIHJlY2lwZSA9IGJhc2U7XG4gICAgICB2YXIgc2VsZl8xID0gdGhpcztcbiAgICAgIHJldHVybiBmdW5jdGlvbiBjdXJyaWVkUHJvZHVjZShiYXNlKSB7XG4gICAgICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIGlmIChiYXNlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBiYXNlID0gZGVmYXVsdEJhc2VfMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhcmdzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHMkMVtfaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZl8xLnByb2R1Y2UoYmFzZSwgZnVuY3Rpb24gKGRyYWZ0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlY2lwZS5jYWxsLmFwcGx5KHJlY2lwZSwgX19zcHJlYWRBcnJheXMoW190aGlzLCBkcmFmdF0sIGFyZ3MpKTtcbiAgICAgICAgfSk7IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgfTtcbiAgICB9IC8vIHByZXR0aWVyLWlnbm9yZVxuXG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHJlY2lwZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBmaXJzdCBvciBzZWNvbmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhdGNoTGlzdGVuZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcGF0Y2hMaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSB0aGlyZCBhcmd1bWVudCB0byBgcHJvZHVjZWAgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIHVuZGVmaW5lZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlc3VsdDsgLy8gT25seSBwbGFpbiBvYmplY3RzLCBhcnJheXMsIGFuZCBcImltbWVyYWJsZSBjbGFzc2VzXCIgYXJlIGRyYWZ0ZWQuXG5cbiAgICBpZiAoaXNEcmFmdGFibGUoYmFzZSkpIHtcbiAgICAgIHZhciBzY29wZV8xID0gSW1tZXJTY29wZS5lbnRlcih0aGlzKTtcbiAgICAgIHZhciBwcm94eSA9IHRoaXMuY3JlYXRlUHJveHkoYmFzZSwgdW5kZWZpbmVkKTtcbiAgICAgIHZhciBoYXNFcnJvciA9IHRydWU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IHJlY2lwZShwcm94eSk7XG4gICAgICAgIGhhc0Vycm9yID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAvLyBmaW5hbGx5IGluc3RlYWQgb2YgY2F0Y2ggKyByZXRocm93IGJldHRlciBwcmVzZXJ2ZXMgb3JpZ2luYWwgc3RhY2tcbiAgICAgICAgaWYgKGhhc0Vycm9yKSB7IHNjb3BlXzEucmV2b2tlKCk7IH1lbHNlIHsgc2NvcGVfMS5sZWF2ZSgpOyB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiByZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgc2NvcGVfMS51c2VQYXRjaGVzKHBhdGNoTGlzdGVuZXIpO1xuICAgICAgICAgIHJldHVybiBwcm9jZXNzUmVzdWx0KF90aGlzLCByZXN1bHQsIHNjb3BlXzEpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBzY29wZV8xLnJldm9rZSgpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc2NvcGVfMS51c2VQYXRjaGVzKHBhdGNoTGlzdGVuZXIpO1xuICAgICAgcmV0dXJuIHByb2Nlc3NSZXN1bHQodGhpcywgcmVzdWx0LCBzY29wZV8xKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gcmVjaXBlKGJhc2UpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gTk9USElORykgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHsgcmVzdWx0ID0gYmFzZTsgfVxuICAgICAgbWF5YmVGcmVlemUodGhpcywgcmVzdWx0LCB0cnVlKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xuXG4gIEltbWVyLnByb3RvdHlwZS5wcm9kdWNlV2l0aFBhdGNoZXMgPSBmdW5jdGlvbiAoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIGFyZzEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50cyQxW19pXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfdGhpcy5wcm9kdWNlV2l0aFBhdGNoZXMoc3RhdGUsIGZ1bmN0aW9uIChkcmFmdCkge1xuICAgICAgICAgIHJldHVybiBhcmcxLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheXMoW2RyYWZ0XSwgYXJncykpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSAvLyBub24tY3VycmllZCBmb3JtXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG5cbiAgICBpZiAoYXJnMykgeyBkaWUoKTsgfVxuICAgIHZhciBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcztcbiAgICB2YXIgbmV4dFN0YXRlID0gdGhpcy5wcm9kdWNlKGFyZzEsIGFyZzIsIGZ1bmN0aW9uIChwLCBpcCkge1xuICAgICAgcGF0Y2hlcyA9IHA7XG4gICAgICBpbnZlcnNlUGF0Y2hlcyA9IGlwO1xuICAgIH0pO1xuICAgIHJldHVybiBbbmV4dFN0YXRlLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlc107XG4gIH07XG5cbiAgSW1tZXIucHJvdG90eXBlLmNyZWF0ZURyYWZ0ID0gZnVuY3Rpb24gKGJhc2UpIHtcbiAgICBpZiAoIWlzRHJhZnRhYmxlKGJhc2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaXJzdCBhcmd1bWVudCB0byBgY3JlYXRlRHJhZnRgIG11c3QgYmUgYSBwbGFpbiBvYmplY3QsIGFuIGFycmF5LCBvciBhbiBpbW1lcmFibGUgb2JqZWN0XCIpOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICB9XG5cbiAgICB2YXIgc2NvcGUgPSBJbW1lclNjb3BlLmVudGVyKHRoaXMpO1xuICAgIHZhciBwcm94eSA9IHRoaXMuY3JlYXRlUHJveHkoYmFzZSwgdW5kZWZpbmVkKTtcbiAgICBwcm94eVtEUkFGVF9TVEFURV0uaXNNYW51YWwgPSB0cnVlO1xuICAgIHNjb3BlLmxlYXZlKCk7XG4gICAgcmV0dXJuIHByb3h5O1xuICB9O1xuXG4gIEltbWVyLnByb3RvdHlwZS5maW5pc2hEcmFmdCA9IGZ1bmN0aW9uIChkcmFmdCwgcGF0Y2hMaXN0ZW5lcikge1xuICAgIHZhciBzdGF0ZSA9IGRyYWZ0ICYmIGRyYWZ0W0RSQUZUX1NUQVRFXTtcblxuICAgIGlmICghc3RhdGUgfHwgIXN0YXRlLmlzTWFudWFsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaXJzdCBhcmd1bWVudCB0byBgZmluaXNoRHJhZnRgIG11c3QgYmUgYSBkcmFmdCByZXR1cm5lZCBieSBgY3JlYXRlRHJhZnRgXCIpOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuZmluYWxpemVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZ2l2ZW4gZHJhZnQgaXMgYWxyZWFkeSBmaW5hbGl6ZWRcIik7IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIH1cblxuICAgIHZhciBzY29wZSA9IHN0YXRlLnNjb3BlO1xuICAgIHNjb3BlLnVzZVBhdGNoZXMocGF0Y2hMaXN0ZW5lcik7XG4gICAgcmV0dXJuIHByb2Nlc3NSZXN1bHQodGhpcywgdW5kZWZpbmVkLCBzY29wZSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFBhc3MgdHJ1ZSB0byBhdXRvbWF0aWNhbGx5IGZyZWV6ZSBhbGwgY29waWVzIGNyZWF0ZWQgYnkgSW1tZXIuXHJcbiAgICpcclxuICAgKiBCeSBkZWZhdWx0LCBhdXRvLWZyZWV6aW5nIGlzIGRpc2FibGVkIGluIHByb2R1Y3Rpb24uXHJcbiAgICovXG5cblxuICBJbW1lci5wcm90b3R5cGUuc2V0QXV0b0ZyZWV6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuYXV0b0ZyZWV6ZSA9IHZhbHVlO1xuICB9O1xuICAvKipcclxuICAgKiBQYXNzIHRydWUgdG8gdXNlIHRoZSBFUzIwMTUgYFByb3h5YCBjbGFzcyB3aGVuIGNyZWF0aW5nIGRyYWZ0cywgd2hpY2ggaXNcclxuICAgKiBhbHdheXMgZmFzdGVyIHRoYW4gdXNpbmcgRVM1IHByb3hpZXMuXHJcbiAgICpcclxuICAgKiBCeSBkZWZhdWx0LCBmZWF0dXJlIGRldGVjdGlvbiBpcyB1c2VkLCBzbyBjYWxsaW5nIHRoaXMgaXMgcmFyZWx5IG5lY2Vzc2FyeS5cclxuICAgKi9cblxuXG4gIEltbWVyLnByb3RvdHlwZS5zZXRVc2VQcm94aWVzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy51c2VQcm94aWVzID0gdmFsdWU7XG4gIH07XG5cbiAgSW1tZXIucHJvdG90eXBlLmFwcGx5UGF0Y2hlcyA9IGZ1bmN0aW9uIChiYXNlLCBwYXRjaGVzKSB7XG4gICAgLy8gSWYgYSBwYXRjaCByZXBsYWNlcyB0aGUgZW50aXJlIHN0YXRlLCB0YWtlIHRoYXQgcmVwbGFjZW1lbnQgYXMgYmFzZVxuICAgIC8vIGJlZm9yZSBhcHBseWluZyBwYXRjaGVzXG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSBwYXRjaGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuXG4gICAgICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDAgJiYgcGF0Y2gub3AgPT09IFwicmVwbGFjZVwiKSB7XG4gICAgICAgIGJhc2UgPSBwYXRjaC52YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzRHJhZnQoYmFzZSkpIHtcbiAgICAgIC8vIE4uQjogbmV2ZXIgaGl0cyBpZiBzb21lIHBhdGNoIGEgcmVwbGFjZW1lbnQsIHBhdGNoZXMgYXJlIG5ldmVyIGRyYWZ0c1xuICAgICAgcmV0dXJuIGFwcGx5UGF0Y2hlcyhiYXNlLCBwYXRjaGVzKTtcbiAgICB9IC8vIE90aGVyd2lzZSwgcHJvZHVjZSBhIGNvcHkgb2YgdGhlIGJhc2Ugc3RhdGUuXG5cblxuICAgIHJldHVybiB0aGlzLnByb2R1Y2UoYmFzZSwgZnVuY3Rpb24gKGRyYWZ0KSB7XG4gICAgICByZXR1cm4gYXBwbHlQYXRjaGVzKGRyYWZ0LCBwYXRjaGVzLnNsaWNlKGkgKyAxKSk7XG4gICAgfSk7XG4gIH07XG5cbiAgSW1tZXIucHJvdG90eXBlLmNyZWF0ZVByb3h5ID0gZnVuY3Rpb24gKHZhbHVlLCBwYXJlbnQpIHtcbiAgICAvLyBwcmVjb25kaXRpb246IGNyZWF0ZVByb3h5IHNob3VsZCBiZSBndWFyZGVkIGJ5IGlzRHJhZnRhYmxlLCBzbyB3ZSBrbm93IHdlIGNhbiBzYWZlbHkgZHJhZnRcbiAgICB2YXIgZHJhZnQgPSBpc01hcCh2YWx1ZSkgPyBwcm94eU1hcCh2YWx1ZSwgcGFyZW50KSA6IGlzU2V0KHZhbHVlKSA/IHByb3h5U2V0KHZhbHVlLCBwYXJlbnQpIDogdGhpcy51c2VQcm94aWVzID8gY3JlYXRlUHJveHkodmFsdWUsIHBhcmVudCkgOiBjcmVhdGVFUzVQcm94eSh2YWx1ZSwgcGFyZW50KTtcbiAgICB2YXIgc2NvcGUgPSBwYXJlbnQgPyBwYXJlbnQuc2NvcGUgOiBJbW1lclNjb3BlLmN1cnJlbnQ7XG4gICAgc2NvcGUuZHJhZnRzLnB1c2goZHJhZnQpO1xuICAgIHJldHVybiBkcmFmdDtcbiAgfTtcblxuICBJbW1lci5wcm90b3R5cGUud2lsbEZpbmFsaXplID0gZnVuY3Rpb24gKHNjb3BlLCB0aGluZywgaXNSZXBsYWNlZCkge1xuICAgIGlmICghdGhpcy51c2VQcm94aWVzKSB7IHdpbGxGaW5hbGl6ZUVTNShzY29wZSwgdGhpbmcsIGlzUmVwbGFjZWQpOyB9XG4gIH07XG5cbiAgSW1tZXIucHJvdG90eXBlLm1hcmtDaGFuZ2VkID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMudXNlUHJveGllcykge1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXJrQ2hhbmdlZEVTNShzdGF0ZSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBJbW1lcjtcbn0oKTtcblxudmFyIGltbWVyID0gbmV3IEltbWVyKCk7XG4vKipcclxuICogVGhlIGBwcm9kdWNlYCBmdW5jdGlvbiB0YWtlcyBhIHZhbHVlIGFuZCBhIFwicmVjaXBlIGZ1bmN0aW9uXCIgKHdob3NlXHJcbiAqIHJldHVybiB2YWx1ZSBvZnRlbiBkZXBlbmRzIG9uIHRoZSBiYXNlIHN0YXRlKS4gVGhlIHJlY2lwZSBmdW5jdGlvbiBpc1xyXG4gKiBmcmVlIHRvIG11dGF0ZSBpdHMgZmlyc3QgYXJndW1lbnQgaG93ZXZlciBpdCB3YW50cy4gQWxsIG11dGF0aW9ucyBhcmVcclxuICogb25seSBldmVyIGFwcGxpZWQgdG8gYSBfX2NvcHlfXyBvZiB0aGUgYmFzZSBzdGF0ZS5cclxuICpcclxuICogUGFzcyBvbmx5IGEgZnVuY3Rpb24gdG8gY3JlYXRlIGEgXCJjdXJyaWVkIHByb2R1Y2VyXCIgd2hpY2ggcmVsaWV2ZXMgeW91XHJcbiAqIGZyb20gcGFzc2luZyB0aGUgcmVjaXBlIGZ1bmN0aW9uIGV2ZXJ5IHRpbWUuXHJcbiAqXHJcbiAqIE9ubHkgcGxhaW4gb2JqZWN0cyBhbmQgYXJyYXlzIGFyZSBtYWRlIG11dGFibGUuIEFsbCBvdGhlciBvYmplY3RzIGFyZVxyXG4gKiBjb25zaWRlcmVkIHVuY29weWFibGUuXHJcbiAqXHJcbiAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgX19ib3VuZF9fIHRvIGl0cyBgSW1tZXJgIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge2FueX0gYmFzZSAtIHRoZSBpbml0aWFsIHN0YXRlXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByb2R1Y2VyIC0gZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhIHByb3h5IG9mIHRoZSBiYXNlIHN0YXRlIGFzIGZpcnN0IGFyZ3VtZW50IGFuZCB3aGljaCBjYW4gYmUgZnJlZWx5IG1vZGlmaWVkXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBhdGNoTGlzdGVuZXIgLSBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggYWxsIHRoZSBwYXRjaGVzIHByb2R1Y2VkIGhlcmVcclxuICogQHJldHVybnMge2FueX0gYSBuZXcgc3RhdGUsIG9yIHRoZSBpbml0aWFsIHN0YXRlIGlmIG5vdGhpbmcgd2FzIG1vZGlmaWVkXHJcbiAqL1xuXG52YXIgcHJvZHVjZSA9IGltbWVyLnByb2R1Y2U7XG4vKipcclxuICogTGlrZSBgcHJvZHVjZWAsIGJ1dCBgcHJvZHVjZVdpdGhQYXRjaGVzYCBhbHdheXMgcmV0dXJucyBhIHR1cGxlXHJcbiAqIFtuZXh0U3RhdGUsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzXSAoaW5zdGVhZCBvZiBqdXN0IHRoZSBuZXh0IHN0YXRlKVxyXG4gKi9cblxudmFyIHByb2R1Y2VXaXRoUGF0Y2hlcyA9IGltbWVyLnByb2R1Y2VXaXRoUGF0Y2hlcy5iaW5kKGltbWVyKTtcbi8qKlxyXG4gKiBQYXNzIHRydWUgdG8gYXV0b21hdGljYWxseSBmcmVlemUgYWxsIGNvcGllcyBjcmVhdGVkIGJ5IEltbWVyLlxyXG4gKlxyXG4gKiBCeSBkZWZhdWx0LCBhdXRvLWZyZWV6aW5nIGlzIGRpc2FibGVkIGluIHByb2R1Y3Rpb24uXHJcbiAqL1xuXG52YXIgc2V0QXV0b0ZyZWV6ZSA9IGltbWVyLnNldEF1dG9GcmVlemUuYmluZChpbW1lcik7XG4vKipcclxuICogUGFzcyB0cnVlIHRvIHVzZSB0aGUgRVMyMDE1IGBQcm94eWAgY2xhc3Mgd2hlbiBjcmVhdGluZyBkcmFmdHMsIHdoaWNoIGlzXHJcbiAqIGFsd2F5cyBmYXN0ZXIgdGhhbiB1c2luZyBFUzUgcHJveGllcy5cclxuICpcclxuICogQnkgZGVmYXVsdCwgZmVhdHVyZSBkZXRlY3Rpb24gaXMgdXNlZCwgc28gY2FsbGluZyB0aGlzIGlzIHJhcmVseSBuZWNlc3NhcnkuXHJcbiAqL1xuXG52YXIgc2V0VXNlUHJveGllcyA9IGltbWVyLnNldFVzZVByb3hpZXMuYmluZChpbW1lcik7XG4vKipcclxuICogQXBwbHkgYW4gYXJyYXkgb2YgSW1tZXIgcGF0Y2hlcyB0byB0aGUgZmlyc3QgYXJndW1lbnQuXHJcbiAqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSBwcm9kdWNlciwgd2hpY2ggbWVhbnMgY29weS1vbi13cml0ZSBpcyBpbiBlZmZlY3QuXHJcbiAqL1xuXG52YXIgYXBwbHlQYXRjaGVzJDEgPSBpbW1lci5hcHBseVBhdGNoZXMuYmluZChpbW1lcik7XG4vKipcclxuICogQ3JlYXRlIGFuIEltbWVyIGRyYWZ0IGZyb20gdGhlIGdpdmVuIGJhc2Ugc3RhdGUsIHdoaWNoIG1heSBiZSBhIGRyYWZ0IGl0c2VsZi5cclxuICogVGhlIGRyYWZ0IGNhbiBiZSBtb2RpZmllZCB1bnRpbCB5b3UgZmluYWxpemUgaXQgd2l0aCB0aGUgYGZpbmlzaERyYWZ0YCBmdW5jdGlvbi5cclxuICovXG5cbnZhciBjcmVhdGVEcmFmdCA9IGltbWVyLmNyZWF0ZURyYWZ0LmJpbmQoaW1tZXIpO1xuLyoqXHJcbiAqIEZpbmFsaXplIGFuIEltbWVyIGRyYWZ0IGZyb20gYSBgY3JlYXRlRHJhZnRgIGNhbGwsIHJldHVybmluZyB0aGUgYmFzZSBzdGF0ZVxyXG4gKiAoaWYgbm8gY2hhbmdlcyB3ZXJlIG1hZGUpIG9yIGEgbW9kaWZpZWQgY29weS4gVGhlIGRyYWZ0IG11c3QgKm5vdCogYmVcclxuICogbXV0YXRlZCBhZnRlcndhcmRzLlxyXG4gKlxyXG4gKiBQYXNzIGEgZnVuY3Rpb24gYXMgdGhlIDJuZCBhcmd1bWVudCB0byBnZW5lcmF0ZSBJbW1lciBwYXRjaGVzIGJhc2VkIG9uIHRoZVxyXG4gKiBjaGFuZ2VzIHRoYXQgd2VyZSBtYWRlLlxyXG4gKi9cblxudmFyIGZpbmlzaERyYWZ0ID0gaW1tZXIuZmluaXNoRHJhZnQuYmluZChpbW1lcik7XG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBpcyBhY3R1YWxseSBhIG5vLW9wLCBidXQgY2FuIGJlIHVzZWQgdG8gY2FzdCBhbiBpbW11dGFibGUgdHlwZVxyXG4gKiB0byBhbiBkcmFmdCB0eXBlIGFuZCBtYWtlIFR5cGVTY3JpcHQgaGFwcHlcclxuICpcclxuICogQHBhcmFtIHZhbHVlXHJcbiAqL1xuXG5mdW5jdGlvbiBjYXN0RHJhZnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYWN0dWFsbHkgYSBuby1vcCwgYnV0IGNhbiBiZSB1c2VkIHRvIGNhc3QgYSBtdXRhYmxlIHR5cGVcclxuICogdG8gYW4gaW1tdXRhYmxlIHR5cGUgYW5kIG1ha2UgVHlwZVNjcmlwdCBoYXBweVxyXG4gKiBAcGFyYW0gdmFsdWVcclxuICovXG5cbmZ1bmN0aW9uIGNhc3RJbW11dGFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcm9kdWNlO1xuZXhwb3J0IHsgSW1tZXIsIGFwcGx5UGF0Y2hlcyQxIGFzIGFwcGx5UGF0Y2hlcywgY2FzdERyYWZ0LCBjYXN0SW1tdXRhYmxlLCBjcmVhdGVEcmFmdCwgZmluaXNoRHJhZnQsIERSQUZUQUJMRSBhcyBpbW1lcmFibGUsIGlzRHJhZnQsIGlzRHJhZnRhYmxlLCBOT1RISU5HIGFzIG5vdGhpbmcsIG9yaWdpbmFsLCBwcm9kdWNlLCBwcm9kdWNlV2l0aFBhdGNoZXMsIHNldEF1dG9GcmVlemUsIHNldFVzZVByb3hpZXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltbWVyLm1vZHVsZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBDb25zdGFudHMuXG4gKi9cblxudmFyIElTX01BQyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgL01hY3xpUG9kfGlQaG9uZXxpUGFkLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0pO1xuXG52YXIgTU9ESUZJRVJTID0ge1xuICBhbHQ6ICdhbHRLZXknLFxuICBjb250cm9sOiAnY3RybEtleScsXG4gIG1ldGE6ICdtZXRhS2V5JyxcbiAgc2hpZnQ6ICdzaGlmdEtleSdcbn07XG5cbnZhciBBTElBU0VTID0ge1xuICBhZGQ6ICcrJyxcbiAgYnJlYWs6ICdwYXVzZScsXG4gIGNtZDogJ21ldGEnLFxuICBjb21tYW5kOiAnbWV0YScsXG4gIGN0bDogJ2NvbnRyb2wnLFxuICBjdHJsOiAnY29udHJvbCcsXG4gIGRlbDogJ2RlbGV0ZScsXG4gIGRvd246ICdhcnJvd2Rvd24nLFxuICBlc2M6ICdlc2NhcGUnLFxuICBpbnM6ICdpbnNlcnQnLFxuICBsZWZ0OiAnYXJyb3dsZWZ0JyxcbiAgbW9kOiBJU19NQUMgPyAnbWV0YScgOiAnY29udHJvbCcsXG4gIG9wdDogJ2FsdCcsXG4gIG9wdGlvbjogJ2FsdCcsXG4gIHJldHVybjogJ2VudGVyJyxcbiAgcmlnaHQ6ICdhcnJvd3JpZ2h0JyxcbiAgc3BhY2U6ICcgJyxcbiAgc3BhY2ViYXI6ICcgJyxcbiAgdXA6ICdhcnJvd3VwJyxcbiAgd2luOiAnbWV0YScsXG4gIHdpbmRvd3M6ICdtZXRhJ1xufTtcblxudmFyIENPREVTID0ge1xuICBiYWNrc3BhY2U6IDgsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzaGlmdDogMTYsXG4gIGNvbnRyb2w6IDE3LFxuICBhbHQ6IDE4LFxuICBwYXVzZTogMTksXG4gIGNhcHNsb2NrOiAyMCxcbiAgZXNjYXBlOiAyNyxcbiAgJyAnOiAzMixcbiAgcGFnZXVwOiAzMyxcbiAgcGFnZWRvd246IDM0LFxuICBlbmQ6IDM1LFxuICBob21lOiAzNixcbiAgYXJyb3dsZWZ0OiAzNyxcbiAgYXJyb3d1cDogMzgsXG4gIGFycm93cmlnaHQ6IDM5LFxuICBhcnJvd2Rvd246IDQwLFxuICBpbnNlcnQ6IDQ1LFxuICBkZWxldGU6IDQ2LFxuICBtZXRhOiA5MSxcbiAgbnVtbG9jazogMTQ0LFxuICBzY3JvbGxsb2NrOiAxNDUsXG4gICc7JzogMTg2LFxuICAnPSc6IDE4NyxcbiAgJywnOiAxODgsXG4gICctJzogMTg5LFxuICAnLic6IDE5MCxcbiAgJy8nOiAxOTEsXG4gICdgJzogMTkyLFxuICAnWyc6IDIxOSxcbiAgJ1xcXFwnOiAyMjAsXG4gICddJzogMjIxLFxuICAnXFwnJzogMjIyXG59O1xuXG5mb3IgKHZhciBmID0gMTsgZiA8IDIwOyBmKyspIHtcbiAgQ09ERVNbJ2YnICsgZl0gPSAxMTEgKyBmO1xufVxuXG4vKipcbiAqIElzIGhvdGtleT9cbiAqL1xuXG5mdW5jdGlvbiBpc0hvdGtleShob3RrZXksIG9wdGlvbnMsIGV2ZW50KSB7XG4gIGlmIChvcHRpb25zICYmICEoJ2J5S2V5JyBpbiBvcHRpb25zKSkge1xuICAgIGV2ZW50ID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShob3RrZXkpKSB7XG4gICAgaG90a2V5ID0gW2hvdGtleV07XG4gIH1cblxuICB2YXIgYXJyYXkgPSBob3RrZXkubWFwKGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICByZXR1cm4gcGFyc2VIb3RrZXkoc3RyaW5nLCBvcHRpb25zKTtcbiAgfSk7XG4gIHZhciBjaGVjayA9IGZ1bmN0aW9uIGNoZWNrKGUpIHtcbiAgICByZXR1cm4gYXJyYXkuc29tZShmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICByZXR1cm4gY29tcGFyZUhvdGtleShvYmplY3QsIGUpO1xuICAgIH0pO1xuICB9O1xuICB2YXIgcmV0ID0gZXZlbnQgPT0gbnVsbCA/IGNoZWNrIDogY2hlY2soZXZlbnQpO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpc0NvZGVIb3RrZXkoaG90a2V5LCBldmVudCkge1xuICByZXR1cm4gaXNIb3RrZXkoaG90a2V5LCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIGlzS2V5SG90a2V5KGhvdGtleSwgZXZlbnQpIHtcbiAgcmV0dXJuIGlzSG90a2V5KGhvdGtleSwgeyBieUtleTogdHJ1ZSB9LCBldmVudCk7XG59XG5cbi8qKlxuICogUGFyc2UuXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VIb3RrZXkoaG90a2V5LCBvcHRpb25zKSB7XG4gIHZhciBieUtleSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5ieUtleTtcbiAgdmFyIHJldCA9IHt9O1xuXG4gIC8vIFNwZWNpYWwgY2FzZSB0byBoYW5kbGUgdGhlIGArYCBrZXkgc2luY2Ugd2UgdXNlIGl0IGFzIGEgc2VwYXJhdG9yLlxuICBob3RrZXkgPSBob3RrZXkucmVwbGFjZSgnKysnLCAnK2FkZCcpO1xuICB2YXIgdmFsdWVzID0gaG90a2V5LnNwbGl0KCcrJyk7XG4gIHZhciBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIC8vIEVuc3VyZSB0aGF0IGFsbCB0aGUgbW9kaWZpZXJzIGFyZSBzZXQgdG8gZmFsc2UgdW5sZXNzIHRoZSBob3RrZXkgaGFzIHRoZW0uXG5cbiAgZm9yICh2YXIgayBpbiBNT0RJRklFUlMpIHtcbiAgICByZXRbTU9ESUZJRVJTW2tdXSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdmFsdWVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgdmFyIHZhbHVlID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIHZhciBvcHRpb25hbCA9IHZhbHVlLmVuZHNXaXRoKCc/JykgJiYgdmFsdWUubGVuZ3RoID4gMTtcblxuICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IHRvS2V5TmFtZSh2YWx1ZSk7XG4gICAgICB2YXIgbW9kaWZpZXIgPSBNT0RJRklFUlNbbmFtZV07XG5cbiAgICAgIGlmIChsZW5ndGggPT09IDEgfHwgIW1vZGlmaWVyKSB7XG4gICAgICAgIGlmIChieUtleSkge1xuICAgICAgICAgIHJldC5rZXkgPSBuYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldC53aGljaCA9IHRvS2V5Q29kZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGlmaWVyKSB7XG4gICAgICAgIHJldFttb2RpZmllcl0gPSBvcHRpb25hbCA/IG51bGwgOiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIENvbXBhcmUuXG4gKi9cblxuZnVuY3Rpb24gY29tcGFyZUhvdGtleShvYmplY3QsIGV2ZW50KSB7XG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICB2YXIgZXhwZWN0ZWQgPSBvYmplY3Rba2V5XTtcbiAgICB2YXIgYWN0dWFsID0gdm9pZCAwO1xuXG4gICAgaWYgKGV4cGVjdGVkID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICdrZXknICYmIGV2ZW50LmtleSAhPSBudWxsKSB7XG4gICAgICBhY3R1YWwgPSBldmVudC5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3doaWNoJykge1xuICAgICAgYWN0dWFsID0gZXhwZWN0ZWQgPT09IDkxICYmIGV2ZW50LndoaWNoID09PSA5MyA/IDkxIDogZXZlbnQud2hpY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjdHVhbCA9IGV2ZW50W2tleV07XG4gICAgfVxuXG4gICAgaWYgKGFjdHVhbCA9PSBudWxsICYmIGV4cGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBVdGlscy5cbiAqL1xuXG5mdW5jdGlvbiB0b0tleUNvZGUobmFtZSkge1xuICBuYW1lID0gdG9LZXlOYW1lKG5hbWUpO1xuICB2YXIgY29kZSA9IENPREVTW25hbWVdIHx8IG5hbWUudG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gY29kZTtcbn1cblxuZnVuY3Rpb24gdG9LZXlOYW1lKG5hbWUpIHtcbiAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgbmFtZSA9IEFMSUFTRVNbbmFtZV0gfHwgbmFtZTtcbiAgcmV0dXJuIG5hbWU7XG59XG5cbi8qKlxuICogRXhwb3J0LlxuICovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IGlzSG90a2V5O1xuZXhwb3J0cy5pc0hvdGtleSA9IGlzSG90a2V5O1xuZXhwb3J0cy5pc0NvZGVIb3RrZXkgPSBpc0NvZGVIb3RrZXk7XG5leHBvcnRzLmlzS2V5SG90a2V5ID0gaXNLZXlIb3RrZXk7XG5leHBvcnRzLnBhcnNlSG90a2V5ID0gcGFyc2VIb3RrZXk7XG5leHBvcnRzLmNvbXBhcmVIb3RrZXkgPSBjb21wYXJlSG90a2V5O1xuZXhwb3J0cy50b0tleUNvZGUgPSB0b0tleUNvZGU7XG5leHBvcnRzLnRvS2V5TmFtZSA9IHRvS2V5TmFtZTsiLCJcbi8qKlxuICogRXhwb3NlIGBpc1VybGAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBpc1VybDtcblxuLyoqXG4gKiBSZWdFeHBzLlxuICogQSBVUkwgbXVzdCBtYXRjaCAjMSBhbmQgdGhlbiBhdCBsZWFzdCBvbmUgb2YgIzIvIzMuXG4gKiBVc2UgdHdvIGxldmVscyBvZiBSRXMgdG8gYXZvaWQgUkVET1MuXG4gKi9cblxudmFyIHByb3RvY29sQW5kRG9tYWluUkUgPSAvXig/Olxcdys6KT9cXC9cXC8oXFxTKykkLztcblxudmFyIGxvY2FsaG9zdERvbWFpblJFID0gL15sb2NhbGhvc3RbXFw6P1xcZF0qKD86W15cXDo/XFxkXVxcUyopPyQvXG52YXIgbm9uTG9jYWxob3N0RG9tYWluUkUgPSAvXlteXFxzXFwuXStcXC5cXFN7Mix9JC87XG5cbi8qKlxuICogTG9vc2VseSB2YWxpZGF0ZSBhIFVSTCBgc3RyaW5nYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzVXJsKHN0cmluZyl7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaChwcm90b2NvbEFuZERvbWFpblJFKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVyeXRoaW5nQWZ0ZXJQcm90b2NvbCA9IG1hdGNoWzFdO1xuICBpZiAoIWV2ZXJ5dGhpbmdBZnRlclByb3RvY29sKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGxvY2FsaG9zdERvbWFpblJFLnRlc3QoZXZlcnl0aGluZ0FmdGVyUHJvdG9jb2wpIHx8XG4gICAgICBub25Mb2NhbGhvc3REb21haW5SRS50ZXN0KGV2ZXJ5dGhpbmdBZnRlclByb3RvY29sKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBub3cgPSByZXF1aXJlKCcuL25vdycpLFxuICAgIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgdGltZVdhaXRpbmcgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICByZXR1cm4gbWF4aW5nXG4gICAgICA/IG5hdGl2ZU1pbih0aW1lV2FpdGluZywgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpXG4gICAgICA6IHRpbWVXYWl0aW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgfVxuICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICB9XG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICB9XG4gICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJvdW5jZTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3ltYm9sO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbm93O1xuIiwidmFyIGRlYm91bmNlID0gcmVxdWlyZSgnLi9kZWJvdW5jZScpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgXG4gKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvXG4gKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGBcbiAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGVcbiAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwgeyAndHJhaWxpbmcnOiBmYWxzZSB9KTtcbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgdGhyb3R0bGVkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cbiAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHtcbiAgICAnbGVhZGluZyc6IGxlYWRpbmcsXG4gICAgJ21heFdhaXQnOiB3YWl0LFxuICAgICd0cmFpbGluZyc6IHRyYWlsaW5nXG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRocm90dGxlO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9OdW1iZXI7XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiaW1wb3J0IGNvbXB1dGUgZnJvbSAnY29tcHV0ZS1zY3JvbGwtaW50by12aWV3JztcblxuZnVuY3Rpb24gaXNPcHRpb25zT2JqZWN0KG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMgPT09IE9iamVjdChvcHRpb25zKSAmJiBPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGggIT09IDA7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRCZWhhdmlvcihhY3Rpb25zLCBiZWhhdmlvcikge1xuICBpZiAoYmVoYXZpb3IgPT09IHZvaWQgMCkge1xuICAgIGJlaGF2aW9yID0gJ2F1dG8nO1xuICB9XG5cbiAgdmFyIGNhblNtb290aFNjcm9sbCA9ICgnc2Nyb2xsQmVoYXZpb3InIGluIGRvY3VtZW50LmJvZHkuc3R5bGUpO1xuICBhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgZWwgPSBfcmVmLmVsLFxuICAgICAgICB0b3AgPSBfcmVmLnRvcCxcbiAgICAgICAgbGVmdCA9IF9yZWYubGVmdDtcblxuICAgIGlmIChlbC5zY3JvbGwgJiYgY2FuU21vb3RoU2Nyb2xsKSB7XG4gICAgICBlbC5zY3JvbGwoe1xuICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgYmVoYXZpb3I6IGJlaGF2aW9yXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2Nyb2xsVG9wID0gdG9wO1xuICAgICAgZWwuc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgIHJldHVybiB7XG4gICAgICBibG9jazogJ2VuZCcsXG4gICAgICBpbmxpbmU6ICduZWFyZXN0J1xuICAgIH07XG4gIH1cblxuICBpZiAoaXNPcHRpb25zT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJsb2NrOiAnc3RhcnQnLFxuICAgIGlubGluZTogJ25lYXJlc3QnXG4gIH07XG59XG5cbmZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KHRhcmdldCwgb3B0aW9ucykge1xuICB2YXIgdGFyZ2V0SXNEZXRhY2hlZCA9ICF0YXJnZXQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnModGFyZ2V0KTtcblxuICBpZiAoaXNPcHRpb25zT2JqZWN0KG9wdGlvbnMpICYmIHR5cGVvZiBvcHRpb25zLmJlaGF2aW9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuYmVoYXZpb3IodGFyZ2V0SXNEZXRhY2hlZCA/IFtdIDogY29tcHV0ZSh0YXJnZXQsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIGlmICh0YXJnZXRJc0RldGFjaGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbXB1dGVPcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgcmV0dXJuIGRlZmF1bHRCZWhhdmlvcihjb21wdXRlKHRhcmdldCwgY29tcHV0ZU9wdGlvbnMpLCBjb21wdXRlT3B0aW9ucy5iZWhhdmlvcik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNjcm9sbEludG9WaWV3OyIsImltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlTWVtbywgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBFZGl0b3IsIFRyYW5zZm9ybXMsIFJhbmdlLCBQYXRoLCBOb2RlIGFzIE5vZGUkMSwgVGV4dCBhcyBUZXh0JDEsIEVsZW1lbnQgYXMgRWxlbWVudCQxIH0gZnJvbSAnc2xhdGUnO1xuaW1wb3J0IHRocm90dGxlIGZyb20gJ2xvZGFzaC90aHJvdHRsZSc7XG5pbXBvcnQgc2Nyb2xsSW50b1ZpZXcgZnJvbSAnc2Nyb2xsLWludG8tdmlldy1pZi1uZWVkZWQnO1xuaW1wb3J0IGdldERpcmVjdGlvbiBmcm9tICdkaXJlY3Rpb24nO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBpc0tleUhvdGtleSB9IGZyb20gJ2lzLWhvdGtleSc7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXHJcbiAqIEFuIGF1dG8taW5jcmVtZW50aW5nIGlkZW50aWZpZXIgZm9yIGtleXMuXHJcbiAqL1xudmFyIG4gPSAwO1xuLyoqXHJcbiAqIEEgY2xhc3MgdGhhdCBrZWVwcyB0cmFjayBvZiBhIGtleSBzdHJpbmcuIFdlIHVzZSBhIGZ1bGwgY2xhc3MgaGVyZSBiZWNhdXNlIHdlXHJcbiAqIHdhbnQgdG8gYmUgYWJsZSB0byB1c2UgdGhlbSBhcyBrZXlzIGluIGBXZWFrTWFwYCBvYmplY3RzLlxyXG4gKi9cblxuY2xhc3MgS2V5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pZCA9IFwiXCIuY29uY2F0KG4rKyk7XG4gIH1cblxufVxuXG4vKipcclxuICogVHdvIHdlYWsgbWFwcyB0aGF0IGFsbG93IHVzIHJlYnVpbGQgYSBwYXRoIGdpdmVuIGEgbm9kZS4gVGhleSBhcmUgcG9wdWxhdGVkXHJcbiAqIGF0IHJlbmRlciB0aW1lIHN1Y2ggdGhhdCBhZnRlciBhIHJlbmRlciBvY2N1cnMgd2UgY2FuIGFsd2F5cyBiYWNrdHJhY2suXHJcbiAqL1xudmFyIE5PREVfVE9fSU5ERVggPSBuZXcgV2Vha01hcCgpO1xudmFyIE5PREVfVE9fUEFSRU5UID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxyXG4gKiBXZWFrIG1hcHMgdGhhdCBhbGxvdyB1cyB0byBnbyBiZXR3ZWVuIFNsYXRlIG5vZGVzIGFuZCBET00gbm9kZXMuIFRoZXNlXHJcbiAqIGFyZSB1c2VkIHRvIHJlc29sdmUgRE9NIGV2ZW50LXJlbGF0ZWQgbG9naWMgaW50byBTbGF0ZSBhY3Rpb25zLlxyXG4gKi9cblxudmFyIEVESVRPUl9UT19FTEVNRU5UID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFTEVNRU5UX1RPX05PREUgPSBuZXcgV2Vha01hcCgpO1xudmFyIEtFWV9UT19FTEVNRU5UID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT0RFX1RPX0VMRU1FTlQgPSBuZXcgV2Vha01hcCgpO1xudmFyIE5PREVfVE9fS0VZID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxyXG4gKiBXZWFrIG1hcHMgZm9yIHN0b3JpbmcgZWRpdG9yLXJlbGF0ZWQgc3RhdGUuXHJcbiAqL1xuXG52YXIgSVNfUkVBRF9PTkxZID0gbmV3IFdlYWtNYXAoKTtcbnZhciBJU19GT0NVU0VEID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxyXG4gKiBXZWFrIG1hcCBmb3IgYXNzb2NpYXRpbmcgdGhlIGNvbnRleHQgYG9uQ2hhbmdlYCBjb250ZXh0IHdpdGggdGhlIHBsdWdpbi5cclxuICovXG5cbnZhciBFRElUT1JfVE9fT05fQ0hBTkdFID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxyXG4gKiBTeW1ib2xzLlxyXG4gKi9cblxudmFyIFBMQUNFSE9MREVSX1NZTUJPTCA9IFN5bWJvbCgncGxhY2Vob2xkZXInKTtcblxuLyoqXHJcbiAqIFR5cGVzLlxyXG4gKi9cbi8qKlxyXG4gKiBDaGVjayBpZiBhIERPTSBub2RlIGlzIGEgY29tbWVudCBub2RlLlxyXG4gKi9cblxudmFyIGlzRE9NQ29tbWVudCA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIGlzRE9NTm9kZSh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDg7XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIGEgRE9NIG5vZGUgaXMgYW4gZWxlbWVudCBub2RlLlxyXG4gKi9cblxudmFyIGlzRE9NRWxlbWVudCA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIGlzRE9NTm9kZSh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDE7XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBET00gbm9kZS5cclxuICovXG5cbnZhciBpc0RPTU5vZGUgPSB2YWx1ZSA9PiB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE5vZGU7XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIGEgRE9NIG5vZGUgaXMgYW4gZWxlbWVudCBub2RlLlxyXG4gKi9cblxudmFyIGlzRE9NVGV4dCA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIGlzRE9NTm9kZSh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDM7XG59O1xuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIGEgcGFzdGUgZXZlbnQgaXMgYSBwbGFpbnRleHQtb25seSBldmVudC5cclxuICovXG5cbnZhciBpc1BsYWluVGV4dE9ubHlQYXN0ZSA9IGV2ZW50ID0+IHtcbiAgcmV0dXJuIGV2ZW50LmNsaXBib2FyZERhdGEgJiYgZXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJykgIT09ICcnICYmIGV2ZW50LmNsaXBib2FyZERhdGEudHlwZXMubGVuZ3RoID09PSAxO1xufTtcbi8qKlxyXG4gKiBOb3JtYWxpemUgYSBET00gcG9pbnQgc28gdGhhdCBpdCBhbHdheXMgcmVmZXJzIHRvIGEgdGV4dCBub2RlLlxyXG4gKi9cblxudmFyIG5vcm1hbGl6ZURPTVBvaW50ID0gZG9tUG9pbnQgPT4ge1xuICB2YXIgW25vZGUsIG9mZnNldF0gPSBkb21Qb2ludDsgLy8gSWYgaXQncyBhbiBlbGVtZW50IG5vZGUsIGl0cyBvZmZzZXQgcmVmZXJzIHRvIHRoZSBpbmRleCBvZiBpdHMgY2hpbGRyZW5cbiAgLy8gaW5jbHVkaW5nIGNvbW1lbnQgbm9kZXMsIHNvIHRyeSB0byBmaW5kIHRoZSByaWdodCB0ZXh0IGNoaWxkIG5vZGUuXG5cbiAgaWYgKGlzRE9NRWxlbWVudChub2RlKSAmJiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgdmFyIGlzTGFzdCA9IG9mZnNldCA9PT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICB2YXIgZGlyZWN0aW9uID0gaXNMYXN0ID8gJ2JhY2t3YXJkJyA6ICdmb3J3YXJkJztcbiAgICB2YXIgaW5kZXggPSBpc0xhc3QgPyBvZmZzZXQgLSAxIDogb2Zmc2V0O1xuICAgIG5vZGUgPSBnZXRFZGl0YWJsZUNoaWxkKG5vZGUsIGluZGV4LCBkaXJlY3Rpb24pOyAvLyBJZiB0aGUgbm9kZSBoYXMgY2hpbGRyZW4sIHRyYXZlcnNlIHVudGlsIHdlIGhhdmUgYSBsZWFmIG5vZGUuIExlYWYgbm9kZXNcbiAgICAvLyBjYW4gYmUgZWl0aGVyIHRleHQgbm9kZXMsIG9yIG90aGVyIHZvaWQgRE9NIG5vZGVzLlxuXG4gICAgd2hpbGUgKGlzRE9NRWxlbWVudChub2RlKSAmJiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgaSA9IGlzTGFzdCA/IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggLSAxIDogMDtcbiAgICAgIG5vZGUgPSBnZXRFZGl0YWJsZUNoaWxkKG5vZGUsIGksIGRpcmVjdGlvbik7XG4gICAgfSAvLyBEZXRlcm1pbmUgdGhlIG5ldyBvZmZzZXQgaW5zaWRlIHRoZSB0ZXh0IG5vZGUuXG5cblxuICAgIG9mZnNldCA9IGlzTGFzdCAmJiBub2RlLnRleHRDb250ZW50ICE9IG51bGwgPyBub2RlLnRleHRDb250ZW50Lmxlbmd0aCA6IDA7XG4gIH0gLy8gUmV0dXJuIHRoZSBub2RlIGFuZCBvZmZzZXQuXG5cblxuICByZXR1cm4gW25vZGUsIG9mZnNldF07XG59O1xuLyoqXHJcbiAqIEdldCB0aGUgbmVhcmVzdCBlZGl0YWJsZSBjaGlsZCBhdCBgaW5kZXhgIGluIGEgYHBhcmVudGAsIHByZWZlcnJpbmdcclxuICogYGRpcmVjdGlvbmAuXHJcbiAqL1xuXG52YXIgZ2V0RWRpdGFibGVDaGlsZCA9IChwYXJlbnQsIGluZGV4LCBkaXJlY3Rpb24pID0+IHtcbiAgdmFyIHtcbiAgICBjaGlsZE5vZGVzXG4gIH0gPSBwYXJlbnQ7XG4gIHZhciBjaGlsZCA9IGNoaWxkTm9kZXNbaW5kZXhdO1xuICB2YXIgaSA9IGluZGV4O1xuICB2YXIgdHJpZWRGb3J3YXJkID0gZmFsc2U7XG4gIHZhciB0cmllZEJhY2t3YXJkID0gZmFsc2U7IC8vIFdoaWxlIHRoZSBjaGlsZCBpcyBhIGNvbW1lbnQgbm9kZSwgb3IgYW4gZWxlbWVudCBub2RlIHdpdGggbm8gY2hpbGRyZW4sXG4gIC8vIGtlZXAgaXRlcmF0aW5nIHRvIGZpbmQgYSBzaWJsaW5nIG5vbi12b2lkLCBub24tY29tbWVudCBub2RlLlxuXG4gIHdoaWxlIChpc0RPTUNvbW1lbnQoY2hpbGQpIHx8IGlzRE9NRWxlbWVudChjaGlsZCkgJiYgY2hpbGQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDAgfHwgaXNET01FbGVtZW50KGNoaWxkKSAmJiBjaGlsZC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpID09PSAnZmFsc2UnKSB7XG4gICAgaWYgKHRyaWVkRm9yd2FyZCAmJiB0cmllZEJhY2t3YXJkKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaSA+PSBjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgdHJpZWRGb3J3YXJkID0gdHJ1ZTtcbiAgICAgIGkgPSBpbmRleCAtIDE7XG4gICAgICBkaXJlY3Rpb24gPSAnYmFja3dhcmQnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICB0cmllZEJhY2t3YXJkID0gdHJ1ZTtcbiAgICAgIGkgPSBpbmRleCArIDE7XG4gICAgICBkaXJlY3Rpb24gPSAnZm9yd2FyZCc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjaGlsZCA9IGNoaWxkTm9kZXNbaV07XG4gICAgaSArPSBkaXJlY3Rpb24gPT09ICdmb3J3YXJkJyA/IDEgOiAtMTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZDtcbn07XG4vKipcclxuICogR2V0IGEgcGxhaW50ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb250ZW50IG9mIGEgbm9kZSwgYWNjb3VudGluZyBmb3IgYmxvY2tcclxuICogZWxlbWVudHMgd2hpY2ggZ2V0IGEgbmV3bGluZSBhcHBlbmRlZC5cclxuICpcclxuICogVGhlIGRvbU5vZGUgbXVzdCBiZSBhdHRhY2hlZCB0byB0aGUgRE9NLlxyXG4gKi9cblxudmFyIGdldFBsYWluVGV4dCA9IGRvbU5vZGUgPT4ge1xuICB2YXIgdGV4dCA9ICcnO1xuXG4gIGlmIChpc0RPTVRleHQoZG9tTm9kZSkgJiYgZG9tTm9kZS5ub2RlVmFsdWUpIHtcbiAgICByZXR1cm4gZG9tTm9kZS5ub2RlVmFsdWU7XG4gIH1cblxuICBpZiAoaXNET01FbGVtZW50KGRvbU5vZGUpKSB7XG4gICAgZm9yICh2YXIgY2hpbGROb2RlIG9mIEFycmF5LmZyb20oZG9tTm9kZS5jaGlsZE5vZGVzKSkge1xuICAgICAgdGV4dCArPSBnZXRQbGFpblRleHQoY2hpbGROb2RlKTtcbiAgICB9XG5cbiAgICB2YXIgZGlzcGxheSA9IGdldENvbXB1dGVkU3R5bGUoZG9tTm9kZSkuZ2V0UHJvcGVydHlWYWx1ZSgnZGlzcGxheScpO1xuXG4gICAgaWYgKGRpc3BsYXkgPT09ICdibG9jaycgfHwgZGlzcGxheSA9PT0gJ2xpc3QnIHx8IGRvbU5vZGUudGFnTmFtZSA9PT0gJ0JSJykge1xuICAgICAgdGV4dCArPSAnXFxuJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGV4dDtcbn07XG5cbnZhciBSZWFjdEVkaXRvciA9IHtcbiAgLyoqXHJcbiAgICogRmluZCBhIGtleSBmb3IgYSBTbGF0ZSBub2RlLlxyXG4gICAqL1xuICBmaW5kS2V5KGVkaXRvciwgbm9kZSkge1xuICAgIHZhciBrZXkgPSBOT0RFX1RPX0tFWS5nZXQobm9kZSk7XG5cbiAgICBpZiAoIWtleSkge1xuICAgICAga2V5ID0gbmV3IEtleSgpO1xuICAgICAgTk9ERV9UT19LRVkuc2V0KG5vZGUsIGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleTtcbiAgfSxcblxuICAvKipcclxuICAgKiBGaW5kIHRoZSBwYXRoIG9mIFNsYXRlIG5vZGUuXHJcbiAgICovXG4gIGZpbmRQYXRoKGVkaXRvciwgbm9kZSkge1xuICAgIHZhciBwYXRoID0gW107XG4gICAgdmFyIGNoaWxkID0gbm9kZTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgcGFyZW50ID0gTk9ERV9UT19QQVJFTlQuZ2V0KGNoaWxkKTtcblxuICAgICAgaWYgKHBhcmVudCA9PSBudWxsKSB7XG4gICAgICAgIGlmIChFZGl0b3IuaXNFZGl0b3IoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGkgPSBOT0RFX1RPX0lOREVYLmdldChjaGlsZCk7XG5cbiAgICAgIGlmIChpID09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHBhdGgudW5zaGlmdChpKTtcbiAgICAgIGNoaWxkID0gcGFyZW50O1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIHRoZSBwYXRoIGZvciBTbGF0ZSBub2RlOiBcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkobm9kZSkpKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgZWRpdG9yIGlzIGZvY3VzZWQuXHJcbiAgICovXG4gIGlzRm9jdXNlZChlZGl0b3IpIHtcbiAgICByZXR1cm4gISFJU19GT0NVU0VELmdldChlZGl0b3IpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSBlZGl0b3IgaXMgaW4gcmVhZC1vbmx5IG1vZGUuXHJcbiAgICovXG4gIGlzUmVhZE9ubHkoZWRpdG9yKSB7XG4gICAgcmV0dXJuICEhSVNfUkVBRF9PTkxZLmdldChlZGl0b3IpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEJsdXIgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgYmx1cihlZGl0b3IpIHtcbiAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgIElTX0ZPQ1VTRUQuc2V0KGVkaXRvciwgZmFsc2UpO1xuXG4gICAgaWYgKHdpbmRvdy5kb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbCkge1xuICAgICAgZWwuYmx1cigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBGb2N1cyB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBmb2N1cyhlZGl0b3IpIHtcbiAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgIElTX0ZPQ1VTRUQuc2V0KGVkaXRvciwgdHJ1ZSk7XG5cbiAgICBpZiAod2luZG93LmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsKSB7XG4gICAgICBlbC5mb2N1cyh7XG4gICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBEZXNlbGVjdCB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBkZXNlbGVjdChlZGl0b3IpIHtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICB2YXIgZG9tU2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKGRvbVNlbGVjdGlvbiAmJiBkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCA+IDApIHtcbiAgICAgIGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgRE9NIG5vZGUgaXMgd2l0aGluIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIGhhc0RPTU5vZGUoZWRpdG9yLCB0YXJnZXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGVkaXRhYmxlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgZWRpdG9yRWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgIHZhciB0YXJnZXRFbDsgLy8gQ09NUEFUOiBJbiBGaXJlZm94LCByZWFkaW5nIGB0YXJnZXQubm9kZVR5cGVgIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWZcbiAgICAvLyB0YXJnZXQgaXMgb3JpZ2luYXRpbmcgZnJvbSBhbiBpbnRlcm5hbCBcInJlc3RyaWN0ZWRcIiBlbGVtZW50IChlLmcuIGFcbiAgICAvLyBzdGVwcGVyIGFycm93IG9uIGEgbnVtYmVyIGlucHV0KS4gKDIwMTgvMDUvMDQpXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2lhbnN0b3JtdGF5bG9yL3NsYXRlL2lzc3Vlcy8xODE5XG5cbiAgICB0cnkge1xuICAgICAgdGFyZ2V0RWwgPSBpc0RPTUVsZW1lbnQodGFyZ2V0KSA/IHRhcmdldCA6IHRhcmdldC5wYXJlbnRFbGVtZW50O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFlcnIubWVzc2FnZS5pbmNsdWRlcygnUGVybWlzc2lvbiBkZW5pZWQgdG8gYWNjZXNzIHByb3BlcnR5IFwibm9kZVR5cGVcIicpKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldEVsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldEVsLmNsb3Nlc3QoXCJbZGF0YS1zbGF0ZS1lZGl0b3JdXCIpID09PSBlZGl0b3JFbCAmJiAoIWVkaXRhYmxlIHx8IHRhcmdldEVsLmlzQ29udGVudEVkaXRhYmxlIHx8ICEhdGFyZ2V0RWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGRhdGEgZnJvbSBhIGBEYXRhVHJhbnNmZXJgIGludG8gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgaW5zZXJ0RGF0YShlZGl0b3IsIGRhdGEpIHtcbiAgICBlZGl0b3IuaW5zZXJ0RGF0YShkYXRhKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBTZXRzIGRhdGEgZnJvbSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGZyYWdtZW50IG9uIGEgYERhdGFUcmFuc2ZlcmAuXHJcbiAgICovXG4gIHNldEZyYWdtZW50RGF0YShlZGl0b3IsIGRhdGEpIHtcbiAgICBlZGl0b3Iuc2V0RnJhZ21lbnREYXRhKGRhdGEpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEZpbmQgdGhlIG5hdGl2ZSBET00gZWxlbWVudCBmcm9tIGEgU2xhdGUgbm9kZS5cclxuICAgKi9cbiAgdG9ET01Ob2RlKGVkaXRvciwgbm9kZSkge1xuICAgIHZhciBkb21Ob2RlID0gRWRpdG9yLmlzRWRpdG9yKG5vZGUpID8gRURJVE9SX1RPX0VMRU1FTlQuZ2V0KGVkaXRvcikgOiBLRVlfVE9fRUxFTUVOVC5nZXQoUmVhY3RFZGl0b3IuZmluZEtleShlZGl0b3IsIG5vZGUpKTtcblxuICAgIGlmICghZG9tTm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBET00gbm9kZSBmcm9tIFNsYXRlIG5vZGU6IFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShub2RlKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBkb21Ob2RlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEZpbmQgYSBuYXRpdmUgRE9NIHNlbGVjdGlvbiBwb2ludCBmcm9tIGEgU2xhdGUgcG9pbnQuXHJcbiAgICovXG4gIHRvRE9NUG9pbnQoZWRpdG9yLCBwb2ludCkge1xuICAgIHZhciBbbm9kZV0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBvaW50LnBhdGgpO1xuICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIG5vZGUpO1xuICAgIHZhciBkb21Qb2ludDsgLy8gSWYgd2UncmUgaW5zaWRlIGEgdm9pZCBub2RlLCBmb3JjZSB0aGUgb2Zmc2V0IHRvIDAsIG90aGVyd2lzZSB0aGUgemVyb1xuICAgIC8vIHdpZHRoIHNwYWNpbmcgY2hhcmFjdGVyIHdpbGwgcmVzdWx0IGluIGFuIGluY29ycmVjdCBvZmZzZXQgb2YgMVxuXG4gICAgaWYgKEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgYXQ6IHBvaW50XG4gICAgfSkpIHtcbiAgICAgIHBvaW50ID0ge1xuICAgICAgICBwYXRoOiBwb2ludC5wYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH07XG4gICAgfSAvLyBGb3IgZWFjaCBsZWFmLCB3ZSBuZWVkIHRvIGlzb2xhdGUgaXRzIGNvbnRlbnQsIHdoaWNoIG1lYW5zIGZpbHRlcmluZ1xuICAgIC8vIHRvIGl0cyBkaXJlY3QgdGV4dCBhbmQgemVyby13aWR0aCBzcGFucy4gKFdlIGhhdmUgdG8gZmlsdGVyIG91dCBhbnlcbiAgICAvLyBvdGhlciBzaWJsaW5ncyB0aGF0IG1heSBoYXZlIGJlZW4gcmVuZGVyZWQgYWxvbmdzaWRlIHRoZW0uKVxuXG5cbiAgICB2YXIgc2VsZWN0b3IgPSBcIltkYXRhLXNsYXRlLXN0cmluZ10sIFtkYXRhLXNsYXRlLXplcm8td2lkdGhdXCI7XG4gICAgdmFyIHRleHRzID0gQXJyYXkuZnJvbShlbC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgdmFyIHN0YXJ0ID0gMDtcblxuICAgIGZvciAodmFyIHRleHQgb2YgdGV4dHMpIHtcbiAgICAgIHZhciBkb21Ob2RlID0gdGV4dC5jaGlsZE5vZGVzWzBdO1xuXG4gICAgICBpZiAoZG9tTm9kZSA9PSBudWxsIHx8IGRvbU5vZGUudGV4dENvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHtcbiAgICAgICAgbGVuZ3RoXG4gICAgICB9ID0gZG9tTm9kZS50ZXh0Q29udGVudDtcbiAgICAgIHZhciBhdHRyID0gdGV4dC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtbGVuZ3RoJyk7XG4gICAgICB2YXIgdHJ1ZUxlbmd0aCA9IGF0dHIgPT0gbnVsbCA/IGxlbmd0aCA6IHBhcnNlSW50KGF0dHIsIDEwKTtcbiAgICAgIHZhciBlbmQgPSBzdGFydCArIHRydWVMZW5ndGg7XG5cbiAgICAgIGlmIChwb2ludC5vZmZzZXQgPD0gZW5kKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBNYXRoLm1pbihsZW5ndGgsIE1hdGgubWF4KDAsIHBvaW50Lm9mZnNldCAtIHN0YXJ0KSk7XG4gICAgICAgIGRvbVBvaW50ID0gW2RvbU5vZGUsIG9mZnNldF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzdGFydCA9IGVuZDtcbiAgICB9XG5cbiAgICBpZiAoIWRvbVBvaW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIERPTSBwb2ludCBmcm9tIFNsYXRlIHBvaW50OiBcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkocG9pbnQpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvbVBvaW50O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEZpbmQgYSBuYXRpdmUgRE9NIHJhbmdlIGZyb20gYSBTbGF0ZSBgcmFuZ2VgLlxyXG4gICAqL1xuICB0b0RPTVJhbmdlKGVkaXRvciwgcmFuZ2UpIHtcbiAgICB2YXIge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9ID0gcmFuZ2U7XG4gICAgdmFyIGlzQmFja3dhcmQgPSBSYW5nZS5pc0JhY2t3YXJkKHJhbmdlKTtcbiAgICB2YXIgZG9tQW5jaG9yID0gUmVhY3RFZGl0b3IudG9ET01Qb2ludChlZGl0b3IsIGFuY2hvcik7XG4gICAgdmFyIGRvbUZvY3VzID0gUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpID8gZG9tQW5jaG9yIDogUmVhY3RFZGl0b3IudG9ET01Qb2ludChlZGl0b3IsIGZvY3VzKTtcbiAgICB2YXIgZG9tUmFuZ2UgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICB2YXIgW3N0YXJ0Tm9kZSwgc3RhcnRPZmZzZXRdID0gaXNCYWNrd2FyZCA/IGRvbUZvY3VzIDogZG9tQW5jaG9yO1xuICAgIHZhciBbZW5kTm9kZSwgZW5kT2Zmc2V0XSA9IGlzQmFja3dhcmQgPyBkb21BbmNob3IgOiBkb21Gb2N1czsgLy8gQSBzbGF0ZSBQb2ludCBhdCB6ZXJvLXdpZHRoIExlYWYgYWx3YXlzIGhhcyBhbiBvZmZzZXQgb2YgMCBidXQgYSBuYXRpdmUgRE9NIHNlbGVjdGlvbiBhdFxuICAgIC8vIHplcm8td2lkdGggbm9kZSBoYXMgYW4gb2Zmc2V0IG9mIDEgc28gd2UgaGF2ZSB0byBjaGVjayBpZiB3ZSBhcmUgaW4gYSB6ZXJvLXdpZHRoIG5vZGUgYW5kXG4gICAgLy8gYWRqdXN0IHRoZSBvZmZzZXQgYWNjb3JkaW5nbHkuXG5cbiAgICB2YXIgc3RhcnRFbCA9IGlzRE9NRWxlbWVudChzdGFydE5vZGUpID8gc3RhcnROb2RlIDogc3RhcnROb2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgdmFyIGlzU3RhcnRBdFplcm9XaWR0aCA9ICEhc3RhcnRFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpO1xuICAgIHZhciBlbmRFbCA9IGlzRE9NRWxlbWVudChlbmROb2RlKSA/IGVuZE5vZGUgOiBlbmROb2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgdmFyIGlzRW5kQXRaZXJvV2lkdGggPSAhIWVuZEVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJyk7XG4gICAgZG9tUmFuZ2Uuc2V0U3RhcnQoc3RhcnROb2RlLCBpc1N0YXJ0QXRaZXJvV2lkdGggPyAxIDogc3RhcnRPZmZzZXQpO1xuICAgIGRvbVJhbmdlLnNldEVuZChlbmROb2RlLCBpc0VuZEF0WmVyb1dpZHRoID8gMSA6IGVuZE9mZnNldCk7XG4gICAgcmV0dXJuIGRvbVJhbmdlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEZpbmQgYSBTbGF0ZSBub2RlIGZyb20gYSBuYXRpdmUgRE9NIGBlbGVtZW50YC5cclxuICAgKi9cbiAgdG9TbGF0ZU5vZGUoZWRpdG9yLCBkb21Ob2RlKSB7XG4gICAgdmFyIGRvbUVsID0gaXNET01FbGVtZW50KGRvbU5vZGUpID8gZG9tTm9kZSA6IGRvbU5vZGUucGFyZW50RWxlbWVudDtcblxuICAgIGlmIChkb21FbCAmJiAhZG9tRWwuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLW5vZGUnKSkge1xuICAgICAgZG9tRWwgPSBkb21FbC5jbG9zZXN0KFwiW2RhdGEtc2xhdGUtbm9kZV1cIik7XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBkb21FbCA/IEVMRU1FTlRfVE9fTk9ERS5nZXQoZG9tRWwpIDogbnVsbDtcblxuICAgIGlmICghbm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBTbGF0ZSBub2RlIGZyb20gRE9NIG5vZGU6IFwiLmNvbmNhdChkb21FbCkpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgdGFyZ2V0IHJhbmdlIGZyb20gYSBET00gYGV2ZW50YC5cclxuICAgKi9cbiAgZmluZEV2ZW50UmFuZ2UoZWRpdG9yLCBldmVudCkge1xuICAgIGlmICgnbmF0aXZlRXZlbnQnIGluIGV2ZW50KSB7XG4gICAgICBldmVudCA9IGV2ZW50Lm5hdGl2ZUV2ZW50O1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBjbGllbnRYOiB4LFxuICAgICAgY2xpZW50WTogeSxcbiAgICAgIHRhcmdldFxuICAgIH0gPSBldmVudDtcblxuICAgIGlmICh4ID09IG51bGwgfHwgeSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIHJhbmdlIGZyb20gYSBET00gZXZlbnQ6IFwiLmNvbmNhdChldmVudCkpO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gUmVhY3RFZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCBldmVudC50YXJnZXQpO1xuICAgIHZhciBwYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBub2RlKTsgLy8gSWYgdGhlIGRyb3AgdGFyZ2V0IGlzIGluc2lkZSBhIHZvaWQgbm9kZSwgbW92ZSBpdCBpbnRvIGVpdGhlciB0aGVcbiAgICAvLyBuZXh0IG9yIHByZXZpb3VzIG5vZGUsIGRlcGVuZGluZyBvbiB3aGljaCBzaWRlIHRoZSBgeGAgYW5kIGB5YFxuICAgIC8vIGNvb3JkaW5hdGVzIGFyZSBjbG9zZXN0IHRvLlxuXG4gICAgaWYgKEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgdmFyIHJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgaXNQcmV2ID0gZWRpdG9yLmlzSW5saW5lKG5vZGUpID8geCAtIHJlY3QubGVmdCA8IHJlY3QubGVmdCArIHJlY3Qud2lkdGggLSB4IDogeSAtIHJlY3QudG9wIDwgcmVjdC50b3AgKyByZWN0LmhlaWdodCAtIHk7XG4gICAgICB2YXIgZWRnZSA9IEVkaXRvci5wb2ludChlZGl0b3IsIHBhdGgsIHtcbiAgICAgICAgZWRnZTogaXNQcmV2ID8gJ3N0YXJ0JyA6ICdlbmQnXG4gICAgICB9KTtcbiAgICAgIHZhciBwb2ludCA9IGlzUHJldiA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBlZGdlKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGVkZ2UpO1xuXG4gICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgdmFyIF9yYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHBvaW50KTtcblxuICAgICAgICByZXR1cm4gX3JhbmdlO1xuICAgICAgfVxuICAgIH0gLy8gRWxzZSByZXNvbHZlIGEgcmFuZ2UgZnJvbSB0aGUgY2FyZXQgcG9zaXRpb24gd2hlcmUgdGhlIGRyb3Agb2NjdXJlZC5cblxuXG4gICAgdmFyIGRvbVJhbmdlO1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudFxuICAgIH0gPSB3aW5kb3c7IC8vIENPTVBBVDogSW4gRmlyZWZveCwgYGNhcmV0UmFuZ2VGcm9tUG9pbnRgIGRvZXNuJ3QgZXhpc3QuICgyMDE2LzA3LzI1KVxuXG4gICAgaWYgKGRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQpIHtcbiAgICAgIGRvbVJhbmdlID0gZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludCh4LCB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBvc2l0aW9uID0gZG9jdW1lbnQuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCh4LCB5KTtcblxuICAgICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICAgIGRvbVJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgZG9tUmFuZ2Uuc2V0U3RhcnQocG9zaXRpb24ub2Zmc2V0Tm9kZSwgcG9zaXRpb24ub2Zmc2V0KTtcbiAgICAgICAgZG9tUmFuZ2Uuc2V0RW5kKHBvc2l0aW9uLm9mZnNldE5vZGUsIHBvc2l0aW9uLm9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFkb21SYW5nZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBTbGF0ZSByYW5nZSBmcm9tIGEgRE9NIGV2ZW50OiBcIi5jb25jYXQoZXZlbnQpKTtcbiAgICB9IC8vIFJlc29sdmUgYSBTbGF0ZSByYW5nZSBmcm9tIHRoZSBET00gcmFuZ2UuXG5cblxuICAgIHZhciByYW5nZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVSYW5nZShlZGl0b3IsIGRvbVJhbmdlKTtcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRmluZCBhIFNsYXRlIHBvaW50IGZyb20gYSBET00gc2VsZWN0aW9uJ3MgYGRvbU5vZGVgIGFuZCBgZG9tT2Zmc2V0YC5cclxuICAgKi9cbiAgdG9TbGF0ZVBvaW50KGVkaXRvciwgZG9tUG9pbnQpIHtcbiAgICB2YXIgW25lYXJlc3ROb2RlLCBuZWFyZXN0T2Zmc2V0XSA9IG5vcm1hbGl6ZURPTVBvaW50KGRvbVBvaW50KTtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IG5lYXJlc3ROb2RlLnBhcmVudE5vZGU7XG4gICAgdmFyIHRleHROb2RlID0gbnVsbDtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICB2YXIgdm9pZE5vZGUgPSBwYXJlbnROb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLXZvaWQ9XCJ0cnVlXCJdJyk7XG4gICAgICB2YXIgbGVhZk5vZGUgPSBwYXJlbnROb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLWxlYWZdJyk7XG4gICAgICB2YXIgZG9tTm9kZSA9IG51bGw7IC8vIENhbGN1bGF0ZSBob3cgZmFyIGludG8gdGhlIHRleHQgbm9kZSB0aGUgYG5lYXJlc3ROb2RlYCBpcywgc28gdGhhdCB3ZVxuICAgICAgLy8gY2FuIGRldGVybWluZSB3aGF0IHRoZSBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlIHRleHQgbm9kZSBpcy5cblxuICAgICAgaWYgKGxlYWZOb2RlKSB7XG4gICAgICAgIHRleHROb2RlID0gbGVhZk5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtbm9kZT1cInRleHRcIl0nKTtcbiAgICAgICAgdmFyIHJhbmdlID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KHRleHROb2RlLCAwKTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKG5lYXJlc3ROb2RlLCBuZWFyZXN0T2Zmc2V0KTtcbiAgICAgICAgdmFyIGNvbnRlbnRzID0gcmFuZ2UuY2xvbmVDb250ZW50cygpO1xuICAgICAgICB2YXIgcmVtb3ZhbHMgPSBbLi4uY29udGVudHMucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2xhdGUtemVyby13aWR0aF0nKSwgLi4uY29udGVudHMucXVlcnlTZWxlY3RvckFsbCgnW2NvbnRlbnRlZGl0YWJsZT1mYWxzZV0nKV07XG4gICAgICAgIHJlbW92YWxzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICB9KTsgLy8gQ09NUEFUOiBFZGdlIGhhcyBhIGJ1ZyB3aGVyZSBSYW5nZS5wcm90b3R5cGUudG9TdHJpbmcoKSB3aWxsXG4gICAgICAgIC8vIGNvbnZlcnQgXFxuIGludG8gXFxyXFxuLiBUaGUgYnVnIGNhdXNlcyBhIGxvb3Agd2hlbiBzbGF0ZS1yZWFjdFxuICAgICAgICAvLyBhdHRlbXB0cyB0byByZXBvc2l0aW9uIGl0cyBjdXJzb3IgdG8gbWF0Y2ggdGhlIG5hdGl2ZSBwb3NpdGlvbi4gVXNlXG4gICAgICAgIC8vIHRleHRDb250ZW50Lmxlbmd0aCBpbnN0ZWFkLlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMDI5MTExNi9cblxuICAgICAgICBvZmZzZXQgPSBjb250ZW50cy50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICAgIGRvbU5vZGUgPSB0ZXh0Tm9kZTtcbiAgICAgIH0gZWxzZSBpZiAodm9pZE5vZGUpIHtcbiAgICAgICAgLy8gRm9yIHZvaWQgbm9kZXMsIHRoZSBlbGVtZW50IHdpdGggdGhlIG9mZnNldCBrZXkgd2lsbCBiZSBhIGNvdXNpbiwgbm90IGFuXG4gICAgICAgIC8vIGFuY2VzdG9yLCBzbyBmaW5kIGl0IGJ5IGdvaW5nIGRvd24gZnJvbSB0aGUgbmVhcmVzdCB2b2lkIHBhcmVudC5cbiAgICAgICAgbGVhZk5vZGUgPSB2b2lkTm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1zbGF0ZS1sZWFmXScpO1xuICAgICAgICB0ZXh0Tm9kZSA9IGxlYWZOb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLW5vZGU9XCJ0ZXh0XCJdJyk7XG4gICAgICAgIGRvbU5vZGUgPSBsZWFmTm9kZTtcbiAgICAgICAgb2Zmc2V0ID0gZG9tTm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICB9IC8vIENPTVBBVDogSWYgdGhlIHBhcmVudCBub2RlIGlzIGEgU2xhdGUgemVyby13aWR0aCBzcGFjZSwgZWRpdG9yIGlzXG4gICAgICAvLyBiZWNhdXNlIHRoZSB0ZXh0IG5vZGUgc2hvdWxkIGhhdmUgbm8gY2hhcmFjdGVycy4gSG93ZXZlciwgZHVyaW5nIElNRVxuICAgICAgLy8gY29tcG9zaXRpb24gdGhlIEFTQ0lJIGNoYXJhY3RlcnMgd2lsbCBiZSBwcmVwZW5kZWQgdG8gdGhlIHplcm8td2lkdGhcbiAgICAgIC8vIHNwYWNlLCBzbyBzdWJ0cmFjdCAxIGZyb20gdGhlIG9mZnNldCB0byBhY2NvdW50IGZvciB0aGUgemVyby13aWR0aFxuICAgICAgLy8gc3BhY2UgY2hhcmFjdGVyLlxuXG5cbiAgICAgIGlmIChkb21Ob2RlICYmIG9mZnNldCA9PT0gZG9tTm9kZS50ZXh0Q29udGVudC5sZW5ndGggJiYgcGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpKSB7XG4gICAgICAgIG9mZnNldC0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGV4dE5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgU2xhdGUgcG9pbnQgZnJvbSBET00gcG9pbnQ6IFwiLmNvbmNhdChkb21Qb2ludCkpO1xuICAgIH0gLy8gQ09NUEFUOiBJZiBzb21lb25lIGlzIGNsaWNraW5nIGZyb20gb25lIFNsYXRlIGVkaXRvciBpbnRvIGFub3RoZXIsXG4gICAgLy8gdGhlIHNlbGVjdCBldmVudCBmaXJlcyB0d2ljZSwgb25jZSBmb3IgdGhlIG9sZCBlZGl0b3IncyBgZWxlbWVudGBcbiAgICAvLyBmaXJzdCwgYW5kIHRoZW4gYWZ0ZXJ3YXJkcyBmb3IgdGhlIGNvcnJlY3QgYGVsZW1lbnRgLiAoMjAxNy8wMy8wMylcblxuXG4gICAgdmFyIHNsYXRlTm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgdGV4dE5vZGUpO1xuICAgIHZhciBwYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBzbGF0ZU5vZGUpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoLFxuICAgICAgb2Zmc2V0XG4gICAgfTtcbiAgfSxcblxuICAvKipcclxuICAgKiBGaW5kIGEgU2xhdGUgcmFuZ2UgZnJvbSBhIERPTSByYW5nZSBvciBzZWxlY3Rpb24uXHJcbiAgICovXG4gIHRvU2xhdGVSYW5nZShlZGl0b3IsIGRvbVJhbmdlKSB7XG4gICAgdmFyIGVsID0gZG9tUmFuZ2UgaW5zdGFuY2VvZiBTZWxlY3Rpb24gPyBkb21SYW5nZS5hbmNob3JOb2RlIDogZG9tUmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgdmFyIGFuY2hvck5vZGU7XG4gICAgdmFyIGFuY2hvck9mZnNldDtcbiAgICB2YXIgZm9jdXNOb2RlO1xuICAgIHZhciBmb2N1c09mZnNldDtcbiAgICB2YXIgaXNDb2xsYXBzZWQ7XG5cbiAgICBpZiAoZWwpIHtcbiAgICAgIGlmIChkb21SYW5nZSBpbnN0YW5jZW9mIFNlbGVjdGlvbikge1xuICAgICAgICBhbmNob3JOb2RlID0gZG9tUmFuZ2UuYW5jaG9yTm9kZTtcbiAgICAgICAgYW5jaG9yT2Zmc2V0ID0gZG9tUmFuZ2UuYW5jaG9yT2Zmc2V0O1xuICAgICAgICBmb2N1c05vZGUgPSBkb21SYW5nZS5mb2N1c05vZGU7XG4gICAgICAgIGZvY3VzT2Zmc2V0ID0gZG9tUmFuZ2UuZm9jdXNPZmZzZXQ7XG4gICAgICAgIGlzQ29sbGFwc2VkID0gZG9tUmFuZ2UuaXNDb2xsYXBzZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmNob3JOb2RlID0gZG9tUmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICAgIGFuY2hvck9mZnNldCA9IGRvbVJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgICBmb2N1c05vZGUgPSBkb21SYW5nZS5lbmRDb250YWluZXI7XG4gICAgICAgIGZvY3VzT2Zmc2V0ID0gZG9tUmFuZ2UuZW5kT2Zmc2V0O1xuICAgICAgICBpc0NvbGxhcHNlZCA9IGRvbVJhbmdlLmNvbGxhcHNlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYW5jaG9yTm9kZSA9PSBudWxsIHx8IGZvY3VzTm9kZSA9PSBudWxsIHx8IGFuY2hvck9mZnNldCA9PSBudWxsIHx8IGZvY3VzT2Zmc2V0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgU2xhdGUgcmFuZ2UgZnJvbSBET00gcmFuZ2U6IFwiLmNvbmNhdChkb21SYW5nZSkpO1xuICAgIH1cblxuICAgIHZhciBhbmNob3IgPSBSZWFjdEVkaXRvci50b1NsYXRlUG9pbnQoZWRpdG9yLCBbYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0XSk7XG4gICAgdmFyIGZvY3VzID0gaXNDb2xsYXBzZWQgPyBhbmNob3IgOiBSZWFjdEVkaXRvci50b1NsYXRlUG9pbnQoZWRpdG9yLCBbZm9jdXNOb2RlLCBmb2N1c09mZnNldF0pO1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH07XG4gIH1cblxufTtcblxuLyoqXHJcbiAqIEEgUmVhY3QgY29udGV4dCBmb3Igc2hhcmluZyB0aGUgYGZvY3VzZWRgIHN0YXRlIG9mIHRoZSBlZGl0b3IuXHJcbiAqL1xuXG52YXIgRm9jdXNlZENvbnRleHQgPSBjcmVhdGVDb250ZXh0KGZhbHNlKTtcbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgYGZvY3VzZWRgIHN0YXRlIG9mIHRoZSBlZGl0b3IuXHJcbiAqL1xuXG52YXIgdXNlRm9jdXNlZCA9ICgpID0+IHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoRm9jdXNlZENvbnRleHQpO1xufTtcblxuLyoqXHJcbiAqIEEgUmVhY3QgY29udGV4dCBmb3Igc2hhcmluZyB0aGUgZWRpdG9yIG9iamVjdC5cclxuICovXG5cbnZhciBFZGl0b3JDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgZWRpdG9yIG9iamVjdCBmcm9tIHRoZSBSZWFjdCBjb250ZXh0LlxyXG4gKi9cblxudmFyIHVzZUVkaXRvciA9ICgpID0+IHtcbiAgdmFyIGVkaXRvciA9IHVzZUNvbnRleHQoRWRpdG9yQ29udGV4dCk7XG5cbiAgaWYgKCFlZGl0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHVzZUVkaXRvcmAgaG9vayBtdXN0IGJlIHVzZWQgaW5zaWRlIHRoZSA8U2xhdGU+IGNvbXBvbmVudCdzIGNvbnRleHQuXCIpO1xuICB9XG5cbiAgcmV0dXJuIGVkaXRvcjtcbn07XG5cbi8qKlxyXG4gKiBBIFJlYWN0IGNvbnRleHQgZm9yIHNoYXJpbmcgdGhlIGVkaXRvciBvYmplY3QsIGluIGEgd2F5IHRoYXQgcmUtcmVuZGVycyB0aGVcclxuICogY29udGV4dCB3aGVuZXZlciBjaGFuZ2VzIG9jY3VyLlxyXG4gKi9cblxudmFyIFNsYXRlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG4vKipcclxuICogR2V0IHRoZSBjdXJyZW50IGVkaXRvciBvYmplY3QgZnJvbSB0aGUgUmVhY3QgY29udGV4dC5cclxuICovXG5cbnZhciB1c2VTbGF0ZSA9ICgpID0+IHtcbiAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KFNsYXRlQ29udGV4dCk7XG5cbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGB1c2VTbGF0ZWAgaG9vayBtdXN0IGJlIHVzZWQgaW5zaWRlIHRoZSA8U2xhdGVQcm92aWRlcj4gY29tcG9uZW50J3MgY29udGV4dC5cIik7XG4gIH1cblxuICB2YXIgW2VkaXRvcl0gPSBjb250ZXh0O1xuICByZXR1cm4gZWRpdG9yO1xufTtcblxuLyoqXHJcbiAqIEEgd3JhcHBlciBhcm91bmQgdGhlIHByb3ZpZGVyIHRvIGhhbmRsZSBgb25DaGFuZ2VgIGV2ZW50cywgYmVjYXVzZSB0aGUgZWRpdG9yXHJcbiAqIGlzIGEgbXV0YWJsZSBzaW5nbGV0b24gc28gaXQgd29uJ3QgZXZlciByZWdpc3RlciBhcyBcImNoYW5nZWRcIiBvdGhlcndpc2UuXHJcbiAqL1xuXG52YXIgU2xhdGUgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgZWRpdG9yLFxuICAgIGNoaWxkcmVuLFxuICAgIG9uQ2hhbmdlLFxuICAgIHZhbHVlXG4gIH0gPSBwcm9wcyxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImVkaXRvclwiLCBcImNoaWxkcmVuXCIsIFwib25DaGFuZ2VcIiwgXCJ2YWx1ZVwiXSk7XG5cbiAgdmFyIFtrZXksIHNldEtleV0gPSB1c2VTdGF0ZSgwKTtcbiAgdmFyIGNvbnRleHQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBlZGl0b3IuY2hpbGRyZW4gPSB2YWx1ZTtcbiAgICBPYmplY3QuYXNzaWduKGVkaXRvciwgcmVzdCk7XG4gICAgcmV0dXJuIFtlZGl0b3JdO1xuICB9LCBba2V5LCB2YWx1ZSwgLi4uT2JqZWN0LnZhbHVlcyhyZXN0KV0pO1xuICB2YXIgb25Db250ZXh0Q2hhbmdlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIG9uQ2hhbmdlKGVkaXRvci5jaGlsZHJlbik7XG4gICAgc2V0S2V5KGtleSArIDEpO1xuICB9LCBba2V5LCBvbkNoYW5nZV0pO1xuICBFRElUT1JfVE9fT05fQ0hBTkdFLnNldChlZGl0b3IsIG9uQ29udGV4dENoYW5nZSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIEVESVRPUl9UT19PTl9DSEFOR0Uuc2V0KGVkaXRvciwgKCkgPT4ge30pO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2xhdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHRcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChFZGl0b3JDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGVkaXRvclxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KEZvY3VzZWRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IFJlYWN0RWRpdG9yLmlzRm9jdXNlZChlZGl0b3IpXG4gIH0sIGNoaWxkcmVuKSkpO1xufTtcblxuLyoqXHJcbiAqIEEgUmVhY3QgY29udGV4dCBmb3Igc2hhcmluZyB0aGUgYHJlYWRPbmx5YCBzdGF0ZSBvZiB0aGUgZWRpdG9yLlxyXG4gKi9cblxudmFyIFJlYWRPbmx5Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQoZmFsc2UpO1xuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCBgcmVhZE9ubHlgIHN0YXRlIG9mIHRoZSBlZGl0b3IuXHJcbiAqL1xuXG52YXIgdXNlUmVhZE9ubHkgPSAoKSA9PiB7XG4gIHJldHVybiB1c2VDb250ZXh0KFJlYWRPbmx5Q29udGV4dCk7XG59O1xuXG4vKipcclxuICogQSBSZWFjdCBjb250ZXh0IGZvciBzaGFyaW5nIHRoZSBgc2VsZWN0ZWRgIHN0YXRlIG9mIGFuIGVsZW1lbnQuXHJcbiAqL1xuXG52YXIgU2VsZWN0ZWRDb250ZXh0ID0gY3JlYXRlQ29udGV4dChmYWxzZSk7XG4vKipcclxuICogR2V0IHRoZSBjdXJyZW50IGBzZWxlY3RlZGAgc3RhdGUgb2YgYW4gZWxlbWVudC5cclxuICovXG5cbnZhciB1c2VTZWxlY3RlZCA9ICgpID0+IHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoU2VsZWN0ZWRDb250ZXh0KTtcbn07XG5cbi8qKlxyXG4gKiBgd2l0aFJlYWN0YCBhZGRzIFJlYWN0IGFuZCBET00gc3BlY2lmaWMgYmVoYXZpb3JzIHRvIHRoZSBlZGl0b3IuXHJcbiAqL1xuXG52YXIgd2l0aFJlYWN0ID0gZWRpdG9yID0+IHtcbiAgdmFyIGUgPSBlZGl0b3I7XG4gIHZhciB7XG4gICAgYXBwbHksXG4gICAgb25DaGFuZ2VcbiAgfSA9IGU7XG5cbiAgZS5hcHBseSA9IG9wID0+IHtcbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuXG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgRWRpdG9yLmxldmVscyhlLCB7XG4gICAgICAgICAgICBhdDogb3AucGF0aFxuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gUmVhY3RFZGl0b3IuZmluZEtleShlLCBub2RlKTtcbiAgICAgICAgICAgIG1hdGNoZXMucHVzaChbcGF0aCwga2V5XSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIGZvciAodmFyIFtfbm9kZSwgX3BhdGhdIG9mIEVkaXRvci5sZXZlbHMoZSwge1xuICAgICAgICAgICAgYXQ6IFBhdGgucGFyZW50KG9wLnBhdGgpXG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHZhciBfa2V5ID0gUmVhY3RFZGl0b3IuZmluZEtleShlLCBfbm9kZSk7XG5cbiAgICAgICAgICAgIG1hdGNoZXMucHVzaChbX3BhdGgsIF9rZXldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFwcGx5KG9wKTtcblxuICAgIGZvciAodmFyIFtfcGF0aDIsIF9rZXkyXSBvZiBtYXRjaGVzKSB7XG4gICAgICB2YXIgW19ub2RlMl0gPSBFZGl0b3Iubm9kZShlLCBfcGF0aDIpO1xuICAgICAgTk9ERV9UT19LRVkuc2V0KF9ub2RlMiwgX2tleTIpO1xuICAgIH1cbiAgfTtcblxuICBlLnNldEZyYWdtZW50RGF0YSA9IGRhdGEgPT4ge1xuICAgIHZhciB7XG4gICAgICBzZWxlY3Rpb25cbiAgICB9ID0gZTtcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHNlbGVjdGlvbik7XG4gICAgdmFyIHN0YXJ0Vm9pZCA9IEVkaXRvci52b2lkKGUsIHtcbiAgICAgIGF0OiBzdGFydC5wYXRoXG4gICAgfSk7XG4gICAgdmFyIGVuZFZvaWQgPSBFZGl0b3Iudm9pZChlLCB7XG4gICAgICBhdDogZW5kLnBhdGhcbiAgICB9KTtcblxuICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pICYmICFzdGFydFZvaWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIENyZWF0ZSBhIGZha2Ugc2VsZWN0aW9uIHNvIHRoYXQgd2UgY2FuIGFkZCBhIEJhc2U2NC1lbmNvZGVkIGNvcHkgb2YgdGhlXG4gICAgLy8gZnJhZ21lbnQgdG8gdGhlIEhUTUwsIHRvIGRlY29kZSBvbiBmdXR1cmUgcGFzdGVzLlxuXG5cbiAgICB2YXIgZG9tUmFuZ2UgPSBSZWFjdEVkaXRvci50b0RPTVJhbmdlKGUsIHNlbGVjdGlvbik7XG4gICAgdmFyIGNvbnRlbnRzID0gZG9tUmFuZ2UuY2xvbmVDb250ZW50cygpO1xuICAgIHZhciBhdHRhY2ggPSBjb250ZW50cy5jaGlsZE5vZGVzWzBdOyAvLyBNYWtlIHN1cmUgYXR0YWNoIGlzIG5vbi1lbXB0eSwgc2luY2UgZW1wdHkgbm9kZXMgd2lsbCBub3QgZ2V0IGNvcGllZC5cblxuICAgIGNvbnRlbnRzLmNoaWxkTm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIGlmIChub2RlLnRleHRDb250ZW50ICYmIG5vZGUudGV4dENvbnRlbnQudHJpbSgpICE9PSAnJykge1xuICAgICAgICBhdHRhY2ggPSBub2RlO1xuICAgICAgfVxuICAgIH0pOyAvLyBDT01QQVQ6IElmIHRoZSBlbmQgbm9kZSBpcyBhIHZvaWQgbm9kZSwgd2UgbmVlZCB0byBtb3ZlIHRoZSBlbmQgb2YgdGhlXG4gICAgLy8gcmFuZ2UgZnJvbSB0aGUgdm9pZCBub2RlJ3Mgc3BhY2VyIHNwYW4sIHRvIHRoZSBlbmQgb2YgdGhlIHZvaWQgbm9kZSdzXG4gICAgLy8gY29udGVudCwgc2luY2UgdGhlIHNwYWNlciBpcyBiZWZvcmUgdm9pZCdzIGNvbnRlbnQgaW4gdGhlIERPTS5cblxuICAgIGlmIChlbmRWb2lkKSB7XG4gICAgICB2YXIgW3ZvaWROb2RlXSA9IGVuZFZvaWQ7XG4gICAgICB2YXIgciA9IGRvbVJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgICAgIHZhciBkb21Ob2RlID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGUsIHZvaWROb2RlKTtcbiAgICAgIHIuc2V0RW5kQWZ0ZXIoZG9tTm9kZSk7XG4gICAgICBjb250ZW50cyA9IHIuY2xvbmVDb250ZW50cygpO1xuICAgIH0gLy8gQ09NUEFUOiBJZiB0aGUgc3RhcnQgbm9kZSBpcyBhIHZvaWQgbm9kZSwgd2UgbmVlZCB0byBhdHRhY2ggdGhlIGVuY29kZWRcbiAgICAvLyBmcmFnbWVudCB0byB0aGUgdm9pZCBub2RlJ3MgY29udGVudCBub2RlIGluc3RlYWQgb2YgdGhlIHNwYWNlciwgYmVjYXVzZVxuICAgIC8vIGF0dGFjaGluZyBpdCB0byBlbXB0eSBgPGRpdj4vPHNwYW4+YCBub2RlcyB3aWxsIGVuZCB1cCBoYXZpbmcgaXQgZXJhc2VkIGJ5XG4gICAgLy8gbW9zdCBicm93c2Vycy4gKDIwMTgvMDQvMjcpXG5cblxuICAgIGlmIChzdGFydFZvaWQpIHtcbiAgICAgIGF0dGFjaCA9IGNvbnRlbnRzLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXNsYXRlLXNwYWNlcl0nKTtcbiAgICB9IC8vIFJlbW92ZSBhbnkgemVyby13aWR0aCBzcGFjZSBzcGFucyBmcm9tIHRoZSBjbG9uZWQgRE9NIHNvIHRoYXQgdGhleSBkb24ndFxuICAgIC8vIHNob3cgdXAgZWxzZXdoZXJlIHdoZW4gcGFzdGVkLlxuXG5cbiAgICBBcnJheS5mcm9tKGNvbnRlbnRzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNsYXRlLXplcm8td2lkdGhdJykpLmZvckVhY2goencgPT4ge1xuICAgICAgdmFyIGlzTmV3bGluZSA9IHp3LmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJykgPT09ICduJztcbiAgICAgIHp3LnRleHRDb250ZW50ID0gaXNOZXdsaW5lID8gJ1xcbicgOiAnJztcbiAgICB9KTsgLy8gU2V0IGEgYGRhdGEtc2xhdGUtZnJhZ21lbnRgIGF0dHJpYnV0ZSBvbiBhIG5vbi1lbXB0eSBub2RlLCBzbyBpdCBzaG93cyB1cFxuICAgIC8vIGluIHRoZSBIVE1MLCBhbmQgY2FuIGJlIHVzZWQgZm9yIGludHJhLVNsYXRlIHBhc3RpbmcuIElmIGl0J3MgYSB0ZXh0XG4gICAgLy8gbm9kZSwgd3JhcCBpdCBpbiBhIGA8c3Bhbj5gIHNvIHdlIGhhdmUgc29tZXRoaW5nIHRvIHNldCBhbiBhdHRyaWJ1dGUgb24uXG5cbiAgICBpZiAoaXNET01UZXh0KGF0dGFjaCkpIHtcbiAgICAgIHZhciBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpOyAvLyBDT01QQVQ6IEluIENocm9tZSBhbmQgU2FmYXJpLCBpZiB3ZSBkb24ndCBhZGQgdGhlIGB3aGl0ZS1zcGFjZWAgc3R5bGVcbiAgICAgIC8vIHRoZW4gbGVhZGluZyBhbmQgdHJhaWxpbmcgc3BhY2VzIHdpbGwgYmUgaWdub3JlZC4gKDIwMTcvMDkvMjEpXG5cbiAgICAgIHNwYW4uc3R5bGUud2hpdGVTcGFjZSA9ICdwcmUnO1xuICAgICAgc3Bhbi5hcHBlbmRDaGlsZChhdHRhY2gpO1xuICAgICAgY29udGVudHMuYXBwZW5kQ2hpbGQoc3Bhbik7XG4gICAgICBhdHRhY2ggPSBzcGFuO1xuICAgIH1cblxuICAgIHZhciBmcmFnbWVudCA9IGUuZ2V0RnJhZ21lbnQoKTtcbiAgICB2YXIgc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZnJhZ21lbnQpO1xuICAgIHZhciBlbmNvZGVkID0gd2luZG93LmJ0b2EoZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZykpO1xuICAgIGF0dGFjaC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtZnJhZ21lbnQnLCBlbmNvZGVkKTtcbiAgICBkYXRhLnNldERhdGEoJ2FwcGxpY2F0aW9uL3gtc2xhdGUtZnJhZ21lbnQnLCBlbmNvZGVkKTsgLy8gQWRkIHRoZSBjb250ZW50IHRvIGEgPGRpdj4gc28gdGhhdCB3ZSBjYW4gZ2V0IGl0cyBpbm5lciBIVE1MLlxuXG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5hcHBlbmRDaGlsZChjb250ZW50cyk7XG4gICAgZGl2LnNldEF0dHJpYnV0ZSgnaGlkZGVuJywgJ3RydWUnKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgZGF0YS5zZXREYXRhKCd0ZXh0L2h0bWwnLCBkaXYuaW5uZXJIVE1MKTtcbiAgICBkYXRhLnNldERhdGEoJ3RleHQvcGxhaW4nLCBnZXRQbGFpblRleHQoZGl2KSk7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuICB9O1xuXG4gIGUuaW5zZXJ0RGF0YSA9IGRhdGEgPT4ge1xuICAgIHZhciBmcmFnbWVudCA9IGRhdGEuZ2V0RGF0YSgnYXBwbGljYXRpb24veC1zbGF0ZS1mcmFnbWVudCcpO1xuXG4gICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICB2YXIgZGVjb2RlZCA9IGRlY29kZVVSSUNvbXBvbmVudCh3aW5kb3cuYXRvYihmcmFnbWVudCkpO1xuICAgICAgdmFyIHBhcnNlZCA9IEpTT04ucGFyc2UoZGVjb2RlZCk7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydEZyYWdtZW50KGUsIHBhcnNlZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRleHQgPSBkYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcblxuICAgIGlmICh0ZXh0KSB7XG4gICAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KC9cXHJcXG58XFxyfFxcbi8pO1xuICAgICAgdmFyIHNwbGl0ID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgaWYgKHNwbGl0KSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGUsIHtcbiAgICAgICAgICAgIGFsd2F5czogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnRUZXh0KGUsIGxpbmUpO1xuICAgICAgICBzcGxpdCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGUub25DaGFuZ2UgPSAoKSA9PiB7XG4gICAgLy8gQ09NUEFUOiBSZWFjdCBkb2Vzbid0IGJhdGNoIGBzZXRTdGF0ZWAgaG9vayBjYWxscywgd2hpY2ggbWVhbnMgdGhhdCB0aGVcbiAgICAvLyBjaGlsZHJlbiBhbmQgc2VsZWN0aW9uIGNhbiBnZXQgb3V0IG9mIHN5bmMgZm9yIG9uZSByZW5kZXIgcGFzcy4gU28gd2VcbiAgICAvLyBoYXZlIHRvIHVzZSB0aGlzIHVuc3RhYmxlIEFQSSB0byBlbnN1cmUgaXQgYmF0Y2hlcyB0aGVtLiAoMjAxOS8xMi8wMylcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE0MjU5I2lzc3VlY29tbWVudC00Mzk3MDIzNjdcbiAgICBSZWFjdERPTS51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICB2YXIgb25Db250ZXh0Q2hhbmdlID0gRURJVE9SX1RPX09OX0NIQU5HRS5nZXQoZSk7XG5cbiAgICAgIGlmIChvbkNvbnRleHRDaGFuZ2UpIHtcbiAgICAgICAgb25Db250ZXh0Q2hhbmdlKCk7XG4gICAgICB9XG5cbiAgICAgIG9uQ2hhbmdlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIGU7XG59O1xuXG4vKipcclxuICogTGVhZiBjb250ZW50IHN0cmluZ3MuXHJcbiAqL1xuXG52YXIgU3RyaW5nID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGlzTGFzdCxcbiAgICBsZWFmLFxuICAgIHBhcmVudCxcbiAgICB0ZXh0XG4gIH0gPSBwcm9wcztcbiAgdmFyIGVkaXRvciA9IHVzZUVkaXRvcigpO1xuICB2YXIgcGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgdGV4dCk7XG4gIHZhciBwYXJlbnRQYXRoID0gUGF0aC5wYXJlbnQocGF0aCk7IC8vIENPTVBBVDogUmVuZGVyIHRleHQgaW5zaWRlIHZvaWQgbm9kZXMgd2l0aCBhIHplcm8td2lkdGggc3BhY2UuXG4gIC8vIFNvIHRoZSBub2RlIGNhbiBjb250YWluIHNlbGVjdGlvbiBidXQgdGhlIHRleHQgaXMgbm90IHZpc2libGUuXG5cbiAgaWYgKGVkaXRvci5pc1ZvaWQocGFyZW50KSkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFplcm9XaWR0aFN0cmluZywge1xuICAgICAgbGVuZ3RoOiBOb2RlJDEuc3RyaW5nKHBhcmVudCkubGVuZ3RoXG4gICAgfSk7XG4gIH0gLy8gQ09NUEFUOiBJZiB0aGlzIGlzIHRoZSBsYXN0IHRleHQgbm9kZSBpbiBhbiBlbXB0eSBibG9jaywgcmVuZGVyIGEgemVyby1cbiAgLy8gd2lkdGggc3BhY2UgdGhhdCB3aWxsIGNvbnZlcnQgaW50byBhIGxpbmUgYnJlYWsgd2hlbiBjb3B5aW5nIGFuZCBwYXN0aW5nXG4gIC8vIHRvIHN1cHBvcnQgZXhwZWN0ZWQgcGxhaW4gdGV4dC5cblxuXG4gIGlmIChsZWFmLnRleHQgPT09ICcnICYmIHBhcmVudC5jaGlsZHJlbltwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPT09IHRleHQgJiYgIWVkaXRvci5pc0lubGluZShwYXJlbnQpICYmIEVkaXRvci5zdHJpbmcoZWRpdG9yLCBwYXJlbnRQYXRoKSA9PT0gJycpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChaZXJvV2lkdGhTdHJpbmcsIHtcbiAgICAgIGlzTGluZUJyZWFrOiB0cnVlXG4gICAgfSk7XG4gIH0gLy8gQ09NUEFUOiBJZiB0aGUgdGV4dCBpcyBlbXB0eSwgaXQncyBiZWNhdXNlIGl0J3Mgb24gdGhlIGVkZ2Ugb2YgYW4gaW5saW5lXG4gIC8vIG5vZGUsIHNvIHdlIHJlbmRlciBhIHplcm8td2lkdGggc3BhY2Ugc28gdGhhdCB0aGUgc2VsZWN0aW9uIGNhbiBiZVxuICAvLyBpbnNlcnRlZCBuZXh0IHRvIGl0IHN0aWxsLlxuXG5cbiAgaWYgKGxlYWYudGV4dCA9PT0gJycpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChaZXJvV2lkdGhTdHJpbmcsIG51bGwpO1xuICB9IC8vIENPTVBBVDogQnJvd3NlcnMgd2lsbCBjb2xsYXBzZSB0cmFpbGluZyBuZXcgbGluZXMgYXQgdGhlIGVuZCBvZiBibG9ja3MsXG4gIC8vIHNvIHdlIG5lZWQgdG8gYWRkIGFuIGV4dHJhIHRyYWlsaW5nIG5ldyBsaW5lcyB0byBwcmV2ZW50IHRoYXQuXG5cblxuICBpZiAoaXNMYXN0ICYmIGxlYWYudGV4dC5zbGljZSgtMSkgPT09ICdcXG4nKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dFN0cmluZywge1xuICAgICAgaXNUcmFpbGluZzogdHJ1ZSxcbiAgICAgIHRleHQ6IGxlYWYudGV4dFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dFN0cmluZywge1xuICAgIHRleHQ6IGxlYWYudGV4dFxuICB9KTtcbn07XG4vKipcclxuICogTGVhZiBzdHJpbmdzIHdpdGggdGV4dCBpbiB0aGVtLlxyXG4gKi9cblxuXG52YXIgVGV4dFN0cmluZyA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICB0ZXh0LFxuICAgIGlzVHJhaWxpbmcgPSBmYWxzZVxuICB9ID0gcHJvcHM7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgXCJkYXRhLXNsYXRlLXN0cmluZ1wiOiB0cnVlXG4gIH0sIHRleHQsIGlzVHJhaWxpbmcgPyAnXFxuJyA6IG51bGwpO1xufTtcbi8qKlxyXG4gKiBMZWFmIHN0cmluZ3Mgd2l0aG91dCB0ZXh0LCByZW5kZXIgYXMgemVyby13aWR0aCBzdHJpbmdzLlxyXG4gKi9cblxuXG52YXIgWmVyb1dpZHRoU3RyaW5nID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGxlbmd0aCA9IDAsXG4gICAgaXNMaW5lQnJlYWsgPSBmYWxzZVxuICB9ID0gcHJvcHM7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgXCJkYXRhLXNsYXRlLXplcm8td2lkdGhcIjogaXNMaW5lQnJlYWsgPyAnbicgOiAneicsXG4gICAgXCJkYXRhLXNsYXRlLWxlbmd0aFwiOiBsZW5ndGhcbiAgfSwgJ1xcdUZFRkYnLCBpc0xpbmVCcmVhayA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJiclwiLCBudWxsKSA6IG51bGwpO1xufTtcblxuLyoqXHJcbiAqIEluZGl2aWR1YWwgbGVhdmVzIGluIGEgdGV4dCBub2RlIHdpdGggdW5pcXVlIGZvcm1hdHRpbmcuXHJcbiAqL1xuXG52YXIgTGVhZiA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBsZWFmLFxuICAgIGlzTGFzdCxcbiAgICB0ZXh0LFxuICAgIHBhcmVudCxcbiAgICByZW5kZXJMZWFmID0gcHJvcHMgPT4gUmVhY3QuY3JlYXRlRWxlbWVudChEZWZhdWx0TGVhZiwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpKVxuICB9ID0gcHJvcHM7XG4gIHZhciBjaGlsZHJlbiA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3RyaW5nLCB7XG4gICAgaXNMYXN0OiBpc0xhc3QsXG4gICAgbGVhZjogbGVhZixcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICB0ZXh0OiB0ZXh0XG4gIH0pO1xuXG4gIGlmIChsZWFmW1BMQUNFSE9MREVSX1NZTUJPTF0pIHtcbiAgICBjaGlsZHJlbiA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgIGNvbnRlbnRFZGl0YWJsZTogZmFsc2UsXG4gICAgICBzdHlsZToge1xuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiAndGV4dC10b3AnLFxuICAgICAgICB3aWR0aDogJzAnLFxuICAgICAgICBtYXhXaWR0aDogJzEwMCUnLFxuICAgICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICAgICAgb3BhY2l0eTogJzAuMzMzJyxcbiAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgICBmb250U3R5bGU6ICdub3JtYWwnLFxuICAgICAgICBmb250V2VpZ2h0OiAnbm9ybWFsJyxcbiAgICAgICAgdGV4dERlY29yYXRpb246ICdub25lJ1xuICAgICAgfVxuICAgIH0sIGxlYWYucGxhY2Vob2xkZXIpLCBjaGlsZHJlbik7XG4gIH0gLy8gQ09NUEFUOiBIYXZpbmcgdGhlIGBkYXRhLWAgYXR0cmlidXRlcyBvbiB0aGVzZSBsZWFmIGVsZW1lbnRzIGVuc3VyZXMgdGhhdFxuICAvLyBpbiBjZXJ0YWluIG1pc2JlaGF2aW5nIGJyb3dzZXJzIHRoZXkgYXJlbid0IHdlaXJkbHkgY2xvbmVkL2Rlc3Ryb3llZCBieVxuICAvLyBjb250ZW50ZWRpdGFibGUgYmVoYXZpb3JzLiAoMjAxOS8wNS8wOClcblxuXG4gIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICdkYXRhLXNsYXRlLWxlYWYnOiB0cnVlXG4gIH07XG4gIHJldHVybiByZW5kZXJMZWFmKHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuLFxuICAgIGxlYWYsXG4gICAgdGV4dFxuICB9KTtcbn07XG5cbnZhciBNZW1vaXplZExlYWYgPSBSZWFjdC5tZW1vKExlYWYsIChwcmV2LCBuZXh0KSA9PiB7XG4gIHJldHVybiBuZXh0LnBhcmVudCA9PT0gcHJldi5wYXJlbnQgJiYgbmV4dC5pc0xhc3QgPT09IHByZXYuaXNMYXN0ICYmIG5leHQucmVuZGVyTGVhZiA9PT0gcHJldi5yZW5kZXJMZWFmICYmIG5leHQudGV4dCA9PT0gcHJldi50ZXh0ICYmIFRleHQkMS5tYXRjaGVzKG5leHQubGVhZiwgcHJldi5sZWFmKTtcbn0pO1xuLyoqXHJcbiAqIFRoZSBkZWZhdWx0IGN1c3RvbSBsZWFmIHJlbmRlcmVyLlxyXG4gKi9cblxudmFyIERlZmF1bHRMZWFmID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGF0dHJpYnV0ZXMsXG4gICAgY2hpbGRyZW5cbiAgfSA9IHByb3BzO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcyksIGNoaWxkcmVuKTtcbn07XG5cbi8qKlxyXG4gKiBQcmV2ZW50IHdhcm5pbmcgb24gU1NSIGJ5IGZhbGxpbmcgYmFjayB0byB1c2VFZmZlY3Qgd2hlbiB3aW5kb3cgaXMgbm90IGRlZmluZWRcclxuICovXG5cbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbi8qKlxyXG4gKiBUZXh0LlxyXG4gKi9cblxudmFyIFRleHQgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgZGVjb3JhdGlvbnMsXG4gICAgaXNMYXN0LFxuICAgIHBhcmVudCxcbiAgICByZW5kZXJMZWFmLFxuICAgIHRleHRcbiAgfSA9IHByb3BzO1xuICB2YXIgZWRpdG9yID0gdXNlRWRpdG9yKCk7XG4gIHZhciByZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBsZWF2ZXMgPSBUZXh0JDEuZGVjb3JhdGlvbnModGV4dCwgZGVjb3JhdGlvbnMpO1xuICB2YXIga2V5ID0gUmVhY3RFZGl0b3IuZmluZEtleShlZGl0b3IsIHRleHQpO1xuICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlYXZlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsZWFmID0gbGVhdmVzW2ldO1xuICAgIGNoaWxkcmVuLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudChNZW1vaXplZExlYWYsIHtcbiAgICAgIGlzTGFzdDogaXNMYXN0ICYmIGkgPT09IGxlYXZlcy5sZW5ndGggLSAxLFxuICAgICAga2V5OiBcIlwiLmNvbmNhdChrZXkuaWQsIFwiLVwiKS5jb25jYXQoaSksXG4gICAgICBsZWFmOiBsZWFmLFxuICAgICAgdGV4dDogdGV4dCxcbiAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgcmVuZGVyTGVhZjogcmVuZGVyTGVhZlxuICAgIH0pKTtcbiAgfSAvLyBVcGRhdGUgZWxlbWVudC1yZWxhdGVkIHdlYWsgbWFwcyB3aXRoIHRoZSBET00gZWxlbWVudCByZWYuXG5cblxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAocmVmLmN1cnJlbnQpIHtcbiAgICAgIEtFWV9UT19FTEVNRU5ULnNldChrZXksIHJlZi5jdXJyZW50KTtcbiAgICAgIE5PREVfVE9fRUxFTUVOVC5zZXQodGV4dCwgcmVmLmN1cnJlbnQpO1xuICAgICAgRUxFTUVOVF9UT19OT0RFLnNldChyZWYuY3VycmVudCwgdGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEtFWV9UT19FTEVNRU5ULmRlbGV0ZShrZXkpO1xuICAgICAgTk9ERV9UT19FTEVNRU5ULmRlbGV0ZSh0ZXh0KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIFwiZGF0YS1zbGF0ZS1ub2RlXCI6IFwidGV4dFwiLFxuICAgIHJlZjogcmVmXG4gIH0sIGNoaWxkcmVuKTtcbn07XG5cbnZhciBNZW1vaXplZFRleHQgPSBSZWFjdC5tZW1vKFRleHQsIChwcmV2LCBuZXh0KSA9PiB7XG4gIHJldHVybiBuZXh0LnBhcmVudCA9PT0gcHJldi5wYXJlbnQgJiYgbmV4dC5pc0xhc3QgPT09IHByZXYuaXNMYXN0ICYmIG5leHQucmVuZGVyTGVhZiA9PT0gcHJldi5yZW5kZXJMZWFmICYmIG5leHQudGV4dCA9PT0gcHJldi50ZXh0O1xufSk7XG5cbi8qKlxyXG4gKiBFbGVtZW50LlxyXG4gKi9cblxudmFyIEVsZW1lbnQgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgZGVjb3JhdGUsXG4gICAgZGVjb3JhdGlvbnMsXG4gICAgZWxlbWVudCxcbiAgICByZW5kZXJFbGVtZW50ID0gcCA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KERlZmF1bHRFbGVtZW50LCBPYmplY3QuYXNzaWduKHt9LCBwKSksXG4gICAgcmVuZGVyTGVhZixcbiAgICBzZWxlY3Rpb25cbiAgfSA9IHByb3BzO1xuICB2YXIgcmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgZWRpdG9yID0gdXNlRWRpdG9yKCk7XG4gIHZhciByZWFkT25seSA9IHVzZVJlYWRPbmx5KCk7XG4gIHZhciBpc0lubGluZSA9IGVkaXRvci5pc0lubGluZShlbGVtZW50KTtcbiAgdmFyIGtleSA9IFJlYWN0RWRpdG9yLmZpbmRLZXkoZWRpdG9yLCBlbGVtZW50KTtcbiAgdmFyIGNoaWxkcmVuID0gUmVhY3QuY3JlYXRlRWxlbWVudChDaGlsZHJlbiwge1xuICAgIGRlY29yYXRlOiBkZWNvcmF0ZSxcbiAgICBkZWNvcmF0aW9uczogZGVjb3JhdGlvbnMsXG4gICAgbm9kZTogZWxlbWVudCxcbiAgICByZW5kZXJFbGVtZW50OiByZW5kZXJFbGVtZW50LFxuICAgIHJlbmRlckxlYWY6IHJlbmRlckxlYWYsXG4gICAgc2VsZWN0aW9uOiBzZWxlY3Rpb25cbiAgfSk7IC8vIEF0dHJpYnV0ZXMgdGhhdCB0aGUgZGV2ZWxvcGVyIG11c3QgbWl4IGludG8gdGhlIGVsZW1lbnQgaW4gdGhlaXJcbiAgLy8gY3VzdG9tIG5vZGUgcmVuZGVyZXIgY29tcG9uZW50LlxuXG4gIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICdkYXRhLXNsYXRlLW5vZGUnOiAnZWxlbWVudCcsXG4gICAgcmVmXG4gIH07XG5cbiAgaWYgKGlzSW5saW5lKSB7XG4gICAgYXR0cmlidXRlc1snZGF0YS1zbGF0ZS1pbmxpbmUnXSA9IHRydWU7XG4gIH0gLy8gSWYgaXQncyBhIGJsb2NrIG5vZGUgd2l0aCBpbmxpbmUgY2hpbGRyZW4sIGFkZCB0aGUgcHJvcGVyIGBkaXJgIGF0dHJpYnV0ZVxuICAvLyBmb3IgdGV4dCBkaXJlY3Rpb24uXG5cblxuICBpZiAoIWlzSW5saW5lICYmIEVkaXRvci5oYXNJbmxpbmVzKGVkaXRvciwgZWxlbWVudCkpIHtcbiAgICB2YXIgdGV4dCA9IE5vZGUkMS5zdHJpbmcoZWxlbWVudCk7XG4gICAgdmFyIGRpciA9IGdldERpcmVjdGlvbih0ZXh0KTtcblxuICAgIGlmIChkaXIgPT09ICdydGwnKSB7XG4gICAgICBhdHRyaWJ1dGVzLmRpciA9IGRpcjtcbiAgICB9XG4gIH0gLy8gSWYgaXQncyBhIHZvaWQgbm9kZSwgd3JhcCB0aGUgY2hpbGRyZW4gaW4gZXh0cmEgdm9pZC1zcGVjaWZpYyBlbGVtZW50cy5cblxuXG4gIGlmIChFZGl0b3IuaXNWb2lkKGVkaXRvciwgZWxlbWVudCkpIHtcbiAgICBhdHRyaWJ1dGVzWydkYXRhLXNsYXRlLXZvaWQnXSA9IHRydWU7XG5cbiAgICBpZiAoIXJlYWRPbmx5ICYmIGlzSW5saW5lKSB7XG4gICAgICBhdHRyaWJ1dGVzLmNvbnRlbnRFZGl0YWJsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBUYWcgPSBpc0lubGluZSA/ICdzcGFuJyA6ICdkaXYnO1xuICAgIHZhciBbW190ZXh0XV0gPSBOb2RlJDEudGV4dHMoZWxlbWVudCk7XG4gICAgY2hpbGRyZW4gPSByZWFkT25seSA/IG51bGwgOiBSZWFjdC5jcmVhdGVFbGVtZW50KFRhZywge1xuICAgICAgXCJkYXRhLXNsYXRlLXNwYWNlclwiOiB0cnVlLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgaGVpZ2h0OiAnMCcsXG4gICAgICAgIGNvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgICB9XG4gICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChNZW1vaXplZFRleHQsIHtcbiAgICAgIGRlY29yYXRpb25zOiBbXSxcbiAgICAgIGlzTGFzdDogZmFsc2UsXG4gICAgICBwYXJlbnQ6IGVsZW1lbnQsXG4gICAgICB0ZXh0OiBfdGV4dFxuICAgIH0pKTtcbiAgICBOT0RFX1RPX0lOREVYLnNldChfdGV4dCwgMCk7XG4gICAgTk9ERV9UT19QQVJFTlQuc2V0KF90ZXh0LCBlbGVtZW50KTtcbiAgfSAvLyBVcGRhdGUgZWxlbWVudC1yZWxhdGVkIHdlYWsgbWFwcyB3aXRoIHRoZSBET00gZWxlbWVudCByZWYuXG5cblxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAocmVmLmN1cnJlbnQpIHtcbiAgICAgIEtFWV9UT19FTEVNRU5ULnNldChrZXksIHJlZi5jdXJyZW50KTtcbiAgICAgIE5PREVfVE9fRUxFTUVOVC5zZXQoZWxlbWVudCwgcmVmLmN1cnJlbnQpO1xuICAgICAgRUxFTUVOVF9UT19OT0RFLnNldChyZWYuY3VycmVudCwgZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEtFWV9UT19FTEVNRU5ULmRlbGV0ZShrZXkpO1xuICAgICAgTk9ERV9UT19FTEVNRU5ULmRlbGV0ZShlbGVtZW50KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChTZWxlY3RlZENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogISFzZWxlY3Rpb25cbiAgfSwgcmVuZGVyRWxlbWVudCh7XG4gICAgYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlbixcbiAgICBlbGVtZW50XG4gIH0pKTtcbn07XG5cbnZhciBNZW1vaXplZEVsZW1lbnQgPSBSZWFjdC5tZW1vKEVsZW1lbnQsIChwcmV2LCBuZXh0KSA9PiB7XG4gIHJldHVybiBwcmV2LmRlY29yYXRlID09PSBuZXh0LmRlY29yYXRlICYmIHByZXYuZWxlbWVudCA9PT0gbmV4dC5lbGVtZW50ICYmIHByZXYucmVuZGVyRWxlbWVudCA9PT0gbmV4dC5yZW5kZXJFbGVtZW50ICYmIHByZXYucmVuZGVyTGVhZiA9PT0gbmV4dC5yZW5kZXJMZWFmICYmIGlzUmFuZ2VMaXN0RXF1YWwocHJldi5kZWNvcmF0aW9ucywgbmV4dC5kZWNvcmF0aW9ucykgJiYgKHByZXYuc2VsZWN0aW9uID09PSBuZXh0LnNlbGVjdGlvbiB8fCAhIXByZXYuc2VsZWN0aW9uICYmICEhbmV4dC5zZWxlY3Rpb24gJiYgUmFuZ2UuZXF1YWxzKHByZXYuc2VsZWN0aW9uLCBuZXh0LnNlbGVjdGlvbikpO1xufSk7XG4vKipcclxuICogVGhlIGRlZmF1bHQgZWxlbWVudCByZW5kZXJlci5cclxuICovXG5cbnZhciBEZWZhdWx0RWxlbWVudCA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuLFxuICAgIGVsZW1lbnRcbiAgfSA9IHByb3BzO1xuICB2YXIgZWRpdG9yID0gdXNlRWRpdG9yKCk7XG4gIHZhciBUYWcgPSBlZGl0b3IuaXNJbmxpbmUoZWxlbWVudCkgPyAnc3BhbicgOiAnZGl2JztcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGFnLCBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgfVxuICB9KSwgY2hpbGRyZW4pO1xufTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhIGxpc3Qgb2YgcmFuZ2VzIGlzIGVxdWFsIHRvIGFub3RoZXIuXHJcbiAqXHJcbiAqIFBFUkY6IHRoaXMgcmVxdWlyZXMgdGhlIHR3byBsaXN0cyB0byBhbHNvIGhhdmUgdGhlIHJhbmdlcyBpbnNpZGUgdGhlbSBpbiB0aGVcclxuICogc2FtZSBvcmRlciwgYnV0IHRoaXMgaXMgYW4gb2theSBjb25zdHJhaW50IGZvciB1cyBzaW5jZSBkZWNvcmF0aW9ucyBhcmVcclxuICoga2VwdCBpbiBvcmRlciwgYW5kIHRoZSBvZGQgY2FzZSB3aGVyZSB0aGV5IGFyZW4ndCBpcyBva2F5IHRvIHJlLXJlbmRlciBmb3IuXHJcbiAqL1xuXG52YXIgaXNSYW5nZUxpc3RFcXVhbCA9IChsaXN0LCBhbm90aGVyKSA9PiB7XG4gIGlmIChsaXN0Lmxlbmd0aCAhPT0gYW5vdGhlci5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmFuZ2UgPSBsaXN0W2ldO1xuICAgIHZhciBvdGhlciA9IGFub3RoZXJbaV07XG5cbiAgICBpZiAoIVJhbmdlLmVxdWFscyhyYW5nZSwgb3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcclxuICogQ2hpbGRyZW4uXHJcbiAqL1xuXG52YXIgQ2hpbGRyZW4gPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgZGVjb3JhdGUsXG4gICAgZGVjb3JhdGlvbnMsXG4gICAgbm9kZSxcbiAgICByZW5kZXJFbGVtZW50LFxuICAgIHJlbmRlckxlYWYsXG4gICAgc2VsZWN0aW9uXG4gIH0gPSBwcm9wcztcbiAgdmFyIGVkaXRvciA9IHVzZUVkaXRvcigpO1xuICB2YXIgcGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgbm9kZSk7XG4gIHZhciBjaGlsZHJlbiA9IFtdO1xuICB2YXIgaXNMZWFmQmxvY2sgPSBFbGVtZW50JDEuaXNFbGVtZW50KG5vZGUpICYmICFlZGl0b3IuaXNJbmxpbmUobm9kZSkgJiYgRWRpdG9yLmhhc0lubGluZXMoZWRpdG9yLCBub2RlKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IHBhdGguY29uY2F0KGkpO1xuICAgIHZhciBuID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICB2YXIga2V5ID0gUmVhY3RFZGl0b3IuZmluZEtleShlZGl0b3IsIG4pO1xuICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHApO1xuICAgIHZhciBzZWwgPSBzZWxlY3Rpb24gJiYgUmFuZ2UuaW50ZXJzZWN0aW9uKHJhbmdlLCBzZWxlY3Rpb24pO1xuICAgIHZhciBkcyA9IGRlY29yYXRlKFtuLCBwXSk7XG5cbiAgICBmb3IgKHZhciBkZWMgb2YgZGVjb3JhdGlvbnMpIHtcbiAgICAgIHZhciBkID0gUmFuZ2UuaW50ZXJzZWN0aW9uKGRlYywgcmFuZ2UpO1xuXG4gICAgICBpZiAoZCkge1xuICAgICAgICBkcy5wdXNoKGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChFbGVtZW50JDEuaXNFbGVtZW50KG4pKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtb2l6ZWRFbGVtZW50LCB7XG4gICAgICAgIGRlY29yYXRlOiBkZWNvcmF0ZSxcbiAgICAgICAgZGVjb3JhdGlvbnM6IGRzLFxuICAgICAgICBlbGVtZW50OiBuLFxuICAgICAgICBrZXk6IGtleS5pZCxcbiAgICAgICAgcmVuZGVyRWxlbWVudDogcmVuZGVyRWxlbWVudCxcbiAgICAgICAgcmVuZGVyTGVhZjogcmVuZGVyTGVhZixcbiAgICAgICAgc2VsZWN0aW9uOiBzZWxcbiAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGRyZW4ucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KE1lbW9pemVkVGV4dCwge1xuICAgICAgICBkZWNvcmF0aW9uczogZHMsXG4gICAgICAgIGtleToga2V5LmlkLFxuICAgICAgICBpc0xhc3Q6IGlzTGVhZkJsb2NrICYmIGkgPT09IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMSxcbiAgICAgICAgcGFyZW50OiBub2RlLFxuICAgICAgICByZW5kZXJMZWFmOiByZW5kZXJMZWFmLFxuICAgICAgICB0ZXh0OiBuXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgTk9ERV9UT19JTkRFWC5zZXQobiwgaSk7XG4gICAgTk9ERV9UT19QQVJFTlQuc2V0KG4sIG5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn07XG5cbnZhciBJU19JT1MgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtO1xudmFyIElTX0FQUExFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL01hYyBPUyBYLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIElTX0ZJUkVGT1ggPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvXig/IS4qU2VhbW9ua2V5KSg/PS4qRmlyZWZveCkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgSVNfU0FGQVJJID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL1ZlcnNpb25cXC9bXFxkXFwuXSsuKlNhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gXCJtb2Rlcm5cIiBFZGdlIHdhcyByZWxlYXNlZCBhdCA3OS54XG5cbnZhciBJU19FREdFX0xFR0FDWSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9FZGdlP1xcLyg/OlswLTZdWzAtOV18WzAtN11bMC04XSkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcclxuICogSG90a2V5IG1hcHBpbmdzIGZvciBlYWNoIHBsYXRmb3JtLlxyXG4gKi9cblxudmFyIEhPVEtFWVMgPSB7XG4gIGJvbGQ6ICdtb2QrYicsXG4gIGNvbXBvc2U6IFsnZG93bicsICdsZWZ0JywgJ3JpZ2h0JywgJ3VwJywgJ2JhY2tzcGFjZScsICdlbnRlciddLFxuICBtb3ZlQmFja3dhcmQ6ICdsZWZ0JyxcbiAgbW92ZUZvcndhcmQ6ICdyaWdodCcsXG4gIG1vdmVXb3JkQmFja3dhcmQ6ICdjdHJsK2xlZnQnLFxuICBtb3ZlV29yZEZvcndhcmQ6ICdjdHJsK3JpZ2h0JyxcbiAgZGVsZXRlQmFja3dhcmQ6ICdzaGlmdD8rYmFja3NwYWNlJyxcbiAgZGVsZXRlRm9yd2FyZDogJ3NoaWZ0PytkZWxldGUnLFxuICBleHRlbmRCYWNrd2FyZDogJ3NoaWZ0K2xlZnQnLFxuICBleHRlbmRGb3J3YXJkOiAnc2hpZnQrcmlnaHQnLFxuICBpdGFsaWM6ICdtb2QraScsXG4gIHNwbGl0QmxvY2s6ICdzaGlmdD8rZW50ZXInLFxuICB1bmRvOiAnbW9kK3onXG59O1xudmFyIEFQUExFX0hPVEtFWVMgPSB7XG4gIG1vdmVMaW5lQmFja3dhcmQ6ICdvcHQrdXAnLFxuICBtb3ZlTGluZUZvcndhcmQ6ICdvcHQrZG93bicsXG4gIG1vdmVXb3JkQmFja3dhcmQ6ICdvcHQrbGVmdCcsXG4gIG1vdmVXb3JkRm9yd2FyZDogJ29wdCtyaWdodCcsXG4gIGRlbGV0ZUJhY2t3YXJkOiBbJ2N0cmwrYmFja3NwYWNlJywgJ2N0cmwraCddLFxuICBkZWxldGVGb3J3YXJkOiBbJ2N0cmwrZGVsZXRlJywgJ2N0cmwrZCddLFxuICBkZWxldGVMaW5lQmFja3dhcmQ6ICdjbWQrc2hpZnQ/K2JhY2tzcGFjZScsXG4gIGRlbGV0ZUxpbmVGb3J3YXJkOiBbJ2NtZCtzaGlmdD8rZGVsZXRlJywgJ2N0cmwrayddLFxuICBkZWxldGVXb3JkQmFja3dhcmQ6ICdvcHQrc2hpZnQ/K2JhY2tzcGFjZScsXG4gIGRlbGV0ZVdvcmRGb3J3YXJkOiAnb3B0K3NoaWZ0PytkZWxldGUnLFxuICBleHRlbmRMaW5lQmFja3dhcmQ6ICdvcHQrc2hpZnQrdXAnLFxuICBleHRlbmRMaW5lRm9yd2FyZDogJ29wdCtzaGlmdCtkb3duJyxcbiAgcmVkbzogJ2NtZCtzaGlmdCt6JyxcbiAgdHJhbnNwb3NlQ2hhcmFjdGVyOiAnY3RybCt0J1xufTtcbnZhciBXSU5ET1dTX0hPVEtFWVMgPSB7XG4gIGRlbGV0ZVdvcmRCYWNrd2FyZDogJ2N0cmwrc2hpZnQ/K2JhY2tzcGFjZScsXG4gIGRlbGV0ZVdvcmRGb3J3YXJkOiAnY3RybCtzaGlmdD8rZGVsZXRlJyxcbiAgcmVkbzogWydjdHJsK3knLCAnY3RybCtzaGlmdCt6J11cbn07XG4vKipcclxuICogQ3JlYXRlIGEgcGxhdGZvcm0tYXdhcmUgaG90a2V5IGNoZWNrZXIuXHJcbiAqL1xuXG52YXIgY3JlYXRlID0ga2V5ID0+IHtcbiAgdmFyIGdlbmVyaWMgPSBIT1RLRVlTW2tleV07XG4gIHZhciBhcHBsZSA9IEFQUExFX0hPVEtFWVNba2V5XTtcbiAgdmFyIHdpbmRvd3MgPSBXSU5ET1dTX0hPVEtFWVNba2V5XTtcbiAgdmFyIGlzR2VuZXJpYyA9IGdlbmVyaWMgJiYgaXNLZXlIb3RrZXkoZ2VuZXJpYyk7XG4gIHZhciBpc0FwcGxlID0gYXBwbGUgJiYgaXNLZXlIb3RrZXkoYXBwbGUpO1xuICB2YXIgaXNXaW5kb3dzID0gd2luZG93cyAmJiBpc0tleUhvdGtleSh3aW5kb3dzKTtcbiAgcmV0dXJuIGV2ZW50ID0+IHtcbiAgICBpZiAoaXNHZW5lcmljICYmIGlzR2VuZXJpYyhldmVudCkpIHJldHVybiB0cnVlO1xuICAgIGlmIChJU19BUFBMRSAmJiBpc0FwcGxlICYmIGlzQXBwbGUoZXZlbnQpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIUlTX0FQUExFICYmIGlzV2luZG93cyAmJiBpc1dpbmRvd3MoZXZlbnQpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59O1xuLyoqXHJcbiAqIEhvdGtleXMuXHJcbiAqL1xuXG5cbnZhciBIb3RrZXlzID0ge1xuICBpc0JvbGQ6IGNyZWF0ZSgnYm9sZCcpLFxuICBpc0NvbXBvc2U6IGNyZWF0ZSgnY29tcG9zZScpLFxuICBpc01vdmVCYWNrd2FyZDogY3JlYXRlKCdtb3ZlQmFja3dhcmQnKSxcbiAgaXNNb3ZlRm9yd2FyZDogY3JlYXRlKCdtb3ZlRm9yd2FyZCcpLFxuICBpc0RlbGV0ZUJhY2t3YXJkOiBjcmVhdGUoJ2RlbGV0ZUJhY2t3YXJkJyksXG4gIGlzRGVsZXRlRm9yd2FyZDogY3JlYXRlKCdkZWxldGVGb3J3YXJkJyksXG4gIGlzRGVsZXRlTGluZUJhY2t3YXJkOiBjcmVhdGUoJ2RlbGV0ZUxpbmVCYWNrd2FyZCcpLFxuICBpc0RlbGV0ZUxpbmVGb3J3YXJkOiBjcmVhdGUoJ2RlbGV0ZUxpbmVGb3J3YXJkJyksXG4gIGlzRGVsZXRlV29yZEJhY2t3YXJkOiBjcmVhdGUoJ2RlbGV0ZVdvcmRCYWNrd2FyZCcpLFxuICBpc0RlbGV0ZVdvcmRGb3J3YXJkOiBjcmVhdGUoJ2RlbGV0ZVdvcmRGb3J3YXJkJyksXG4gIGlzRXh0ZW5kQmFja3dhcmQ6IGNyZWF0ZSgnZXh0ZW5kQmFja3dhcmQnKSxcbiAgaXNFeHRlbmRGb3J3YXJkOiBjcmVhdGUoJ2V4dGVuZEZvcndhcmQnKSxcbiAgaXNFeHRlbmRMaW5lQmFja3dhcmQ6IGNyZWF0ZSgnZXh0ZW5kTGluZUJhY2t3YXJkJyksXG4gIGlzRXh0ZW5kTGluZUZvcndhcmQ6IGNyZWF0ZSgnZXh0ZW5kTGluZUZvcndhcmQnKSxcbiAgaXNJdGFsaWM6IGNyZWF0ZSgnaXRhbGljJyksXG4gIGlzTW92ZUxpbmVCYWNrd2FyZDogY3JlYXRlKCdtb3ZlTGluZUJhY2t3YXJkJyksXG4gIGlzTW92ZUxpbmVGb3J3YXJkOiBjcmVhdGUoJ21vdmVMaW5lRm9yd2FyZCcpLFxuICBpc01vdmVXb3JkQmFja3dhcmQ6IGNyZWF0ZSgnbW92ZVdvcmRCYWNrd2FyZCcpLFxuICBpc01vdmVXb3JkRm9yd2FyZDogY3JlYXRlKCdtb3ZlV29yZEZvcndhcmQnKSxcbiAgaXNSZWRvOiBjcmVhdGUoJ3JlZG8nKSxcbiAgaXNTcGxpdEJsb2NrOiBjcmVhdGUoJ3NwbGl0QmxvY2snKSxcbiAgaXNUcmFuc3Bvc2VDaGFyYWN0ZXI6IGNyZWF0ZSgndHJhbnNwb3NlQ2hhcmFjdGVyJyksXG4gIGlzVW5kbzogY3JlYXRlKCd1bmRvJylcbn07XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUID0gIShJU19GSVJFRk9YIHx8IElTX0VER0VfTEVHQUNZKTtcbi8qKlxyXG4gKiBFZGl0YWJsZS5cclxuICovXG5cbnZhciBFZGl0YWJsZSA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBhdXRvRm9jdXMsXG4gICAgZGVjb3JhdGUgPSBkZWZhdWx0RGVjb3JhdGUsXG4gICAgb25ET01CZWZvcmVJbnB1dDogcHJvcHNPbkRPTUJlZm9yZUlucHV0LFxuICAgIHBsYWNlaG9sZGVyLFxuICAgIHJlYWRPbmx5ID0gZmFsc2UsXG4gICAgcmVuZGVyRWxlbWVudCxcbiAgICByZW5kZXJMZWFmLFxuICAgIHN0eWxlID0ge30sXG4gICAgYXM6IENvbXBvbmVudCA9ICdkaXYnXG4gIH0gPSBwcm9wcyxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImF1dG9Gb2N1c1wiLCBcImRlY29yYXRlXCIsIFwib25ET01CZWZvcmVJbnB1dFwiLCBcInBsYWNlaG9sZGVyXCIsIFwicmVhZE9ubHlcIiwgXCJyZW5kZXJFbGVtZW50XCIsIFwicmVuZGVyTGVhZlwiLCBcInN0eWxlXCIsIFwiYXNcIl0pO1xuXG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZSgpO1xuICB2YXIgcmVmID0gdXNlUmVmKG51bGwpOyAvLyBVcGRhdGUgaW50ZXJuYWwgc3RhdGUgb24gZWFjaCByZW5kZXIuXG5cbiAgSVNfUkVBRF9PTkxZLnNldChlZGl0b3IsIHJlYWRPbmx5KTsgLy8gS2VlcCB0cmFjayBvZiBzb21lIHN0YXRlIGZvciB0aGUgZXZlbnQgaGFuZGxlciBsb2dpYy5cblxuICB2YXIgc3RhdGUgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgaXNDb21wb3Npbmc6IGZhbHNlLFxuICAgIGlzVXBkYXRpbmdTZWxlY3Rpb246IGZhbHNlLFxuICAgIGxhdGVzdEVsZW1lbnQ6IG51bGxcbiAgfSksIFtdKTsgLy8gVXBkYXRlIGVsZW1lbnQtcmVsYXRlZCB3ZWFrIG1hcHMgd2l0aCB0aGUgRE9NIGVsZW1lbnQgcmVmLlxuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudCkge1xuICAgICAgRURJVE9SX1RPX0VMRU1FTlQuc2V0KGVkaXRvciwgcmVmLmN1cnJlbnQpO1xuICAgICAgTk9ERV9UT19FTEVNRU5ULnNldChlZGl0b3IsIHJlZi5jdXJyZW50KTtcbiAgICAgIEVMRU1FTlRfVE9fTk9ERS5zZXQocmVmLmN1cnJlbnQsIGVkaXRvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIE5PREVfVE9fRUxFTUVOVC5kZWxldGUoZWRpdG9yKTtcbiAgICB9XG4gIH0pOyAvLyBXaGVuZXZlciB0aGUgZWRpdG9yIHVwZGF0ZXMsIG1ha2Ugc3VyZSB0aGUgRE9NIHNlbGVjdGlvbiBzdGF0ZSBpcyBpbiBzeW5jLlxuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICBzZWxlY3Rpb25cbiAgICB9ID0gZWRpdG9yO1xuICAgIHZhciBkb21TZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoc3RhdGUuaXNDb21wb3NpbmcgfHwgIWRvbVNlbGVjdGlvbiB8fCAhUmVhY3RFZGl0b3IuaXNGb2N1c2VkKGVkaXRvcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaGFzRG9tU2VsZWN0aW9uID0gZG9tU2VsZWN0aW9uLnR5cGUgIT09ICdOb25lJzsgLy8gSWYgdGhlIERPTSBzZWxlY3Rpb24gaXMgcHJvcGVybHkgdW5zZXQsIHdlJ3JlIGRvbmUuXG5cbiAgICBpZiAoIXNlbGVjdGlvbiAmJiAhaGFzRG9tU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyB2ZXJpZnkgdGhhdCB0aGUgZG9tIHNlbGVjdGlvbiBpcyBpbiB0aGUgZWRpdG9yXG5cblxuICAgIHZhciBlZGl0b3JFbGVtZW50ID0gRURJVE9SX1RPX0VMRU1FTlQuZ2V0KGVkaXRvcik7XG4gICAgdmFyIGhhc0RvbVNlbGVjdGlvbkluRWRpdG9yID0gZmFsc2U7XG5cbiAgICBpZiAoZWRpdG9yRWxlbWVudC5jb250YWlucyhkb21TZWxlY3Rpb24uYW5jaG9yTm9kZSkgJiYgZWRpdG9yRWxlbWVudC5jb250YWlucyhkb21TZWxlY3Rpb24uZm9jdXNOb2RlKSkge1xuICAgICAgaGFzRG9tU2VsZWN0aW9uSW5FZGl0b3IgPSB0cnVlO1xuICAgIH0gLy8gSWYgdGhlIERPTSBzZWxlY3Rpb24gaXMgaW4gdGhlIGVkaXRvciBhbmQgdGhlIGVkaXRvciBzZWxlY3Rpb24gaXMgYWxyZWFkeSBjb3JyZWN0LCB3ZSdyZSBkb25lLlxuXG5cbiAgICBpZiAoaGFzRG9tU2VsZWN0aW9uICYmIGhhc0RvbVNlbGVjdGlvbkluRWRpdG9yICYmIHNlbGVjdGlvbiAmJiBSYW5nZS5lcXVhbHMoUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgZG9tU2VsZWN0aW9uKSwgc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gT3RoZXJ3aXNlIHRoZSBET00gc2VsZWN0aW9uIGlzIG91dCBvZiBzeW5jLCBzbyB1cGRhdGUgaXQuXG5cblxuICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiA9IHRydWU7XG4gICAgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIHZhciBuZXdEb21SYW5nZSA9IHNlbGVjdGlvbiAmJiBSZWFjdEVkaXRvci50b0RPTVJhbmdlKGVkaXRvciwgc2VsZWN0aW9uKTtcblxuICAgIGlmIChuZXdEb21SYW5nZSkge1xuICAgICAgZG9tU2VsZWN0aW9uLmFkZFJhbmdlKG5ld0RvbVJhbmdlKTtcbiAgICAgIHZhciBsZWFmRWwgPSBuZXdEb21SYW5nZS5zdGFydENvbnRhaW5lci5wYXJlbnRFbGVtZW50O1xuICAgICAgc2Nyb2xsSW50b1ZpZXcobGVhZkVsLCB7XG4gICAgICAgIHNjcm9sbE1vZGU6ICdpZi1uZWVkZWQnLFxuICAgICAgICBib3VuZGFyeTogZWxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgLy8gQ09NUEFUOiBJbiBGaXJlZm94LCBpdCdzIG5vdCBlbm91Z2ggdG8gY3JlYXRlIGEgcmFuZ2UsIHlvdSBhbHNvIG5lZWRcbiAgICAgIC8vIHRvIGZvY3VzIHRoZSBjb250ZW50ZWRpdGFibGUgZWxlbWVudCB0b28uICgyMDE2LzExLzE2KVxuICAgICAgaWYgKG5ld0RvbVJhbmdlICYmIElTX0ZJUkVGT1gpIHtcbiAgICAgICAgZWwuZm9jdXMoKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiA9IGZhbHNlO1xuICAgIH0pO1xuICB9KTsgLy8gVGhlIGF1dG9Gb2N1cyBUZXh0YXJlYUhUTUxBdHRyaWJ1dGUgZG9lc24ndCBkbyBhbnl0aGluZyBvbiBhIGRpdiwgc28gaXRcbiAgLy8gbmVlZHMgdG8gYmUgbWFudWFsbHkgZm9jdXNlZC5cblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudCAmJiBhdXRvRm9jdXMpIHtcbiAgICAgIHJlZi5jdXJyZW50LmZvY3VzKCk7XG4gICAgfVxuICB9LCBbYXV0b0ZvY3VzXSk7IC8vIExpc3RlbiBvbiB0aGUgbmF0aXZlIGBiZWZvcmVpbnB1dGAgZXZlbnQgdG8gZ2V0IHJlYWwgXCJMZXZlbCAyXCIgZXZlbnRzLiBUaGlzXG4gIC8vIGlzIHJlcXVpcmVkIGJlY2F1c2UgUmVhY3QncyBgYmVmb3JlaW5wdXRgIGlzIGZha2UgYW5kIG5ldmVyIHJlYWxseSBhdHRhY2hlc1xuICAvLyB0byB0aGUgcmVhbCBldmVudCBzYWRseS4gKDIwMTkvMTEvMDEpXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTEyMTFcblxuICB2YXIgb25ET01CZWZvcmVJbnB1dCA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICBpZiAoIXJlYWRPbmx5ICYmIGhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNET01FdmVudEhhbmRsZWQoZXZlbnQsIHByb3BzT25ET01CZWZvcmVJbnB1dCkpIHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcbiAgICAgIHZhciB7XG4gICAgICAgIGlucHV0VHlwZTogdHlwZVxuICAgICAgfSA9IGV2ZW50O1xuICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhVHJhbnNmZXIgfHwgZXZlbnQuZGF0YSB8fCB1bmRlZmluZWQ7IC8vIFRoZXNlIHR3byB0eXBlcyBvY2N1ciB3aGlsZSBhIHVzZXIgaXMgY29tcG9zaW5nIHRleHQgYW5kIGNhbid0IGJlXG4gICAgICAvLyBjYW5jZWxsZWQuIExldCB0aGVtIHRocm91Z2ggYW5kIHdhaXQgZm9yIHRoZSBjb21wb3NpdGlvbiB0byBlbmQuXG5cbiAgICAgIGlmICh0eXBlID09PSAnaW5zZXJ0Q29tcG9zaXRpb25UZXh0JyB8fCB0eXBlID09PSAnZGVsZXRlQ29tcG9zaXRpb25UZXh0Jykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIENPTVBBVDogRm9yIHRoZSBkZWxldGluZyBmb3J3YXJkL2JhY2t3YXJkIGlucHV0IHR5cGVzIHdlIGRvbid0IHdhbnRcbiAgICAgIC8vIHRvIGNoYW5nZSB0aGUgc2VsZWN0aW9uIGJlY2F1c2UgaXQgaXMgdGhlIHJhbmdlIHRoYXQgd2lsbCBiZSBkZWxldGVkLFxuICAgICAgLy8gYW5kIHRob3NlIGNvbW1hbmRzIGRldGVybWluZSB0aGF0IGZvciB0aGVtc2VsdmVzLlxuXG4gICAgICBpZiAoIXR5cGUuc3RhcnRzV2l0aCgnZGVsZXRlJykgfHwgdHlwZS5zdGFydHNXaXRoKCdkZWxldGVCeScpKSB7XG4gICAgICAgIHZhciBbdGFyZ2V0UmFuZ2VdID0gZXZlbnQuZ2V0VGFyZ2V0UmFuZ2VzKCk7XG5cbiAgICAgICAgaWYgKHRhcmdldFJhbmdlKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgdGFyZ2V0UmFuZ2UpO1xuXG4gICAgICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgIVJhbmdlLmVxdWFscyhzZWxlY3Rpb24sIHJhbmdlKSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCByYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIENPTVBBVDogSWYgdGhlIHNlbGVjdGlvbiBpcyBleHBhbmRlZCwgZXZlbiBpZiB0aGUgY29tbWFuZCBzZWVtcyBsaWtlXG4gICAgICAvLyBhIGRlbGV0ZSBmb3J3YXJkL2JhY2t3YXJkIGNvbW1hbmQgaXQgc2hvdWxkIGRlbGV0ZSB0aGUgc2VsZWN0aW9uLlxuXG5cbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pICYmIHR5cGUuc3RhcnRzV2l0aCgnZGVsZXRlJykpIHtcbiAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2RlbGV0ZUJ5Q29tcG9zaXRpb24nOlxuICAgICAgICBjYXNlICdkZWxldGVCeUN1dCc6XG4gICAgICAgIGNhc2UgJ2RlbGV0ZUJ5RHJhZyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGVsZXRlQ29udGVudCc6XG4gICAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnRGb3J3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnRCYWNrd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGVsZXRlRW50aXJlU29mdExpbmUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RlbGV0ZUhhcmRMaW5lQmFja3dhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2Jsb2NrJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGVsZXRlU29mdExpbmVCYWNrd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RlbGV0ZUhhcmRMaW5lRm9yd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdibG9jaydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RlbGV0ZVNvZnRMaW5lRm9yd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGVsZXRlV29yZEJhY2t3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICd3b3JkJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGVsZXRlV29yZEZvcndhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnd29yZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2luc2VydExpbmVCcmVhayc6XG4gICAgICAgIGNhc2UgJ2luc2VydFBhcmFncmFwaCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmluc2VydEJyZWFrKGVkaXRvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnaW5zZXJ0RnJvbUNvbXBvc2l0aW9uJzpcbiAgICAgICAgY2FzZSAnaW5zZXJ0RnJvbURyb3AnOlxuICAgICAgICBjYXNlICdpbnNlcnRGcm9tUGFzdGUnOlxuICAgICAgICBjYXNlICdpbnNlcnRGcm9tWWFuayc6XG4gICAgICAgIGNhc2UgJ2luc2VydFJlcGxhY2VtZW50VGV4dCc6XG4gICAgICAgIGNhc2UgJ2luc2VydFRleHQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRGF0YVRyYW5zZmVyKSB7XG4gICAgICAgICAgICAgIFJlYWN0RWRpdG9yLmluc2VydERhdGEoZWRpdG9yLCBkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIEVkaXRvci5pbnNlcnRUZXh0KGVkaXRvciwgZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIFtyZWFkT25seV0pOyAvLyBBdHRhY2ggYSBuYXRpdmUgRE9NIGV2ZW50IGhhbmRsZXIgZm9yIGBiZWZvcmVpbnB1dGAgZXZlbnRzLCBiZWNhdXNlIFJlYWN0J3NcbiAgLy8gYnVpbHQtaW4gYG9uQmVmb3JlSW5wdXRgIGlzIGFjdHVhbGx5IGEgbGVha3kgcG9seWZpbGwgdGhhdCBkb2Vzbid0IGV4cG9zZVxuICAvLyByZWFsIGBiZWZvcmVpbnB1dGAgZXZlbnRzIHNhZGx5Li4uICgyMDE5LzExLzA0KVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzExMjExXG5cbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50KSB7XG4gICAgICAvLyBAdHMtaWdub3JlIFRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50IGlzbid0IHJlY29nbml6ZWQuXG4gICAgICByZWYuY3VycmVudC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmVpbnB1dCcsIG9uRE9NQmVmb3JlSW5wdXQpO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAocmVmLmN1cnJlbnQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBUaGUgYGJlZm9yZWlucHV0YCBldmVudCBpc24ndCByZWNvZ25pemVkLlxuICAgICAgICByZWYuY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdiZWZvcmVpbnB1dCcsIG9uRE9NQmVmb3JlSW5wdXQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtvbkRPTUJlZm9yZUlucHV0XSk7IC8vIExpc3RlbiBvbiB0aGUgbmF0aXZlIGBzZWxlY3Rpb25jaGFuZ2VgIGV2ZW50IHRvIGJlIGFibGUgdG8gdXBkYXRlIGFueSB0aW1lXG4gIC8vIHRoZSBzZWxlY3Rpb24gY2hhbmdlcy4gVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIFJlYWN0J3MgYG9uU2VsZWN0YCBpcyBsZWFreVxuICAvLyBhbmQgbm9uLXN0YW5kYXJkIHNvIGl0IGRvZXNuJ3QgZmlyZSB1bnRpbCBhZnRlciBhIHNlbGVjdGlvbiBoYXMgYmVlblxuICAvLyByZWxlYXNlZC4gVGhpcyBjYXVzZXMgaXNzdWVzIGluIHNpdHVhdGlvbnMgd2hlcmUgYW5vdGhlciBjaGFuZ2UgaGFwcGVuc1xuICAvLyB3aGlsZSBhIHNlbGVjdGlvbiBpcyBiZWluZyBkcmFnZ2VkLlxuXG4gIHZhciBvbkRPTVNlbGVjdGlvbkNoYW5nZSA9IHVzZUNhbGxiYWNrKHRocm90dGxlKCgpID0+IHtcbiAgICBpZiAoIXJlYWRPbmx5ICYmICFzdGF0ZS5pc0NvbXBvc2luZyAmJiAhc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbikge1xuICAgICAgdmFyIHtcbiAgICAgICAgYWN0aXZlRWxlbWVudFxuICAgICAgfSA9IHdpbmRvdy5kb2N1bWVudDtcbiAgICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgICB2YXIgZG9tU2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gZWwpIHtcbiAgICAgICAgc3RhdGUubGF0ZXN0RWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIElTX0ZPQ1VTRUQuc2V0KGVkaXRvciwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBJU19GT0NVU0VELmRlbGV0ZShlZGl0b3IpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRvbVNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpO1xuICAgICAgfVxuXG4gICAgICB2YXIge1xuICAgICAgICBhbmNob3JOb2RlLFxuICAgICAgICBmb2N1c05vZGVcbiAgICAgIH0gPSBkb21TZWxlY3Rpb247XG4gICAgICB2YXIgYW5jaG9yTm9kZVNlbGVjdGFibGUgPSBoYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIGFuY2hvck5vZGUpIHx8IGlzVGFyZ2V0SW5zaWRlVm9pZChlZGl0b3IsIGFuY2hvck5vZGUpO1xuICAgICAgdmFyIGZvY3VzTm9kZVNlbGVjdGFibGUgPSBoYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIGZvY3VzTm9kZSkgfHwgaXNUYXJnZXRJbnNpZGVWb2lkKGVkaXRvciwgZm9jdXNOb2RlKTtcblxuICAgICAgaWYgKGFuY2hvck5vZGVTZWxlY3RhYmxlICYmIGZvY3VzTm9kZVNlbGVjdGFibGUpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgZG9tU2VsZWN0aW9uKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCByYW5nZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvcik7XG4gICAgICB9XG4gICAgfVxuICB9LCAxMDApLCBbcmVhZE9ubHldKTsgLy8gQXR0YWNoIGEgbmF0aXZlIERPTSBldmVudCBoYW5kbGVyIGZvciBgc2VsZWN0aW9uY2hhbmdlYCwgYmVjYXVzZSBSZWFjdCdzXG4gIC8vIGJ1aWx0LWluIGBvblNlbGVjdGAgaGFuZGxlciBkb2Vzbid0IGZpcmUgZm9yIGFsbCBzZWxlY3Rpb24gY2hhbmdlcy4gSXQncyBhXG4gIC8vIGxlYWt5IHBvbHlmaWxsIHRoYXQgb25seSBmaXJlcyBvbiBrZXlwcmVzc2VzIG9yIGNsaWNrcy4gSW5zdGVhZCwgd2Ugd2FudCB0b1xuICAvLyBmaXJlIGZvciBhbnkgY2hhbmdlIHRvIHRoZSBzZWxlY3Rpb24gaW5zaWRlIHRoZSBlZGl0b3IuICgyMDE5LzExLzA0KVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzU3ODVcblxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgb25ET01TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgb25ET01TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH07XG4gIH0sIFtvbkRPTVNlbGVjdGlvbkNoYW5nZV0pO1xuICB2YXIgZGVjb3JhdGlvbnMgPSBkZWNvcmF0ZShbZWRpdG9yLCBbXV0pO1xuXG4gIGlmIChwbGFjZWhvbGRlciAmJiBlZGl0b3IuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIEFycmF5LmZyb20oTm9kZSQxLnRleHRzKGVkaXRvcikpLmxlbmd0aCA9PT0gMSAmJiBOb2RlJDEuc3RyaW5nKGVkaXRvcikgPT09ICcnKSB7XG4gICAgdmFyIHN0YXJ0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgW10pO1xuICAgIGRlY29yYXRpb25zLnB1c2goe1xuICAgICAgW1BMQUNFSE9MREVSX1NZTUJPTF06IHRydWUsXG4gICAgICBwbGFjZWhvbGRlcixcbiAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICBmb2N1czogc3RhcnRcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWRPbmx5Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiByZWFkT25seVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCAvLyBDT01QQVQ6IFRoZSBHcmFtbWFybHkgQ2hyb21lIGV4dGVuc2lvbiB3b3JrcyBieSBjaGFuZ2luZyB0aGUgRE9NXG4gIC8vIG91dCBmcm9tIHVuZGVyIGBjb250ZW50ZWRpdGFibGVgIGVsZW1lbnRzLCB3aGljaCBsZWFkcyB0byB3ZWlyZFxuICAvLyBiZWhhdmlvcnMgc28gd2UgaGF2ZSB0byBkaXNhYmxlIGl0IGxpa2UgZWRpdG9yLiAoMjAxNy8wNC8yNClcbiAgLCBPYmplY3QuYXNzaWduKHtcbiAgICBcImRhdGEtZ3JhbW1cIjogZmFsc2UsXG4gICAgcm9sZTogcmVhZE9ubHkgPyB1bmRlZmluZWQgOiAndGV4dGJveCdcbiAgfSwgYXR0cmlidXRlcywge1xuICAgIC8vIENPTVBBVDogQ2VydGFpbiBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50LCBzbyB3ZSdkXG4gICAgLy8gaGF2ZSB0byB1c2UgaGFja3MgdG8gbWFrZSB0aGVzZSByZXBsYWNlbWVudC1iYXNlZCBmZWF0dXJlcyB3b3JrLlxuICAgIHNwZWxsQ2hlY2s6ICFIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgPyB1bmRlZmluZWQgOiBhdHRyaWJ1dGVzLnNwZWxsQ2hlY2ssXG4gICAgYXV0b0NvcnJlY3Q6ICFIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgPyB1bmRlZmluZWQgOiBhdHRyaWJ1dGVzLmF1dG9Db3JyZWN0LFxuICAgIGF1dG9DYXBpdGFsaXplOiAhSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUID8gdW5kZWZpbmVkIDogYXR0cmlidXRlcy5hdXRvQ2FwaXRhbGl6ZSxcbiAgICBcImRhdGEtc2xhdGUtZWRpdG9yXCI6IHRydWUsXG4gICAgXCJkYXRhLXNsYXRlLW5vZGVcIjogXCJ2YWx1ZVwiLFxuICAgIGNvbnRlbnRFZGl0YWJsZTogcmVhZE9ubHkgPyB1bmRlZmluZWQgOiB0cnVlLFxuICAgIHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzogdHJ1ZSxcbiAgICByZWY6IHJlZixcbiAgICBzdHlsZTogX29iamVjdFNwcmVhZCh7XG4gICAgICAvLyBQcmV2ZW50IHRoZSBkZWZhdWx0IG91dGxpbmUgc3R5bGVzLlxuICAgICAgb3V0bGluZTogJ25vbmUnLFxuICAgICAgLy8gUHJlc2VydmUgYWRqYWNlbnQgd2hpdGVzcGFjZSBhbmQgbmV3IGxpbmVzLlxuICAgICAgd2hpdGVTcGFjZTogJ3ByZS13cmFwJyxcbiAgICAgIC8vIEFsbG93IHdvcmRzIHRvIGJyZWFrIGlmIHRoZXkgYXJlIHRvbyBsb25nLlxuICAgICAgd29yZFdyYXA6ICdicmVhay13b3JkJ1xuICAgIH0sIHN0eWxlKSxcbiAgICBvbkJlZm9yZUlucHV0OiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICAvLyBDT01QQVQ6IENlcnRhaW4gYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgYGJlZm9yZWlucHV0YCBldmVudCwgc28gd2VcbiAgICAgIC8vIGZhbGwgYmFjayB0byBSZWFjdCdzIGxlYWt5IHBvbHlmaWxsIGluc3RlYWQganVzdCBmb3IgaXQuIEl0XG4gICAgICAvLyBvbmx5IHdvcmtzIGZvciB0aGUgYGluc2VydFRleHRgIGlucHV0IHR5cGUuXG4gICAgICBpZiAoIUhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCAmJiAhcmVhZE9ubHkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQmVmb3JlSW5wdXQpICYmIGhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgdGV4dCA9IGV2ZW50LmRhdGE7XG4gICAgICAgIEVkaXRvci5pbnNlcnRUZXh0KGVkaXRvciwgdGV4dCk7XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5XSksXG4gICAgb25CbHVyOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAocmVhZE9ubHkgfHwgc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiB8fCAhaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpIHx8IGlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQmx1cikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBDT01QQVQ6IElmIHRoZSBjdXJyZW50IGBhY3RpdmVFbGVtZW50YCBpcyBzdGlsbCB0aGUgcHJldmlvdXNcbiAgICAgIC8vIG9uZSwgdGhpcyBpcyBkdWUgdG8gdGhlIHdpbmRvdyBiZWluZyBibHVycmVkIHdoZW4gdGhlIHRhYlxuICAgICAgLy8gaXRzZWxmIGJlY29tZXMgdW5mb2N1c2VkLCBzbyB3ZSB3YW50IHRvIGFib3J0IGVhcmx5IHRvIGFsbG93IHRvXG4gICAgICAvLyBlZGl0b3IgdG8gc3RheSBmb2N1c2VkIHdoZW4gdGhlIHRhYiBiZWNvbWVzIGZvY3VzZWQgYWdhaW4uXG5cblxuICAgICAgaWYgKHN0YXRlLmxhdGVzdEVsZW1lbnQgPT09IHdpbmRvdy5kb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldFxuICAgICAgfSA9IGV2ZW50O1xuICAgICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTsgLy8gQ09NUEFUOiBUaGUgZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQgaWYgdGhlIGZvY3VzIGlzIHJldHVybmluZ1xuICAgICAgLy8gdG8gdGhlIGVkaXRvciBmcm9tIGFuIGVtYmVkZGVkIGVkaXRhYmxlIGVsZW1lbnQgKGVnLiBhbiA8aW5wdXQ+XG4gICAgICAvLyBlbGVtZW50IGluc2lkZSBhIHZvaWQgbm9kZSkuXG5cbiAgICAgIGlmIChyZWxhdGVkVGFyZ2V0ID09PSBlbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIENPTVBBVDogVGhlIGV2ZW50IHNob3VsZCBiZSBpZ25vcmVkIGlmIHRoZSBmb2N1cyBpcyBtb3ZpbmcgZnJvbVxuICAgICAgLy8gdGhlIGVkaXRvciB0byBpbnNpZGUgYSB2b2lkIG5vZGUncyBzcGFjZXIgZWxlbWVudC5cblxuXG4gICAgICBpZiAoaXNET01FbGVtZW50KHJlbGF0ZWRUYXJnZXQpICYmIHJlbGF0ZWRUYXJnZXQuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLXNwYWNlcicpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQ09NUEFUOiBUaGUgZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQgaWYgdGhlIGZvY3VzIGlzIG1vdmluZyB0byBhXG4gICAgICAvLyBub24tIGVkaXRhYmxlIHNlY3Rpb24gb2YgYW4gZWxlbWVudCB0aGF0IGlzbid0IGEgdm9pZCBub2RlIChlZy5cbiAgICAgIC8vIGEgbGlzdCBpdGVtIG9mIHRoZSBjaGVjayBsaXN0IGV4YW1wbGUpLlxuXG5cbiAgICAgIGlmIChyZWxhdGVkVGFyZ2V0ICE9IG51bGwgJiYgaXNET01Ob2RlKHJlbGF0ZWRUYXJnZXQpICYmIFJlYWN0RWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCByZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICB2YXIgbm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgcmVsYXRlZFRhcmdldCk7XG5cbiAgICAgICAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgIWVkaXRvci5pc1ZvaWQobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgSVNfRk9DVVNFRC5kZWxldGUoZWRpdG9yKTtcbiAgICB9LCBbcmVhZE9ubHksIGF0dHJpYnV0ZXMub25CbHVyXSksXG4gICAgb25DbGljazogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKCFyZWFkT25seSAmJiBoYXNUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkNsaWNrKSAmJiBpc0RPTU5vZGUoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICB2YXIgbm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgdmFyIHBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIG5vZGUpO1xuXG4gICAgICAgIHZhciBfc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBwYXRoKTtcblxuICAgICAgICB2YXIgZW5kID0gRWRpdG9yLmVuZChlZGl0b3IsIHBhdGgpO1xuICAgICAgICB2YXIgc3RhcnRWb2lkID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IF9zdGFydFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGVuZFZvaWQgPSBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgICBhdDogZW5kXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzdGFydFZvaWQgJiYgZW5kVm9pZCAmJiBQYXRoLmVxdWFscyhzdGFydFZvaWRbMV0sIGVuZFZvaWRbMV0pKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgX3N0YXJ0KTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtyZWFkT25seSwgYXR0cmlidXRlcy5vbkNsaWNrXSksXG4gICAgb25Db21wb3NpdGlvbkVuZDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKGhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25Db21wb3NpdGlvbkVuZCkpIHtcbiAgICAgICAgc3RhdGUuaXNDb21wb3NpbmcgPSBmYWxzZTsgLy8gQ09NUEFUOiBJbiBDaHJvbWUsIGBiZWZvcmVpbnB1dGAgZXZlbnRzIGZvciBjb21wb3NpdGlvbnNcbiAgICAgICAgLy8gYXJlbid0IGNvcnJlY3QgYW5kIG5ldmVyIGZpcmUgdGhlIFwiaW5zZXJ0RnJvbUNvbXBvc2l0aW9uXCJcbiAgICAgICAgLy8gdHlwZSB0aGF0IHdlIG5lZWQuIFNvIGluc3RlYWQsIGluc2VydCB3aGVuZXZlciBhIGNvbXBvc2l0aW9uXG4gICAgICAgIC8vIGVuZHMgc2luY2UgaXQgd2lsbCBhbHJlYWR5IGhhdmUgYmVlbiBjb21taXR0ZWQgdG8gdGhlIERPTS5cblxuICAgICAgICBpZiAoIUlTX1NBRkFSSSAmJiAhSVNfRklSRUZPWCAmJiBldmVudC5kYXRhKSB7XG4gICAgICAgICAgRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBldmVudC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFthdHRyaWJ1dGVzLm9uQ29tcG9zaXRpb25FbmRdKSxcbiAgICBvbkNvbXBvc2l0aW9uU3RhcnQ6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmIChoYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQ29tcG9zaXRpb25TdGFydCkpIHtcbiAgICAgICAgc3RhdGUuaXNDb21wb3NpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sIFthdHRyaWJ1dGVzLm9uQ29tcG9zaXRpb25TdGFydF0pLFxuICAgIG9uQ29weTogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKGhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25Db3B5KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBSZWFjdEVkaXRvci5zZXRGcmFnbWVudERhdGEoZWRpdG9yLCBldmVudC5jbGlwYm9hcmREYXRhKTtcbiAgICAgIH1cbiAgICB9LCBbYXR0cmlidXRlcy5vbkNvcHldKSxcbiAgICBvbkN1dDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKCFyZWFkT25seSAmJiBoYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQ3V0KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBSZWFjdEVkaXRvci5zZXRGcmFnbWVudERhdGEoZWRpdG9yLCBldmVudC5jbGlwYm9hcmREYXRhKTtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBzZWxlY3Rpb25cbiAgICAgICAgfSA9IGVkaXRvcjtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBhdHRyaWJ1dGVzLm9uQ3V0XSksXG4gICAgb25EcmFnT3ZlcjogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKGhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uRHJhZ092ZXIpKSB7XG4gICAgICAgIC8vIE9ubHkgd2hlbiB0aGUgdGFyZ2V0IGlzIHZvaWQsIGNhbGwgYHByZXZlbnREZWZhdWx0YCB0byBzaWduYWxcbiAgICAgICAgLy8gdGhhdCBkcm9wcyBhcmUgYWxsb3dlZC4gRWRpdGFibGUgY29udGVudCBpcyBkcm9wcGFibGUgYnlcbiAgICAgICAgLy8gZGVmYXVsdCwgYW5kIGNhbGxpbmcgYHByZXZlbnREZWZhdWx0YCBoaWRlcyB0aGUgY3Vyc29yLlxuICAgICAgICB2YXIgbm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgZXZlbnQudGFyZ2V0KTtcblxuICAgICAgICBpZiAoRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFthdHRyaWJ1dGVzLm9uRHJhZ092ZXJdKSxcbiAgICBvbkRyYWdTdGFydDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKGhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uRHJhZ1N0YXJ0KSkge1xuICAgICAgICB2YXIgbm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgdmFyIHBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIG5vZGUpO1xuICAgICAgICB2YXIgdm9pZE1hdGNoID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgfSk7IC8vIElmIHN0YXJ0aW5nIGEgZHJhZyBvbiBhIHZvaWQgbm9kZSwgbWFrZSBzdXJlIGl0IGlzIHNlbGVjdGVkXG4gICAgICAgIC8vIHNvIHRoYXQgaXQgc2hvd3MgdXAgaW4gdGhlIHNlbGVjdGlvbidzIGZyYWdtZW50LlxuXG4gICAgICAgIGlmICh2b2lkTWF0Y2gpIHtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlYWN0RWRpdG9yLnNldEZyYWdtZW50RGF0YShlZGl0b3IsIGV2ZW50LmRhdGFUcmFuc2Zlcik7XG4gICAgICB9XG4gICAgfSwgW2F0dHJpYnV0ZXMub25EcmFnU3RhcnRdKSxcbiAgICBvbkRyb3A6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmIChoYXNUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFyZWFkT25seSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25Ecm9wKSkge1xuICAgICAgICAvLyBDT01QQVQ6IENlcnRhaW4gYnJvd3NlcnMgZG9uJ3QgZmlyZSBgYmVmb3JlaW5wdXRgIGV2ZW50cyBhdCBhbGwsIGFuZFxuICAgICAgICAvLyBDaHJvbWl1bSBicm93c2VycyBkb24ndCBwcm9wZXJseSBmaXJlIHRoZW0gZm9yIGZpbGVzIGJlaW5nXG4gICAgICAgIC8vIGRyb3BwZWQgaW50byBhIGBjb250ZW50ZWRpdGFibGVgLiAoMjAxOS8xMS8yNilcbiAgICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTAyODY2OFxuICAgICAgICBpZiAoIUhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCB8fCAhSVNfU0FGQVJJICYmIGV2ZW50LmRhdGFUcmFuc2Zlci5maWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBSZWFjdEVkaXRvci5maW5kRXZlbnRSYW5nZShlZGl0b3IsIGV2ZW50KTtcbiAgICAgICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGFUcmFuc2ZlcjtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKTtcbiAgICAgICAgICBSZWFjdEVkaXRvci5pbnNlcnREYXRhKGVkaXRvciwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbcmVhZE9ubHksIGF0dHJpYnV0ZXMub25Ecm9wXSksXG4gICAgb25Gb2N1czogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKCFyZWFkT25seSAmJiAhc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiAmJiBoYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uRm9jdXMpKSB7XG4gICAgICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgICAgIHN0YXRlLmxhdGVzdEVsZW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQuYWN0aXZlRWxlbWVudDsgLy8gQ09NUEFUOiBJZiB0aGUgZWRpdG9yIGhhcyBuZXN0ZWQgZWRpdGFibGUgZWxlbWVudHMsIHRoZSBmb2N1c1xuICAgICAgICAvLyBjYW4gZ28gdG8gdGhlbS4gSW4gRmlyZWZveCwgdGhpcyBtdXN0IGJlIHByZXZlbnRlZCBiZWNhdXNlIGl0XG4gICAgICAgIC8vIHJlc3VsdHMgaW4gaXNzdWVzIHdpdGgga2V5Ym9hcmQgbmF2aWdhdGlvbi4gKDIwMTcvMDMvMzApXG5cbiAgICAgICAgaWYgKElTX0ZJUkVGT1ggJiYgZXZlbnQudGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICAgIGVsLmZvY3VzKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgSVNfRk9DVVNFRC5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9LCBbcmVhZE9ubHksIGF0dHJpYnV0ZXMub25Gb2N1c10pLFxuICAgIG9uS2V5RG93bjogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKCFyZWFkT25seSAmJiBoYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uS2V5RG93bikpIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBuYXRpdmVFdmVudFxuICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgc2VsZWN0aW9uXG4gICAgICAgIH0gPSBlZGl0b3I7IC8vIENPTVBBVDogU2luY2Ugd2UgcHJldmVudCB0aGUgZGVmYXVsdCBiZWhhdmlvciBvblxuICAgICAgICAvLyBgYmVmb3JlaW5wdXRgIGV2ZW50cywgdGhlIGJyb3dzZXIgZG9lc24ndCB0aGluayB0aGVyZSdzIGV2ZXJcbiAgICAgICAgLy8gYW55IGhpc3Rvcnkgc3RhY2sgdG8gdW5kbyBvciByZWRvLCBzbyB3ZSBoYXZlIHRvIG1hbmFnZSB0aGVzZVxuICAgICAgICAvLyBob3RrZXlzIG91cnNlbHZlcy4gKDIwMTkvMTEvMDYpXG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNSZWRvKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGVkaXRvci5yZWRvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBlZGl0b3IucmVkbygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzVW5kbyhuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBlZGl0b3IudW5kbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZWRpdG9yLnVuZG8oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gQ09NUEFUOiBDZXJ0YWluIGJyb3dzZXJzIGRvbid0IGhhbmRsZSB0aGUgc2VsZWN0aW9uIHVwZGF0ZXNcbiAgICAgICAgLy8gcHJvcGVybHkuIEluIENocm9tZSwgdGhlIHNlbGVjdGlvbiBpc24ndCBwcm9wZXJseSBleHRlbmRlZC5cbiAgICAgICAgLy8gQW5kIGluIEZpcmVmb3gsIHRoZSBzZWxlY3Rpb24gaXNuJ3QgcHJvcGVybHkgY29sbGFwc2VkLlxuICAgICAgICAvLyAoMjAxNy8xMC8xNylcblxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzTW92ZUxpbmVCYWNrd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdsaW5lJyxcbiAgICAgICAgICAgIHJldmVyc2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSG90a2V5cy5pc01vdmVMaW5lRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzRXh0ZW5kTGluZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ2xpbmUnLFxuICAgICAgICAgICAgZWRnZTogJ2ZvY3VzJyxcbiAgICAgICAgICAgIHJldmVyc2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSG90a2V5cy5pc0V4dGVuZExpbmVGb3J3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ2xpbmUnLFxuICAgICAgICAgICAgZWRnZTogJ2ZvY3VzJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBDT01QQVQ6IElmIGEgdm9pZCBub2RlIGlzIHNlbGVjdGVkLCBvciBhIHplcm8td2lkdGggdGV4dCBub2RlXG4gICAgICAgIC8vIGFkamFjZW50IHRvIGFuIGlubGluZSBpcyBzZWxlY3RlZCwgd2UgbmVlZCB0byBoYW5kbGUgdGhlc2VcbiAgICAgICAgLy8gaG90a2V5cyBtYW51YWxseSBiZWNhdXNlIGJyb3dzZXJzIHdvbid0IGJlIGFibGUgdG8gc2tpcCBvdmVyXG4gICAgICAgIC8vIHRoZSB2b2lkIG5vZGUgd2l0aCB0aGUgemVyby13aWR0aCBzcGFjZSBub3QgYmVpbmcgYW4gZW1wdHlcbiAgICAgICAgLy8gc3RyaW5nLlxuXG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNNb3ZlQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgICByZXZlcnNlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5jb2xsYXBzZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgZWRnZTogJ3N0YXJ0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNNb3ZlRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5jb2xsYXBzZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgZWRnZTogJ2VuZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzTW92ZVdvcmRCYWNrd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICd3b3JkJyxcbiAgICAgICAgICAgIHJldmVyc2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSG90a2V5cy5pc01vdmVXb3JkRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICd3b3JkJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBDT01QQVQ6IENlcnRhaW4gYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgYGJlZm9yZWlucHV0YCBldmVudCwgc28gd2VcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIGd1ZXNzaW5nIGF0IHRoZSBpbnB1dCBpbnRlbnRpb24gZm9yIGhvdGtleXMuXG4gICAgICAgIC8vIENPTVBBVDogSW4gaU9TLCBzb21lIG9mIHRoZXNlIGhvdGtleXMgYXJlIGhhbmRsZWQgaW4gdGhlXG5cblxuICAgICAgICBpZiAoIUhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCkge1xuICAgICAgICAgIC8vIFdlIGRvbid0IGhhdmUgYSBjb3JlIGJlaGF2aW9yIGZvciB0aGVzZSwgYnV0IHRoZXkgY2hhbmdlIHRoZVxuICAgICAgICAgIC8vIERPTSBpZiB3ZSBkb24ndCBwcmV2ZW50IHRoZW0sIHNvIHdlIGhhdmUgdG8uXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNCb2xkKG5hdGl2ZUV2ZW50KSB8fCBIb3RrZXlzLmlzSXRhbGljKG5hdGl2ZUV2ZW50KSB8fCBIb3RrZXlzLmlzVHJhbnNwb3NlQ2hhcmFjdGVyKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc1NwbGl0QmxvY2sobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgRWRpdG9yLmluc2VydEJyZWFrKGVkaXRvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNEZWxldGVCYWNrd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc0RlbGV0ZUZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc0RlbGV0ZUxpbmVCYWNrd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzRGVsZXRlTGluZUZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzRGVsZXRlV29yZEJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgdW5pdDogJ3dvcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNEZWxldGVXb3JkRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgdW5pdDogJ3dvcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBhdHRyaWJ1dGVzLm9uS2V5RG93bl0pLFxuICAgIG9uUGFzdGU6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIC8vIENPTVBBVDogQ2VydGFpbiBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50LCBzbyB3ZVxuICAgICAgLy8gZmFsbCBiYWNrIHRvIFJlYWN0J3MgYG9uUGFzdGVgIGhlcmUgaW5zdGVhZC5cbiAgICAgIC8vIENPTVBBVDogRmlyZWZveCwgQ2hyb21lIGFuZCBTYWZhcmkgYXJlIG5vdCBlbWl0dGluZyBgYmVmb3JlaW5wdXRgIGV2ZW50c1xuICAgICAgLy8gd2hlbiBcInBhc3RlIHdpdGhvdXQgZm9ybWF0dGluZ1wiIG9wdGlvbiBpcyB1c2VkLlxuICAgICAgLy8gVGhpcyB1bmZvcnR1bmF0ZWx5IG5lZWRzIHRvIGJlIGhhbmRsZWQgd2l0aCBwYXN0ZSBldmVudHMgaW5zdGVhZC5cbiAgICAgIGlmICghaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25QYXN0ZSkgJiYgKCFIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgfHwgaXNQbGFpblRleHRPbmx5UGFzdGUoZXZlbnQubmF0aXZlRXZlbnQpKSAmJiAhcmVhZE9ubHkgJiYgaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIFJlYWN0RWRpdG9yLmluc2VydERhdGEoZWRpdG9yLCBldmVudC5jbGlwYm9hcmREYXRhKTtcbiAgICAgIH1cbiAgICB9LCBbcmVhZE9ubHksIGF0dHJpYnV0ZXMub25QYXN0ZV0pXG4gIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KENoaWxkcmVuLCB7XG4gICAgZGVjb3JhdGU6IGRlY29yYXRlLFxuICAgIGRlY29yYXRpb25zOiBkZWNvcmF0aW9ucyxcbiAgICBub2RlOiBlZGl0b3IsXG4gICAgcmVuZGVyRWxlbWVudDogcmVuZGVyRWxlbWVudCxcbiAgICByZW5kZXJMZWFmOiByZW5kZXJMZWFmLFxuICAgIHNlbGVjdGlvbjogZWRpdG9yLnNlbGVjdGlvblxuICB9KSkpO1xufTtcbi8qKlxyXG4gKiBBIGRlZmF1bHQgbWVtb2l6ZWQgZGVjb3JhdGUgZnVuY3Rpb24uXHJcbiAqL1xuXG52YXIgZGVmYXVsdERlY29yYXRlID0gKCkgPT4gW107XG4vKipcclxuICogQ2hlY2sgaWYgdGhlIHRhcmdldCBpcyBpbiB0aGUgZWRpdG9yLlxyXG4gKi9cblxuXG52YXIgaGFzVGFyZ2V0ID0gKGVkaXRvciwgdGFyZ2V0KSA9PiB7XG4gIHJldHVybiBpc0RPTU5vZGUodGFyZ2V0KSAmJiBSZWFjdEVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgdGFyZ2V0KTtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgdGhlIHRhcmdldCBpcyBlZGl0YWJsZSBhbmQgaW4gdGhlIGVkaXRvci5cclxuICovXG5cblxudmFyIGhhc0VkaXRhYmxlVGFyZ2V0ID0gKGVkaXRvciwgdGFyZ2V0KSA9PiB7XG4gIHJldHVybiBpc0RPTU5vZGUodGFyZ2V0KSAmJiBSZWFjdEVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgdGFyZ2V0LCB7XG4gICAgZWRpdGFibGU6IHRydWVcbiAgfSk7XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIHRoZSB0YXJnZXQgaXMgaW5zaWRlIHZvaWQgYW5kIGluIHRoZSBlZGl0b3IuXHJcbiAqL1xuXG5cbnZhciBpc1RhcmdldEluc2lkZVZvaWQgPSAoZWRpdG9yLCB0YXJnZXQpID0+IHtcbiAgdmFyIHNsYXRlTm9kZSA9IGhhc1RhcmdldChlZGl0b3IsIHRhcmdldCkgJiYgUmVhY3RFZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCB0YXJnZXQpO1xuICByZXR1cm4gRWRpdG9yLmlzVm9pZChlZGl0b3IsIHNsYXRlTm9kZSk7XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIGFuIGV2ZW50IGlzIG92ZXJyaWRlZCBieSBhIGhhbmRsZXIuXHJcbiAqL1xuXG5cbnZhciBpc0V2ZW50SGFuZGxlZCA9IChldmVudCwgaGFuZGxlcikgPT4ge1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYW5kbGVyKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCk7XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIGEgRE9NIGV2ZW50IGlzIG92ZXJyaWRlZCBieSBhIGhhbmRsZXIuXHJcbiAqL1xuXG5cbnZhciBpc0RPTUV2ZW50SGFuZGxlZCA9IChldmVudCwgaGFuZGxlcikgPT4ge1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYW5kbGVyKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG59O1xuXG5leHBvcnQgeyBEZWZhdWx0RWxlbWVudCwgRGVmYXVsdExlYWYsIEVkaXRhYmxlLCBSZWFjdEVkaXRvciwgU2xhdGUsIHVzZUVkaXRvciwgdXNlRm9jdXNlZCwgdXNlUmVhZE9ubHksIHVzZVNlbGVjdGVkLCB1c2VTbGF0ZSwgd2l0aFJlYWN0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiIsImltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gJ2lzLXBsYWluLW9iamVjdCc7XG5pbXBvcnQgeyBjcmVhdGVEcmFmdCwgZmluaXNoRHJhZnQsIGlzRHJhZnQsIHByb2R1Y2UgfSBmcm9tICdpbW1lcic7XG5pbXBvcnQgeyByZXZlcnNlIH0gZnJvbSAnZXNyZXZlcic7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxudmFyIERJUlRZX1BBVEhTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBGTFVTSElORyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTk9STUFMSVpJTkcgPSBuZXcgV2Vha01hcCgpO1xudmFyIFBBVEhfUkVGUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgUE9JTlRfUkVGUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgUkFOR0VfUkVGUyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxyXG4gKiBDb25zdGFudHMgZm9yIHN0cmluZyBkaXN0YW5jZSBjaGVja2luZy5cclxuICovXG52YXIgU1BBQ0UgPSAvXFxzLztcbnZhciBQVU5DVFVBVElPTiA9IC9bXFx1MDAyMS1cXHUwMDIzXFx1MDAyNS1cXHUwMDJBXFx1MDAyQy1cXHUwMDJGXFx1MDAzQVxcdTAwM0JcXHUwMDNGXFx1MDA0MFxcdTAwNUItXFx1MDA1RFxcdTAwNUZcXHUwMDdCXFx1MDA3RFxcdTAwQTFcXHUwMEE3XFx1MDBBQlxcdTAwQjZcXHUwMEI3XFx1MDBCQlxcdTAwQkZcXHUwMzdFXFx1MDM4N1xcdTA1NUEtXFx1MDU1RlxcdTA1ODlcXHUwNThBXFx1MDVCRVxcdTA1QzBcXHUwNUMzXFx1MDVDNlxcdTA1RjNcXHUwNUY0XFx1MDYwOVxcdTA2MEFcXHUwNjBDXFx1MDYwRFxcdTA2MUJcXHUwNjFFXFx1MDYxRlxcdTA2NkEtXFx1MDY2RFxcdTA2RDRcXHUwNzAwLVxcdTA3MERcXHUwN0Y3LVxcdTA3RjlcXHUwODMwLVxcdTA4M0VcXHUwODVFXFx1MDk2NFxcdTA5NjVcXHUwOTcwXFx1MEFGMFxcdTBERjRcXHUwRTRGXFx1MEU1QVxcdTBFNUJcXHUwRjA0LVxcdTBGMTJcXHUwRjE0XFx1MEYzQS1cXHUwRjNEXFx1MEY4NVxcdTBGRDAtXFx1MEZENFxcdTBGRDlcXHUwRkRBXFx1MTA0QS1cXHUxMDRGXFx1MTBGQlxcdTEzNjAtXFx1MTM2OFxcdTE0MDBcXHUxNjZEXFx1MTY2RVxcdTE2OUJcXHUxNjlDXFx1MTZFQi1cXHUxNkVEXFx1MTczNVxcdTE3MzZcXHUxN0Q0LVxcdTE3RDZcXHUxN0Q4LVxcdTE3REFcXHUxODAwLVxcdTE4MEFcXHUxOTQ0XFx1MTk0NVxcdTFBMUVcXHUxQTFGXFx1MUFBMC1cXHUxQUE2XFx1MUFBOC1cXHUxQUFEXFx1MUI1QS1cXHUxQjYwXFx1MUJGQy1cXHUxQkZGXFx1MUMzQi1cXHUxQzNGXFx1MUM3RVxcdTFDN0ZcXHUxQ0MwLVxcdTFDQzdcXHUxQ0QzXFx1MjAxMC1cXHUyMDI3XFx1MjAzMC1cXHUyMDQzXFx1MjA0NS1cXHUyMDUxXFx1MjA1My1cXHUyMDVFXFx1MjA3RFxcdTIwN0VcXHUyMDhEXFx1MjA4RVxcdTIzMjlcXHUyMzJBXFx1Mjc2OC1cXHUyNzc1XFx1MjdDNVxcdTI3QzZcXHUyN0U2LVxcdTI3RUZcXHUyOTgzLVxcdTI5OThcXHUyOUQ4LVxcdTI5REJcXHUyOUZDXFx1MjlGRFxcdTJDRjktXFx1MkNGQ1xcdTJDRkVcXHUyQ0ZGXFx1MkQ3MFxcdTJFMDAtXFx1MkUyRVxcdTJFMzAtXFx1MkUzQlxcdTMwMDEtXFx1MzAwM1xcdTMwMDgtXFx1MzAxMVxcdTMwMTQtXFx1MzAxRlxcdTMwMzBcXHUzMDNEXFx1MzBBMFxcdTMwRkJcXHVBNEZFXFx1QTRGRlxcdUE2MEQtXFx1QTYwRlxcdUE2NzNcXHVBNjdFXFx1QTZGMi1cXHVBNkY3XFx1QTg3NC1cXHVBODc3XFx1QThDRVxcdUE4Q0ZcXHVBOEY4LVxcdUE4RkFcXHVBOTJFXFx1QTkyRlxcdUE5NUZcXHVBOUMxLVxcdUE5Q0RcXHVBOURFXFx1QTlERlxcdUFBNUMtXFx1QUE1RlxcdUFBREVcXHVBQURGXFx1QUFGMFxcdUFBRjFcXHVBQkVCXFx1RkQzRVxcdUZEM0ZcXHVGRTEwLVxcdUZFMTlcXHVGRTMwLVxcdUZFNTJcXHVGRTU0LVxcdUZFNjFcXHVGRTYzXFx1RkU2OFxcdUZFNkFcXHVGRTZCXFx1RkYwMS1cXHVGRjAzXFx1RkYwNS1cXHVGRjBBXFx1RkYwQy1cXHVGRjBGXFx1RkYxQVxcdUZGMUJcXHVGRjFGXFx1RkYyMFxcdUZGM0ItXFx1RkYzRFxcdUZGM0ZcXHVGRjVCXFx1RkY1RFxcdUZGNUYtXFx1RkY2NV0vO1xudmFyIENIQU1FTEVPTiA9IC9bJ1xcdTIwMThcXHUyMDE5XS87XG52YXIgU1VSUk9HQVRFX1NUQVJUID0gMHhkODAwO1xudmFyIFNVUlJPR0FURV9FTkQgPSAweGRmZmY7XG52YXIgWkVST19XSURUSF9KT0lORVIgPSAweDIwMGQ7XG4vKipcclxuICogR2V0IHRoZSBkaXN0YW5jZSB0byB0aGUgZW5kIG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gYSBzdHJpbmcgb2YgdGV4dC5cclxuICovXG5cbnZhciBnZXRDaGFyYWN0ZXJEaXN0YW5jZSA9IHRleHQgPT4ge1xuICB2YXIgb2Zmc2V0ID0gMDsgLy8gcHJldiB0eXBlczpcbiAgLy8gU1VSUjogc3Vycm9nYXRlIHBhaXJcbiAgLy8gTU9EOiBtb2RpZmllciAodGVjaG5pY2FsbHkgYWxzbyBzdXJyb2dhdGUgcGFpcilcbiAgLy8gWldKOiB6ZXJvIHdpZHRoIGpvaW5lclxuICAvLyBWQVI6IHZhcmlhdGlvbiBzZWxlY3RvclxuICAvLyBCTVA6IHNlcXVlbmNlYWJsZSBjaGFyYWN0ZXIgZnJvbSBiYXNpYyBtdWx0aWxpbmd1YWwgcGxhbmVcblxuICB2YXIgcHJldiA9IG51bGw7XG4gIHZhciBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdCgwKTtcblxuICB3aGlsZSAoY2hhckNvZGUpIHtcbiAgICBpZiAoaXNTdXJyb2dhdGUoY2hhckNvZGUpKSB7XG4gICAgICB2YXIgbW9kaWZpZXIgPSBpc01vZGlmaWVyKGNoYXJDb2RlLCB0ZXh0LCBvZmZzZXQpOyAvLyBFYXJseSByZXR1cm5zIGFyZSB0aGUgaGVhcnQgb2YgdGhpcyBmdW5jdGlvbiwgd2hlcmUgd2UgZGVjaWRlIGlmIHByZXZpb3VzIGFuZCBjdXJyZW50XG4gICAgICAvLyBjb2RlcG9pbnRzIHNob3VsZCBmb3JtIGEgc2luZ2xlIGNoYXJhY3RlciAoaW4gdGVybXMgb2YgaG93IG1hbnkgb2YgdGhlbSBzaG91bGQgc2VsZWN0aW9uXG4gICAgICAvLyBqdW1wIG92ZXIpLlxuXG4gICAgICBpZiAocHJldiA9PT0gJ1NVUlInIHx8IHByZXYgPT09ICdCTVAnKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIHByZXYgPSBtb2RpZmllciA/ICdNT0QnIDogJ1NVUlInO1xuICAgICAgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQob2Zmc2V0KTsgLy8gQWJzb2x1dGVseSBmaW5lIHRvIGBjb250aW51ZWAgd2l0aG91dCBhbnkgY2hlY2tzIGJlY2F1c2UgaWYgYGNoYXJDb2RlYCBpcyBOYU4gKHdoaWNoXG4gICAgICAvLyBpcyB0aGUgY2FzZSB3aGVuIG91dCBvZiBgdGV4dGAgcmFuZ2UpLCBuZXh0IGB3aGlsZWAgbG9vcCB3b25cInQgZXhlY3V0ZSBhbmQgd2VcInJlIGRvbmUuXG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjaGFyQ29kZSA9PT0gWkVST19XSURUSF9KT0lORVIpIHtcbiAgICAgIG9mZnNldCArPSAxO1xuICAgICAgcHJldiA9ICdaV0onO1xuICAgICAgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChpc0JNUEVtb2ppKGNoYXJDb2RlKSkge1xuICAgICAgaWYgKHByZXYgJiYgcHJldiAhPT0gJ1pXSicgJiYgcHJldiAhPT0gJ1ZBUicpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIG9mZnNldCArPSAxO1xuICAgICAgcHJldiA9ICdCTVAnO1xuICAgICAgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChpc1ZhcmlhdGlvblNlbGVjdG9yKGNoYXJDb2RlKSkge1xuICAgICAgaWYgKHByZXYgJiYgcHJldiAhPT0gJ1pXSicpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIG9mZnNldCArPSAxO1xuICAgICAgcHJldiA9ICdWQVInO1xuICAgICAgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gTW9kaWZpZXIgJ2dyb3VwcyB1cCcgd2l0aCB3aGF0IGV2ZXIgY2hhcmFjdGVyIGlzIGJlZm9yZSB0aGF0IChldmVuIHdoaXRlc3BhY2UpLCBuZWVkIHRvXG4gICAgLy8gbG9vayBhaGVhZC5cblxuXG4gICAgaWYgKHByZXYgPT09ICdNT0QnKSB7XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICAgIGJyZWFrO1xuICAgIH0gLy8gSWYgd2hpbGUgbG9vcCBldmVyIGdldHMgaGVyZSwgd2UncmUgZG9uZSAoZS5nIGxhdGluIGNoYXJzKS5cblxuXG4gICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0IHx8IDE7XG59O1xuLyoqXHJcbiAqIEdldCB0aGUgZGlzdGFuY2UgdG8gdGhlIGVuZCBvZiB0aGUgZmlyc3Qgd29yZCBpbiBhIHN0cmluZyBvZiB0ZXh0LlxyXG4gKi9cblxudmFyIGdldFdvcmREaXN0YW5jZSA9IHRleHQgPT4ge1xuICB2YXIgbGVuZ3RoID0gMDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgc3RhcnRlZCA9IGZhbHNlO1xuICB2YXIgY2hhcjtcblxuICB3aGlsZSAoY2hhciA9IHRleHQuY2hhckF0KGkpKSB7XG4gICAgdmFyIGwgPSBnZXRDaGFyYWN0ZXJEaXN0YW5jZShjaGFyKTtcbiAgICBjaGFyID0gdGV4dC5zbGljZShpLCBpICsgbCk7XG4gICAgdmFyIHJlc3QgPSB0ZXh0LnNsaWNlKGkgKyBsKTtcblxuICAgIGlmIChpc1dvcmRDaGFyYWN0ZXIoY2hhciwgcmVzdCkpIHtcbiAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgbGVuZ3RoICs9IGw7XG4gICAgfSBlbHNlIGlmICghc3RhcnRlZCkge1xuICAgICAgbGVuZ3RoICs9IGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGkgKz0gbDtcbiAgfVxuXG4gIHJldHVybiBsZW5ndGg7XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIGEgY2hhcmFjdGVyIGlzIGEgd29yZCBjaGFyYWN0ZXIuIFRoZSBgcmVtYWluaW5nYCBhcmd1bWVudCBpcyB1c2VkXHJcbiAqIGJlY2F1c2Ugc29tZXRpbWVzIHlvdSBtdXN0IHJlYWQgc3Vic2VxdWVudCBjaGFyYWN0ZXJzIHRvIHRydWx5IGRldGVybWluZSBpdC5cclxuICovXG5cbnZhciBpc1dvcmRDaGFyYWN0ZXIgPSAoY2hhciwgcmVtYWluaW5nKSA9PiB7XG4gIGlmIChTUEFDRS50ZXN0KGNoYXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIENoYW1lbGVvbnMgY291bnQgYXMgd29yZCBjaGFyYWN0ZXJzIGFzIGxvbmcgYXMgdGhleSdyZSBpbiBhIHdvcmQsIHNvXG4gIC8vIHJlY3Vyc2UgdG8gc2VlIGlmIHRoZSBuZXh0IG9uZSBpcyBhIHdvcmQgY2hhcmFjdGVyIG9yIG5vdC5cblxuXG4gIGlmIChDSEFNRUxFT04udGVzdChjaGFyKSkge1xuICAgIHZhciBuZXh0ID0gcmVtYWluaW5nLmNoYXJBdCgwKTtcbiAgICB2YXIgbGVuZ3RoID0gZ2V0Q2hhcmFjdGVyRGlzdGFuY2UobmV4dCk7XG4gICAgbmV4dCA9IHJlbWFpbmluZy5zbGljZSgwLCBsZW5ndGgpO1xuICAgIHZhciByZXN0ID0gcmVtYWluaW5nLnNsaWNlKGxlbmd0aCk7XG5cbiAgICBpZiAoaXNXb3JkQ2hhcmFjdGVyKG5leHQsIHJlc3QpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoUFVOQ1RVQVRJT04udGVzdChjaGFyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIGlmIGBjb2RlYCBpcyBhIHN1cnJvZ2F0ZVxyXG4gKi9cblxuXG52YXIgaXNTdXJyb2dhdGUgPSBjb2RlID0+IFNVUlJPR0FURV9TVEFSVCA8PSBjb2RlICYmIGNvZGUgPD0gU1VSUk9HQVRFX0VORDtcbi8qKlxyXG4gKiBEb2VzIGBjb2RlYCBmb3JtIE1vZGlmaWVyIHdpdGggbmV4dCBvbmUuXHJcbiAqXHJcbiAqIGh0dHBzOi8vZW1vamlwZWRpYS5vcmcvbW9kaWZpZXJzL1xyXG4gKi9cblxuXG52YXIgaXNNb2RpZmllciA9IChjb2RlLCB0ZXh0LCBvZmZzZXQpID0+IHtcbiAgaWYgKGNvZGUgPT09IDB4ZDgzYykge1xuICAgIHZhciBuZXh0ID0gdGV4dC5jaGFyQ29kZUF0KG9mZnNldCArIDEpO1xuICAgIHJldHVybiBuZXh0IDw9IDB4ZGZmZiAmJiBuZXh0ID49IDB4ZGZmYjtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG4vKipcclxuICogSXMgYGNvZGVgIGEgVmFyaWF0aW9uIFNlbGVjdG9yLlxyXG4gKlxyXG4gKiBodHRwczovL2NvZGVwb2ludHMubmV0L3ZhcmlhdGlvbl9zZWxlY3RvcnNcclxuICovXG5cblxudmFyIGlzVmFyaWF0aW9uU2VsZWN0b3IgPSBjb2RlID0+IHtcbiAgcmV0dXJuIGNvZGUgPD0gMHhmZTBmICYmIGNvZGUgPj0gMHhmZTAwO1xufTtcbi8qKlxyXG4gKiBJcyBgY29kZWAgb25lIG9mIHRoZSBCTVAgY29kZXMgdXNlZCBpbiBlbW9qaSBzZXF1ZW5jZXMuXHJcbiAqXHJcbiAqIGh0dHBzOi8vZW1vamlwZWRpYS5vcmcvZW1vamktendqLXNlcXVlbmNlcy9cclxuICovXG5cblxudmFyIGlzQk1QRW1vamkgPSBjb2RlID0+IHtcbiAgLy8gVGhpcyByZXF1aXJlcyB0aW55IGJpdCBvZiBtYWludGFuYW5jZSwgYmV0dGVyIGlkZWFzP1xuICAvLyBGb3J0dW5hdGVseSBpdCBvbmx5IGhhcHBlbnMgaWYgbmV3IFVuaWNvZGUgU3RhbmRhcmRcbiAgLy8gaXMgcmVsZWFzZWQuIEZhaWxzIGdyYWNlZnVsbHkgaWYgdXBrZWVwIGxhZ3MgYmVoaW5kLFxuICAvLyBzYW1lIHdheSBTbGF0ZSBwcmV2aW91c2x5IGJlaGF2ZWQgd2l0aCBhbGwgZW1vamlzLlxuICByZXR1cm4gY29kZSA9PT0gMHgyNzY0IHx8IC8vIGhlYXJ0ICjinaQpXG4gIGNvZGUgPT09IDB4MjY0MiB8fCAvLyBtYWxlICjimYIpXG4gIGNvZGUgPT09IDB4MjY0MCB8fCAvLyBmZW1hbGUgKOKZgClcbiAgY29kZSA9PT0gMHgyNjIwIHx8IC8vIHNjdWxsICjimKApXG4gIGNvZGUgPT09IDB4MjY5NSB8fCAvLyBtZWRpY2FsICjimpUpXG4gIGNvZGUgPT09IDB4MjcwOCB8fCAvLyBwbGFuZSAo4pyI77iPKVxuICBjb2RlID09PSAweDI1ZWYgLy8gbGFyZ2UgY2lyY2xlICjil68pXG4gIDtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIEVkaXRvciA9IHtcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBhbmNlc3RvciBhYm92ZSBhIGxvY2F0aW9uIGluIHRoZSBkb2N1bWVudC5cclxuICAgKi9cbiAgYWJvdmUoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICB2b2lkcyA9IGZhbHNlLFxuICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgbWF0Y2hcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQpO1xuICAgIHZhciByZXZlcnNlID0gbW9kZSA9PT0gJ2xvd2VzdCc7XG5cbiAgICBmb3IgKHZhciBbbiwgcF0gb2YgRWRpdG9yLmxldmVscyhlZGl0b3IsIHtcbiAgICAgIGF0OiBwYXRoLFxuICAgICAgdm9pZHMsXG4gICAgICBtYXRjaCxcbiAgICAgIHJldmVyc2VcbiAgICB9KSkge1xuICAgICAgaWYgKCFUZXh0LmlzVGV4dChuKSAmJiAhUGF0aC5lcXVhbHMocGF0aCwgcCkpIHtcbiAgICAgICAgcmV0dXJuIFtuLCBwXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQWRkIGEgY3VzdG9tIHByb3BlcnR5IHRvIHRoZSBsZWFmIHRleHQgbm9kZXMgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIHNlbGVjdGlvbiBpcyBjdXJyZW50bHkgY29sbGFwc2VkLCB0aGUgbWFya3Mgd2lsbCBiZSBhZGRlZCB0byB0aGVcclxuICAgKiBgZWRpdG9yLm1hcmtzYCBwcm9wZXJ0eSBpbnN0ZWFkLCBhbmQgYXBwbGllZCB3aGVuIHRleHQgaXMgaW5zZXJ0ZWQgbmV4dC5cclxuICAgKi9cbiAgYWRkTWFyayhlZGl0b3IsIGtleSwgdmFsdWUpIHtcbiAgICBlZGl0b3IuYWRkTWFyayhrZXksIHZhbHVlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHBvaW50IGFmdGVyIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGFmdGVyKGVkaXRvciwgYXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIGFuY2hvciA9IEVkaXRvci5wb2ludChlZGl0b3IsIGF0LCB7XG4gICAgICBlZGdlOiAnZW5kJ1xuICAgIH0pO1xuICAgIHZhciBmb2N1cyA9IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG4gICAgdmFyIHJhbmdlID0ge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9O1xuICAgIHZhciB7XG4gICAgICBkaXN0YW5jZSA9IDFcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgZCA9IDA7XG4gICAgdmFyIHRhcmdldDtcblxuICAgIGZvciAodmFyIHAgb2YgRWRpdG9yLnBvc2l0aW9ucyhlZGl0b3IsIF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICAgIGF0OiByYW5nZVxuICAgIH0pKSkge1xuICAgICAgaWYgKGQgPiBkaXN0YW5jZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGQgIT09IDApIHtcbiAgICAgICAgdGFyZ2V0ID0gcDtcbiAgICAgIH1cblxuICAgICAgZCsrO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBwb2ludCBiZWZvcmUgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgYmVmb3JlKGVkaXRvciwgYXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIGFuY2hvciA9IEVkaXRvci5zdGFydChlZGl0b3IsIFtdKTtcbiAgICB2YXIgZm9jdXMgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ3N0YXJ0J1xuICAgIH0pO1xuICAgIHZhciByYW5nZSA9IHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfTtcbiAgICB2YXIge1xuICAgICAgZGlzdGFuY2UgPSAxXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIGQgPSAwO1xuICAgIHZhciB0YXJnZXQ7XG5cbiAgICBmb3IgKHZhciBwIG9mIEVkaXRvci5wb3NpdGlvbnMoZWRpdG9yLCBfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zLCB7XG4gICAgICBhdDogcmFuZ2UsXG4gICAgICByZXZlcnNlOiB0cnVlXG4gICAgfSkpKSB7XG4gICAgICBpZiAoZCA+IGRpc3RhbmNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoZCAhPT0gMCkge1xuICAgICAgICB0YXJnZXQgPSBwO1xuICAgICAgfVxuXG4gICAgICBkKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWxldGUgY29udGVudCBpbiB0aGUgZWRpdG9yIGJhY2t3YXJkIGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBkZWxldGVCYWNrd2FyZChlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHVuaXQgPSAnY2hhcmFjdGVyJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIGVkaXRvci5kZWxldGVCYWNrd2FyZCh1bml0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWxldGUgY29udGVudCBpbiB0aGUgZWRpdG9yIGZvcndhcmQgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICovXG4gIGRlbGV0ZUZvcndhcmQoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICB1bml0ID0gJ2NoYXJhY3RlcidcbiAgICB9ID0gb3B0aW9ucztcbiAgICBlZGl0b3IuZGVsZXRlRm9yd2FyZCh1bml0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWxldGUgdGhlIGNvbnRlbnQgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBkZWxldGVGcmFnbWVudChlZGl0b3IpIHtcbiAgICBlZGl0b3IuZGVsZXRlRnJhZ21lbnQoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGVkZ2VzKGVkaXRvciwgYXQpIHtcbiAgICByZXR1cm4gW0VkaXRvci5zdGFydChlZGl0b3IsIGF0KSwgRWRpdG9yLmVuZChlZGl0b3IsIGF0KV07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBlbmQgcG9pbnQgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgZW5kKGVkaXRvciwgYXQpIHtcbiAgICByZXR1cm4gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdlbmQnXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBmaXJzdCBub2RlIGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGZpcnN0KGVkaXRvciwgYXQpIHtcbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdzdGFydCdcbiAgICB9KTtcbiAgICByZXR1cm4gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGZyYWdtZW50IGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGZyYWdtZW50KGVkaXRvciwgYXQpIHtcbiAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgdmFyIGZyYWdtZW50ID0gTm9kZS5mcmFnbWVudChlZGl0b3IsIHJhbmdlKTtcbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBub2RlIGhhcyBibG9jayBjaGlsZHJlbi5cclxuICAgKi9cbiAgaGFzQmxvY2tzKGVkaXRvciwgZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LmNoaWxkcmVuLnNvbWUobiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIG5vZGUgaGFzIGlubGluZSBhbmQgdGV4dCBjaGlsZHJlbi5cclxuICAgKi9cbiAgaGFzSW5saW5lcyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jaGlsZHJlbi5zb21lKG4gPT4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbikpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgbm9kZSBoYXMgdGV4dCBjaGlsZHJlbi5cclxuICAgKi9cbiAgaGFzVGV4dHMoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4uZXZlcnkobiA9PiBUZXh0LmlzVGV4dChuKSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgYmxvY2sgYnJlYWsgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIHNlbGVjdGlvbiBpcyBjdXJyZW50bHkgZXhwYW5kZWQsIGl0IHdpbGwgYmUgZGVsZXRlZCBmaXJzdC5cclxuICAgKi9cbiAgaW5zZXJ0QnJlYWsoZWRpdG9yKSB7XG4gICAgZWRpdG9yLmluc2VydEJyZWFrKCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgZnJhZ21lbnQgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIHNlbGVjdGlvbiBpcyBjdXJyZW50bHkgZXhwYW5kZWQsIGl0IHdpbGwgYmUgZGVsZXRlZCBmaXJzdC5cclxuICAgKi9cbiAgaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBmcmFnbWVudCkge1xuICAgIGVkaXRvci5pbnNlcnRGcmFnbWVudChmcmFnbWVudCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgbm9kZSBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBleHBhbmRlZCwgaXQgd2lsbCBiZSBkZWxldGVkIGZpcnN0LlxyXG4gICAqL1xuICBpbnNlcnROb2RlKGVkaXRvciwgbm9kZSkge1xuICAgIGVkaXRvci5pbnNlcnROb2RlKG5vZGUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCB0ZXh0IGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGV4cGFuZGVkLCBpdCB3aWxsIGJlIGRlbGV0ZWQgZmlyc3QuXHJcbiAgICovXG4gIGluc2VydFRleHQoZWRpdG9yLCB0ZXh0KSB7XG4gICAgZWRpdG9yLmluc2VydFRleHQodGV4dCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGJsb2NrIGBFbGVtZW50YCBvYmplY3QuXHJcbiAgICovXG4gIGlzQmxvY2soZWRpdG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudCh2YWx1ZSkgJiYgIWVkaXRvci5pc0lubGluZSh2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBgRWRpdG9yYCBvYmplY3QuXHJcbiAgICovXG4gIGlzRWRpdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpICYmIHR5cGVvZiB2YWx1ZS5hZGRNYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5hcHBseSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuZGVsZXRlQmFja3dhcmQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmRlbGV0ZUZvcndhcmQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmRlbGV0ZUZyYWdtZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnRCcmVhayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0RnJhZ21lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydE5vZGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydFRleHQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmlzSW5saW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pc1ZvaWQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLm5vcm1hbGl6ZU5vZGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLm9uQ2hhbmdlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5yZW1vdmVNYXJrID09PSAnZnVuY3Rpb24nICYmICh2YWx1ZS5tYXJrcyA9PT0gbnVsbCB8fCBpc1BsYWluT2JqZWN0KHZhbHVlLm1hcmtzKSkgJiYgKHZhbHVlLnNlbGVjdGlvbiA9PT0gbnVsbCB8fCBSYW5nZS5pc1JhbmdlKHZhbHVlLnNlbGVjdGlvbikpICYmIE5vZGUuaXNOb2RlTGlzdCh2YWx1ZS5jaGlsZHJlbikgJiYgT3BlcmF0aW9uLmlzT3BlcmF0aW9uTGlzdCh2YWx1ZS5vcGVyYXRpb25zKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIHRoZSBlbmQgcG9pbnQgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgaXNFbmQoZWRpdG9yLCBwb2ludCwgYXQpIHtcbiAgICB2YXIgZW5kID0gRWRpdG9yLmVuZChlZGl0b3IsIGF0KTtcbiAgICByZXR1cm4gUG9pbnQuZXF1YWxzKHBvaW50LCBlbmQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgYW4gZWRnZSBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBpc0VkZ2UoZWRpdG9yLCBwb2ludCwgYXQpIHtcbiAgICByZXR1cm4gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBwb2ludCwgYXQpIHx8IEVkaXRvci5pc0VuZChlZGl0b3IsIHBvaW50LCBhdCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBlbXB0eSwgYWNjb3VudGluZyBmb3Igdm9pZCBub2Rlcy5cclxuICAgKi9cbiAgaXNFbXB0eShlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICB2YXIge1xuICAgICAgY2hpbGRyZW5cbiAgICB9ID0gZWxlbWVudDtcbiAgICB2YXIgW2ZpcnN0XSA9IGNoaWxkcmVuO1xuICAgIHJldHVybiBjaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIFRleHQuaXNUZXh0KGZpcnN0KSAmJiBmaXJzdC50ZXh0ID09PSAnJyAmJiAhZWRpdG9yLmlzVm9pZChlbGVtZW50KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGlubGluZSBgRWxlbWVudGAgb2JqZWN0LlxyXG4gICAqL1xuICBpc0lubGluZShlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KHZhbHVlKSAmJiBlZGl0b3IuaXNJbmxpbmUodmFsdWUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSBlZGl0b3IgaXMgY3VycmVudGx5IG5vcm1hbGl6aW5nIGFmdGVyIGVhY2ggb3BlcmF0aW9uLlxyXG4gICAqL1xuICBpc05vcm1hbGl6aW5nKGVkaXRvcikge1xuICAgIHZhciBpc05vcm1hbGl6aW5nID0gTk9STUFMSVpJTkcuZ2V0KGVkaXRvcik7XG4gICAgcmV0dXJuIGlzTm9ybWFsaXppbmcgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBpc05vcm1hbGl6aW5nO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgdGhlIHN0YXJ0IHBvaW50IG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGlzU3RhcnQoZWRpdG9yLCBwb2ludCwgYXQpIHtcbiAgICAvLyBQRVJGOiBJZiB0aGUgb2Zmc2V0IGlzbid0IGAwYCB3ZSBrbm93IGl0J3Mgbm90IHRoZSBzdGFydC5cbiAgICBpZiAocG9pbnQub2Zmc2V0ICE9PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpO1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMocG9pbnQsIHN0YXJ0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgdm9pZCBgRWxlbWVudGAgb2JqZWN0LlxyXG4gICAqL1xuICBpc1ZvaWQoZWRpdG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudCh2YWx1ZSkgJiYgZWRpdG9yLmlzVm9pZCh2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBsYXN0IG5vZGUgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgbGFzdChlZGl0b3IsIGF0KSB7XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCB7XG4gICAgICBlZGdlOiAnZW5kJ1xuICAgIH0pO1xuICAgIHJldHVybiBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbGVhZiB0ZXh0IG5vZGUgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgbGVhZihlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwgb3B0aW9ucyk7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmxlYWYoZWRpdG9yLCBwYXRoKTtcbiAgICByZXR1cm4gW25vZGUsIHBhdGhdO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIGxldmVscyBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICAqbGV2ZWxzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgcmV2ZXJzZSA9IGZhbHNlLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBtYXRjaFxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIG1hdGNoID0gKCkgPT4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxldmVscyA9IFtdO1xuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCk7XG5cbiAgICBmb3IgKHZhciBbbiwgcF0gb2YgTm9kZS5sZXZlbHMoZWRpdG9yLCBwYXRoKSkge1xuICAgICAgaWYgKCFtYXRjaChuKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbGV2ZWxzLnB1c2goW24sIHBdKTtcblxuICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbikpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGxldmVscy5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgeWllbGQqIGxldmVscztcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIG1hcmtzIHRoYXQgd291bGQgYmUgYWRkZWQgdG8gdGV4dCBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICovXG4gIG1hcmtzKGVkaXRvcikge1xuICAgIHZhciB7XG4gICAgICBtYXJrcyxcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBlZGl0b3I7XG5cbiAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKG1hcmtzKSB7XG4gICAgICByZXR1cm4gbWFya3M7XG4gICAgfVxuXG4gICAgaWYgKFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgdmFyIFttYXRjaF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB2YXIgW19ub2RlXSA9IG1hdGNoO1xuXG4gICAgICAgIHZhciBfcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfbm9kZSwgW1widGV4dFwiXSk7XG5cbiAgICAgICAgcmV0dXJuIF9yZXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBhbmNob3JcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIHZhciB7XG4gICAgICBwYXRoXG4gICAgfSA9IGFuY2hvcjtcbiAgICB2YXIgW25vZGVdID0gRWRpdG9yLmxlYWYoZWRpdG9yLCBwYXRoKTtcblxuICAgIGlmIChhbmNob3Iub2Zmc2V0ID09PSAwKSB7XG4gICAgICB2YXIgcHJldiA9IEVkaXRvci5wcmV2aW91cyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dFxuICAgICAgfSk7XG4gICAgICB2YXIgYmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbilcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocHJldiAmJiBibG9jaykge1xuICAgICAgICB2YXIgW3ByZXZOb2RlLCBwcmV2UGF0aF0gPSBwcmV2O1xuICAgICAgICB2YXIgWywgYmxvY2tQYXRoXSA9IGJsb2NrO1xuXG4gICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IoYmxvY2tQYXRoLCBwcmV2UGF0aCkpIHtcbiAgICAgICAgICBub2RlID0gcHJldk5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBbXCJ0ZXh0XCJdKTtcblxuICAgIHJldHVybiByZXN0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbWF0Y2hpbmcgbm9kZSBpbiB0aGUgYnJhbmNoIG9mIHRoZSBkb2N1bWVudCBhZnRlciBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBuZXh0KGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBtYXRjaCxcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBbLCBmcm9tXSA9IEVkaXRvci5sYXN0KGVkaXRvciwgYXQpO1xuICAgIHZhciBbLCB0b10gPSBFZGl0b3IubGFzdChlZGl0b3IsIFtdKTtcbiAgICB2YXIgc3BhbiA9IFtmcm9tLCB0b107XG5cbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpICYmIGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgbmV4dCBub2RlIGZyb20gdGhlIHJvb3Qgbm9kZSFcIik7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgdmFyIFtwYXJlbnRdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIGF0KTtcblxuICAgICAgICBtYXRjaCA9IG4gPT4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2ggPSAoKSA9PiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBbLCBuZXh0XSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBzcGFuLFxuICAgICAgbWF0Y2gsXG4gICAgICBtb2RlLFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIG5vZGUgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgbm9kZShlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwgb3B0aW9ucyk7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChlZGl0b3IsIHBhdGgpO1xuICAgIHJldHVybiBbbm9kZSwgcGF0aF07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUgbm9kZXMgaW4gdGhlIEVkaXRvci5cclxuICAgKi9cbiAgKm5vZGVzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgbW9kZSA9ICdhbGwnLFxuICAgICAgdW5pdmVyc2FsID0gZmFsc2UsXG4gICAgICByZXZlcnNlID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICBtYXRjaCA9ICgpID0+IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmcm9tO1xuICAgIHZhciB0bztcblxuICAgIGlmIChTcGFuLmlzU3BhbihhdCkpIHtcbiAgICAgIGZyb20gPSBhdFswXTtcbiAgICAgIHRvID0gYXRbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmaXJzdCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICAgICAgZWRnZTogJ3N0YXJ0J1xuICAgICAgfSk7XG4gICAgICB2YXIgbGFzdCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICAgICAgZWRnZTogJ2VuZCdcbiAgICAgIH0pO1xuICAgICAgZnJvbSA9IHJldmVyc2UgPyBsYXN0IDogZmlyc3Q7XG4gICAgICB0byA9IHJldmVyc2UgPyBmaXJzdCA6IGxhc3Q7XG4gICAgfVxuXG4gICAgdmFyIGl0ZXJhYmxlID0gTm9kZS5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIHJldmVyc2UsXG4gICAgICBmcm9tLFxuICAgICAgdG8sXG4gICAgICBwYXNzOiAoX3JlZikgPT4ge1xuICAgICAgICB2YXIgW25dID0gX3JlZjtcbiAgICAgICAgcmV0dXJuIHZvaWRzID8gZmFsc2UgOiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICB2YXIgaGl0O1xuXG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXNMb3dlciA9IGhpdCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgaGl0WzFdKSA9PT0gMDsgLy8gSW4gaGlnaGVzdCBtb2RlIGFueSBub2RlIGxvd2VyIHRoYW4gdGhlIGxhc3QgaGl0IGlzIG5vdCBhIG1hdGNoLlxuXG4gICAgICBpZiAobW9kZSA9PT0gJ2hpZ2hlc3QnICYmIGlzTG93ZXIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghbWF0Y2gobm9kZSkpIHtcbiAgICAgICAgLy8gSWYgd2UndmUgYXJyaXZlZCBhdCBhIGxlYWYgdGV4dCBub2RlIHRoYXQgaXMgbm90IGxvd2VyIHRoYW4gdGhlIGxhc3RcbiAgICAgICAgLy8gaGl0LCB0aGVuIHdlJ3ZlIGZvdW5kIGEgYnJhbmNoIHRoYXQgZG9lc24ndCBpbmNsdWRlIGEgbWF0Y2gsIHdoaWNoXG4gICAgICAgIC8vIG1lYW5zIHRoZSBtYXRjaCBpcyBub3QgdW5pdmVyc2FsLlxuICAgICAgICBpZiAodW5pdmVyc2FsICYmICFpc0xvd2VyICYmIFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIElmIHRoZXJlJ3MgYSBtYXRjaCBhbmQgaXQncyBsb3dlciB0aGFuIHRoZSBsYXN0LCB1cGRhdGUgdGhlIGhpdC5cblxuXG4gICAgICBpZiAobW9kZSA9PT0gJ2xvd2VzdCcgJiYgaXNMb3dlcikge1xuICAgICAgICBoaXQgPSBbbm9kZSwgcGF0aF07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBJbiBsb3dlc3QgbW9kZSB3ZSBlbWl0IHRoZSBsYXN0IGhpdCwgb25jZSBpdCdzIGd1YXJhbnRlZWQgbG93ZXN0LlxuXG5cbiAgICAgIHZhciBlbWl0ID0gbW9kZSA9PT0gJ2xvd2VzdCcgPyBoaXQgOiBbbm9kZSwgcGF0aF07XG5cbiAgICAgIGlmIChlbWl0KSB7XG4gICAgICAgIGlmICh1bml2ZXJzYWwpIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goZW1pdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeWllbGQgZW1pdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBoaXQgPSBbbm9kZSwgcGF0aF07XG4gICAgfSAvLyBTaW5jZSBsb3dlc3QgaXMgYWx3YXlzIGVtaXR0aW5nIG9uZSBiZWhpbmQsIGNhdGNoIHVwIGF0IHRoZSBlbmQuXG5cblxuICAgIGlmIChtb2RlID09PSAnbG93ZXN0JyAmJiBoaXQpIHtcbiAgICAgIGlmICh1bml2ZXJzYWwpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKGhpdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5aWVsZCBoaXQ7XG4gICAgICB9XG4gICAgfSAvLyBVbml2ZXJzYWwgZGVmZXJzIHRvIGVuc3VyZSB0aGF0IHRoZSBtYXRjaCBvY2N1cnMgaW4gZXZlcnkgYnJhbmNoLCBzbyB3ZVxuICAgIC8vIHlpZWxkIGFsbCBvZiB0aGUgbWF0Y2hlcyBhZnRlciBpdGVyYXRpbmcuXG5cblxuICAgIGlmICh1bml2ZXJzYWwpIHtcbiAgICAgIHlpZWxkKiBtYXRjaGVzO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBOb3JtYWxpemUgYW55IGRpcnR5IG9iamVjdHMgaW4gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgbm9ybWFsaXplKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgZm9yY2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgdmFyIGdldERpcnR5UGF0aHMgPSBlZGl0b3IgPT4ge1xuICAgICAgcmV0dXJuIERJUlRZX1BBVEhTLmdldChlZGl0b3IpIHx8IFtdO1xuICAgIH07XG5cbiAgICBpZiAoIUVkaXRvci5pc05vcm1hbGl6aW5nKGVkaXRvcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZm9yY2UpIHtcbiAgICAgIHZhciBhbGxQYXRocyA9IEFycmF5LmZyb20oTm9kZS5ub2RlcyhlZGl0b3IpLCAoX3JlZjIpID0+IHtcbiAgICAgICAgdmFyIFssIHBdID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfSk7XG4gICAgICBESVJUWV9QQVRIUy5zZXQoZWRpdG9yLCBhbGxQYXRocyk7XG4gICAgfVxuXG4gICAgaWYgKGdldERpcnR5UGF0aHMoZWRpdG9yKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIG1heCA9IGdldERpcnR5UGF0aHMoZWRpdG9yKS5sZW5ndGggKiA0MjsgLy8gSEFDSzogYmV0dGVyIHdheT9cblxuICAgICAgdmFyIG0gPSAwO1xuXG4gICAgICB3aGlsZSAoZ2V0RGlydHlQYXRocyhlZGl0b3IpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBpZiAobSA+IG1heCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcbiAgICAgICAgICAgIENvdWxkIG5vdCBjb21wbGV0ZWx5IG5vcm1hbGl6ZSB0aGUgZWRpdG9yIGFmdGVyIFwiLmNvbmNhdChtYXgsIFwiIGl0ZXJhdGlvbnMhIFRoaXMgaXMgdXN1YWxseSBkdWUgdG8gaW5jb3JyZWN0IG5vcm1hbGl6YXRpb24gbG9naWMgdGhhdCBsZWF2ZXMgYSBub2RlIGluIGFuIGludmFsaWQgc3RhdGUuXFxuICAgICAgICAgIFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF0aCA9IGdldERpcnR5UGF0aHMoZWRpdG9yKS5wb3AoKTtcbiAgICAgICAgdmFyIGVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUoZW50cnkpO1xuICAgICAgICBtKys7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBwYXJlbnQgbm9kZSBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBwYXJlbnQoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIG9wdGlvbnMpO1xuICAgIHZhciBwYXJlbnRQYXRoID0gUGF0aC5wYXJlbnQocGF0aCk7XG4gICAgdmFyIGVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXJlbnRQYXRoKTtcbiAgICByZXR1cm4gZW50cnk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBwYXRoIG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHBhdGgoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgZGVwdGgsXG4gICAgICBlZGdlXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICB2YXIgWywgZmlyc3RQYXRoXSA9IE5vZGUuZmlyc3QoZWRpdG9yLCBhdCk7XG4gICAgICAgIGF0ID0gZmlyc3RQYXRoO1xuICAgICAgfSBlbHNlIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgICB2YXIgWywgbGFzdFBhdGhdID0gTm9kZS5sYXN0KGVkaXRvciwgYXQpO1xuICAgICAgICBhdCA9IGxhc3RQYXRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgICAgYXQgPSBSYW5nZS5zdGFydChhdCk7XG4gICAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICAgIGF0ID0gUmFuZ2UuZW5kKGF0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0ID0gUGF0aC5jb21tb24oYXQuYW5jaG9yLnBhdGgsIGF0LmZvY3VzLnBhdGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChQb2ludC5pc1BvaW50KGF0KSkge1xuICAgICAgYXQgPSBhdC5wYXRoO1xuICAgIH1cblxuICAgIGlmIChkZXB0aCAhPSBudWxsKSB7XG4gICAgICBhdCA9IGF0LnNsaWNlKDAsIGRlcHRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbXV0YWJsZSByZWYgZm9yIGEgYFBhdGhgIG9iamVjdCwgd2hpY2ggd2lsbCBzdGF5IGluIHN5bmMgYXMgbmV3XHJcbiAgICogb3BlcmF0aW9ucyBhcmUgYXBwbGllZCB0byB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBwYXRoUmVmKGVkaXRvciwgcGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgYWZmaW5pdHkgPSAnZm9yd2FyZCdcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgcmVmID0ge1xuICAgICAgY3VycmVudDogcGF0aCxcbiAgICAgIGFmZmluaXR5LFxuXG4gICAgICB1bnJlZigpIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBjdXJyZW50XG4gICAgICAgIH0gPSByZWY7XG4gICAgICAgIHZhciBwYXRoUmVmcyA9IEVkaXRvci5wYXRoUmVmcyhlZGl0b3IpO1xuICAgICAgICBwYXRoUmVmcy5kZWxldGUocmVmKTtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cblxuICAgIH07XG4gICAgdmFyIHJlZnMgPSBFZGl0b3IucGF0aFJlZnMoZWRpdG9yKTtcbiAgICByZWZzLmFkZChyZWYpO1xuICAgIHJldHVybiByZWY7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzZXQgb2YgY3VycmVudGx5IHRyYWNrZWQgcGF0aCByZWZzIG9mIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIHBhdGhSZWZzKGVkaXRvcikge1xuICAgIHZhciByZWZzID0gUEFUSF9SRUZTLmdldChlZGl0b3IpO1xuXG4gICAgaWYgKCFyZWZzKSB7XG4gICAgICByZWZzID0gbmV3IFNldCgpO1xuICAgICAgUEFUSF9SRUZTLnNldChlZGl0b3IsIHJlZnMpO1xuICAgIH1cblxuICAgIHJldHVybiByZWZzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3RhcnQgb3IgZW5kIHBvaW50IG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHBvaW50KGVkaXRvciwgYXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGVkZ2UgPSAnc3RhcnQnXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICB2YXIgcGF0aDtcblxuICAgICAgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICAgIHZhciBbLCBsYXN0UGF0aF0gPSBOb2RlLmxhc3QoZWRpdG9yLCBhdCk7XG4gICAgICAgIHBhdGggPSBsYXN0UGF0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBbLCBmaXJzdFBhdGhdID0gTm9kZS5maXJzdChlZGl0b3IsIGF0KTtcbiAgICAgICAgcGF0aCA9IGZpcnN0UGF0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGUgPSBOb2RlLmdldChlZGl0b3IsIHBhdGgpO1xuXG4gICAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIFwiLmNvbmNhdChlZGdlLCBcIiBwb2ludCBpbiB0aGUgbm9kZSBhdCBwYXRoIFtcIikuY29uY2F0KGF0LCBcIl0gYmVjYXVzZSBpdCBoYXMgbm8gXCIpLmNvbmNhdChlZGdlLCBcIiB0ZXh0IG5vZGUuXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgb2Zmc2V0OiBlZGdlID09PSAnZW5kJyA/IG5vZGUudGV4dC5sZW5ndGggOiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgIHJldHVybiBlZGdlID09PSAnc3RhcnQnID8gc3RhcnQgOiBlbmQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG11dGFibGUgcmVmIGZvciBhIGBQb2ludGAgb2JqZWN0LCB3aGljaCB3aWxsIHN0YXkgaW4gc3luYyBhcyBuZXdcclxuICAgKiBvcGVyYXRpb25zIGFyZSBhcHBsaWVkIHRvIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIHBvaW50UmVmKGVkaXRvciwgcG9pbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGFmZmluaXR5ID0gJ2ZvcndhcmQnXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHJlZiA9IHtcbiAgICAgIGN1cnJlbnQ6IHBvaW50LFxuICAgICAgYWZmaW5pdHksXG5cbiAgICAgIHVucmVmKCkge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgfSA9IHJlZjtcbiAgICAgICAgdmFyIHBvaW50UmVmcyA9IEVkaXRvci5wb2ludFJlZnMoZWRpdG9yKTtcbiAgICAgICAgcG9pbnRSZWZzLmRlbGV0ZShyZWYpO1xuICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuXG4gICAgfTtcbiAgICB2YXIgcmVmcyA9IEVkaXRvci5wb2ludFJlZnMoZWRpdG9yKTtcbiAgICByZWZzLmFkZChyZWYpO1xuICAgIHJldHVybiByZWY7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzZXQgb2YgY3VycmVudGx5IHRyYWNrZWQgcG9pbnQgcmVmcyBvZiB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBwb2ludFJlZnMoZWRpdG9yKSB7XG4gICAgdmFyIHJlZnMgPSBQT0lOVF9SRUZTLmdldChlZGl0b3IpO1xuXG4gICAgaWYgKCFyZWZzKSB7XG4gICAgICByZWZzID0gbmV3IFNldCgpO1xuICAgICAgUE9JTlRfUkVGUy5zZXQoZWRpdG9yLCByZWZzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVmcztcbiAgfSxcblxuICAvKipcclxuICAgKiBJdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBwb3NpdGlvbnMgaW4gdGhlIGRvY3VtZW50IHdoZXJlIGEgYFBvaW50YCBjYW4gYmVcclxuICAgKiBwbGFjZWQuXHJcbiAgICpcclxuICAgKiBCeSBkZWZhdWx0IGl0IHdpbGwgbW92ZSBmb3J3YXJkIGJ5IGluZGl2aWR1YWwgb2Zmc2V0cyBhdCBhIHRpbWUsICBidXQgeW91XHJcbiAgICogY2FuIHBhc3MgdGhlIGB1bml0OiAnY2hhcmFjdGVyJ2Agb3B0aW9uIHRvIG1vdmVkIGZvcndhcmQgb25lIGNoYXJhY3Rlciwgd29yZCxcclxuICAgKiBvciBsaW5lIGF0IGF0IHRpbWUuXHJcbiAgICpcclxuICAgKiBOb3RlOiB2b2lkIG5vZGVzIGFyZSB0cmVhdGVkIGFzIGEgc2luZ2xlIHBvaW50LCBhbmQgaXRlcmF0aW9uIHdpbGwgbm90XHJcbiAgICogaGFwcGVuIGluc2lkZSB0aGVpciBjb250ZW50LlxyXG4gICAqL1xuICAqcG9zaXRpb25zKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgdW5pdCA9ICdvZmZzZXQnLFxuICAgICAgcmV2ZXJzZTogcmV2ZXJzZSQxID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICB2YXIgZmlyc3QgPSByZXZlcnNlJDEgPyBlbmQgOiBzdGFydDtcbiAgICB2YXIgc3RyaW5nID0gJyc7XG4gICAgdmFyIGF2YWlsYWJsZSA9IDA7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgdmFyIGRpc3RhbmNlID0gbnVsbDtcbiAgICB2YXIgaXNOZXdCbG9jayA9IGZhbHNlO1xuXG4gICAgdmFyIGFkdmFuY2UgPSAoKSA9PiB7XG4gICAgICBpZiAoZGlzdGFuY2UgPT0gbnVsbCkge1xuICAgICAgICBpZiAodW5pdCA9PT0gJ2NoYXJhY3RlcicpIHtcbiAgICAgICAgICBkaXN0YW5jZSA9IGdldENoYXJhY3RlckRpc3RhbmNlKHN0cmluZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodW5pdCA9PT0gJ3dvcmQnKSB7XG4gICAgICAgICAgZGlzdGFuY2UgPSBnZXRXb3JkRGlzdGFuY2Uoc3RyaW5nKTtcbiAgICAgICAgfSBlbHNlIGlmICh1bml0ID09PSAnbGluZScgfHwgdW5pdCA9PT0gJ2Jsb2NrJykge1xuICAgICAgICAgIGRpc3RhbmNlID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaXN0YW5jZSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoZGlzdGFuY2UpO1xuICAgICAgfSAvLyBBZGQgb3Igc3Vic3RyYWN0IHRoZSBvZmZzZXQuXG5cblxuICAgICAgb2Zmc2V0ID0gcmV2ZXJzZSQxID8gb2Zmc2V0IC0gZGlzdGFuY2UgOiBvZmZzZXQgKyBkaXN0YW5jZTsgLy8gU3VidHJhY3QgdGhlIGRpc3RhbmNlIHRyYXZlbGVkIGZyb20gdGhlIGF2YWlsYWJsZSB0ZXh0LlxuXG4gICAgICBhdmFpbGFibGUgPSBhdmFpbGFibGUgLSBkaXN0YW5jZTsgLy8gSWYgdGhlIGF2YWlsYWJsZSBoYWQgcm9vbSB0byBzcGFyZSwgcmVzZXQgdGhlIGRpc3RhbmNlIHNvIHRoYXQgaXQgd2lsbFxuICAgICAgLy8gYWR2YW5jZSBhZ2FpbiBuZXh0IHRpbWUuIE90aGVyd2lzZSwgc2V0IGl0IHRvIHRoZSBvdmVyZmxvdyBhbW91bnQuXG5cbiAgICAgIGRpc3RhbmNlID0gYXZhaWxhYmxlID49IDAgPyBudWxsIDogMCAtIGF2YWlsYWJsZTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgcmV2ZXJzZTogcmV2ZXJzZSQxXG4gICAgfSkpIHtcbiAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSkge1xuICAgICAgICAvLyBWb2lkIG5vZGVzIGFyZSBhIHNwZWNpYWwgY2FzZSwgc2luY2Ugd2UgZG9uJ3Qgd2FudCB0byBpdGVyYXRlIG92ZXJcbiAgICAgICAgLy8gdGhlaXIgY29udGVudC4gV2UgaW5zdGVhZCBhbHdheXMganVzdCB5aWVsZCB0aGVpciBmaXJzdCBwb2ludC5cbiAgICAgICAgaWYgKGVkaXRvci5pc1ZvaWQobm9kZSkpIHtcbiAgICAgICAgICB5aWVsZCBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlZGl0b3IuaXNJbmxpbmUobm9kZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChFZGl0b3IuaGFzSW5saW5lcyhlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgdmFyIGUgPSBQYXRoLmlzQW5jZXN0b3IocGF0aCwgZW5kLnBhdGgpID8gZW5kIDogRWRpdG9yLmVuZChlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgIHZhciBzID0gUGF0aC5pc0FuY2VzdG9yKHBhdGgsIHN0YXJ0LnBhdGgpID8gc3RhcnQgOiBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgICB2YXIgdGV4dCA9IEVkaXRvci5zdHJpbmcoZWRpdG9yLCB7XG4gICAgICAgICAgICBhbmNob3I6IHMsXG4gICAgICAgICAgICBmb2N1czogZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0cmluZyA9IHJldmVyc2UkMSA/IHJldmVyc2UodGV4dCkgOiB0ZXh0O1xuICAgICAgICAgIGlzTmV3QmxvY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICB2YXIgaXNGaXJzdCA9IFBhdGguZXF1YWxzKHBhdGgsIGZpcnN0LnBhdGgpO1xuICAgICAgICBhdmFpbGFibGUgPSBub2RlLnRleHQubGVuZ3RoO1xuICAgICAgICBvZmZzZXQgPSByZXZlcnNlJDEgPyBhdmFpbGFibGUgOiAwO1xuXG4gICAgICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgICAgYXZhaWxhYmxlID0gcmV2ZXJzZSQxID8gZmlyc3Qub2Zmc2V0IDogYXZhaWxhYmxlIC0gZmlyc3Qub2Zmc2V0O1xuICAgICAgICAgIG9mZnNldCA9IGZpcnN0Lm9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0ZpcnN0IHx8IGlzTmV3QmxvY2sgfHwgdW5pdCA9PT0gJ29mZnNldCcpIHtcbiAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgb2Zmc2V0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUncyBubyBtb3JlIHN0cmluZywgY29udGludWUgdG8gdGhlIG5leHQgYmxvY2suXG4gICAgICAgICAgaWYgKHN0cmluZyA9PT0gJycpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZHZhbmNlKCk7XG4gICAgICAgICAgfSAvLyBJZiB0aGUgYXZhaWxhYmxlIHNwYWNlIGhhc24ndCBvdmVyZmxvdywgd2UgaGF2ZSBhbm90aGVyIHBvaW50IHRvXG4gICAgICAgICAgLy8geWllbGQgaW4gdGhlIGN1cnJlbnQgdGV4dCBub2RlLlxuXG5cbiAgICAgICAgICBpZiAoYXZhaWxhYmxlID49IDApIHtcbiAgICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgb2Zmc2V0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpc05ld0Jsb2NrID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbWF0Y2hpbmcgbm9kZSBpbiB0aGUgYnJhbmNoIG9mIHRoZSBkb2N1bWVudCBiZWZvcmUgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgcHJldmlvdXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoLFxuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIFssIGZyb21dID0gRWRpdG9yLmZpcnN0KGVkaXRvciwgYXQpO1xuICAgIHZhciBbLCB0b10gPSBFZGl0b3IuZmlyc3QoZWRpdG9yLCBbXSk7XG4gICAgdmFyIHNwYW4gPSBbZnJvbSwgdG9dO1xuXG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSAmJiBhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHByZXZpb3VzIG5vZGUgZnJvbSB0aGUgcm9vdCBub2RlIVwiKTtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICB2YXIgW3BhcmVudF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgYXQpO1xuXG4gICAgICAgIG1hdGNoID0gbiA9PiBwYXJlbnQuY2hpbGRyZW4uaW5jbHVkZXMobik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaCA9ICgpID0+IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFssIHByZXZpb3VzXSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICBhdDogc3BhbixcbiAgICAgIG1hdGNoLFxuICAgICAgbW9kZSxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgcmV0dXJuIHByZXZpb3VzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCBhIHJhbmdlIG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHJhbmdlKGVkaXRvciwgYXQsIHRvKSB7XG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpICYmICF0bykge1xuICAgICAgcmV0dXJuIGF0O1xuICAgIH1cblxuICAgIHZhciBzdGFydCA9IEVkaXRvci5zdGFydChlZGl0b3IsIGF0KTtcbiAgICB2YXIgZW5kID0gRWRpdG9yLmVuZChlZGl0b3IsIHRvIHx8IGF0KTtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yOiBzdGFydCxcbiAgICAgIGZvY3VzOiBlbmRcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG11dGFibGUgcmVmIGZvciBhIGBSYW5nZWAgb2JqZWN0LCB3aGljaCB3aWxsIHN0YXkgaW4gc3luYyBhcyBuZXdcclxuICAgKiBvcGVyYXRpb25zIGFyZSBhcHBsaWVkIHRvIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIHJhbmdlUmVmKGVkaXRvciwgcmFuZ2UpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGFmZmluaXR5ID0gJ2ZvcndhcmQnXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHJlZiA9IHtcbiAgICAgIGN1cnJlbnQ6IHJhbmdlLFxuICAgICAgYWZmaW5pdHksXG5cbiAgICAgIHVucmVmKCkge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgfSA9IHJlZjtcbiAgICAgICAgdmFyIHJhbmdlUmVmcyA9IEVkaXRvci5yYW5nZVJlZnMoZWRpdG9yKTtcbiAgICAgICAgcmFuZ2VSZWZzLmRlbGV0ZShyZWYpO1xuICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuXG4gICAgfTtcbiAgICB2YXIgcmVmcyA9IEVkaXRvci5yYW5nZVJlZnMoZWRpdG9yKTtcbiAgICByZWZzLmFkZChyZWYpO1xuICAgIHJldHVybiByZWY7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzZXQgb2YgY3VycmVudGx5IHRyYWNrZWQgcmFuZ2UgcmVmcyBvZiB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICByYW5nZVJlZnMoZWRpdG9yKSB7XG4gICAgdmFyIHJlZnMgPSBSQU5HRV9SRUZTLmdldChlZGl0b3IpO1xuXG4gICAgaWYgKCFyZWZzKSB7XG4gICAgICByZWZzID0gbmV3IFNldCgpO1xuICAgICAgUkFOR0VfUkVGUy5zZXQoZWRpdG9yLCByZWZzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVmcztcbiAgfSxcblxuICAvKipcclxuICAgKiBSZW1vdmUgYSBjdXN0b20gcHJvcGVydHkgZnJvbSBhbGwgb2YgdGhlIGxlYWYgdGV4dCBub2RlcyBpbiB0aGUgY3VycmVudFxyXG4gICAqIHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGNvbGxhcHNlZCwgdGhlIHJlbW92YWwgd2lsbCBiZSBzdG9yZWQgb25cclxuICAgKiBgZWRpdG9yLm1hcmtzYCBhbmQgYXBwbGllZCB0byB0aGUgdGV4dCBpbnNlcnRlZCBuZXh0LlxyXG4gICAqL1xuICByZW1vdmVNYXJrKGVkaXRvciwga2V5KSB7XG4gICAgZWRpdG9yLnJlbW92ZU1hcmsoa2V5KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHN0YXJ0IHBvaW50IG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHN0YXJ0KGVkaXRvciwgYXQpIHtcbiAgICByZXR1cm4gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdzdGFydCdcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHRleHQgc3RyaW5nIGNvbnRlbnQgb2YgYSBsb2NhdGlvbi5cclxuICAgKlxyXG4gICAqIE5vdGU6IHRoZSB0ZXh0IG9mIHZvaWQgbm9kZXMgaXMgcHJlc3VtZWQgdG8gYmUgYW4gZW1wdHkgc3RyaW5nLCByZWdhcmRsZXNzXHJcbiAgICogb2Ygd2hhdCB0aGVpciBhY3R1YWwgY29udGVudCBpcy5cclxuICAgKi9cbiAgc3RyaW5nKGVkaXRvciwgYXQpIHtcbiAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICB2YXIgdGV4dCA9ICcnO1xuXG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZSxcbiAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dFxuICAgIH0pKSB7XG4gICAgICB2YXIgdCA9IG5vZGUudGV4dDtcblxuICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIGVuZC5wYXRoKSkge1xuICAgICAgICB0ID0gdC5zbGljZSgwLCBlbmQub2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIHN0YXJ0LnBhdGgpKSB7XG4gICAgICAgIHQgPSB0LnNsaWNlKHN0YXJ0Lm9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIHRleHQgKz0gdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfSxcblxuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gdGhlIGVkaXRvciBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybShlZGl0b3IsIG9wKSB7XG4gICAgZWRpdG9yLmNoaWxkcmVuID0gY3JlYXRlRHJhZnQoZWRpdG9yLmNoaWxkcmVuKTtcbiAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbiAmJiBjcmVhdGVEcmFmdChlZGl0b3Iuc2VsZWN0aW9uKTtcblxuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBub2RlXG4gICAgICAgICAgfSA9IG9wO1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBOb2RlLnBhcmVudChlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgIHZhciBpbmRleCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBub2RlKTtcblxuICAgICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGZvciAodmFyIFtwb2ludCwga2V5XSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBzZWxlY3Rpb25ba2V5XSA9IFBvaW50LnRyYW5zZm9ybShwb2ludCwgb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIHRleHRcbiAgICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgICB2YXIgX25vZGUyID0gTm9kZS5sZWFmKGVkaXRvciwgX3BhdGgpO1xuXG4gICAgICAgICAgdmFyIGJlZm9yZSA9IF9ub2RlMi50ZXh0LnNsaWNlKDAsIG9mZnNldCk7XG5cbiAgICAgICAgICB2YXIgYWZ0ZXIgPSBfbm9kZTIudGV4dC5zbGljZShvZmZzZXQpO1xuXG4gICAgICAgICAgX25vZGUyLnRleHQgPSBiZWZvcmUgKyB0ZXh0ICsgYWZ0ZXI7XG5cbiAgICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBbX3BvaW50LCBfa2V5XSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleV0gPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50LCBvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogX3BhdGgyXG4gICAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgICAgdmFyIF9ub2RlMyA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGgyKTtcblxuICAgICAgICAgIHZhciBwcmV2UGF0aCA9IFBhdGgucHJldmlvdXMoX3BhdGgyKTtcbiAgICAgICAgICB2YXIgcHJldiA9IE5vZGUuZ2V0KGVkaXRvciwgcHJldlBhdGgpO1xuXG4gICAgICAgICAgdmFyIF9wYXJlbnQgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoMik7XG5cbiAgICAgICAgICB2YXIgX2luZGV4ID0gX3BhdGgyW19wYXRoMi5sZW5ndGggLSAxXTtcblxuICAgICAgICAgIGlmIChUZXh0LmlzVGV4dChfbm9kZTMpICYmIFRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgICAgICBwcmV2LnRleHQgKz0gX25vZGUzLnRleHQ7XG4gICAgICAgICAgfSBlbHNlIGlmICghVGV4dC5pc1RleHQoX25vZGUzKSAmJiAhVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgICAgIHByZXYuY2hpbGRyZW4ucHVzaCguLi5fbm9kZTMuY2hpbGRyZW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgYSBcXFwibWVyZ2Vfbm9kZVxcXCIgb3BlcmF0aW9uIGF0IHBhdGggW1wiLmNvbmNhdChfcGF0aDIsIFwiXSB0byBub2RlcyBvZiBkaWZmZXJlbnQgaW50ZXJhY2VzOiBcIikuY29uY2F0KF9ub2RlMywgXCIgXCIpLmNvbmNhdChwcmV2KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3BhcmVudC5jaGlsZHJlbi5zcGxpY2UoX2luZGV4LCAxKTtcblxuICAgICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQyLCBfa2V5Ml0gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXkyXSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQyLCBvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfcGF0aDMsXG4gICAgICAgICAgICBuZXdQYXRoXG4gICAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgICAgaWYgKFBhdGguaXNBbmNlc3RvcihfcGF0aDMsIG5ld1BhdGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbW92ZSBhIHBhdGggW1wiLmNvbmNhdChfcGF0aDMsIFwiXSB0byBuZXcgcGF0aCBbXCIpLmNvbmNhdChuZXdQYXRoLCBcIl0gYmVjYXVzZSB0aGUgZGVzdGluYXRpb24gaXMgaW5zaWRlIGl0c2VsZi5cIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfbm9kZTQgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoMyk7XG5cbiAgICAgICAgICB2YXIgX3BhcmVudDIgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoMyk7XG5cbiAgICAgICAgICB2YXIgX2luZGV4MiA9IF9wYXRoM1tfcGF0aDMubGVuZ3RoIC0gMV07IC8vIFRoaXMgaXMgdHJpY2t5LCBidXQgc2luY2UgdGhlIGBwYXRoYCBhbmQgYG5ld1BhdGhgIGJvdGggcmVmZXIgdG9cbiAgICAgICAgICAvLyB0aGUgc2FtZSBzbmFwc2hvdCBpbiB0aW1lLCB0aGVyZSdzIGEgbWlzbWF0Y2guIEFmdGVyIGVpdGhlclxuICAgICAgICAgIC8vIHJlbW92aW5nIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiwgdGhlIHNlY29uZCBzdGVwJ3MgcGF0aCBjYW4gYmUgb3V0XG4gICAgICAgICAgLy8gb2YgZGF0ZS4gU28gaW5zdGVhZCBvZiB1c2luZyB0aGUgYG9wLm5ld1BhdGhgIGRpcmVjdGx5LCB3ZVxuICAgICAgICAgIC8vIHRyYW5zZm9ybSBgb3AucGF0aGAgdG8gYXNjZXJ0YWluIHdoYXQgdGhlIGBuZXdQYXRoYCB3b3VsZCBiZSBhZnRlclxuICAgICAgICAgIC8vIHRoZSBvcGVyYXRpb24gd2FzIGFwcGxpZWQuXG5cbiAgICAgICAgICBfcGFyZW50Mi5jaGlsZHJlbi5zcGxpY2UoX2luZGV4MiwgMSk7XG5cbiAgICAgICAgICB2YXIgdHJ1ZVBhdGggPSBQYXRoLnRyYW5zZm9ybShfcGF0aDMsIG9wKTtcbiAgICAgICAgICB2YXIgbmV3UGFyZW50ID0gTm9kZS5nZXQoZWRpdG9yLCBQYXRoLnBhcmVudCh0cnVlUGF0aCkpO1xuICAgICAgICAgIHZhciBuZXdJbmRleCA9IHRydWVQYXRoW3RydWVQYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIG5ld1BhcmVudC5jaGlsZHJlbi5zcGxpY2UobmV3SW5kZXgsIDAsIF9ub2RlNCk7XG5cbiAgICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBbX3BvaW50MywgX2tleTNdIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5M10gPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50Mywgb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfcGF0aDRcbiAgICAgICAgICB9ID0gb3A7XG4gICAgICAgICAgdmFyIF9pbmRleDMgPSBfcGF0aDRbX3BhdGg0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgdmFyIF9wYXJlbnQzID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDQpO1xuXG4gICAgICAgICAgX3BhcmVudDMuY2hpbGRyZW4uc3BsaWNlKF9pbmRleDMsIDEpOyAvLyBUcmFuc2Zvcm0gYWxsIG9mIHRoZSBwb2ludHMgaW4gdGhlIHZhbHVlLCBidXQgaWYgdGhlIHBvaW50IHdhcyBpbiB0aGVcbiAgICAgICAgICAvLyBub2RlIHRoYXQgd2FzIHJlbW92ZWQgd2UgbmVlZCB0byB1cGRhdGUgdGhlIHJhbmdlIG9yIHJlbW92ZSBpdC5cblxuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgZm9yICh2YXIgW19wb2ludDQsIF9rZXk0XSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDQsIG9wKTtcblxuICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uICE9IG51bGwgJiYgcmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleTRdID0gcmVzdWx0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBfcHJldiA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gdm9pZCAwO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgW24sIHBdIG9mIE5vZGUudGV4dHMoZWRpdG9yKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKFBhdGguY29tcGFyZShwLCBfcGF0aDQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBfcHJldiA9IFtuLCBwXTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBbbiwgcF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfcHJldikge1xuICAgICAgICAgICAgICAgICAgX3BvaW50NC5wYXRoID0gX3ByZXZbMV07XG4gICAgICAgICAgICAgICAgICBfcG9pbnQ0Lm9mZnNldCA9IF9wcmV2WzBdLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgX3BvaW50NC5wYXRoID0gbmV4dFsxXTtcbiAgICAgICAgICAgICAgICAgIF9wb2ludDQub2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogX3BhdGg1LFxuICAgICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0LFxuICAgICAgICAgICAgdGV4dDogX3RleHQyXG4gICAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgICAgdmFyIF9ub2RlNSA9IE5vZGUubGVhZihlZGl0b3IsIF9wYXRoNSk7XG5cbiAgICAgICAgICB2YXIgX2JlZm9yZSA9IF9ub2RlNS50ZXh0LnNsaWNlKDAsIF9vZmZzZXQpO1xuXG4gICAgICAgICAgdmFyIF9hZnRlciA9IF9ub2RlNS50ZXh0LnNsaWNlKF9vZmZzZXQgKyBfdGV4dDIubGVuZ3RoKTtcblxuICAgICAgICAgIF9ub2RlNS50ZXh0ID0gX2JlZm9yZSArIF9hZnRlcjtcblxuICAgICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQ1LCBfa2V5NV0gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk1XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQ1LCBvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoNixcbiAgICAgICAgICAgIG5ld1Byb3BlcnRpZXNcbiAgICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgICBpZiAoX3BhdGg2Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBwcm9wZXJ0aWVzIG9uIHRoZSByb290IG5vZGUhXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfbm9kZTYgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoNik7XG5cbiAgICAgICAgICBmb3IgKHZhciBfa2V5NiBpbiBuZXdQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAoX2tleTYgPT09ICdjaGlsZHJlbicgfHwgX2tleTYgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHRoZSBcXFwiXCIuY29uY2F0KF9rZXk2LCBcIlxcXCIgcHJvcGVydHkgb2Ygbm9kZXMhXCIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gbmV3UHJvcGVydGllc1tfa2V5Nl07XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBfbm9kZTZbX2tleTZdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX25vZGU2W19rZXk2XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IF9uZXdQcm9wZXJ0aWVzXG4gICAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgICAgaWYgKF9uZXdQcm9wZXJ0aWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IF9uZXdQcm9wZXJ0aWVzO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghUmFuZ2UuaXNSYW5nZShfbmV3UHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGFuIGluY29tcGxldGUgXFxcInNldF9zZWxlY3Rpb25cXFwiIG9wZXJhdGlvbiBwcm9wZXJ0aWVzIFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShfbmV3UHJvcGVydGllcyksIFwiIHdoZW4gdGhlcmUgaXMgbm8gY3VycmVudCBzZWxlY3Rpb24uXCIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZWN0aW9uID0gX25ld1Byb3BlcnRpZXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2VsZWN0aW9uLCBfbmV3UHJvcGVydGllcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogX3BhdGg3LFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBwcm9wZXJ0aWVzXG4gICAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgICAgaWYgKF9wYXRoNy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhIFxcXCJzcGxpdF9ub2RlXFxcIiBvcGVyYXRpb24gYXQgcGF0aCBbXCIuY29uY2F0KF9wYXRoNywgXCJdIGJlY2F1c2UgdGhlIHJvb3Qgbm9kZSBjYW5ub3QgYmUgc3BsaXQuXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX25vZGU3ID0gTm9kZS5nZXQoZWRpdG9yLCBfcGF0aDcpO1xuXG4gICAgICAgICAgdmFyIF9wYXJlbnQ0ID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDcpO1xuXG4gICAgICAgICAgdmFyIF9pbmRleDQgPSBfcGF0aDdbX3BhdGg3Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHZhciBuZXdOb2RlO1xuXG4gICAgICAgICAgaWYgKFRleHQuaXNUZXh0KF9ub2RlNykpIHtcbiAgICAgICAgICAgIHZhciBfYmVmb3JlMiA9IF9ub2RlNy50ZXh0LnNsaWNlKDAsIHBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdmFyIF9hZnRlcjIgPSBfbm9kZTcudGV4dC5zbGljZShwb3NpdGlvbik7XG5cbiAgICAgICAgICAgIF9ub2RlNy50ZXh0ID0gX2JlZm9yZTI7XG4gICAgICAgICAgICBuZXdOb2RlID0gX29iamVjdFNwcmVhZCh7fSwgX25vZGU3LCB7fSwgcHJvcGVydGllcywge1xuICAgICAgICAgICAgICB0ZXh0OiBfYWZ0ZXIyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIF9iZWZvcmUzID0gX25vZGU3LmNoaWxkcmVuLnNsaWNlKDAsIHBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdmFyIF9hZnRlcjMgPSBfbm9kZTcuY2hpbGRyZW4uc2xpY2UocG9zaXRpb24pO1xuXG4gICAgICAgICAgICBfbm9kZTcuY2hpbGRyZW4gPSBfYmVmb3JlMztcbiAgICAgICAgICAgIG5ld05vZGUgPSBfb2JqZWN0U3ByZWFkKHt9LCBfbm9kZTcsIHt9LCBwcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBfYWZ0ZXIzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfcGFyZW50NC5jaGlsZHJlbi5zcGxpY2UoX2luZGV4NCArIDEsIDAsIG5ld05vZGUpO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgZm9yICh2YXIgW19wb2ludDYsIF9rZXk3XSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleTddID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDYsIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVkaXRvci5jaGlsZHJlbiA9IGZpbmlzaERyYWZ0KGVkaXRvci5jaGlsZHJlbik7XG5cbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uID0gaXNEcmFmdChzZWxlY3Rpb24pID8gZmluaXNoRHJhZnQoc2VsZWN0aW9uKSA6IHNlbGVjdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIENvbnZlcnQgYSByYW5nZSBpbnRvIGEgbm9uLWhhbmdpbmcgb25lLlxyXG4gICAqL1xuICB1bmhhbmdSYW5nZShlZGl0b3IsIHJhbmdlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTsgLy8gUEVSRjogZXhpdCBlYXJseSBpZiB3ZSBjYW4gZ3VhcmFudGVlIHRoYXQgdGhlIHJhbmdlIGlzbid0IGhhbmdpbmcuXG5cbiAgICBpZiAoc3RhcnQub2Zmc2V0ICE9PSAwIHx8IGVuZC5vZmZzZXQgIT09IDAgfHwgUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpKSB7XG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuXG4gICAgdmFyIGVuZEJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgYXQ6IGVuZCxcbiAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbilcbiAgICB9KTtcbiAgICB2YXIgYmxvY2tQYXRoID0gZW5kQmxvY2sgPyBlbmRCbG9ja1sxXSA6IFtdO1xuICAgIHZhciBmaXJzdCA9IEVkaXRvci5zdGFydChlZGl0b3IsIFtdKTtcbiAgICB2YXIgYmVmb3JlID0ge1xuICAgICAgYW5jaG9yOiBmaXJzdCxcbiAgICAgIGZvY3VzOiBlbmRcbiAgICB9O1xuICAgIHZhciBza2lwID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogYmVmb3JlLFxuICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgIHZvaWRzXG4gICAgfSkpIHtcbiAgICAgIGlmIChza2lwKSB7XG4gICAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnRleHQgIT09ICcnIHx8IFBhdGguaXNCZWZvcmUocGF0aCwgYmxvY2tQYXRoKSkge1xuICAgICAgICBlbmQgPSB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IG5vZGUudGV4dC5sZW5ndGhcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICBmb2N1czogZW5kXG4gICAgfTtcbiAgfSxcblxuICAvKipcclxuICAgKiBNYXRjaCBhIHZvaWQgbm9kZSBpbiB0aGUgY3VycmVudCBicmFuY2ggb2YgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgdm9pZChlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIEVkaXRvci5hYm92ZShlZGl0b3IsIF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBuKVxuICAgIH0pKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDYWxsIGEgZnVuY3Rpb24sIGRlZmVycmluZyBub3JtYWxpemF0aW9uIHVudGlsIGFmdGVyIGl0IGNvbXBsZXRlcy5cclxuICAgKi9cbiAgd2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZm4pIHtcbiAgICB2YXIgdmFsdWUgPSBFZGl0b3IuaXNOb3JtYWxpemluZyhlZGl0b3IpO1xuICAgIE5PUk1BTElaSU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICBmbigpO1xuICAgIE5PUk1BTElaSU5HLnNldChlZGl0b3IsIHZhbHVlKTtcbiAgICBFZGl0b3Iubm9ybWFsaXplKGVkaXRvcik7XG4gIH1cblxufTtcblxudmFyIEVsZW1lbnQgPSB7XG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgYEVsZW1lbnRgIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNFbGVtZW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpICYmIE5vZGUuaXNOb2RlTGlzdCh2YWx1ZS5jaGlsZHJlbikgJiYgIUVkaXRvci5pc0VkaXRvcih2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBhcnJheSBvZiBgRWxlbWVudGAgb2JqZWN0cy5cclxuICAgKi9cbiAgaXNFbGVtZW50TGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiAodmFsdWUubGVuZ3RoID09PSAwIHx8IEVsZW1lbnQuaXNFbGVtZW50KHZhbHVlWzBdKSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYW4gZWxlbWVudCBtYXRjaGVzIHNldCBvZiBwcm9wZXJ0aWVzLlxyXG4gICAqXHJcbiAgICogTm90ZTogdGhpcyBjaGVja3MgY3VzdG9tIHByb3BlcnRpZXMsIGFuZCBpdCBkb2VzIG5vdCBlbnN1cmUgdGhhdCBhbnlcclxuICAgKiBjaGlsZHJlbiBhcmUgZXF1aXZhbGVudC5cclxuICAgKi9cbiAgbWF0Y2hlcyhlbGVtZW50LCBwcm9wcykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKGtleSA9PT0gJ2NoaWxkcmVuJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnRba2V5XSAhPT0gcHJvcHNba2V5XSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxufTtcblxudmFyIExvY2F0aW9uID0ge1xuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBMb2NhdGlvbmAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc0xvY2F0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlKSB8fCBQb2ludC5pc1BvaW50KHZhbHVlKSB8fCBSYW5nZS5pc1JhbmdlKHZhbHVlKTtcbiAgfVxuXG59O1xudmFyIFNwYW4gPSB7XG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgYFNwYW5gIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNTcGFuKHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMiAmJiB2YWx1ZS5ldmVyeShQYXRoLmlzUGF0aCk7XG4gIH1cblxufTtcblxudmFyIE5vZGUgPSB7XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbm9kZSBhdCBhIHNwZWNpZmljIHBhdGgsIGFzc2VydGluZyB0aGF0IGl0J3MgYW4gYW5jZXN0b3Igbm9kZS5cclxuICAgKi9cbiAgYW5jZXN0b3Iocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gTm9kZS5nZXQocm9vdCwgcGF0aCk7XG5cbiAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGFuY2VzdG9yIG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IHJlZmVycyB0byBhIHRleHQgbm9kZSBpbnN0ZWFkOiBcIikuY29uY2F0KG5vZGUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYW4gaXRlcmFibGUgb2YgYWxsIHRoZSBhbmNlc3RvciBub2RlcyBhYm92ZSBhIHNwZWNpZmljIHBhdGguXHJcbiAgICpcclxuICAgKiBCeSBkZWZhdWx0IHRoZSBvcmRlciBpcyBib3R0b20tdXAsIGZyb20gbG93ZXN0IHRvIGhpZ2hlc3QgYW5jZXN0b3IgaW5cclxuICAgKiB0aGUgdHJlZSwgYnV0IHlvdSBjYW4gcGFzcyB0aGUgYHJldmVyc2U6IHRydWVgIG9wdGlvbiB0byBnbyB0b3AtZG93bi5cclxuICAgKi9cbiAgKmFuY2VzdG9ycyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgZm9yICh2YXIgcCBvZiBQYXRoLmFuY2VzdG9ycyhwYXRoLCBvcHRpb25zKSkge1xuICAgICAgdmFyIG4gPSBOb2RlLmFuY2VzdG9yKHJvb3QsIHApO1xuICAgICAgdmFyIGVudHJ5ID0gW24sIHBdO1xuICAgICAgeWllbGQgZW50cnk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY2hpbGQgb2YgYSBub2RlIGF0IGEgc3BlY2lmaWMgaW5kZXguXHJcbiAgICovXG4gIGNoaWxkKHJvb3QsIGluZGV4KSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KHJvb3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBjaGlsZCBvZiBhIHRleHQgbm9kZTogXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgfVxuXG4gICAgdmFyIGMgPSByb290LmNoaWxkcmVuW2luZGV4XTtcblxuICAgIGlmIChjID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgY2hpbGQgYXQgaW5kZXggYFwiLmNvbmNhdChpbmRleCwgXCJgIGluIG5vZGU6IFwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYztcbiAgfSxcblxuICAvKipcclxuICAgKiBJdGVyYXRlIG92ZXIgdGhlIGNoaWxkcmVuIG9mIGEgbm9kZSBhdCBhIHNwZWNpZmljIHBhdGguXHJcbiAgICovXG4gICpjaGlsZHJlbihyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICByZXZlcnNlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgYW5jZXN0b3IgPSBOb2RlLmFuY2VzdG9yKHJvb3QsIHBhdGgpO1xuICAgIHZhciB7XG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBhbmNlc3RvcjtcbiAgICB2YXIgaW5kZXggPSByZXZlcnNlID8gY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDA7XG5cbiAgICB3aGlsZSAocmV2ZXJzZSA/IGluZGV4ID49IDAgOiBpbmRleCA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkID0gTm9kZS5jaGlsZChhbmNlc3RvciwgaW5kZXgpO1xuICAgICAgdmFyIGNoaWxkUGF0aCA9IHBhdGguY29uY2F0KGluZGV4KTtcbiAgICAgIHlpZWxkIFtjaGlsZCwgY2hpbGRQYXRoXTtcbiAgICAgIGluZGV4ID0gcmV2ZXJzZSA/IGluZGV4IC0gMSA6IGluZGV4ICsgMTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IGFuIGVudHJ5IGZvciB0aGUgY29tbW9uIGFuY2VzZXRvciBub2RlIG9mIHR3byBwYXRocy5cclxuICAgKi9cbiAgY29tbW9uKHJvb3QsIHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgcCA9IFBhdGguY29tbW9uKHBhdGgsIGFub3RoZXIpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgcmV0dXJuIFtuLCBwXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLCBhc3NlcnRpbmcgdGhhdCBpdCdzIGEgZGVzY2VuZGFudCBub2RlLlxyXG4gICAqL1xuICBkZXNjZW5kYW50KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KHJvb3QsIHBhdGgpO1xuXG4gICAgaWYgKEVkaXRvci5pc0VkaXRvcihub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgZGVzY2VuZGFudCBub2RlIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCByZWZlcnMgdG8gdGhlIHJvb3QgZWRpdG9yIG5vZGUgaW5zdGVhZDogXCIpLmNvbmNhdChub2RlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGFuIGl0ZXJhYmxlIG9mIGFsbCB0aGUgZGVzY2VuZGFudCBub2RlIGVudHJpZXMgaW5zaWRlIGEgcm9vdCBub2RlLlxyXG4gICAqL1xuICAqZGVzY2VuZGFudHMocm9vdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBOb2RlLm5vZGVzKHJvb3QsIG9wdGlvbnMpKSB7XG4gICAgICBpZiAocGF0aC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgLy8gTk9URTogd2UgaGF2ZSB0byBjb2VyY2UgaGVyZSBiZWNhdXNlIGNoZWNraW5nIHRoZSBwYXRoJ3MgbGVuZ3RoIGRvZXNcbiAgICAgICAgLy8gZ3VhcmFudGVlIHRoYXQgYG5vZGVgIGlzIG5vdCBhIGBFZGl0b3JgLCBidXQgVHlwZVNjcmlwdCBkb2Vzbid0IGtub3cuXG4gICAgICAgIHlpZWxkIFtub2RlLCBwYXRoXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGFuIGl0ZXJhYmxlIG9mIGFsbCB0aGUgZWxlbWVudCBub2RlcyBpbnNpZGUgYSByb290IG5vZGUuIEVhY2ggaXRlcmF0aW9uXHJcbiAgICogd2lsbCByZXR1cm4gYW4gYEVsZW1lbnRFbnRyeWAgdHVwbGUgY29uc2lzdGluZyBvZiBgW0VsZW1lbnQsIFBhdGhdYC4gSWYgdGhlXHJcbiAgICogcm9vdCBub2RlIGlzIGFuIGVsZW1lbnQgaXQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgaXRlcmF0aW9uIGFzIHdlbGwuXHJcbiAgICovXG4gICplbGVtZW50cyhyb290KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIE5vZGUubm9kZXMocm9vdCwgb3B0aW9ucykpIHtcbiAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSkge1xuICAgICAgICB5aWVsZCBbbm9kZSwgcGF0aF07XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZmlyc3Qgbm9kZSBlbnRyeSBpbiBhIHJvb3Qgbm9kZSBmcm9tIGEgcGF0aC5cclxuICAgKi9cbiAgZmlyc3Qocm9vdCwgcGF0aCkge1xuICAgIHZhciBwID0gcGF0aC5zbGljZSgpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG5cbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG4pIHx8IG4uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IG4uY2hpbGRyZW5bMF07XG4gICAgICAgIHAucHVzaCgwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW24sIHBdO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc2xpY2VkIGZyYWdtZW50IHJlcHJlc2VudGVkIGJ5IGEgcmFuZ2UgaW5zaWRlIGEgcm9vdCBub2RlLlxyXG4gICAqL1xuICBmcmFnbWVudChyb290LCByYW5nZSkge1xuICAgIGlmIChUZXh0LmlzVGV4dChyb290KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBhIGZyYWdtZW50IHN0YXJ0aW5nIGZyb20gYSByb290IHRleHQgbm9kZTogXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgfVxuXG4gICAgdmFyIG5ld1Jvb3QgPSBwcm9kdWNlKHJvb3QsIHIgPT4ge1xuICAgICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICAgIHZhciBpdGVyYWJsZSA9IE5vZGUubm9kZXMociwge1xuICAgICAgICByZXZlcnNlOiB0cnVlLFxuICAgICAgICBwYXNzOiAoX3JlZikgPT4ge1xuICAgICAgICAgIHZhciBbLCBwYXRoXSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuICFSYW5nZS5pbmNsdWRlcyhyYW5nZSwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBbLCBwYXRoXSBvZiBpdGVyYWJsZSkge1xuICAgICAgICBpZiAoIVJhbmdlLmluY2x1ZGVzKHJhbmdlLCBwYXRoKSkge1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBOb2RlLnBhcmVudChyLCBwYXRoKTtcbiAgICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgZW5kLnBhdGgpKSB7XG4gICAgICAgICAgdmFyIGxlYWYgPSBOb2RlLmxlYWYociwgcGF0aCk7XG4gICAgICAgICAgbGVhZi50ZXh0ID0gbGVhZi50ZXh0LnNsaWNlKDAsIGVuZC5vZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIHN0YXJ0LnBhdGgpKSB7XG4gICAgICAgICAgdmFyIF9sZWFmID0gTm9kZS5sZWFmKHIsIHBhdGgpO1xuXG4gICAgICAgICAgX2xlYWYudGV4dCA9IF9sZWFmLnRleHQuc2xpY2Uoc3RhcnQub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkZWxldGUgci5zZWxlY3Rpb247XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld1Jvb3QuY2hpbGRyZW47XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBkZXNjZW5kYW50IG5vZGUgcmVmZXJyZWQgdG8gYnkgYSBzcGVjaWZpYyBwYXRoLiBJZiB0aGUgcGF0aCBpcyBhblxyXG4gICAqIGVtcHR5IGFycmF5LCBpdCByZWZlcnMgdG8gdGhlIHJvb3Qgbm9kZSBpdHNlbGYuXHJcbiAgICovXG4gIGdldChyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSByb290O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHBhdGhbaV07XG5cbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSB8fCAhbm9kZS5jaGlsZHJlbltwXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBhIGRlc2NlbmRhbnQgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBpbiBub2RlOiBcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW3BdO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgZGVzY2VuZGFudCBub2RlIGV4aXN0cyBhdCBhIHNwZWNpZmljIHBhdGguXHJcbiAgICovXG4gIGhhcyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSByb290O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHBhdGhbaV07XG5cbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSB8fCAhbm9kZS5jaGlsZHJlbltwXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgYE5vZGVgIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNOb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIFRleHQuaXNUZXh0KHZhbHVlKSB8fCBFbGVtZW50LmlzRWxlbWVudCh2YWx1ZSkgfHwgRWRpdG9yLmlzRWRpdG9yKHZhbHVlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgbGlzdCBvZiBgTm9kZWAgb2JqZWN0cy5cclxuICAgKi9cbiAgaXNOb2RlTGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiAodmFsdWUubGVuZ3RoID09PSAwIHx8IE5vZGUuaXNOb2RlKHZhbHVlWzBdKSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBsYXNoIG5vZGUgZW50cnkgaW4gYSByb290IG5vZGUgZnJvbSBhIHBhdGguXHJcbiAgICovXG4gIGxhc3Qocm9vdCwgcGF0aCkge1xuICAgIHZhciBwID0gcGF0aC5zbGljZSgpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG5cbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG4pIHx8IG4uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSBuLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgIG4gPSBuLmNoaWxkcmVuW2ldO1xuICAgICAgICBwLnB1c2goaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtuLCBwXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLCBlbnN1cmluZyBpdCdzIGEgbGVhZiB0ZXh0IG5vZGUuXHJcbiAgICovXG4gIGxlYWYocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gTm9kZS5nZXQocm9vdCwgcGF0aCk7XG5cbiAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBsZWFmIG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IHJlZmVycyB0byBhIG5vbi1sZWFmIG5vZGU6IFwiKS5jb25jYXQobm9kZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJldHVybiBhbiBpdGVyYWJsZSBvZiB0aGUgaW4gYSBicmFuY2ggb2YgdGhlIHRyZWUsIGZyb20gYSBzcGVjaWZpYyBwYXRoLlxyXG4gICAqXHJcbiAgICogQnkgZGVmYXVsdCB0aGUgb3JkZXIgaXMgdG9wLWRvd24sIGZyb20gbG93ZXN0IHRvIGhpZ2hlc3Qgbm9kZSBpbiB0aGUgdHJlZSxcclxuICAgKiBidXQgeW91IGNhbiBwYXNzIHRoZSBgcmV2ZXJzZTogdHJ1ZWAgb3B0aW9uIHRvIGdvIGJvdHRvbS11cC5cclxuICAgKi9cbiAgKmxldmVscyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgZm9yICh2YXIgcCBvZiBQYXRoLmxldmVscyhwYXRoLCBvcHRpb25zKSkge1xuICAgICAgdmFyIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgIHlpZWxkIFtuLCBwXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBub2RlIG1hdGNoZXMgYSBzZXQgb2YgcHJvcHMuXHJcbiAgICovXG4gIG1hdGNoZXMobm9kZSwgcHJvcHMpIHtcbiAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgRWxlbWVudC5tYXRjaGVzKG5vZGUsIHByb3BzKSB8fCBUZXh0LmlzVGV4dChub2RlKSAmJiBUZXh0Lm1hdGNoZXMobm9kZSwgcHJvcHMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJldHVybiBhbiBpdGVyYWJsZSBvZiBhbGwgdGhlIG5vZGUgZW50cmllcyBvZiBhIHJvb3Qgbm9kZS4gRWFjaCBlbnRyeSBpc1xyXG4gICAqIHJldHVybmVkIGFzIGEgYFtOb2RlLCBQYXRoXWAgdHVwbGUsIHdpdGggdGhlIHBhdGggcmVmZXJyaW5nIHRvIHRoZSBub2RlJ3NcclxuICAgKiBwb3NpdGlvbiBpbnNpZGUgdGhlIHJvb3Qgbm9kZS5cclxuICAgKi9cbiAgKm5vZGVzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHBhc3MsXG4gICAgICByZXZlcnNlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgZnJvbSA9IFtdLFxuICAgICAgdG9cbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgICB2YXIgcCA9IFtdO1xuICAgIHZhciBuID0gcm9vdDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAodG8gJiYgKHJldmVyc2UgPyBQYXRoLmlzQmVmb3JlKHAsIHRvKSA6IFBhdGguaXNBZnRlcihwLCB0bykpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKG4pKSB7XG4gICAgICAgIHlpZWxkIFtuLCBwXTtcbiAgICAgIH0gLy8gSWYgd2UncmUgYWxsb3dlZCB0byBnbyBkb3dud2FyZCBhbmQgd2UgaGF2ZW4ndCBkZWNzZW5kZWQgeWV0LCBkby5cblxuXG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKG4pICYmICFUZXh0LmlzVGV4dChuKSAmJiBuLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCAmJiAocGFzcyA9PSBudWxsIHx8IHBhc3MoW24sIHBdKSA9PT0gZmFsc2UpKSB7XG4gICAgICAgIHZpc2l0ZWQuYWRkKG4pO1xuICAgICAgICB2YXIgbmV4dEluZGV4ID0gcmV2ZXJzZSA/IG4uY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDA7XG5cbiAgICAgICAgaWYgKFBhdGguaXNBbmNlc3RvcihwLCBmcm9tKSkge1xuICAgICAgICAgIG5leHRJbmRleCA9IGZyb21bcC5sZW5ndGhdO1xuICAgICAgICB9XG5cbiAgICAgICAgcCA9IHAuY29uY2F0KG5leHRJbmRleCk7XG4gICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIElmIHdlJ3JlIGF0IHRoZSByb290IGFuZCB3ZSBjYW4ndCBnbyBkb3duLCB3ZSdyZSBkb25lLlxuXG5cbiAgICAgIGlmIChwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gSWYgd2UncmUgZ29pbmcgZm9yd2FyZC4uLlxuXG5cbiAgICAgIGlmICghcmV2ZXJzZSkge1xuICAgICAgICB2YXIgbmV3UGF0aCA9IFBhdGgubmV4dChwKTtcblxuICAgICAgICBpZiAoTm9kZS5oYXMocm9vdCwgbmV3UGF0aCkpIHtcbiAgICAgICAgICBwID0gbmV3UGF0aDtcbiAgICAgICAgICBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gSWYgd2UncmUgZ29pbmcgYmFja3dhcmQuLi5cblxuXG4gICAgICBpZiAocmV2ZXJzZSAmJiBwW3AubGVuZ3RoIC0gMV0gIT09IDApIHtcbiAgICAgICAgdmFyIF9uZXdQYXRoID0gUGF0aC5wcmV2aW91cyhwKTtcblxuICAgICAgICBwID0gX25ld1BhdGg7XG4gICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIE90aGVyd2lzZSB3ZSdyZSBnb2luZyB1cHdhcmQuLi5cblxuXG4gICAgICBwID0gUGF0aC5wYXJlbnQocCk7XG4gICAgICBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgICB2aXNpdGVkLmFkZChuKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBwYXJlbnQgb2YgYSBub2RlIGF0IGEgc3BlY2lmaWMgcGF0aC5cclxuICAgKi9cbiAgcGFyZW50KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgcGFyZW50UGF0aCA9IFBhdGgucGFyZW50KHBhdGgpO1xuICAgIHZhciBwID0gTm9kZS5nZXQocm9vdCwgcGFyZW50UGF0aCk7XG5cbiAgICBpZiAoVGV4dC5pc1RleHQocCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHBhcmVudCBvZiBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHJvb3QuXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGNvbmNhdGVuYXRlZCB0ZXh0IHN0cmluZyBvZiBhIG5vZGUncyBjb250ZW50LlxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IHRoaXMgd2lsbCBub3QgaW5jbHVkZSBzcGFjZXMgb3IgbGluZSBicmVha3MgYmV0d2VlbiBibG9jayBub2Rlcy5cclxuICAgKiBJdCBpcyBub3QgYSB1c2VyLWZhY2luZyBzdHJpbmcsIGJ1dCBhIHN0cmluZyBmb3IgcGVyZm9ybWluZyBvZmZzZXQtcmVsYXRlZFxyXG4gICAqIGNvbXB1dGF0aW9ucyBmb3IgYSBub2RlLlxyXG4gICAqL1xuICBzdHJpbmcobm9kZSkge1xuICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGUudGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4ubWFwKE5vZGUuc3RyaW5nKS5qb2luKCcnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGFuIGl0ZXJhYmxlIG9mIGFsbCBsZWFmIHRleHQgbm9kZXMgaW4gYSByb290IG5vZGUuXHJcbiAgICovXG4gICp0ZXh0cyhyb290KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIE5vZGUubm9kZXMocm9vdCwgb3B0aW9ucykpIHtcbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICB5aWVsZCBbbm9kZSwgcGF0aF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQxKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkMShPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG52YXIgT3BlcmF0aW9uID0ge1xuICAvKipcclxuICAgKiBDaGVjayBvZiBhIHZhbHVlIGlzIGEgYE5vZGVPcGVyYXRpb25gIG9iamVjdC5cclxuICAgKi9cbiAgaXNOb2RlT3BlcmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9wZXJhdGlvbi5pc09wZXJhdGlvbih2YWx1ZSkgJiYgdmFsdWUudHlwZS5lbmRzV2l0aCgnX25vZGUnKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBvZiBhIHZhbHVlIGlzIGFuIGBPcGVyYXRpb25gIG9iamVjdC5cclxuICAgKi9cbiAgaXNPcGVyYXRpb24odmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3dpdGNoICh2YWx1ZS50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBOb2RlLmlzTm9kZSh2YWx1ZS5ub2RlKTtcblxuICAgICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLm9mZnNldCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlLnRleHQgPT09ICdzdHJpbmcnICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpO1xuXG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5wb3NpdGlvbiA9PT0gJ251bWJlcicgJiYgKHR5cGVvZiB2YWx1ZS50YXJnZXQgPT09ICdudW1iZXInIHx8IHZhbHVlLnRhcmdldCA9PT0gbnVsbCkgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZS5wcm9wZXJ0aWVzKTtcblxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIFBhdGguaXNQYXRoKHZhbHVlLm5ld1BhdGgpO1xuXG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBOb2RlLmlzTm9kZSh2YWx1ZS5ub2RlKTtcblxuICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLm9mZnNldCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlLnRleHQgPT09ICdzdHJpbmcnICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpO1xuXG4gICAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBpc1BsYWluT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpICYmIGlzUGxhaW5PYmplY3QodmFsdWUubmV3UHJvcGVydGllcyk7XG5cbiAgICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAgICByZXR1cm4gdmFsdWUucHJvcGVydGllcyA9PT0gbnVsbCAmJiBSYW5nZS5pc1JhbmdlKHZhbHVlLm5ld1Byb3BlcnRpZXMpIHx8IHZhbHVlLm5ld1Byb3BlcnRpZXMgPT09IG51bGwgJiYgUmFuZ2UuaXNSYW5nZSh2YWx1ZS5wcm9wZXJ0aWVzKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpICYmIGlzUGxhaW5PYmplY3QodmFsdWUubmV3UHJvcGVydGllcyk7XG5cbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgdHlwZW9mIHZhbHVlLnBvc2l0aW9uID09PSAnbnVtYmVyJyAmJiAodHlwZW9mIHZhbHVlLnRhcmdldCA9PT0gJ251bWJlcicgfHwgdmFsdWUudGFyZ2V0ID09PSBudWxsKSAmJiBpc1BsYWluT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBsaXN0IG9mIGBPcGVyYXRpb25gIG9iamVjdHMuXHJcbiAgICovXG4gIGlzT3BlcmF0aW9uTGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiAodmFsdWUubGVuZ3RoID09PSAwIHx8IE9wZXJhdGlvbi5pc09wZXJhdGlvbih2YWx1ZVswXSkpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIG9mIGEgdmFsdWUgaXMgYSBgU2VsZWN0aW9uT3BlcmF0aW9uYCBvYmplY3QuXHJcbiAgICovXG4gIGlzU2VsZWN0aW9uT3BlcmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9wZXJhdGlvbi5pc09wZXJhdGlvbih2YWx1ZSkgJiYgdmFsdWUudHlwZS5lbmRzV2l0aCgnX3NlbGVjdGlvbicpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIG9mIGEgdmFsdWUgaXMgYSBgVGV4dE9wZXJhdGlvbmAgb2JqZWN0LlxyXG4gICAqL1xuICBpc1RleHRPcGVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbHVlKSAmJiB2YWx1ZS50eXBlLmVuZHNXaXRoKCdfdGV4dCcpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEludmVydCBhbiBvcGVyYXRpb24sIHJldHVybmluZyBhIG5ldyBvcGVyYXRpb24gdGhhdCB3aWxsIGV4YWN0bHkgdW5kbyB0aGVcclxuICAgKiBvcmlnaW5hbCB3aGVuIGFwcGxpZWQuXHJcbiAgICovXG4gIGludmVyc2Uob3ApIHtcbiAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDEoe30sIG9wLCB7XG4gICAgICAgICAgICB0eXBlOiAncmVtb3ZlX25vZGUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkMSh7fSwgb3AsIHtcbiAgICAgICAgICAgIHR5cGU6ICdyZW1vdmVfdGV4dCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDEoe30sIG9wLCB7XG4gICAgICAgICAgICB0eXBlOiAnc3BsaXRfbm9kZScsXG4gICAgICAgICAgICBwYXRoOiBQYXRoLnByZXZpb3VzKG9wLnBhdGgpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBuZXdQYXRoLFxuICAgICAgICAgICAgcGF0aFxuICAgICAgICAgIH0gPSBvcDsgLy8gUEVSRjogaW4gdGhpcyBjYXNlIHRoZSBtb3ZlIG9wZXJhdGlvbiBpcyBhIG5vLW9wIGFueXdheXMuXG5cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMobmV3UGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvcDtcbiAgICAgICAgICB9IC8vIElmIHRoZSBtb3ZlIGhhcHBlbnMgY29tcGxldGVseSB3aXRoaW4gYSBzaW5nbGUgcGFyZW50IHRoZSBwYXRoIGFuZFxuICAgICAgICAgIC8vIG5ld1BhdGggYXJlIHN0YWJsZSB3aXRoIHJlc3BlY3QgdG8gZWFjaCBvdGhlci5cblxuXG4gICAgICAgICAgaWYgKFBhdGguaXNTaWJsaW5nKHBhdGgsIG5ld1BhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQxKHt9LCBvcCwge1xuICAgICAgICAgICAgICBwYXRoOiBuZXdQYXRoLFxuICAgICAgICAgICAgICBuZXdQYXRoOiBwYXRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IC8vIElmIHRoZSBtb3ZlIGRvZXMgbm90IGhhcHBlbiB3aXRoaW4gYSBzaW5nbGUgcGFyZW50IGl0IGlzIHBvc3NpYmxlXG4gICAgICAgICAgLy8gZm9yIHRoZSBtb3ZlIHRvIGltcGFjdCB0aGUgdHJ1ZSBwYXRoIHRvIHRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgbm9kZVxuICAgICAgICAgIC8vIHdhcyByZW1vdmVkIGZyb20gYW5kIHdoZXJlIGl0IHdhcyBpbnNlcnRlZC4gV2UgaGF2ZSB0byBhZGp1c3QgZm9yIHRoaXNcbiAgICAgICAgICAvLyBhbmQgZmluZCB0aGUgb3JpZ2luYWwgcGF0aC4gV2UgY2FuIGFjY29tcGxpc2ggdGhpcyAob25seSBpbiBub24tc2libGluZylcbiAgICAgICAgICAvLyBtb3ZlcyBieSBsb29raW5nIGF0IHRoZSBpbXBhY3Qgb2YgdGhlIG1vdmUgb3BlcmF0aW9uIG9uIHRoZSBub2RlXG4gICAgICAgICAgLy8gYWZ0ZXIgdGhlIG9yaWdpbmFsIG1vdmUgcGF0aC5cblxuXG4gICAgICAgICAgdmFyIGludmVyc2VQYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3ApO1xuICAgICAgICAgIHZhciBpbnZlcnNlTmV3UGF0aCA9IFBhdGgudHJhbnNmb3JtKFBhdGgubmV4dChwYXRoKSwgb3ApO1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDEoe30sIG9wLCB7XG4gICAgICAgICAgICBwYXRoOiBpbnZlcnNlUGF0aCxcbiAgICAgICAgICAgIG5ld1BhdGg6IGludmVyc2VOZXdQYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkMSh7fSwgb3AsIHtcbiAgICAgICAgICAgIHR5cGU6ICdpbnNlcnRfbm9kZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQxKHt9LCBvcCwge1xuICAgICAgICAgICAgdHlwZTogJ2luc2VydF90ZXh0J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgbmV3UHJvcGVydGllc1xuICAgICAgICAgIH0gPSBvcDtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQxKHt9LCBvcCwge1xuICAgICAgICAgICAgcHJvcGVydGllczogbmV3UHJvcGVydGllcyxcbiAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IHByb3BlcnRpZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzZXRfc2VsZWN0aW9uJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBfcHJvcGVydGllcyxcbiAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IF9uZXdQcm9wZXJ0aWVzXG4gICAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgICAgaWYgKF9wcm9wZXJ0aWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDEoe30sIG9wLCB7XG4gICAgICAgICAgICAgIHByb3BlcnRpZXM6IF9uZXdQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICBuZXdQcm9wZXJ0aWVzOiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKF9uZXdQcm9wZXJ0aWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDEoe30sIG9wLCB7XG4gICAgICAgICAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IF9wcm9wZXJ0aWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkMSh7fSwgb3AsIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllczogX25ld1Byb3BlcnRpZXMsXG4gICAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IF9wcm9wZXJ0aWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQxKHt9LCBvcCwge1xuICAgICAgICAgICAgdHlwZTogJ21lcmdlX25vZGUnLFxuICAgICAgICAgICAgcGF0aDogUGF0aC5uZXh0KG9wLnBhdGgpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxudmFyIFBhdGggPSB7XG4gIC8qKlxyXG4gICAqIEdldCBhIGxpc3Qgb2YgYW5jZXN0b3IgcGF0aHMgZm9yIGEgZ2l2ZW4gcGF0aC5cclxuICAgKlxyXG4gICAqIFRoZSBwYXRocyBhcmUgc29ydGVkIGZyb20gZGVlcGVzdCB0byBzaGFsbG93ZXN0IGFuY2VzdG9yLiBIb3dldmVyLCBpZiB0aGVcclxuICAgKiBgcmV2ZXJzZTogdHJ1ZWAgb3B0aW9uIGlzIHBhc3NlZCwgdGhleSBhcmUgcmV2ZXJzZWQuXHJcbiAgICovXG4gIGFuY2VzdG9ycyhwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICByZXZlcnNlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgcGF0aHMgPSBQYXRoLmxldmVscyhwYXRoLCBvcHRpb25zKTtcblxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBwYXRocyA9IHBhdGhzLnNsaWNlKDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRocyA9IHBhdGhzLnNsaWNlKDAsIC0xKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aHM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBjb21tb24gYW5jZXN0b3IgcGF0aCBvZiB0d28gcGF0aHMuXHJcbiAgICovXG4gIGNvbW1vbihwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIGNvbW1vbiA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAmJiBpIDwgYW5vdGhlci5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGF2ID0gcGF0aFtpXTtcbiAgICAgIHZhciBidiA9IGFub3RoZXJbaV07XG5cbiAgICAgIGlmIChhdiAhPT0gYnYpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbW1vbi5wdXNoKGF2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tbW9uO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENvbXBhcmUgYSBwYXRoIHRvIGFub3RoZXIsIHJldHVybmluZyBhbiBpbnRlZ2VyIGluZGljYXRpbmcgd2hldGhlciB0aGUgcGF0aFxyXG4gICAqIHdhcyBiZWZvcmUsIGF0LCBvciBhZnRlciB0aGUgb3RoZXIuXHJcbiAgICpcclxuICAgKiBOb3RlOiBUd28gcGF0aHMgb2YgdW5lcXVhbCBsZW5ndGggY2FuIHN0aWxsIHJlY2VpdmUgYSBgMGAgcmVzdWx0IGlmIG9uZSBpc1xyXG4gICAqIGRpcmVjdGx5IGFib3ZlIG9yIGJlbG93IHRoZSBvdGhlci4gSWYgeW91IHdhbnQgZXhhY3QgbWF0Y2hpbmcsIHVzZVxyXG4gICAqIFtbUGF0aC5lcXVhbHNdXSBpbnN0ZWFkLlxyXG4gICAqL1xuICBjb21wYXJlKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgbWluID0gTWF0aC5taW4ocGF0aC5sZW5ndGgsIGFub3RoZXIubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWluOyBpKyspIHtcbiAgICAgIGlmIChwYXRoW2ldIDwgYW5vdGhlcltpXSkgcmV0dXJuIC0xO1xuICAgICAgaWYgKHBhdGhbaV0gPiBhbm90aGVyW2ldKSByZXR1cm4gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggZW5kcyBhZnRlciBvbmUgb2YgdGhlIGluZGV4ZXMgaW4gYW5vdGhlci5cclxuICAgKi9cbiAgZW5kc0FmdGVyKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTtcbiAgICB2YXIgYXMgPSBwYXRoLnNsaWNlKDAsIGkpO1xuICAgIHZhciBicyA9IGFub3RoZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGF2ID0gcGF0aFtpXTtcbiAgICB2YXIgYnYgPSBhbm90aGVyW2ldO1xuICAgIHJldHVybiBQYXRoLmVxdWFscyhhcywgYnMpICYmIGF2ID4gYnY7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGVuZHMgYXQgb25lIG9mIHRoZSBpbmRleGVzIGluIGFub3RoZXIuXHJcbiAgICovXG4gIGVuZHNBdChwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIGkgPSBwYXRoLmxlbmd0aDtcbiAgICB2YXIgYXMgPSBwYXRoLnNsaWNlKDAsIGkpO1xuICAgIHZhciBicyA9IGFub3RoZXIuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGVuZHMgYmVmb3JlIG9uZSBvZiB0aGUgaW5kZXhlcyBpbiBhbm90aGVyLlxyXG4gICAqL1xuICBlbmRzQmVmb3JlKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTtcbiAgICB2YXIgYXMgPSBwYXRoLnNsaWNlKDAsIGkpO1xuICAgIHZhciBicyA9IGFub3RoZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGF2ID0gcGF0aFtpXTtcbiAgICB2YXIgYnYgPSBhbm90aGVyW2ldO1xuICAgIHJldHVybiBQYXRoLmVxdWFscyhhcywgYnMpICYmIGF2IDwgYnY7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGV4YWN0bHkgZXF1YWwgdG8gYW5vdGhlci5cclxuICAgKi9cbiAgZXF1YWxzKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPT09IGFub3RoZXIubGVuZ3RoICYmIHBhdGguZXZlcnkoKG4sIGkpID0+IG4gPT09IGFub3RoZXJbaV0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBhZnRlciBhbm90aGVyLlxyXG4gICAqL1xuICBpc0FmdGVyKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAxO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBhbiBhbmNlc3RvciBvZiBhbm90aGVyLlxyXG4gICAqL1xuICBpc0FuY2VzdG9yKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPCBhbm90aGVyLmxlbmd0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGJlZm9yZSBhbm90aGVyLlxyXG4gICAqL1xuICBpc0JlZm9yZShwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gLTE7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGEgY2hpbGQgb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNDaGlsZChwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID09PSBhbm90aGVyLmxlbmd0aCArIDEgJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBlcXVhbCB0byBvciBhbiBhbmNlc3RvciBvZiBhbm90aGVyLlxyXG4gICAqL1xuICBpc0NvbW1vbihwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoIDw9IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgYSBkZXNjZW5kYW50IG9mIGFub3RoZXIuXHJcbiAgICovXG4gIGlzRGVzY2VuZGFudChwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyB0aGUgcGFyZW50IG9mIGFub3RoZXIuXHJcbiAgICovXG4gIGlzUGFyZW50KHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggKyAxID09PSBhbm90aGVyLmxlbmd0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaXMgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBgUGF0aGAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc1BhdGgodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgKHZhbHVlLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgdmFsdWVbMF0gPT09ICdudW1iZXInKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgYSBzaWJsaW5nIG9mIGFub3RoZXIuXHJcbiAgICovXG4gIGlzU2libGluZyhwYXRoLCBhbm90aGVyKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoICE9PSBhbm90aGVyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgLTEpO1xuICAgIHZhciBicyA9IGFub3RoZXIuc2xpY2UoMCwgLTEpO1xuICAgIHZhciBhbCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICB2YXIgYmwgPSBhbm90aGVyW2Fub3RoZXIubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGFsICE9PSBibCAmJiBQYXRoLmVxdWFscyhhcywgYnMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCBhIGxpc3Qgb2YgcGF0aHMgYXQgZXZlcnkgbGV2ZWwgZG93biB0byBhIHBhdGguIE5vdGU6IHRoaXMgaXMgdGhlIHNhbWVcclxuICAgKiBhcyBgUGF0aC5hbmNlc3RvcnNgLCBidXQgaW5jbHVkaW5nIHRoZSBwYXRoIGl0c2VsZi5cclxuICAgKlxyXG4gICAqIFRoZSBwYXRocyBhcmUgc29ydGVkIGZyb20gc2hhbGxvd2VzdCB0byBkZWVwZXN0LiBIb3dldmVyLCBpZiB0aGUgYHJldmVyc2U6XHJcbiAgICogdHJ1ZWAgb3B0aW9uIGlzIHBhc3NlZCwgdGhleSBhcmUgcmV2ZXJzZWQuXHJcbiAgICovXG4gIGxldmVscyhwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICByZXZlcnNlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgbGlzdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdC5wdXNoKHBhdGguc2xpY2UoMCwgaSkpO1xuICAgIH1cblxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBsaXN0LnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBHaXZlbiBhIHBhdGgsIGdldCB0aGUgcGF0aCB0byB0aGUgbmV4dCBzaWJsaW5nIG5vZGUuXHJcbiAgICovXG4gIG5leHQocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgbmV4dCBwYXRoIG9mIGEgcm9vdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdLCBiZWNhdXNlIGl0IGhhcyBubyBuZXh0IGluZGV4LlwiKSk7XG4gICAgfVxuXG4gICAgdmFyIGxhc3QgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgLTEpLmNvbmNhdChsYXN0ICsgMSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2l2ZW4gYSBwYXRoLCByZXR1cm4gYSBuZXcgcGF0aCByZWZlcnJpbmcgdG8gdGhlIHBhcmVudCBub2RlIGFib3ZlIGl0LlxyXG4gICAqL1xuICBwYXJlbnQocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcGFyZW50IHBhdGggb2YgdGhlIHJvb3QgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXS5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHaXZlbiBhIHBhdGgsIGdldCB0aGUgcGF0aCB0byB0aGUgcHJldmlvdXMgc2libGluZyBub2RlLlxyXG4gICAqL1xuICBwcmV2aW91cyhwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBwcmV2aW91cyBwYXRoIG9mIGEgcm9vdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdLCBiZWNhdXNlIGl0IGhhcyBubyBwcmV2aW91cyBpbmRleC5cIikpO1xuICAgIH1cblxuICAgIHZhciBsYXN0ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGxhc3QgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcHJldmlvdXMgcGF0aCBvZiBhIGZpcnN0IGNoaWxkIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCB3b3VsZCByZXN1bHQgaW4gYSBuZWdhdGl2ZSBpbmRleC5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIC0xKS5jb25jYXQobGFzdCAtIDEpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCBhIHBhdGggcmVsYXRpdmUgdG8gYW4gYW5jZXN0b3IuXHJcbiAgICovXG4gIHJlbGF0aXZlKHBhdGgsIGFuY2VzdG9yKSB7XG4gICAgaWYgKCFQYXRoLmlzQW5jZXN0b3IoYW5jZXN0b3IsIHBhdGgpICYmICFQYXRoLmVxdWFscyhwYXRoLCBhbmNlc3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHJlbGF0aXZlIHBhdGggb2YgW1wiLmNvbmNhdChwYXRoLCBcIl0gaW5zaWRlIGFuY2VzdG9yIFtcIikuY29uY2F0KGFuY2VzdG9yLCBcIl0sIGJlY2F1c2UgaXQgaXMgbm90IGFib3ZlIG9yIGVxdWFsIHRvIHRoZSBwYXRoLlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGguc2xpY2UoYW5jZXN0b3IubGVuZ3RoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gYSBwYXRoIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtKHBhdGgsIG9wZXJhdGlvbikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gcHJvZHVjZShwYXRoLCBwID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIGFmZmluaXR5ID0gJ2ZvcndhcmQnXG4gICAgICB9ID0gb3B0aW9uczsgLy8gUEVSRjogRXhpdCBlYXJseSBpZiB0aGUgb3BlcmF0aW9uIGlzIGd1YXJhbnRlZWQgbm90IHRvIGhhdmUgYW4gZWZmZWN0LlxuXG4gICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKG9wZXJhdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgICBwYXRoOiBvcFxuICAgICAgICAgICAgfSA9IG9wZXJhdGlvbjtcblxuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLCBwKSB8fCBQYXRoLmVuZHNCZWZvcmUob3AsIHApIHx8IFBhdGguaXNBbmNlc3RvcihvcCwgcCkpIHtcbiAgICAgICAgICAgICAgcFtvcC5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICAgIHBhdGg6IF9vcFxuICAgICAgICAgICAgfSA9IG9wZXJhdGlvbjtcblxuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcCwgcCkgfHwgUGF0aC5pc0FuY2VzdG9yKF9vcCwgcCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShfb3AsIHApKSB7XG4gICAgICAgICAgICAgIHBbX29wLmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgICBwYXRoOiBfb3AyLFxuICAgICAgICAgICAgICBwb3NpdGlvblxuICAgICAgICAgICAgfSA9IG9wZXJhdGlvbjtcblxuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDIsIHApIHx8IFBhdGguZW5kc0JlZm9yZShfb3AyLCBwKSkge1xuICAgICAgICAgICAgICBwW19vcDIubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5pc0FuY2VzdG9yKF9vcDIsIHApKSB7XG4gICAgICAgICAgICAgIHBbX29wMi5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgICBwW19vcDIubGVuZ3RoXSArPSBwb3NpdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICAgIHBhdGg6IF9vcDMsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBfcG9zaXRpb25cbiAgICAgICAgICAgIH0gPSBvcGVyYXRpb247XG5cbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhfb3AzLCBwKSkge1xuICAgICAgICAgICAgICBpZiAoYWZmaW5pdHkgPT09ICdmb3J3YXJkJykge1xuICAgICAgICAgICAgICAgIHBbcC5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFmZmluaXR5ID09PSAnYmFja3dhcmQnKSA7IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShfb3AzLCBwKSkge1xuICAgICAgICAgICAgICBwW19vcDMubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5pc0FuY2VzdG9yKF9vcDMsIHApICYmIHBhdGhbX29wMy5sZW5ndGhdID49IF9wb3NpdGlvbikge1xuICAgICAgICAgICAgICBwW19vcDMubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgICAgcFtfb3AzLmxlbmd0aF0gLT0gX3Bvc2l0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgICBwYXRoOiBfb3A0LFxuICAgICAgICAgICAgICBuZXdQYXRoOiBvbnBcbiAgICAgICAgICAgIH0gPSBvcGVyYXRpb247IC8vIElmIHRoZSBvbGQgYW5kIG5ldyBwYXRoIGFyZSB0aGUgc2FtZSwgaXQncyBhIG5vLW9wLlxuXG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wNCwgb25wKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wNCwgcCkgfHwgUGF0aC5lcXVhbHMoX29wNCwgcCkpIHtcbiAgICAgICAgICAgICAgdmFyIGNvcHkgPSBvbnAuc2xpY2UoKTtcblxuICAgICAgICAgICAgICBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDQsIG9ucCkgJiYgX29wNC5sZW5ndGggPCBvbnAubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29weVtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gY29weS5jb25jYXQocC5zbGljZShfb3A0Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzU2libGluZyhfb3A0LCBvbnApICYmIChQYXRoLmlzQW5jZXN0b3Iob25wLCBwKSB8fCBQYXRoLmVxdWFscyhvbnAsIHApKSkge1xuICAgICAgICAgICAgICBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDQsIHApKSB7XG4gICAgICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKG9ucCwgcCkgfHwgUGF0aC5lcXVhbHMob25wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3Iob25wLCBwKSkge1xuICAgICAgICAgICAgICBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDQsIHApKSB7XG4gICAgICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBwW29ucC5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgcCkpIHtcbiAgICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9ucCwgcCkpIHtcbiAgICAgICAgICAgICAgICBwW29ucC5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG59O1xuXG52YXIgUGF0aFJlZiA9IHtcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtIHRoZSBwYXRoIHJlZidzIGN1cnJlbnQgdmFsdWUgYnkgYW4gb3BlcmF0aW9uLlxyXG4gICAqL1xuICB0cmFuc2Zvcm0ocmVmLCBvcCkge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgYWZmaW5pdHlcbiAgICB9ID0gcmVmO1xuXG4gICAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gUGF0aC50cmFuc2Zvcm0oY3VycmVudCwgb3AsIHtcbiAgICAgIGFmZmluaXR5XG4gICAgfSk7XG4gICAgcmVmLmN1cnJlbnQgPSBwYXRoO1xuXG4gICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgcmVmLnVucmVmKCk7XG4gICAgfVxuICB9XG5cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMihvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQyKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkMihPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG52YXIgUG9pbnQgPSB7XG4gIC8qKlxyXG4gICAqIENvbXBhcmUgYSBwb2ludCB0byBhbm90aGVyLCByZXR1cm5pbmcgYW4gaW50ZWdlciBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlXHJcbiAgICogcG9pbnQgd2FzIGJlZm9yZSwgYXQsIG9yIGFmdGVyIHRoZSBvdGhlci5cclxuICAgKi9cbiAgY29tcGFyZShwb2ludCwgYW5vdGhlcikge1xuICAgIHZhciByZXN1bHQgPSBQYXRoLmNvbXBhcmUocG9pbnQucGF0aCwgYW5vdGhlci5wYXRoKTtcblxuICAgIGlmIChyZXN1bHQgPT09IDApIHtcbiAgICAgIGlmIChwb2ludC5vZmZzZXQgPCBhbm90aGVyLm9mZnNldCkgcmV0dXJuIC0xO1xuICAgICAgaWYgKHBvaW50Lm9mZnNldCA+IGFub3RoZXIub2Zmc2V0KSByZXR1cm4gMTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyBhZnRlciBhbm90aGVyLlxyXG4gICAqL1xuICBpc0FmdGVyKHBvaW50LCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmNvbXBhcmUocG9pbnQsIGFub3RoZXIpID09PSAxO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgYmVmb3JlIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQmVmb3JlKHBvaW50LCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmNvbXBhcmUocG9pbnQsIGFub3RoZXIpID09PSAtMTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIGV4YWN0bHkgZXF1YWwgdG8gYW5vdGhlci5cclxuICAgKi9cbiAgZXF1YWxzKHBvaW50LCBhbm90aGVyKSB7XG4gICAgLy8gUEVSRjogZW5zdXJlIHRoZSBvZmZzZXRzIGFyZSBlcXVhbCBmaXJzdCBzaW5jZSB0aGV5IGFyZSBjaGVhcGVyIHRvIGNoZWNrLlxuICAgIHJldHVybiBwb2ludC5vZmZzZXQgPT09IGFub3RoZXIub2Zmc2V0ICYmIFBhdGguZXF1YWxzKHBvaW50LnBhdGgsIGFub3RoZXIucGF0aCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBgUG9pbnRgIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNQb2ludCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gYSBwb2ludCBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybShwb2ludCwgb3ApIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgcmV0dXJuIHByb2R1Y2UocG9pbnQsIHAgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgYWZmaW5pdHkgPSAnZm9yd2FyZCdcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgb2Zmc2V0XG4gICAgICB9ID0gcDtcblxuICAgICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSAmJiBvcC5vZmZzZXQgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgIHAub2Zmc2V0ICs9IG9wLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgICAgIHAub2Zmc2V0ICs9IG9wLnBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSAmJiBvcC5vZmZzZXQgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgIHAub2Zmc2V0IC09IE1hdGgubWluKG9mZnNldCAtIG9wLm9mZnNldCwgb3AudGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSB8fCBQYXRoLmlzQW5jZXN0b3Iob3AucGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICAgICAgaWYgKG9wLnBvc2l0aW9uID09PSBvZmZzZXQgJiYgYWZmaW5pdHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wLnBvc2l0aW9uIDwgb2Zmc2V0IHx8IG9wLnBvc2l0aW9uID09PSBvZmZzZXQgJiYgYWZmaW5pdHkgPT09ICdmb3J3YXJkJykge1xuICAgICAgICAgICAgICAgIHAub2Zmc2V0IC09IG9wLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBfb2JqZWN0U3ByZWFkJDIoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgIGFmZmluaXR5OiAnZm9yd2FyZCdcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn07XG5cbnZhciBQb2ludFJlZiA9IHtcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtIHRoZSBwb2ludCByZWYncyBjdXJyZW50IHZhbHVlIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtKHJlZiwgb3ApIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIGFmZmluaXR5XG4gICAgfSA9IHJlZjtcblxuICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcG9pbnQgPSBQb2ludC50cmFuc2Zvcm0oY3VycmVudCwgb3AsIHtcbiAgICAgIGFmZmluaXR5XG4gICAgfSk7XG4gICAgcmVmLmN1cnJlbnQgPSBwb2ludDtcblxuICAgIGlmIChwb2ludCA9PSBudWxsKSB7XG4gICAgICByZWYudW5yZWYoKTtcbiAgICB9XG4gIH1cblxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDModGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbnZhciBSYW5nZSA9IHtcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzdGFydCBhbmQgZW5kIHBvaW50cyBvZiBhIHJhbmdlLCBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcHBlYXJcclxuICAgKiBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgICovXG4gIGVkZ2VzKHJhbmdlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICByZXZlcnNlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9ID0gcmFuZ2U7XG4gICAgcmV0dXJuIFJhbmdlLmlzQmFja3dhcmQocmFuZ2UpID09PSByZXZlcnNlID8gW2FuY2hvciwgZm9jdXNdIDogW2ZvY3VzLCBhbmNob3JdO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZW5kIHBvaW50IG9mIGEgcmFuZ2UuXHJcbiAgICovXG4gIGVuZChyYW5nZSkge1xuICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgIHJldHVybiBlbmQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSByYW5nZSBpcyBleGFjdGx5IGVxdWFsIHRvIGFub3RoZXIuXHJcbiAgICovXG4gIGVxdWFscyhyYW5nZSwgYW5vdGhlcikge1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMocmFuZ2UuYW5jaG9yLCBhbm90aGVyLmFuY2hvcikgJiYgUG9pbnQuZXF1YWxzKHJhbmdlLmZvY3VzLCBhbm90aGVyLmZvY3VzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGluY2x1ZGVzIGEgcGF0aCwgYSBwb2ludCBvciBwYXJ0IG9mIGFub3RoZXIgcmFuZ2UuXHJcbiAgICovXG4gIGluY2x1ZGVzKHJhbmdlLCB0YXJnZXQpIHtcbiAgICBpZiAoUmFuZ2UuaXNSYW5nZSh0YXJnZXQpKSB7XG4gICAgICBpZiAoUmFuZ2UuaW5jbHVkZXMocmFuZ2UsIHRhcmdldC5hbmNob3IpIHx8IFJhbmdlLmluY2x1ZGVzKHJhbmdlLCB0YXJnZXQuZm9jdXMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgW3JzLCByZV0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgICB2YXIgW3RzLCB0ZV0gPSBSYW5nZS5lZGdlcyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIFBvaW50LmlzQmVmb3JlKHJzLCB0cykgJiYgUG9pbnQuaXNBZnRlcihyZSwgdGUpO1xuICAgIH1cblxuICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIGlzQWZ0ZXJTdGFydCA9IGZhbHNlO1xuICAgIHZhciBpc0JlZm9yZUVuZCA9IGZhbHNlO1xuXG4gICAgaWYgKFBvaW50LmlzUG9pbnQodGFyZ2V0KSkge1xuICAgICAgaXNBZnRlclN0YXJ0ID0gUG9pbnQuY29tcGFyZSh0YXJnZXQsIHN0YXJ0KSA+PSAwO1xuICAgICAgaXNCZWZvcmVFbmQgPSBQb2ludC5jb21wYXJlKHRhcmdldCwgZW5kKSA8PSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc0FmdGVyU3RhcnQgPSBQYXRoLmNvbXBhcmUodGFyZ2V0LCBzdGFydC5wYXRoKSA+PSAwO1xuICAgICAgaXNCZWZvcmVFbmQgPSBQYXRoLmNvbXBhcmUodGFyZ2V0LCBlbmQucGF0aCkgPD0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNBZnRlclN0YXJ0ICYmIGlzQmVmb3JlRW5kO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgaW50ZXJzZWN0aW9uIG9mIGEgcmFuZ2Ugd2l0aCBhbm90aGVyLlxyXG4gICAqL1xuICBpbnRlcnNlY3Rpb24ocmFuZ2UsIGFub3RoZXIpIHtcbiAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhyYW5nZSwgW1wiYW5jaG9yXCIsIFwiZm9jdXNcIl0pO1xuXG4gICAgdmFyIFtzMSwgZTFdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgIHZhciBbczIsIGUyXSA9IFJhbmdlLmVkZ2VzKGFub3RoZXIpO1xuICAgIHZhciBzdGFydCA9IFBvaW50LmlzQmVmb3JlKHMxLCBzMikgPyBzMiA6IHMxO1xuICAgIHZhciBlbmQgPSBQb2ludC5pc0JlZm9yZShlMSwgZTIpID8gZTEgOiBlMjtcblxuICAgIGlmIChQb2ludC5pc0JlZm9yZShlbmQsIHN0YXJ0KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDMoe1xuICAgICAgICBhbmNob3I6IHN0YXJ0LFxuICAgICAgICBmb2N1czogZW5kXG4gICAgICB9LCByZXN0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSByYW5nZSBpcyBiYWNrd2FyZCwgbWVhbmluZyB0aGF0IGl0cyBhbmNob3IgcG9pbnQgYXBwZWFycyBpbiB0aGVcclxuICAgKiBkb2N1bWVudCBfYWZ0ZXJfIGl0cyBmb2N1cyBwb2ludC5cclxuICAgKi9cbiAgaXNCYWNrd2FyZChyYW5nZSkge1xuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSByYW5nZTtcbiAgICByZXR1cm4gUG9pbnQuaXNBZnRlcihhbmNob3IsIGZvY3VzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGlzIGNvbGxhcHNlZCwgbWVhbmluZyB0aGF0IGJvdGggaXRzIGFuY2hvciBhbmQgZm9jdXNcclxuICAgKiBwb2ludHMgcmVmZXIgdG8gdGhlIGV4YWN0IHNhbWUgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LlxyXG4gICAqL1xuICBpc0NvbGxhcHNlZChyYW5nZSkge1xuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSByYW5nZTtcbiAgICByZXR1cm4gUG9pbnQuZXF1YWxzKGFuY2hvciwgZm9jdXMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcmFuZ2UgaXMgZXhwYW5kZWQuXHJcbiAgICpcclxuICAgKiBUaGlzIGlzIHRoZSBvcHBvc2l0ZSBvZiBbW1JhbmdlLmlzQ29sbGFwc2VkXV0gYW5kIGlzIHByb3ZpZGVkIGZvciBsZWdpYmlsaXR5LlxyXG4gICAqL1xuICBpc0V4cGFuZGVkKHJhbmdlKSB7XG4gICAgcmV0dXJuICFSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSByYW5nZSBpcyBmb3J3YXJkLlxyXG4gICAqXHJcbiAgICogVGhpcyBpcyB0aGUgb3Bwb3NpdGUgb2YgW1tSYW5nZS5pc0JhY2t3YXJkXV0gYW5kIGlzIHByb3ZpZGVkIGZvciBsZWdpYmlsaXR5LlxyXG4gICAqL1xuICBpc0ZvcndhcmQocmFuZ2UpIHtcbiAgICByZXR1cm4gIVJhbmdlLmlzQmFja3dhcmQocmFuZ2UpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgW1tSYW5nZV1dIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNSYW5nZSh2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiBQb2ludC5pc1BvaW50KHZhbHVlLmFuY2hvcikgJiYgUG9pbnQuaXNQb2ludCh2YWx1ZS5mb2N1cyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUgcG9pbnQgZW50cmllcyBpbiBhIHJhbmdlLlxyXG4gICAqL1xuICAqcG9pbnRzKHJhbmdlKSB7XG4gICAgeWllbGQgW3JhbmdlLmFuY2hvciwgJ2FuY2hvciddO1xuICAgIHlpZWxkIFtyYW5nZS5mb2N1cywgJ2ZvY3VzJ107XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzdGFydCBwb2ludCBvZiBhIHJhbmdlLlxyXG4gICAqL1xuICBzdGFydChyYW5nZSkge1xuICAgIHZhciBbc3RhcnRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgIHJldHVybiBzdGFydDtcbiAgfSxcblxuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gYSByYW5nZSBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybShyYW5nZSwgb3AsIG9wdGlvbnMpIHtcbiAgICB2YXIge1xuICAgICAgYWZmaW5pdHkgPSAnaW53YXJkJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBhZmZpbml0eUFuY2hvcjtcbiAgICB2YXIgYWZmaW5pdHlGb2N1cztcblxuICAgIGlmIChhZmZpbml0eSA9PT0gJ2lud2FyZCcpIHtcbiAgICAgIGlmIChSYW5nZS5pc0ZvcndhcmQocmFuZ2UpKSB7XG4gICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2ZvcndhcmQnO1xuICAgICAgICBhZmZpbml0eUZvY3VzID0gJ2JhY2t3YXJkJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2JhY2t3YXJkJztcbiAgICAgICAgYWZmaW5pdHlGb2N1cyA9ICdmb3J3YXJkJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFmZmluaXR5ID09PSAnb3V0d2FyZCcpIHtcbiAgICAgIGlmIChSYW5nZS5pc0ZvcndhcmQocmFuZ2UpKSB7XG4gICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2JhY2t3YXJkJztcbiAgICAgICAgYWZmaW5pdHlGb2N1cyA9ICdmb3J3YXJkJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2ZvcndhcmQnO1xuICAgICAgICBhZmZpbml0eUZvY3VzID0gJ2JhY2t3YXJkJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYWZmaW5pdHlBbmNob3IgPSBhZmZpbml0eTtcbiAgICAgIGFmZmluaXR5Rm9jdXMgPSBhZmZpbml0eTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvZHVjZShyYW5nZSwgciA9PiB7XG4gICAgICB2YXIgYW5jaG9yID0gUG9pbnQudHJhbnNmb3JtKHIuYW5jaG9yLCBvcCwge1xuICAgICAgICBhZmZpbml0eTogYWZmaW5pdHlBbmNob3JcbiAgICAgIH0pO1xuICAgICAgdmFyIGZvY3VzID0gUG9pbnQudHJhbnNmb3JtKHIuZm9jdXMsIG9wLCB7XG4gICAgICAgIGFmZmluaXR5OiBhZmZpbml0eUZvY3VzXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFhbmNob3IgfHwgIWZvY3VzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgIHIuZm9jdXMgPSBmb2N1cztcbiAgICB9KTtcbiAgfVxuXG59O1xuXG52YXIgUmFuZ2VSZWYgPSB7XG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSB0aGUgcmFuZ2UgcmVmJ3MgY3VycmVudCB2YWx1ZSBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybShyZWYsIG9wKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBhZmZpbml0eVxuICAgIH0gPSByZWY7XG5cbiAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhdGggPSBSYW5nZS50cmFuc2Zvcm0oY3VycmVudCwgb3AsIHtcbiAgICAgIGFmZmluaXR5XG4gICAgfSk7XG4gICAgcmVmLmN1cnJlbnQgPSBwYXRoO1xuXG4gICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgcmVmLnVucmVmKCk7XG4gICAgfVxuICB9XG5cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkNChvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ0KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkNChPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDQoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG52YXIgVGV4dCA9IHtcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdHdvIHRleHQgbm9kZXMgYXJlIGVxdWFsLlxyXG4gICAqL1xuICBlcXVhbHModGV4dCwgYW5vdGhlcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgbG9vc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRleHQpIHtcbiAgICAgIGlmIChsb29zZSAmJiBrZXkgPT09ICd0ZXh0Jykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRba2V5XSAhPT0gYW5vdGhlcltrZXldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfa2V5IGluIGFub3RoZXIpIHtcbiAgICAgIGlmIChsb29zZSAmJiBfa2V5ID09PSAndGV4dCcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0W19rZXldICE9PSBhbm90aGVyW19rZXldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBUZXh0YCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzVGV4dCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZyc7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGxpc3Qgb2YgYFRleHRgIG9iamVjdHMuXHJcbiAgICovXG4gIGlzVGV4dExpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgKHZhbHVlLmxlbmd0aCA9PT0gMCB8fCBUZXh0LmlzVGV4dCh2YWx1ZVswXSkpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGFuIHRleHQgbWF0Y2hlcyBzZXQgb2YgcHJvcGVydGllcy5cclxuICAgKlxyXG4gICAqIE5vdGU6IHRoaXMgaXMgZm9yIG1hdGNoaW5nIGN1c3RvbSBwcm9wZXJ0aWVzLCBhbmQgaXQgZG9lcyBub3QgZW5zdXJlIHRoYXRcclxuICAgKiB0aGUgYHRleHRgIHByb3BlcnR5IGFyZSB0d28gbm9kZXMgZXF1YWwuXHJcbiAgICovXG4gIG1hdGNoZXModGV4dCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICd0ZXh0Jykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRba2V5XSAhPT0gcHJvcHNba2V5XSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBsZWF2ZXMgZm9yIGEgdGV4dCBub2RlIGdpdmVuIGRlY29yYXRpb25zLlxyXG4gICAqL1xuICBkZWNvcmF0aW9ucyhub2RlLCBkZWNvcmF0aW9ucykge1xuICAgIHZhciBsZWF2ZXMgPSBbX29iamVjdFNwcmVhZCQ0KHt9LCBub2RlKV07XG5cbiAgICBmb3IgKHZhciBkZWMgb2YgZGVjb3JhdGlvbnMpIHtcbiAgICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGRlYywgW1wiYW5jaG9yXCIsIFwiZm9jdXNcIl0pO1xuXG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoZGVjKTtcbiAgICAgIHZhciBuZXh0ID0gW107XG4gICAgICB2YXIgbyA9IDA7XG5cbiAgICAgIGZvciAodmFyIGxlYWYgb2YgbGVhdmVzKSB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgbGVuZ3RoXG4gICAgICAgIH0gPSBsZWFmLnRleHQ7XG4gICAgICAgIHZhciBvZmZzZXQgPSBvO1xuICAgICAgICBvICs9IGxlbmd0aDsgLy8gSWYgdGhlIHJhbmdlIGVuY29tcGFzZXMgdGhlIGVudGlyZSBsZWFmLCBhZGQgdGhlIHJhbmdlLlxuXG4gICAgICAgIGlmIChzdGFydC5vZmZzZXQgPD0gb2Zmc2V0ICYmIGVuZC5vZmZzZXQgPj0gb2Zmc2V0ICsgbGVuZ3RoKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihsZWFmLCByZXN0KTtcbiAgICAgICAgICBuZXh0LnB1c2gobGVhZik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gSWYgdGhlIHJhbmdlIHN0YXJ0cyBhZnRlciB0aGUgbGVhZiwgb3IgZW5kcyBiZWZvcmUgaXQsIGNvbnRpbnVlLlxuXG5cbiAgICAgICAgaWYgKHN0YXJ0Lm9mZnNldCA+IG9mZnNldCArIGxlbmd0aCB8fCBlbmQub2Zmc2V0IDwgb2Zmc2V0IHx8IGVuZC5vZmZzZXQgPT09IG9mZnNldCAmJiBvZmZzZXQgIT09IDApIHtcbiAgICAgICAgICBuZXh0LnB1c2gobGVhZik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gc3BsaXQgdGhlIGxlYWYsIGF0IHRoZSBzdGFydCwgZW5kLCBvciBib3RoLFxuICAgICAgICAvLyBhbmQgYWRkIHRoZSByYW5nZSB0byB0aGUgbWlkZGxlIGludGVyc2VjdGluZyBzZWN0aW9uLiBEbyB0aGUgZW5kXG4gICAgICAgIC8vIHNwbGl0IGZpcnN0IHNpbmNlIHdlIGRvbid0IG5lZWQgdG8gdXBkYXRlIHRoZSBvZmZzZXQgdGhhdCB3YXkuXG5cblxuICAgICAgICB2YXIgbWlkZGxlID0gbGVhZjtcbiAgICAgICAgdmFyIGJlZm9yZSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGFmdGVyID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChlbmQub2Zmc2V0IDwgb2Zmc2V0ICsgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIG9mZiA9IGVuZC5vZmZzZXQgLSBvZmZzZXQ7XG4gICAgICAgICAgYWZ0ZXIgPSBfb2JqZWN0U3ByZWFkJDQoe30sIG1pZGRsZSwge1xuICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2Uob2ZmKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1pZGRsZSA9IF9vYmplY3RTcHJlYWQkNCh7fSwgbWlkZGxlLCB7XG4gICAgICAgICAgICB0ZXh0OiBtaWRkbGUudGV4dC5zbGljZSgwLCBvZmYpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnQub2Zmc2V0ID4gb2Zmc2V0KSB7XG4gICAgICAgICAgdmFyIF9vZmYgPSBzdGFydC5vZmZzZXQgLSBvZmZzZXQ7XG5cbiAgICAgICAgICBiZWZvcmUgPSBfb2JqZWN0U3ByZWFkJDQoe30sIG1pZGRsZSwge1xuICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoMCwgX29mZilcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtaWRkbGUgPSBfb2JqZWN0U3ByZWFkJDQoe30sIG1pZGRsZSwge1xuICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoX29mZilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWlkZGxlLCByZXN0KTtcblxuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgbmV4dC5wdXNoKGJlZm9yZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0LnB1c2gobWlkZGxlKTtcblxuICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICBuZXh0LnB1c2goYWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxlYXZlcyA9IG5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlYXZlcztcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDUob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDUoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQ1KE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIEdlbmVyYWxUcmFuc2Zvcm1zID0ge1xuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gdGhlIGVkaXRvciBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybShlZGl0b3IsIG9wKSB7XG4gICAgZWRpdG9yLmNoaWxkcmVuID0gY3JlYXRlRHJhZnQoZWRpdG9yLmNoaWxkcmVuKTtcbiAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbiAmJiBjcmVhdGVEcmFmdChlZGl0b3Iuc2VsZWN0aW9uKTtcblxuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBub2RlXG4gICAgICAgICAgfSA9IG9wO1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBOb2RlLnBhcmVudChlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgIHZhciBpbmRleCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBub2RlKTtcblxuICAgICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGZvciAodmFyIFtwb2ludCwga2V5XSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBzZWxlY3Rpb25ba2V5XSA9IFBvaW50LnRyYW5zZm9ybShwb2ludCwgb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIHRleHRcbiAgICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgICB2YXIgX25vZGUgPSBOb2RlLmxlYWYoZWRpdG9yLCBfcGF0aCk7XG5cbiAgICAgICAgICB2YXIgYmVmb3JlID0gX25vZGUudGV4dC5zbGljZSgwLCBvZmZzZXQpO1xuXG4gICAgICAgICAgdmFyIGFmdGVyID0gX25vZGUudGV4dC5zbGljZShvZmZzZXQpO1xuXG4gICAgICAgICAgX25vZGUudGV4dCA9IGJlZm9yZSArIHRleHQgKyBhZnRlcjtcblxuICAgICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQsIF9rZXldIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQsIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfcGF0aDJcbiAgICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgICB2YXIgX25vZGUyID0gTm9kZS5nZXQoZWRpdG9yLCBfcGF0aDIpO1xuXG4gICAgICAgICAgdmFyIHByZXZQYXRoID0gUGF0aC5wcmV2aW91cyhfcGF0aDIpO1xuICAgICAgICAgIHZhciBwcmV2ID0gTm9kZS5nZXQoZWRpdG9yLCBwcmV2UGF0aCk7XG5cbiAgICAgICAgICB2YXIgX3BhcmVudCA9IE5vZGUucGFyZW50KGVkaXRvciwgX3BhdGgyKTtcblxuICAgICAgICAgIHZhciBfaW5kZXggPSBfcGF0aDJbX3BhdGgyLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgaWYgKFRleHQuaXNUZXh0KF9ub2RlMikgJiYgVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgICAgIHByZXYudGV4dCArPSBfbm9kZTIudGV4dDtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFUZXh0LmlzVGV4dChfbm9kZTIpICYmICFUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICAgICAgcHJldi5jaGlsZHJlbi5wdXNoKC4uLl9ub2RlMi5jaGlsZHJlbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhIFxcXCJtZXJnZV9ub2RlXFxcIiBvcGVyYXRpb24gYXQgcGF0aCBbXCIuY29uY2F0KF9wYXRoMiwgXCJdIHRvIG5vZGVzIG9mIGRpZmZlcmVudCBpbnRlcmFjZXM6IFwiKS5jb25jYXQoX25vZGUyLCBcIiBcIikuY29uY2F0KHByZXYpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfcGFyZW50LmNoaWxkcmVuLnNwbGljZShfaW5kZXgsIDEpO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgZm9yICh2YXIgW19wb2ludDIsIF9rZXkyXSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleTJdID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDIsIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoMyxcbiAgICAgICAgICAgIG5ld1BhdGhcbiAgICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKF9wYXRoMywgbmV3UGF0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtb3ZlIGEgcGF0aCBbXCIuY29uY2F0KF9wYXRoMywgXCJdIHRvIG5ldyBwYXRoIFtcIikuY29uY2F0KG5ld1BhdGgsIFwiXSBiZWNhdXNlIHRoZSBkZXN0aW5hdGlvbiBpcyBpbnNpZGUgaXRzZWxmLlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9ub2RlMyA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGgzKTtcblxuICAgICAgICAgIHZhciBfcGFyZW50MiA9IE5vZGUucGFyZW50KGVkaXRvciwgX3BhdGgzKTtcblxuICAgICAgICAgIHZhciBfaW5kZXgyID0gX3BhdGgzW19wYXRoMy5sZW5ndGggLSAxXTsgLy8gVGhpcyBpcyB0cmlja3ksIGJ1dCBzaW5jZSB0aGUgYHBhdGhgIGFuZCBgbmV3UGF0aGAgYm90aCByZWZlciB0b1xuICAgICAgICAgIC8vIHRoZSBzYW1lIHNuYXBzaG90IGluIHRpbWUsIHRoZXJlJ3MgYSBtaXNtYXRjaC4gQWZ0ZXIgZWl0aGVyXG4gICAgICAgICAgLy8gcmVtb3ZpbmcgdGhlIG9yaWdpbmFsIHBvc2l0aW9uLCB0aGUgc2Vjb25kIHN0ZXAncyBwYXRoIGNhbiBiZSBvdXRcbiAgICAgICAgICAvLyBvZiBkYXRlLiBTbyBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBgb3AubmV3UGF0aGAgZGlyZWN0bHksIHdlXG4gICAgICAgICAgLy8gdHJhbnNmb3JtIGBvcC5wYXRoYCB0byBhc2NlcnRhaW4gd2hhdCB0aGUgYG5ld1BhdGhgIHdvdWxkIGJlIGFmdGVyXG4gICAgICAgICAgLy8gdGhlIG9wZXJhdGlvbiB3YXMgYXBwbGllZC5cblxuICAgICAgICAgIF9wYXJlbnQyLmNoaWxkcmVuLnNwbGljZShfaW5kZXgyLCAxKTtcblxuICAgICAgICAgIHZhciB0cnVlUGF0aCA9IFBhdGgudHJhbnNmb3JtKF9wYXRoMywgb3ApO1xuICAgICAgICAgIHZhciBuZXdQYXJlbnQgPSBOb2RlLmdldChlZGl0b3IsIFBhdGgucGFyZW50KHRydWVQYXRoKSk7XG4gICAgICAgICAgdmFyIG5ld0luZGV4ID0gdHJ1ZVBhdGhbdHJ1ZVBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgbmV3UGFyZW50LmNoaWxkcmVuLnNwbGljZShuZXdJbmRleCwgMCwgX25vZGUzKTtcblxuICAgICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQzLCBfa2V5M10gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXkzXSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQzLCBvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoNFxuICAgICAgICAgIH0gPSBvcDtcbiAgICAgICAgICB2YXIgX2luZGV4MyA9IF9wYXRoNFtfcGF0aDQubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICB2YXIgX3BhcmVudDMgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoNCk7XG5cbiAgICAgICAgICBfcGFyZW50My5jaGlsZHJlbi5zcGxpY2UoX2luZGV4MywgMSk7IC8vIFRyYW5zZm9ybSBhbGwgb2YgdGhlIHBvaW50cyBpbiB0aGUgdmFsdWUsIGJ1dCBpZiB0aGUgcG9pbnQgd2FzIGluIHRoZVxuICAgICAgICAgIC8vIG5vZGUgdGhhdCB3YXMgcmVtb3ZlZCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgcmFuZ2Ugb3IgcmVtb3ZlIGl0LlxuXG5cbiAgICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBbX3BvaW50NCwgX2tleTRdIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50NCwgb3ApO1xuXG4gICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gIT0gbnVsbCAmJiByZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5NF0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIF9wcmV2ID0gdm9pZCAwO1xuXG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBbbiwgcF0gb2YgTm9kZS50ZXh0cyhlZGl0b3IpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoUGF0aC5jb21wYXJlKHAsIF9wYXRoNCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIF9wcmV2ID0gW24sIHBdO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IFtuLCBwXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF9wcmV2KSB7XG4gICAgICAgICAgICAgICAgICBfcG9pbnQ0LnBhdGggPSBfcHJldlsxXTtcbiAgICAgICAgICAgICAgICAgIF9wb2ludDQub2Zmc2V0ID0gX3ByZXZbMF0udGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgICBfcG9pbnQ0LnBhdGggPSBuZXh0WzFdO1xuICAgICAgICAgICAgICAgICAgX3BvaW50NC5vZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfcGF0aDUsXG4gICAgICAgICAgICBvZmZzZXQ6IF9vZmZzZXQsXG4gICAgICAgICAgICB0ZXh0OiBfdGV4dFxuICAgICAgICAgIH0gPSBvcDtcblxuICAgICAgICAgIHZhciBfbm9kZTQgPSBOb2RlLmxlYWYoZWRpdG9yLCBfcGF0aDUpO1xuXG4gICAgICAgICAgdmFyIF9iZWZvcmUgPSBfbm9kZTQudGV4dC5zbGljZSgwLCBfb2Zmc2V0KTtcblxuICAgICAgICAgIHZhciBfYWZ0ZXIgPSBfbm9kZTQudGV4dC5zbGljZShfb2Zmc2V0ICsgX3RleHQubGVuZ3RoKTtcblxuICAgICAgICAgIF9ub2RlNC50ZXh0ID0gX2JlZm9yZSArIF9hZnRlcjtcblxuICAgICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQ1LCBfa2V5NV0gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk1XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQ1LCBvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoNixcbiAgICAgICAgICAgIG5ld1Byb3BlcnRpZXNcbiAgICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgICBpZiAoX3BhdGg2Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBwcm9wZXJ0aWVzIG9uIHRoZSByb290IG5vZGUhXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfbm9kZTUgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoNik7XG5cbiAgICAgICAgICBmb3IgKHZhciBfa2V5NiBpbiBuZXdQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAoX2tleTYgPT09ICdjaGlsZHJlbicgfHwgX2tleTYgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHRoZSBcXFwiXCIuY29uY2F0KF9rZXk2LCBcIlxcXCIgcHJvcGVydHkgb2Ygbm9kZXMhXCIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gbmV3UHJvcGVydGllc1tfa2V5Nl07XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBfbm9kZTVbX2tleTZdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX25vZGU1W19rZXk2XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IF9uZXdQcm9wZXJ0aWVzXG4gICAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgICAgaWYgKF9uZXdQcm9wZXJ0aWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IF9uZXdQcm9wZXJ0aWVzO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghUmFuZ2UuaXNSYW5nZShfbmV3UHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGFuIGluY29tcGxldGUgXFxcInNldF9zZWxlY3Rpb25cXFwiIG9wZXJhdGlvbiBwcm9wZXJ0aWVzIFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShfbmV3UHJvcGVydGllcyksIFwiIHdoZW4gdGhlcmUgaXMgbm8gY3VycmVudCBzZWxlY3Rpb24uXCIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZWN0aW9uID0gX25ld1Byb3BlcnRpZXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2VsZWN0aW9uLCBfbmV3UHJvcGVydGllcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogX3BhdGg3LFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBwcm9wZXJ0aWVzXG4gICAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgICAgaWYgKF9wYXRoNy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhIFxcXCJzcGxpdF9ub2RlXFxcIiBvcGVyYXRpb24gYXQgcGF0aCBbXCIuY29uY2F0KF9wYXRoNywgXCJdIGJlY2F1c2UgdGhlIHJvb3Qgbm9kZSBjYW5ub3QgYmUgc3BsaXQuXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX25vZGU2ID0gTm9kZS5nZXQoZWRpdG9yLCBfcGF0aDcpO1xuXG4gICAgICAgICAgdmFyIF9wYXJlbnQ0ID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDcpO1xuXG4gICAgICAgICAgdmFyIF9pbmRleDQgPSBfcGF0aDdbX3BhdGg3Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHZhciBuZXdOb2RlO1xuXG4gICAgICAgICAgaWYgKFRleHQuaXNUZXh0KF9ub2RlNikpIHtcbiAgICAgICAgICAgIHZhciBfYmVmb3JlMiA9IF9ub2RlNi50ZXh0LnNsaWNlKDAsIHBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdmFyIF9hZnRlcjIgPSBfbm9kZTYudGV4dC5zbGljZShwb3NpdGlvbik7XG5cbiAgICAgICAgICAgIF9ub2RlNi50ZXh0ID0gX2JlZm9yZTI7XG4gICAgICAgICAgICBuZXdOb2RlID0gX29iamVjdFNwcmVhZCQ1KHt9LCBfbm9kZTYsIHt9LCBwcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICAgIHRleHQ6IF9hZnRlcjJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgX2JlZm9yZTMgPSBfbm9kZTYuY2hpbGRyZW4uc2xpY2UoMCwgcG9zaXRpb24pO1xuXG4gICAgICAgICAgICB2YXIgX2FmdGVyMyA9IF9ub2RlNi5jaGlsZHJlbi5zbGljZShwb3NpdGlvbik7XG5cbiAgICAgICAgICAgIF9ub2RlNi5jaGlsZHJlbiA9IF9iZWZvcmUzO1xuICAgICAgICAgICAgbmV3Tm9kZSA9IF9vYmplY3RTcHJlYWQkNSh7fSwgX25vZGU2LCB7fSwgcHJvcGVydGllcywge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogX2FmdGVyM1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3BhcmVudDQuY2hpbGRyZW4uc3BsaWNlKF9pbmRleDQgKyAxLCAwLCBuZXdOb2RlKTtcblxuICAgICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQ2LCBfa2V5N10gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk3XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQ2LCBvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlZGl0b3IuY2hpbGRyZW4gPSBmaW5pc2hEcmFmdChlZGl0b3IuY2hpbGRyZW4pO1xuXG4gICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IGlzRHJhZnQoc2VsZWN0aW9uKSA/IGZpbmlzaERyYWZ0KHNlbGVjdGlvbikgOiBzZWxlY3Rpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkaXRvci5zZWxlY3Rpb24gPSBudWxsO1xuICAgIH1cbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDYob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNih0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDYoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQ2KE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIE5vZGVUcmFuc2Zvcm1zID0ge1xuICAvKipcclxuICAgKiBJbnNlcnQgbm9kZXMgYXQgYSBzcGVjaWZpYyBsb2NhdGlvbiBpbiB0aGUgRWRpdG9yLlxyXG4gICAqL1xuICBpbnNlcnROb2RlcyhlZGl0b3IsIG5vZGVzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBoYW5naW5nID0gZmFsc2UsXG4gICAgICAgIHZvaWRzID0gZmFsc2UsXG4gICAgICAgIG1vZGUgPSAnbG93ZXN0J1xuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIHNlbGVjdFxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmIChOb2RlLmlzTm9kZShub2RlcykpIHtcbiAgICAgICAgbm9kZXMgPSBbbm9kZXNdO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIFtub2RlXSA9IG5vZGVzOyAvLyBCeSBkZWZhdWx0LCB1c2UgdGhlIHNlbGVjdGlvbiBhcyB0aGUgdGFyZ2V0IGxvY2F0aW9uLiBCdXQgaWYgdGhlcmUgaXNcbiAgICAgIC8vIG5vIHNlbGVjdGlvbiwgaW5zZXJ0IGF0IHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50IHNpbmNlIHRoYXQgaXMgc3VjaCBhXG4gICAgICAvLyBjb21tb24gdXNlIGNhc2Ugd2hlbiBpbnNlcnRpbmcgZnJvbSBhIG5vbi1zZWxlY3RlZCBzdGF0ZS5cblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmIChlZGl0b3IuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGF0ID0gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdCA9IFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGVjdCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3QgPT0gbnVsbCkge1xuICAgICAgICBzZWxlY3QgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGlmICghaGFuZ2luZykge1xuICAgICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGF0ID0gcG9pbnRSZWYudW5yZWYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoUG9pbnQuaXNQb2ludChhdCkpIHtcbiAgICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICAgIG1hdGNoID0gbiA9PiBUZXh0LmlzVGV4dChuKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVkaXRvci5pc0lubGluZShub2RlKSkge1xuICAgICAgICAgICAgbWF0Y2ggPSBuID0+IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaCA9IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgW2VudHJ5XSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYXQucGF0aCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHZhciBbLCBfbWF0Y2hQYXRoXSA9IGVudHJ5O1xuICAgICAgICAgIHZhciBwYXRoUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBfbWF0Y2hQYXRoKTtcbiAgICAgICAgICB2YXIgaXNBdEVuZCA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBfbWF0Y2hQYXRoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdCxcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICAgICAgYXQgPSBpc0F0RW5kID8gUGF0aC5uZXh0KHBhdGgpIDogcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChhdCk7XG4gICAgICB2YXIgaW5kZXggPSBhdFthdC5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhcmVudFBhdGhcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX25vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgdmFyIF9wYXRoID0gcGFyZW50UGF0aC5jb25jYXQoaW5kZXgpO1xuXG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogJ2luc2VydF9ub2RlJyxcbiAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICBub2RlOiBfbm9kZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdCkge1xuICAgICAgICB2YXIgcG9pbnQgPSBFZGl0b3IuZW5kKGVkaXRvciwgYXQpO1xuXG4gICAgICAgIGlmIChwb2ludCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcG9pbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogTGlmdCBub2RlcyBhdCBhIHNwZWNpZmljIGxvY2F0aW9uIHVwd2FyZHMgaW4gdGhlIGRvY3VtZW50IHRyZWUsIHNwbGl0dGluZ1xyXG4gICAqIHRoZWlyIHBhcmVudCBpbiB0d28gaWYgbmVjZXNzYXJ5LlxyXG4gICAqL1xuICBsaWZ0Tm9kZXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgICAgdm9pZHMgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBtYXRjaFxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hdGNoZXMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShtYXRjaGVzLCAoX3JlZikgPT4ge1xuICAgICAgICB2YXIgWywgcF0gPSBfcmVmO1xuICAgICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBwYXRoUmVmIG9mIHBhdGhSZWZzKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbGlmdCBub2RlIGF0IGEgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IGhhcyBhIGRlcHRoIG9mIGxlc3MgdGhhbiBgMmAuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnROb2RlRW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIFBhdGgucGFyZW50KHBhdGgpKTtcbiAgICAgICAgdmFyIFtwYXJlbnQsIHBhcmVudFBhdGhdID0gcGFyZW50Tm9kZUVudHJ5O1xuICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgbGVuZ3RoXG4gICAgICAgIH0gPSBwYXJlbnQuY2hpbGRyZW47XG5cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHZhciB0b1BhdGggPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICAgIHRvOiB0b1BhdGgsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGFyZW50UGF0aCxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgdG86IHBhcmVudFBhdGgsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgdmFyIF90b1BhdGggPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgdG86IF90b1BhdGgsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzcGxpdFBhdGggPSBQYXRoLm5leHQocGF0aCk7XG5cbiAgICAgICAgICB2YXIgX3RvUGF0aDIgPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogc3BsaXRQYXRoLFxuICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgdG86IF90b1BhdGgyLFxuICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1lcmdlIGEgbm9kZSBhdCBhIGxvY2F0aW9uIHdpdGggdGhlIHByZXZpb3VzIG5vZGUgb2YgdGhlIHNhbWUgZGVwdGgsXHJcbiAgICogcmVtb3ZpbmcgYW55IGVtcHR5IGNvbnRhaW5pbmcgbm9kZXMgYWZ0ZXIgdGhlIG1lcmdlIGlmIG5lY2Vzc2FyeS5cclxuICAgKi9cbiAgbWVyZ2VOb2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIG1hdGNoLFxuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb25cbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgICB2b2lkcyA9IGZhbHNlLFxuICAgICAgICBtb2RlID0gJ2xvd2VzdCdcbiAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICAgIHZhciBbcGFyZW50XSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBhdCk7XG5cbiAgICAgICAgICBtYXRjaCA9IG4gPT4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoID0gbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFuZ2luZyAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgWywgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgICAgICB2YXIgcG9pbnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgICAgYXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhdCA9IHBvaW50UmVmLnVucmVmKCk7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGF0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIFtjdXJyZW50XSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICB2b2lkcyxcbiAgICAgICAgbW9kZVxuICAgICAgfSk7XG4gICAgICB2YXIgcHJldiA9IEVkaXRvci5wcmV2aW91cyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICB2b2lkcyxcbiAgICAgICAgbW9kZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghY3VycmVudCB8fCAhcHJldikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBbbm9kZSwgcGF0aF0gPSBjdXJyZW50O1xuICAgICAgdmFyIFtwcmV2Tm9kZSwgcHJldlBhdGhdID0gcHJldjtcblxuICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwIHx8IHByZXZQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdQYXRoID0gUGF0aC5uZXh0KHByZXZQYXRoKTtcbiAgICAgIHZhciBjb21tb25QYXRoID0gUGF0aC5jb21tb24ocGF0aCwgcHJldlBhdGgpO1xuICAgICAgdmFyIGlzUHJldmlvdXNTaWJsaW5nID0gUGF0aC5pc1NpYmxpbmcocGF0aCwgcHJldlBhdGgpO1xuICAgICAgdmFyIGxldmVscyA9IEFycmF5LmZyb20oRWRpdG9yLmxldmVscyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGhcbiAgICAgIH0pLCAoX3JlZjIpID0+IHtcbiAgICAgICAgdmFyIFtuXSA9IF9yZWYyO1xuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH0pLnNsaWNlKGNvbW1vblBhdGgubGVuZ3RoKS5zbGljZSgwLCAtMSk7IC8vIERldGVybWluZSBpZiB0aGUgbWVyZ2Ugd2lsbCBsZWF2ZSBhbiBhbmNlc3RvciBvZiB0aGUgcGF0aCBlbXB0eSBhcyBhXG4gICAgICAvLyByZXN1bHQsIGluIHdoaWNoIGNhc2Ugd2UnbGwgd2FudCB0byByZW1vdmUgaXQgYWZ0ZXIgbWVyZ2luZy5cblxuICAgICAgdmFyIGVtcHR5QW5jZXN0b3IgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBwYXRoLFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICAgIG1hdGNoOiBuID0+IGxldmVscy5pbmNsdWRlcyhuKSAmJiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBuLmNoaWxkcmVuLmxlbmd0aCA9PT0gMVxuICAgICAgfSk7XG4gICAgICB2YXIgZW1wdHlSZWYgPSBlbXB0eUFuY2VzdG9yICYmIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgZW1wdHlBbmNlc3RvclsxXSk7XG4gICAgICB2YXIgcHJvcGVydGllcztcbiAgICAgIHZhciBwb3NpdGlvbjsgLy8gRW5zdXJlIHRoYXQgdGhlIG5vZGVzIGFyZSBlcXVpdmFsZW50LCBhbmQgZmlndXJlIG91dCB3aGF0IHRoZSBwb3NpdGlvblxuICAgICAgLy8gYW5kIGV4dHJhIHByb3BlcnRpZXMgb2YgdGhlIG1lcmdlIHdpbGwgYmUuXG5cbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSAmJiBUZXh0LmlzVGV4dChwcmV2Tm9kZSkpIHtcbiAgICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgW1widGV4dFwiXSk7XG5cbiAgICAgICAgcG9zaXRpb24gPSBwcmV2Tm9kZS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgcHJvcGVydGllcyA9IHJlc3Q7XG4gICAgICB9IGVsc2UgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIEVsZW1lbnQuaXNFbGVtZW50KHByZXZOb2RlKSkge1xuICAgICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBbXCJjaGlsZHJlblwiXSk7XG5cbiAgICAgICAgcG9zaXRpb24gPSBwcmV2Tm9kZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIHByb3BlcnRpZXMgPSByZXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1lcmdlIHRoZSBub2RlIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gd2l0aCB0aGUgcHJldmlvdXMgc2libGluZyBiZWNhdXNlIGl0IGlzIG5vdCB0aGUgc2FtZSBraW5kOiBcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KG5vZGUpLCBcIiBcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KHByZXZOb2RlKSkpO1xuICAgICAgfSAvLyBJZiB0aGUgbm9kZSBpc24ndCBhbHJlYWR5IHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIHByZXZpb3VzIG5vZGUsIG1vdmVcbiAgICAgIC8vIGl0IHNvIHRoYXQgaXQgaXMgYmVmb3JlIG1lcmdpbmcuXG5cblxuICAgICAgaWYgKCFpc1ByZXZpb3VzU2libGluZykge1xuICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICB0bzogbmV3UGF0aCxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gSWYgdGhlcmUgd2FzIGdvaW5nIHRvIGJlIGFuIGVtcHR5IGFuY2VzdG9yIG9mIHRoZSBub2RlIHRoYXQgd2FzIG1lcmdlZCxcbiAgICAgIC8vIHdlIHJlbW92ZSBpdCBmcm9tIHRoZSB0cmVlLlxuXG5cbiAgICAgIGlmIChlbXB0eVJlZikge1xuICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlbXB0eVJlZi5jdXJyZW50LFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBJZiB0aGUgdGFyZ2V0IG5vZGUgdGhhdCB3ZSdyZSBtZXJnaW5nIHdpdGggaXMgZW1wdHksIHJlbW92ZSBpdCBpbnN0ZWFkXG4gICAgICAvLyBvZiBtZXJnaW5nIHRoZSB0d28uIFRoaXMgaXMgYSBjb21tb24gcmljaCB0ZXh0IGVkaXRvciBiZWhhdmlvciB0b1xuICAgICAgLy8gcHJldmVudCBsb3NpbmcgZm9ybWF0dGluZyB3aGVuIGRlbGV0aW5nIGVudGlyZSBub2RlcyB3aGVuIHlvdSBoYXZlIGFcbiAgICAgIC8vIGhhbmdpbmcgc2VsZWN0aW9uLlxuXG5cbiAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChwcmV2Tm9kZSkgJiYgRWRpdG9yLmlzRW1wdHkoZWRpdG9yLCBwcmV2Tm9kZSkgfHwgVGV4dC5pc1RleHQocHJldk5vZGUpICYmIHByZXZOb2RlLnRleHQgPT09ICcnKSB7XG4gICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHByZXZQYXRoLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICB0eXBlOiAnbWVyZ2Vfbm9kZScsXG4gICAgICAgICAgcGF0aDogbmV3UGF0aCxcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgICAgcHJvcGVydGllc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVtcHR5UmVmKSB7XG4gICAgICAgIGVtcHR5UmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogTW92ZSB0aGUgbm9kZXMgYXQgYSBsb2NhdGlvbiB0byBhIG5ldyBsb2NhdGlvbi5cclxuICAgKi9cbiAgbW92ZU5vZGVzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICB0byxcbiAgICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICAgIHZvaWRzID0gZmFsc2VcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgbWF0Y2hcbiAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b1JlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgdG8pO1xuICAgICAgdmFyIHRhcmdldHMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbSh0YXJnZXRzLCAoX3JlZjMpID0+IHtcbiAgICAgICAgdmFyIFssIHBdID0gX3JlZjM7XG4gICAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIHBhdGhSZWYgb2YgcGF0aFJlZnMpIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICAgIHZhciBuZXdQYXRoID0gdG9SZWYuY3VycmVudDtcblxuICAgICAgICBpZiAocGF0aC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgdHlwZTogJ21vdmVfbm9kZScsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgbmV3UGF0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRvUmVmLnVucmVmKCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmVtb3ZlIHRoZSBub2RlcyBhdCBhIHNwZWNpZmljIGxvY2F0aW9uIGluIHRoZSBkb2N1bWVudC5cclxuICAgKi9cbiAgcmVtb3ZlTm9kZXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBoYW5naW5nID0gZmFsc2UsXG4gICAgICAgIHZvaWRzID0gZmFsc2UsXG4gICAgICAgIG1vZGUgPSAnbG93ZXN0J1xuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIG1hdGNoXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWhhbmdpbmcgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZXB0aHMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShkZXB0aHMsIChfcmVmNCkgPT4ge1xuICAgICAgICB2YXIgWywgcF0gPSBfcmVmNDtcbiAgICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgcGF0aFJlZiBvZiBwYXRoUmVmcykge1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcblxuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgIHZhciBbbm9kZV0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICB0eXBlOiAncmVtb3ZlX25vZGUnLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIG5vZGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNldCBuZXcgcHJvcGVydGllcyBvbiB0aGUgbm9kZXMgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgc2V0Tm9kZXMoZWRpdG9yLCBwcm9wcykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBoYW5naW5nID0gZmFsc2UsXG4gICAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgICAgc3BsaXQgPSBmYWxzZSxcbiAgICAgICAgdm9pZHMgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYW5naW5nICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BsaXQgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgdmFyIHJhbmdlUmVmID0gRWRpdG9yLnJhbmdlUmVmKGVkaXRvciwgYXQsIHtcbiAgICAgICAgICBhZmZpbml0eTogJ2lud2FyZCdcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICAgIHZhciBzcGxpdE1vZGUgPSBtb2RlID09PSAnbG93ZXN0JyA/ICdsb3dlc3QnIDogJ2hpZ2hlc3QnO1xuICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVuZCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlOiBzcGxpdE1vZGUsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogc3RhcnQsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgbW9kZTogc3BsaXRNb2RlLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgICBhdCA9IHJhbmdlUmVmLnVucmVmKCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgYXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgIHZhciBuZXdQcm9wZXJ0aWVzID0ge307IC8vIFlvdSBjYW4ndCBzZXQgcHJvcGVydGllcyBvbiB0aGUgZWRpdG9yIG5vZGUuXG5cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBrIGluIHByb3BzKSB7XG4gICAgICAgICAgaWYgKGsgPT09ICdjaGlsZHJlbicgfHwgayA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocHJvcHNba10gIT09IG5vZGVba10pIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXNba10gPSBub2RlW2tdO1xuICAgICAgICAgICAgbmV3UHJvcGVydGllc1trXSA9IHByb3BzW2tdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhuZXdQcm9wZXJ0aWVzKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgdHlwZTogJ3NldF9ub2RlJyxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgbmV3UHJvcGVydGllc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogU3BsaXQgdGhlIG5vZGVzIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24uXHJcbiAgICovXG4gIHNwbGl0Tm9kZXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICAgIHZvaWRzID0gZmFsc2VcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgaGVpZ2h0ID0gMCxcbiAgICAgICAgYWx3YXlzID0gZmFsc2VcbiAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGF0ID0gZGVsZXRlUmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgICB9IC8vIElmIHRoZSB0YXJnZXQgaXMgYSBwYXRoLCB0aGUgZGVmYXVsdCBoZWlnaHQtc2tpcHBpbmcgYW5kIHBvc2l0aW9uXG4gICAgICAvLyBjb3VudGVycyBuZWVkIHRvIGFjY291bnQgZm9yIHVzIHBvdGVudGlhbGx5IHNwbGl0dGluZyBhdCBhIG5vbi1sZWFmLlxuXG5cbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgdmFyIHBhdGggPSBhdDtcbiAgICAgICAgdmFyIHBvaW50ID0gRWRpdG9yLnBvaW50KGVkaXRvciwgcGF0aCk7XG4gICAgICAgIHZhciBbcGFyZW50XSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBwYXRoKTtcblxuICAgICAgICBtYXRjaCA9IG4gPT4gbiA9PT0gcGFyZW50O1xuXG4gICAgICAgIGhlaWdodCA9IHBvaW50LnBhdGgubGVuZ3RoIC0gcGF0aC5sZW5ndGggKyAxO1xuICAgICAgICBhdCA9IHBvaW50O1xuICAgICAgICBhbHdheXMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGJlZm9yZVJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGF0LCB7XG4gICAgICAgIGFmZmluaXR5OiAnYmFja3dhcmQnXG4gICAgICB9KTtcbiAgICAgIHZhciBbaGlnaGVzdF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWhpZ2hlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdm9pZE1hdGNoID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICAgIH0pO1xuICAgICAgdmFyIG51ZGdlID0gMDtcblxuICAgICAgaWYgKCF2b2lkcyAmJiB2b2lkTWF0Y2gpIHtcbiAgICAgICAgdmFyIFt2b2lkTm9kZSwgdm9pZFBhdGhdID0gdm9pZE1hdGNoO1xuXG4gICAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudCh2b2lkTm9kZSkgJiYgZWRpdG9yLmlzSW5saW5lKHZvaWROb2RlKSkge1xuICAgICAgICAgIHZhciBhZnRlciA9IEVkaXRvci5hZnRlcihlZGl0b3IsIHZvaWRQYXRoKTtcblxuICAgICAgICAgIGlmICghYWZ0ZXIpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0ge1xuICAgICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBhZnRlclBhdGggPSBQYXRoLm5leHQodm9pZFBhdGgpO1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHRleHQsIHtcbiAgICAgICAgICAgICAgYXQ6IGFmdGVyUGF0aCxcbiAgICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWZ0ZXIgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBhZnRlclBhdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGF0ID0gYWZ0ZXI7XG4gICAgICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaWJsaW5nSGVpZ2h0ID0gYXQucGF0aC5sZW5ndGggLSB2b2lkUGF0aC5sZW5ndGg7XG4gICAgICAgIGhlaWdodCA9IHNpYmxpbmdIZWlnaHQgKyAxO1xuICAgICAgICBhbHdheXMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWZ0ZXJSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBhdCk7XG4gICAgICB2YXIgZGVwdGggPSBhdC5wYXRoLmxlbmd0aCAtIGhlaWdodDtcbiAgICAgIHZhciBbLCBoaWdoZXN0UGF0aF0gPSBoaWdoZXN0O1xuICAgICAgdmFyIGxvd2VzdFBhdGggPSBhdC5wYXRoLnNsaWNlKDAsIGRlcHRoKTtcbiAgICAgIHZhciBwb3NpdGlvbiA9IGhlaWdodCA9PT0gMCA/IGF0Lm9mZnNldCA6IGF0LnBhdGhbZGVwdGhdICsgbnVkZ2U7XG4gICAgICB2YXIgdGFyZ2V0ID0gbnVsbDtcblxuICAgICAgZm9yICh2YXIgW25vZGUsIF9wYXRoMl0gb2YgRWRpdG9yLmxldmVscyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGxvd2VzdFBhdGgsXG4gICAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KSkge1xuICAgICAgICB2YXIgc3BsaXQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoX3BhdGgyLmxlbmd0aCA8IGhpZ2hlc3RQYXRoLmxlbmd0aCB8fCBfcGF0aDIubGVuZ3RoID09PSAwIHx8ICF2b2lkcyAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfcG9pbnQgPSBiZWZvcmVSZWYuY3VycmVudDtcbiAgICAgICAgdmFyIGlzRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgX3BvaW50LCBfcGF0aDIpO1xuXG4gICAgICAgIGlmIChhbHdheXMgfHwgIWJlZm9yZVJlZiB8fCAhRWRpdG9yLmlzRWRnZShlZGl0b3IsIF9wb2ludCwgX3BhdGgyKSkge1xuICAgICAgICAgIHNwbGl0ID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIFtcInRleHRcIiwgXCJjaGlsZHJlblwiXSk7XG5cbiAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgdHlwZTogJ3NwbGl0X25vZGUnLFxuICAgICAgICAgICAgcGF0aDogX3BhdGgyLFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQgPSBwb3NpdGlvbjtcbiAgICAgICAgcG9zaXRpb24gPSBfcGF0aDJbX3BhdGgyLmxlbmd0aCAtIDFdICsgKHNwbGl0IHx8IGlzRW5kID8gMSA6IDApO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgIHZhciBfcG9pbnQyID0gYWZ0ZXJSZWYuY3VycmVudCB8fCBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuXG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgX3BvaW50Mik7XG4gICAgICB9XG5cbiAgICAgIGJlZm9yZVJlZi51bnJlZigpO1xuICAgICAgYWZ0ZXJSZWYudW5yZWYoKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBVbnNldCBwcm9wZXJ0aWVzIG9uIHRoZSBub2RlcyBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICB1bnNldE5vZGVzKGVkaXRvciwgcHJvcHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgICBwcm9wcyA9IFtwcm9wc107XG4gICAgfVxuXG4gICAgdmFyIG9iaiA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IG9mIHByb3BzKSB7XG4gICAgICBvYmpba2V5XSA9IG51bGw7XG4gICAgfVxuXG4gICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIG9iaiwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogVW53cmFwIHRoZSBub2RlcyBhdCBhIGxvY2F0aW9uIGZyb20gYSBwYXJlbnQgbm9kZSwgc3BsaXR0aW5nIHRoZSBwYXJlbnQgaWZcclxuICAgKiBuZWNlc3NhcnkgdG8gZW5zdXJlIHRoYXQgb25seSB0aGUgY29udGVudCBpbiB0aGUgcmFuZ2UgaXMgdW53cmFwcGVkLlxyXG4gICAqL1xuICB1bndyYXBOb2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgICBzcGxpdCA9IGZhbHNlLFxuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgbWF0Y2hcbiAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgYXQgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgICB9XG5cbiAgICAgIHZhciByYW5nZVJlZiA9IFJhbmdlLmlzUmFuZ2UoYXQpID8gRWRpdG9yLnJhbmdlUmVmKGVkaXRvciwgYXQpIDogbnVsbDtcbiAgICAgIHZhciBtYXRjaGVzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20obWF0Y2hlcywgKF9yZWY1KSA9PiB7XG4gICAgICAgIHZhciBbLCBwXSA9IF9yZWY1O1xuICAgICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChwYXRoUmVmKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuICAgICAgICB2YXIgW25vZGVdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcGF0aCk7XG5cbiAgICAgICAgaWYgKHNwbGl0ICYmIHJhbmdlUmVmKSB7XG4gICAgICAgICAgcmFuZ2UgPSBSYW5nZS5pbnRlcnNlY3Rpb24ocmFuZ2VSZWYuY3VycmVudCwgcmFuZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgVHJhbnNmb3Jtcy5saWZ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgIG1hdGNoOiBuID0+IG5vZGUuY2hpbGRyZW4uaW5jbHVkZXMobiksXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBwYXRoUmVmIG9mIHBhdGhSZWZzKSB7XG4gICAgICAgIF9sb29wKHBhdGhSZWYpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmFuZ2VSZWYpIHtcbiAgICAgICAgcmFuZ2VSZWYudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBXcmFwIHRoZSBub2RlcyBhdCBhIGxvY2F0aW9uIGluIGEgbmV3IGNvbnRhaW5lciBub2RlLCBzcGxpdHRpbmcgdGhlIGVkZ2VzXHJcbiAgICogb2YgdGhlIHJhbmdlIGZpcnN0IHRvIGVuc3VyZSB0aGF0IG9ubHkgdGhlIGNvbnRlbnQgaW4gdGhlIHJhbmdlIGlzIHdyYXBwZWQuXHJcbiAgICovXG4gIHdyYXBOb2RlcyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgICAgc3BsaXQgPSBmYWxzZSxcbiAgICAgICAgdm9pZHMgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBtYXRjaCxcbiAgICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgICBtYXRjaCA9IG1hdGNoUGF0aChlZGl0b3IsIGF0KTtcbiAgICAgICAgfSBlbHNlIGlmIChlZGl0b3IuaXNJbmxpbmUoZWxlbWVudCkpIHtcbiAgICAgICAgICBtYXRjaCA9IG4gPT4gRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbikgfHwgVGV4dC5pc1RleHQobik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2ggPSBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNwbGl0ICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICAgIHZhciByYW5nZVJlZiA9IEVkaXRvci5yYW5nZVJlZihlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgYWZmaW5pdHk6ICdpbndhcmQnXG4gICAgICAgIH0pO1xuICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVuZCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBzdGFydCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgICAgYXQgPSByYW5nZVJlZi51bnJlZigpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGF0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcm9vdHMgPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoOiBlZGl0b3IuaXNJbmxpbmUoZWxlbWVudCkgPyBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbikgOiBuID0+IEVkaXRvci5pc0VkaXRvcihuKSxcbiAgICAgICAgbW9kZTogJ2xvd2VzdCcsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KSk7XG5cbiAgICAgIGZvciAodmFyIFssIHJvb3RQYXRoXSBvZiByb290cykge1xuICAgICAgICB2YXIgYSA9IFJhbmdlLmlzUmFuZ2UoYXQpID8gUmFuZ2UuaW50ZXJzZWN0aW9uKGF0LCBFZGl0b3IucmFuZ2UoZWRpdG9yLCByb290UGF0aCkpIDogYXQ7XG5cbiAgICAgICAgaWYgKCFhKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWF0Y2hlcyA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBhLFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIFtmaXJzdF0gPSBtYXRjaGVzO1xuICAgICAgICAgICAgdmFyIGxhc3QgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB2YXIgWywgZmlyc3RQYXRoXSA9IGZpcnN0O1xuICAgICAgICAgICAgdmFyIFssIGxhc3RQYXRoXSA9IGxhc3Q7XG4gICAgICAgICAgICB2YXIgY29tbW9uUGF0aCA9IFBhdGguZXF1YWxzKGZpcnN0UGF0aCwgbGFzdFBhdGgpID8gUGF0aC5wYXJlbnQoZmlyc3RQYXRoKSA6IFBhdGguY29tbW9uKGZpcnN0UGF0aCwgbGFzdFBhdGgpO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgZmlyc3RQYXRoLCBsYXN0UGF0aCk7XG4gICAgICAgICAgICB2YXIgY29tbW9uTm9kZUVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBjb21tb25QYXRoKTtcbiAgICAgICAgICAgIHZhciBbY29tbW9uTm9kZV0gPSBjb21tb25Ob2RlRW50cnk7XG4gICAgICAgICAgICB2YXIgZGVwdGggPSBjb21tb25QYXRoLmxlbmd0aCArIDE7XG4gICAgICAgICAgICB2YXIgd3JhcHBlclBhdGggPSBQYXRoLm5leHQobGFzdFBhdGguc2xpY2UoMCwgZGVwdGgpKTtcblxuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBfb2JqZWN0U3ByZWFkJDYoe30sIGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHdyYXBwZXIsIHtcbiAgICAgICAgICAgICAgYXQ6IHdyYXBwZXJQYXRoLFxuICAgICAgICAgICAgICB2b2lkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgICBtYXRjaDogbiA9PiBjb21tb25Ob2RlLmNoaWxkcmVuLmluY2x1ZGVzKG4pLFxuICAgICAgICAgICAgICB0bzogd3JhcHBlclBhdGguY29uY2F0KDApLFxuICAgICAgICAgICAgICB2b2lkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn07XG4vKipcclxuICogQ29udmVydCBhIHJhbmdlIGludG8gYSBwb2ludCBieSBkZWxldGluZyBpdCdzIGNvbnRlbnQuXHJcbiAqL1xuXG52YXIgZGVsZXRlUmFuZ2UgPSAoZWRpdG9yLCByYW5nZSkgPT4ge1xuICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpKSB7XG4gICAgcmV0dXJuIHJhbmdlLmFuY2hvcjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgWywgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICB2YXIgcG9pbnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgYXQ6IHJhbmdlXG4gICAgfSk7XG4gICAgcmV0dXJuIHBvaW50UmVmLnVucmVmKCk7XG4gIH1cbn07XG5cbnZhciBtYXRjaFBhdGggPSAoZWRpdG9yLCBwYXRoKSA9PiB7XG4gIHZhciBbbm9kZV0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xuICByZXR1cm4gbiA9PiBuID09PSBub2RlO1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ3KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDcodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ3KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkNyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbnZhciBTZWxlY3Rpb25UcmFuc2Zvcm1zID0ge1xuICAvKipcclxuICAgKiBDb2xsYXBzZSB0aGUgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBjb2xsYXBzZShlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGVkZ2UgPSAnYW5jaG9yJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBzZWxlY3Rpb25cbiAgICB9ID0gZWRpdG9yO1xuXG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdhbmNob3InKSB7XG4gICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHNlbGVjdGlvbi5hbmNob3IpO1xuICAgIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2ZvY3VzJykge1xuICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzZWxlY3Rpb24uZm9jdXMpO1xuICAgIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgdmFyIFtzdGFydF0gPSBSYW5nZS5lZGdlcyhzZWxlY3Rpb24pO1xuICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzdGFydCk7XG4gICAgfSBlbHNlIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhzZWxlY3Rpb24pO1xuICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBlbmQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBVbnNldCB0aGUgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBkZXNlbGVjdChlZGl0b3IpIHtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcblxuICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6ICdzZXRfc2VsZWN0aW9uJyxcbiAgICAgICAgcHJvcGVydGllczogc2VsZWN0aW9uLFxuICAgICAgICBuZXdQcm9wZXJ0aWVzOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogTW92ZSB0aGUgc2VsZWN0aW9uJ3MgcG9pbnQgZm9yd2FyZCBvciBiYWNrd2FyZC5cclxuICAgKi9cbiAgbW92ZShlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBlZGl0b3I7XG4gICAgdmFyIHtcbiAgICAgIGRpc3RhbmNlID0gMSxcbiAgICAgIHVuaXQgPSAnY2hhcmFjdGVyJyxcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBlZGdlID0gbnVsbFxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdmb2N1cycgOiAnYW5jaG9yJztcbiAgICB9XG5cbiAgICBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnYW5jaG9yJyA6ICdmb2N1cyc7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICB2YXIgb3B0cyA9IHtcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgdW5pdFxuICAgIH07XG4gICAgdmFyIHByb3BzID0ge307XG5cbiAgICBpZiAoZWRnZSA9PSBudWxsIHx8IGVkZ2UgPT09ICdhbmNob3InKSB7XG4gICAgICB2YXIgcG9pbnQgPSByZXZlcnNlID8gRWRpdG9yLmJlZm9yZShlZGl0b3IsIGFuY2hvciwgb3B0cykgOiBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBhbmNob3IsIG9wdHMpO1xuXG4gICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgcHJvcHMuYW5jaG9yID0gcG9pbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVkZ2UgPT0gbnVsbCB8fCBlZGdlID09PSAnZm9jdXMnKSB7XG4gICAgICB2YXIgX3BvaW50ID0gcmV2ZXJzZSA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBmb2N1cywgb3B0cykgOiBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBmb2N1cywgb3B0cyk7XG5cbiAgICAgIGlmIChfcG9pbnQpIHtcbiAgICAgICAgcHJvcHMuZm9jdXMgPSBfcG9pbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCBwcm9wcyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogU2V0IHRoZSBzZWxlY3Rpb24gdG8gYSBuZXcgdmFsdWUuXHJcbiAgICovXG4gIHNlbGVjdChlZGl0b3IsIHRhcmdldCkge1xuICAgIHZhciB7XG4gICAgICBzZWxlY3Rpb25cbiAgICB9ID0gZWRpdG9yO1xuICAgIHRhcmdldCA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHRhcmdldCk7XG5cbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHRhcmdldCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFSYW5nZS5pc1JhbmdlKHRhcmdldCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldoZW4gc2V0dGluZyB0aGUgc2VsZWN0aW9uIGFuZCB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgYG51bGxgIHlvdSBtdXN0IHByb3ZpZGUgYXQgbGVhc3QgYW4gYGFuY2hvcmAgYW5kIGBmb2N1c2AsIGJ1dCB5b3UgcGFzc2VkOiBcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkodGFyZ2V0KSkpO1xuICAgIH1cblxuICAgIGVkaXRvci5hcHBseSh7XG4gICAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgICBwcm9wZXJ0aWVzOiBzZWxlY3Rpb24sXG4gICAgICBuZXdQcm9wZXJ0aWVzOiB0YXJnZXRcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBTZXQgbmV3IHByb3BlcnRpZXMgb24gb25lIG9mIHRoZSBzZWxlY3Rpb24ncyBwb2ludHMuXHJcbiAgICovXG4gIHNldFBvaW50KGVkaXRvciwgcHJvcHMsIG9wdGlvbnMpIHtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICB2YXIge1xuICAgICAgZWRnZSA9ICdib3RoJ1xuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdmb2N1cycgOiAnYW5jaG9yJztcbiAgICB9XG5cbiAgICBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnYW5jaG9yJyA6ICdmb2N1cyc7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICB2YXIgcG9pbnQgPSBlZGdlID09PSAnYW5jaG9yJyA/IGFuY2hvciA6IGZvY3VzO1xuICAgIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwge1xuICAgICAgW2VkZ2UgPT09ICdhbmNob3InID8gJ2FuY2hvcicgOiAnZm9jdXMnXTogX29iamVjdFNwcmVhZCQ3KHt9LCBwb2ludCwge30sIHByb3BzKVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNldCBuZXcgcHJvcGVydGllcyBvbiB0aGUgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBzZXRTZWxlY3Rpb24oZWRpdG9yLCBwcm9wcykge1xuICAgIHZhciB7XG4gICAgICBzZWxlY3Rpb25cbiAgICB9ID0gZWRpdG9yO1xuICAgIHZhciBvbGRQcm9wcyA9IHt9O1xuICAgIHZhciBuZXdQcm9wcyA9IHt9O1xuXG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBrIGluIHByb3BzKSB7XG4gICAgICBpZiAoayA9PT0gJ2FuY2hvcicgJiYgcHJvcHMuYW5jaG9yICE9IG51bGwgJiYgIVBvaW50LmVxdWFscyhwcm9wcy5hbmNob3IsIHNlbGVjdGlvbi5hbmNob3IpIHx8IGsgPT09ICdmb2N1cycgJiYgcHJvcHMuZm9jdXMgIT0gbnVsbCAmJiAhUG9pbnQuZXF1YWxzKHByb3BzLmZvY3VzLCBzZWxlY3Rpb24uZm9jdXMpIHx8IGsgIT09ICdhbmNob3InICYmIGsgIT09ICdmb2N1cycgJiYgcHJvcHNba10gIT09IHNlbGVjdGlvbltrXSkge1xuICAgICAgICBvbGRQcm9wc1trXSA9IHNlbGVjdGlvbltrXTtcbiAgICAgICAgbmV3UHJvcHNba10gPSBwcm9wc1trXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmtleXMob2xkUHJvcHMpLmxlbmd0aCA+IDApIHtcbiAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6ICdzZXRfc2VsZWN0aW9uJyxcbiAgICAgICAgcHJvcGVydGllczogb2xkUHJvcHMsXG4gICAgICAgIG5ld1Byb3BlcnRpZXM6IG5ld1Byb3BzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxufTtcblxudmFyIFRleHRUcmFuc2Zvcm1zID0ge1xuICAvKipcclxuICAgKiBEZWxldGUgY29udGVudCBpbiB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBkZWxldGUoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICByZXZlcnNlID0gZmFsc2UsXG4gICAgICAgIHVuaXQgPSAnY2hhcmFjdGVyJyxcbiAgICAgICAgZGlzdGFuY2UgPSAxLFxuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgaGFuZ2luZyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSAmJiBSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICB9XG5cbiAgICAgIGlmIChQb2ludC5pc1BvaW50KGF0KSkge1xuICAgICAgICB2YXIgZnVydGhlc3RWb2lkID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgYXQsXG4gICAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghdm9pZHMgJiYgZnVydGhlc3RWb2lkKSB7XG4gICAgICAgICAgdmFyIFssIHZvaWRQYXRoXSA9IGZ1cnRoZXN0Vm9pZDtcbiAgICAgICAgICBhdCA9IHZvaWRQYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgICAgdW5pdCxcbiAgICAgICAgICAgIGRpc3RhbmNlXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gcmV2ZXJzZSA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBhdCwgb3B0cykgfHwgRWRpdG9yLnN0YXJ0KGVkaXRvciwgW10pIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgYXQsIG9wdHMpIHx8IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG4gICAgICAgICAgYXQgPSB7XG4gICAgICAgICAgICBhbmNob3I6IGF0LFxuICAgICAgICAgICAgZm9jdXM6IHRhcmdldFxuICAgICAgICAgIH07XG4gICAgICAgICAgaGFuZ2luZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0LFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWhhbmdpbmcpIHtcbiAgICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgdmFyIHN0YXJ0QmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICAgIGF0OiBzdGFydCxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIGVuZEJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICBtYXRjaDogbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuICAgICAgICBhdDogZW5kLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgaXNBY3Jvc3NCbG9ja3MgPSBzdGFydEJsb2NrICYmIGVuZEJsb2NrICYmICFQYXRoLmVxdWFscyhzdGFydEJsb2NrWzFdLCBlbmRCbG9ja1sxXSk7XG4gICAgICB2YXIgaXNTaW5nbGVUZXh0ID0gUGF0aC5lcXVhbHMoc3RhcnQucGF0aCwgZW5kLnBhdGgpO1xuICAgICAgdmFyIHN0YXJ0Vm9pZCA9IHZvaWRzID8gbnVsbCA6IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICBhdDogc3RhcnQsXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgICAgfSk7XG4gICAgICB2YXIgZW5kVm9pZCA9IHZvaWRzID8gbnVsbCA6IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICBhdDogZW5kLFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICAgIH0pOyAvLyBJZiB0aGUgc3RhcnQgb3IgZW5kIHBvaW50cyBhcmUgaW5zaWRlIGFuIGlubGluZSB2b2lkLCBudWRnZSB0aGVtIG91dC5cblxuICAgICAgaWYgKHN0YXJ0Vm9pZCkge1xuICAgICAgICB2YXIgYmVmb3JlID0gRWRpdG9yLmJlZm9yZShlZGl0b3IsIHN0YXJ0KTtcblxuICAgICAgICBpZiAoYmVmb3JlICYmIHN0YXJ0QmxvY2sgJiYgUGF0aC5pc0FuY2VzdG9yKHN0YXJ0QmxvY2tbMV0sIGJlZm9yZS5wYXRoKSkge1xuICAgICAgICAgIHN0YXJ0ID0gYmVmb3JlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmRWb2lkKSB7XG4gICAgICAgIHZhciBhZnRlciA9IEVkaXRvci5hZnRlcihlZGl0b3IsIGVuZCk7XG5cbiAgICAgICAgaWYgKGFmdGVyICYmIGVuZEJsb2NrICYmIFBhdGguaXNBbmNlc3RvcihlbmRCbG9ja1sxXSwgYWZ0ZXIucGF0aCkpIHtcbiAgICAgICAgICBlbmQgPSBhZnRlcjtcbiAgICAgICAgfVxuICAgICAgfSAvLyBHZXQgdGhlIGhpZ2hlc3Qgbm9kZXMgdGhhdCBhcmUgY29tcGxldGVseSBpbnNpZGUgdGhlIHJhbmdlLCBhcyB3ZWxsIGFzXG4gICAgICAvLyB0aGUgc3RhcnQgYW5kIGVuZCBub2Rlcy5cblxuXG4gICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgdmFyIGxhc3RQYXRoO1xuXG4gICAgICBmb3IgKHZhciBlbnRyeSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICB2b2lkc1xuICAgICAgfSkpIHtcbiAgICAgICAgdmFyIFtub2RlLCBwYXRoXSA9IGVudHJ5O1xuXG4gICAgICAgIGlmIChsYXN0UGF0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgbGFzdFBhdGgpID09PSAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSB8fCAhUGF0aC5pc0NvbW1vbihwYXRoLCBzdGFydC5wYXRoKSAmJiAhUGF0aC5pc0NvbW1vbihwYXRoLCBlbmQucGF0aCkpIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goZW50cnkpO1xuICAgICAgICAgIGxhc3RQYXRoID0gcGF0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKG1hdGNoZXMsIChfcmVmKSA9PiB7XG4gICAgICAgIHZhciBbLCBwXSA9IF9yZWY7XG4gICAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgICAgfSk7XG4gICAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBzdGFydCk7XG4gICAgICB2YXIgZW5kUmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcblxuICAgICAgaWYgKCFpc1NpbmdsZVRleHQgJiYgIXN0YXJ0Vm9pZCkge1xuICAgICAgICB2YXIgX3BvaW50ID0gc3RhcnRSZWYuY3VycmVudDtcbiAgICAgICAgdmFyIFtfbm9kZV0gPSBFZGl0b3IubGVhZihlZGl0b3IsIF9wb2ludCk7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGhcbiAgICAgICAgfSA9IF9wb2ludDtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBvZmZzZXRcbiAgICAgICAgfSA9IHN0YXJ0O1xuXG4gICAgICAgIHZhciB0ZXh0ID0gX25vZGUudGV4dC5zbGljZShvZmZzZXQpO1xuXG4gICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogJ3JlbW92ZV90ZXh0JyxcbiAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgdGV4dFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgcGF0aFJlZiBvZiBwYXRoUmVmcykge1xuICAgICAgICB2YXIgX3BhdGgyID0gcGF0aFJlZi51bnJlZigpO1xuXG4gICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IF9wYXRoMixcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFlbmRWb2lkKSB7XG4gICAgICAgIHZhciBfcG9pbnQyID0gZW5kUmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciBbX25vZGUyXSA9IEVkaXRvci5sZWFmKGVkaXRvciwgX3BvaW50Mik7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGgzXG4gICAgICAgIH0gPSBfcG9pbnQyO1xuXG4gICAgICAgIHZhciBfb2Zmc2V0ID0gaXNTaW5nbGVUZXh0ID8gc3RhcnQub2Zmc2V0IDogMDtcblxuICAgICAgICB2YXIgX3RleHQgPSBfbm9kZTIudGV4dC5zbGljZShfb2Zmc2V0LCBlbmQub2Zmc2V0KTtcblxuICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgIHR5cGU6ICdyZW1vdmVfdGV4dCcsXG4gICAgICAgICAgcGF0aDogX3BhdGgzLFxuICAgICAgICAgIG9mZnNldDogX29mZnNldCxcbiAgICAgICAgICB0ZXh0OiBfdGV4dFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1NpbmdsZVRleHQgJiYgaXNBY3Jvc3NCbG9ja3MgJiYgZW5kUmVmLmN1cnJlbnQgJiYgc3RhcnRSZWYuY3VycmVudCkge1xuICAgICAgICBUcmFuc2Zvcm1zLm1lcmdlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVuZFJlZi5jdXJyZW50LFxuICAgICAgICAgIGhhbmdpbmc6IHRydWUsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludCA9IGVuZFJlZi51bnJlZigpIHx8IHN0YXJ0UmVmLnVucmVmKCk7XG5cbiAgICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwgJiYgcG9pbnQpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBwb2ludCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgZnJhZ21lbnQgYXQgYSBzcGVjaWZpYyBsb2NhdGlvbiBpbiB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBpbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBoYW5naW5nID0gZmFsc2UsXG4gICAgICAgIHZvaWRzID0gZmFsc2VcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKCFmcmFnbWVudC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgaWYgKCFoYW5naW5nKSB7XG4gICAgICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG5cbiAgICAgICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGVuZFxuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXQgPSBwb2ludFJlZi51bnJlZigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci5zdGFydChlZGl0b3IsIGF0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgYXRcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gSWYgdGhlIGluc2VydCBwb2ludCBpcyBhdCB0aGUgZWRnZSBvZiBhbiBpbmxpbmUgbm9kZSwgbW92ZSBpdCBvdXRzaWRlXG4gICAgICAvLyBpbnN0ZWFkIHNpbmNlIGl0IHdpbGwgbmVlZCB0byBiZSBzcGxpdCBvdGhlcndpc2UuXG5cblxuICAgICAgdmFyIGlubGluZUVsZW1lbnRNYXRjaCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcblxuICAgICAgaWYgKGlubGluZUVsZW1lbnRNYXRjaCkge1xuICAgICAgICB2YXIgWywgX2lubGluZVBhdGhdID0gaW5saW5lRWxlbWVudE1hdGNoO1xuXG4gICAgICAgIGlmIChFZGl0b3IuaXNFbmQoZWRpdG9yLCBhdCwgX2lubGluZVBhdGgpKSB7XG4gICAgICAgICAgdmFyIGFmdGVyID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgX2lubGluZVBhdGgpO1xuICAgICAgICAgIGF0ID0gYWZ0ZXI7XG4gICAgICAgIH0gZWxzZSBpZiAoRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBhdCwgX2lubGluZVBhdGgpKSB7XG4gICAgICAgICAgdmFyIGJlZm9yZSA9IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBfaW5saW5lUGF0aCk7XG4gICAgICAgICAgYXQgPSBiZWZvcmU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGJsb2NrTWF0Y2ggPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICAgIGF0LFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgWywgYmxvY2tQYXRoXSA9IGJsb2NrTWF0Y2g7XG4gICAgICB2YXIgaXNCbG9ja1N0YXJ0ID0gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBhdCwgYmxvY2tQYXRoKTtcbiAgICAgIHZhciBpc0Jsb2NrRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIGJsb2NrUGF0aCk7XG4gICAgICB2YXIgbWVyZ2VTdGFydCA9ICFpc0Jsb2NrU3RhcnQgfHwgaXNCbG9ja1N0YXJ0ICYmIGlzQmxvY2tFbmQ7XG4gICAgICB2YXIgbWVyZ2VFbmQgPSAhaXNCbG9ja0VuZDtcbiAgICAgIHZhciBbLCBmaXJzdFBhdGhdID0gTm9kZS5maXJzdCh7XG4gICAgICAgIGNoaWxkcmVuOiBmcmFnbWVudFxuICAgICAgfSwgW10pO1xuICAgICAgdmFyIFssIGxhc3RQYXRoXSA9IE5vZGUubGFzdCh7XG4gICAgICAgIGNoaWxkcmVuOiBmcmFnbWVudFxuICAgICAgfSwgW10pO1xuICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcblxuICAgICAgdmFyIG1hdGNoZXIgPSAoX3JlZjIpID0+IHtcbiAgICAgICAgdmFyIFtuLCBwXSA9IF9yZWYyO1xuXG4gICAgICAgIGlmIChtZXJnZVN0YXJ0ICYmIFBhdGguaXNBbmNlc3RvcihwLCBmaXJzdFBhdGgpICYmIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmICFlZGl0b3IuaXNWb2lkKG4pICYmICFlZGl0b3IuaXNJbmxpbmUobikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWVyZ2VFbmQgJiYgUGF0aC5pc0FuY2VzdG9yKHAsIGxhc3RQYXRoKSAmJiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiAhZWRpdG9yLmlzVm9pZChuKSAmJiAhZWRpdG9yLmlzSW5saW5lKG4pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBlbnRyeSBvZiBOb2RlLm5vZGVzKHtcbiAgICAgICAgY2hpbGRyZW46IGZyYWdtZW50XG4gICAgICB9LCB7XG4gICAgICAgIHBhc3M6IG1hdGNoZXJcbiAgICAgIH0pKSB7XG4gICAgICAgIGlmIChlbnRyeVsxXS5sZW5ndGggPiAwICYmIG1hdGNoZXIoZW50cnkpKSB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnRzID0gW107XG4gICAgICB2YXIgbWlkZGxlcyA9IFtdO1xuICAgICAgdmFyIGVuZHMgPSBbXTtcbiAgICAgIHZhciBzdGFydGluZyA9IHRydWU7XG4gICAgICB2YXIgaGFzQmxvY2tzID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIFtub2RlXSBvZiBtYXRjaGVzKSB7XG4gICAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiAhZWRpdG9yLmlzSW5saW5lKG5vZGUpKSB7XG4gICAgICAgICAgc3RhcnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBoYXNCbG9ja3MgPSB0cnVlO1xuICAgICAgICAgIG1pZGRsZXMucHVzaChub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydGluZykge1xuICAgICAgICAgIHN0YXJ0cy5wdXNoKG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVuZHMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgW2lubGluZU1hdGNoXSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoOiBuID0+IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBbLCBpbmxpbmVQYXRoXSA9IGlubGluZU1hdGNoO1xuICAgICAgdmFyIGlzSW5saW5lU3RhcnQgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBpbmxpbmVQYXRoKTtcbiAgICAgIHZhciBpc0lubGluZUVuZCA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBpbmxpbmVQYXRoKTtcbiAgICAgIHZhciBtaWRkbGVSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsIGlzQmxvY2tFbmQgPyBQYXRoLm5leHQoYmxvY2tQYXRoKSA6IGJsb2NrUGF0aCk7XG4gICAgICB2YXIgZW5kUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBpc0lubGluZUVuZCA/IFBhdGgubmV4dChpbmxpbmVQYXRoKSA6IGlubGluZVBhdGgpO1xuICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2g6IG4gPT4gaGFzQmxvY2tzID8gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSA6IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgICBtb2RlOiBoYXNCbG9ja3MgPyAnbG93ZXN0JyA6ICdoaWdoZXN0JyxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIHN0YXJ0UmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCAhaXNJbmxpbmVTdGFydCB8fCBpc0lubGluZVN0YXJ0ICYmIGlzSW5saW5lRW5kID8gUGF0aC5uZXh0KGlubGluZVBhdGgpIDogaW5saW5lUGF0aCk7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgc3RhcnRzLCB7XG4gICAgICAgIGF0OiBzdGFydFJlZi5jdXJyZW50LFxuICAgICAgICBtYXRjaDogbiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbWlkZGxlcywge1xuICAgICAgICBhdDogbWlkZGxlUmVmLmN1cnJlbnQsXG4gICAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICAgIG1vZGU6ICdsb3dlc3QnLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgZW5kcywge1xuICAgICAgICBhdDogZW5kUmVmLmN1cnJlbnQsXG4gICAgICAgIG1hdGNoOiBuID0+IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFvcHRpb25zLmF0KSB7XG4gICAgICAgIHZhciBwYXRoO1xuXG4gICAgICAgIGlmIChlbmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBwYXRoID0gUGF0aC5wcmV2aW91cyhlbmRSZWYuY3VycmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWlkZGxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcGF0aCA9IFBhdGgucHJldmlvdXMobWlkZGxlUmVmLmN1cnJlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGggPSBQYXRoLnByZXZpb3VzKHN0YXJ0UmVmLmN1cnJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9lbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgcGF0aCk7XG5cbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBfZW5kKTtcbiAgICAgIH1cblxuICAgICAgc3RhcnRSZWYudW5yZWYoKTtcbiAgICAgIG1pZGRsZVJlZi51bnJlZigpO1xuICAgICAgZW5kUmVmLnVucmVmKCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgc3RyaW5nIG9mIHRleHQgaW4gdGhlIEVkaXRvci5cclxuICAgKi9cbiAgaW5zZXJ0VGV4dChlZGl0b3IsIHRleHQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHZvaWRzID0gZmFsc2VcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgYXQgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGVuZCA9IFJhbmdlLmVuZChhdCk7XG5cbiAgICAgICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGVuZFxuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0LFxuICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhdCA9IHBvaW50UmVmLnVucmVmKCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB7XG4gICAgICAgICAgICBhbmNob3I6IGF0LFxuICAgICAgICAgICAgZm9jdXM6IGF0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgYXRcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgb2Zmc2V0XG4gICAgICB9ID0gYXQ7XG4gICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiAnaW5zZXJ0X3RleHQnLFxuICAgICAgICBwYXRoLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIHRleHRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkOChvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ4KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkOChPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDgoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG52YXIgVHJhbnNmb3JtcyA9IF9vYmplY3RTcHJlYWQkOCh7fSwgR2VuZXJhbFRyYW5zZm9ybXMsIHt9LCBOb2RlVHJhbnNmb3Jtcywge30sIFNlbGVjdGlvblRyYW5zZm9ybXMsIHt9LCBUZXh0VHJhbnNmb3Jtcyk7XG5cbmZ1bmN0aW9uIG93bktleXMkOShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ5KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkOShPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDkoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG4vKipcclxuICogQ3JlYXRlIGEgbmV3IFNsYXRlIGBFZGl0b3JgIG9iamVjdC5cclxuICovXG5cbnZhciBjcmVhdGVFZGl0b3IgPSAoKSA9PiB7XG4gIHZhciBlZGl0b3IgPSB7XG4gICAgY2hpbGRyZW46IFtdLFxuICAgIG9wZXJhdGlvbnM6IFtdLFxuICAgIHNlbGVjdGlvbjogbnVsbCxcbiAgICBtYXJrczogbnVsbCxcbiAgICBpc0lubGluZTogKCkgPT4gZmFsc2UsXG4gICAgaXNWb2lkOiAoKSA9PiBmYWxzZSxcbiAgICBvbkNoYW5nZTogKCkgPT4ge30sXG4gICAgYXBwbHk6IG9wID0+IHtcbiAgICAgIGZvciAodmFyIHJlZiBvZiBFZGl0b3IucGF0aFJlZnMoZWRpdG9yKSkge1xuICAgICAgICBQYXRoUmVmLnRyYW5zZm9ybShyZWYsIG9wKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX3JlZiBvZiBFZGl0b3IucG9pbnRSZWZzKGVkaXRvcikpIHtcbiAgICAgICAgUG9pbnRSZWYudHJhbnNmb3JtKF9yZWYsIG9wKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX3JlZjIgb2YgRWRpdG9yLnJhbmdlUmVmcyhlZGl0b3IpKSB7XG4gICAgICAgIFJhbmdlUmVmLnRyYW5zZm9ybShfcmVmMiwgb3ApO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgdmFyIGRpcnR5UGF0aHMgPSBbXTtcblxuICAgICAgdmFyIGFkZCA9IHBhdGggPT4ge1xuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgIHZhciBrZXkgPSBwYXRoLmpvaW4oJywnKTtcblxuICAgICAgICAgIGlmICghc2V0LmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBzZXQuYWRkKGtleSk7XG4gICAgICAgICAgICBkaXJ0eVBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgb2xkRGlydHlQYXRocyA9IERJUlRZX1BBVEhTLmdldChlZGl0b3IpIHx8IFtdO1xuICAgICAgdmFyIG5ld0RpcnR5UGF0aHMgPSBnZXREaXJ0eVBhdGhzKG9wKTtcblxuICAgICAgZm9yICh2YXIgcGF0aCBvZiBvbGREaXJ0eVBhdGhzKSB7XG4gICAgICAgIHZhciBuZXdQYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3ApO1xuICAgICAgICBhZGQobmV3UGF0aCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9wYXRoIG9mIG5ld0RpcnR5UGF0aHMpIHtcbiAgICAgICAgYWRkKF9wYXRoKTtcbiAgICAgIH1cblxuICAgICAgRElSVFlfUEFUSFMuc2V0KGVkaXRvciwgZGlydHlQYXRocyk7XG4gICAgICBFZGl0b3IudHJhbnNmb3JtKGVkaXRvciwgb3ApO1xuICAgICAgZWRpdG9yLm9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgICBFZGl0b3Iubm9ybWFsaXplKGVkaXRvcik7IC8vIENsZWFyIGFueSBmb3JtYXRzIGFwcGxpZWQgdG8gdGhlIGN1cnNvciBpZiB0aGUgc2VsZWN0aW9uIGNoYW5nZXMuXG5cbiAgICAgIGlmIChvcC50eXBlID09PSAnc2V0X3NlbGVjdGlvbicpIHtcbiAgICAgICAgZWRpdG9yLm1hcmtzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFGTFVTSElORy5nZXQoZWRpdG9yKSkge1xuICAgICAgICBGTFVTSElORy5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgRkxVU0hJTkcuc2V0KGVkaXRvciwgZmFsc2UpO1xuICAgICAgICAgIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgIGVkaXRvci5vcGVyYXRpb25zID0gW107XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgYWRkTWFyazogKGtleSwgdmFsdWUpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcblxuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICBpZiAoUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIFtrZXldOiB2YWx1ZVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICAgICAgICAgIHNwbGl0OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1hcmtzID0gX29iamVjdFNwcmVhZCQ5KHt9LCBFZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fSwge1xuICAgICAgICAgICAgW2tleV06IHZhbHVlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBlZGl0b3IubWFya3MgPSBtYXJrcztcbiAgICAgICAgICBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGVsZXRlQmFja3dhcmQ6IHVuaXQgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9ID0gZWRpdG9yO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgdW5pdCxcbiAgICAgICAgICByZXZlcnNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVsZXRlRm9yd2FyZDogdW5pdCA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0gPSBlZGl0b3I7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICB1bml0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVsZXRlRnJhZ21lbnQ6ICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcblxuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldEZyYWdtZW50OiAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0gPSBlZGl0b3I7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIE5vZGUuZnJhZ21lbnQoZWRpdG9yLCBzZWxlY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICBpbnNlcnRCcmVhazogKCkgPT4ge1xuICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICBhbHdheXM6IHRydWVcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgaW5zZXJ0RnJhZ21lbnQ6IGZyYWdtZW50ID0+IHtcbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBmcmFnbWVudCk7XG4gICAgfSxcbiAgICBpbnNlcnROb2RlOiBub2RlID0+IHtcbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBub2RlKTtcbiAgICB9LFxuICAgIGluc2VydFRleHQ6IHRleHQgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICBtYXJrc1xuICAgICAgfSA9IGVkaXRvcjtcblxuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAvLyBJZiB0aGUgY3Vyc29yIGlzIGF0IHRoZSBlbmQgb2YgYW4gaW5saW5lLCBtb3ZlIGl0IG91dHNpZGUgb2ZcbiAgICAgICAgLy8gdGhlIGlubGluZSBiZWZvcmUgaW5zZXJ0aW5nXG4gICAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgdmFyIGlubGluZSA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoaW5saW5lKSB7XG4gICAgICAgICAgICB2YXIgWywgaW5saW5lUGF0aF0gPSBpbmxpbmU7XG5cbiAgICAgICAgICAgIGlmIChFZGl0b3IuaXNFbmQoZWRpdG9yLCBzZWxlY3Rpb24uYW5jaG9yLCBpbmxpbmVQYXRoKSkge1xuICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBpbmxpbmVQYXRoKTtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgYW5jaG9yOiBwb2ludCxcbiAgICAgICAgICAgICAgICBmb2N1czogcG9pbnRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hcmtzKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBfb2JqZWN0U3ByZWFkJDkoe1xuICAgICAgICAgICAgdGV4dFxuICAgICAgICAgIH0sIG1hcmtzKTtcblxuICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydFRleHQoZWRpdG9yLCB0ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVkaXRvci5tYXJrcyA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBub3JtYWxpemVOb2RlOiBlbnRyeSA9PiB7XG4gICAgICB2YXIgW25vZGUsIHBhdGhdID0gZW50cnk7IC8vIFRoZXJlIGFyZSBubyBjb3JlIG5vcm1hbGl6YXRpb25zIGZvciB0ZXh0IG5vZGVzLlxuXG4gICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBFbnN1cmUgdGhhdCBibG9jayBhbmQgaW5saW5lIG5vZGVzIGhhdmUgYXQgbGVhc3Qgb25lIHRleHQgY2hpbGQuXG5cblxuICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHtcbiAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICB9O1xuICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgY2hpbGQsIHtcbiAgICAgICAgICBhdDogcGF0aC5jb25jYXQoMCksXG4gICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGhhdmUgYmxvY2sgb3IgaW5saW5lIGNoaWxkcmVuLlxuXG5cbiAgICAgIHZhciBzaG91bGRIYXZlSW5saW5lcyA9IEVkaXRvci5pc0VkaXRvcihub2RlKSA/IGZhbHNlIDogRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgKGVkaXRvci5pc0lubGluZShub2RlKSB8fCBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBUZXh0LmlzVGV4dChub2RlLmNoaWxkcmVuWzBdKSB8fCBlZGl0b3IuaXNJbmxpbmUobm9kZS5jaGlsZHJlblswXSkpOyAvLyBTaW5jZSB3ZSdsbCBiZSBhcHBseWluZyBvcGVyYXRpb25zIHdoaWxlIGl0ZXJhdGluZywga2VlcCB0cmFjayBvZiBhblxuICAgICAgLy8gaW5kZXggdGhhdCBhY2NvdW50cyBmb3IgYW55IGFkZGVkL3JlbW92ZWQgbm9kZXMuXG5cbiAgICAgIHZhciBuID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrLCBuKyspIHtcbiAgICAgICAgdmFyIF9jaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIHZhciBwcmV2ID0gbm9kZS5jaGlsZHJlbltpIC0gMV07XG4gICAgICAgIHZhciBpc0xhc3QgPSBpID09PSBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBpc0lubGluZU9yVGV4dCA9IFRleHQuaXNUZXh0KF9jaGlsZCkgfHwgRWxlbWVudC5pc0VsZW1lbnQoX2NoaWxkKSAmJiBlZGl0b3IuaXNJbmxpbmUoX2NoaWxkKTsgLy8gT25seSBhbGxvdyBibG9jayBub2RlcyBpbiB0aGUgdG9wLWxldmVsIGNoaWxkcmVuIGFuZCBwYXJlbnQgYmxvY2tzXG4gICAgICAgIC8vIHRoYXQgb25seSBjb250YWluIGJsb2NrIG5vZGVzLiBTaW1pbGFybHksIG9ubHkgYWxsb3cgaW5saW5lIG5vZGVzIGluXG4gICAgICAgIC8vIG90aGVyIGlubGluZSBub2Rlcywgb3IgcGFyZW50IGJsb2NrcyB0aGF0IG9ubHkgY29udGFpbiBpbmxpbmVzIGFuZFxuICAgICAgICAvLyB0ZXh0LlxuXG4gICAgICAgIGlmIChpc0lubGluZU9yVGV4dCAhPT0gc2hvdWxkSGF2ZUlubGluZXMpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuLS07XG4gICAgICAgIH0gZWxzZSBpZiAoRWxlbWVudC5pc0VsZW1lbnQoX2NoaWxkKSkge1xuICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IGlubGluZSBub2RlcyBhcmUgc3Vycm91bmRlZCBieSB0ZXh0IG5vZGVzLlxuICAgICAgICAgIGlmIChlZGl0b3IuaXNJbmxpbmUoX2NoaWxkKSkge1xuICAgICAgICAgICAgaWYgKHByZXYgPT0gbnVsbCB8fCAhVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgICAgICAgdmFyIG5ld0NoaWxkID0ge1xuICAgICAgICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBuZXdDaGlsZCwge1xuICAgICAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xhc3QpIHtcbiAgICAgICAgICAgICAgdmFyIF9uZXdDaGlsZCA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgX25ld0NoaWxkLCB7XG4gICAgICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4gKyAxKSxcbiAgICAgICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBNZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzIHRoYXQgYXJlIGVtcHR5IG9yIG1hdGNoLlxuICAgICAgICAgIGlmIChwcmV2ICE9IG51bGwgJiYgVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgICAgIGlmIChUZXh0LmVxdWFscyhfY2hpbGQsIHByZXYsIHtcbiAgICAgICAgICAgICAgbG9vc2U6IHRydWVcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMubWVyZ2VOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldi50ZXh0ID09PSAnJykge1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuIC0gMSksXG4gICAgICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNMYXN0ICYmIF9jaGlsZC50ZXh0ID09PSAnJykge1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlTWFyazoga2V5ID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcblxuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICBpZiAoUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy51bnNldE5vZGVzKGVkaXRvciwga2V5LCB7XG4gICAgICAgICAgICBtYXRjaDogVGV4dC5pc1RleHQsXG4gICAgICAgICAgICBzcGxpdDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBtYXJrcyA9IF9vYmplY3RTcHJlYWQkOSh7fSwgRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge30pO1xuXG4gICAgICAgICAgZGVsZXRlIG1hcmtzW2tleV07XG4gICAgICAgICAgZWRpdG9yLm1hcmtzID0gbWFya3M7XG4gICAgICAgICAgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBlZGl0b3I7XG59O1xuLyoqXHJcbiAqIEdldCB0aGUgXCJkaXJ0eVwiIHBhdGhzIGdlbmVyYXRlZCBmcm9tIGFuIG9wZXJhdGlvbi5cclxuICovXG5cbnZhciBnZXREaXJ0eVBhdGhzID0gb3AgPT4ge1xuICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoXG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgcmV0dXJuIFBhdGgubGV2ZWxzKHBhdGgpO1xuICAgICAgfVxuXG4gICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgcGF0aDogX3BhdGgyXG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgdmFyIGxldmVscyA9IFBhdGgubGV2ZWxzKF9wYXRoMik7XG4gICAgICAgIHZhciBkZXNjZW5kYW50cyA9IFRleHQuaXNUZXh0KG5vZGUpID8gW10gOiBBcnJheS5mcm9tKE5vZGUubm9kZXMobm9kZSksIChfcmVmMykgPT4ge1xuICAgICAgICAgIHZhciBbLCBwXSA9IF9yZWYzO1xuICAgICAgICAgIHJldHVybiBfcGF0aDIuY29uY2F0KHApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFsuLi5sZXZlbHMsIC4uLmRlc2NlbmRhbnRzXTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoM1xuICAgICAgICB9ID0gb3A7XG4gICAgICAgIHZhciBhbmNlc3RvcnMgPSBQYXRoLmFuY2VzdG9ycyhfcGF0aDMpO1xuICAgICAgICB2YXIgcHJldmlvdXNQYXRoID0gUGF0aC5wcmV2aW91cyhfcGF0aDMpO1xuICAgICAgICByZXR1cm4gWy4uLmFuY2VzdG9ycywgcHJldmlvdXNQYXRoXTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGg0LFxuICAgICAgICAgIG5ld1BhdGhcbiAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgIGlmIChQYXRoLmVxdWFscyhfcGF0aDQsIG5ld1BhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9sZEFuY2VzdG9ycyA9IFtdO1xuICAgICAgICB2YXIgbmV3QW5jZXN0b3JzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgYW5jZXN0b3Igb2YgUGF0aC5hbmNlc3RvcnMoX3BhdGg0KSkge1xuICAgICAgICAgIHZhciBwID0gUGF0aC50cmFuc2Zvcm0oYW5jZXN0b3IsIG9wKTtcbiAgICAgICAgICBvbGRBbmNlc3RvcnMucHVzaChwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9hbmNlc3RvciBvZiBQYXRoLmFuY2VzdG9ycyhuZXdQYXRoKSkge1xuICAgICAgICAgIHZhciBfcCA9IFBhdGgudHJhbnNmb3JtKF9hbmNlc3Rvciwgb3ApO1xuXG4gICAgICAgICAgbmV3QW5jZXN0b3JzLnB1c2goX3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFsuLi5vbGRBbmNlc3RvcnMsIC4uLm5ld0FuY2VzdG9yc107XG4gICAgICB9XG5cbiAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGg1XG4gICAgICAgIH0gPSBvcDtcblxuICAgICAgICB2YXIgX2FuY2VzdG9ycyA9IFBhdGguYW5jZXN0b3JzKF9wYXRoNSk7XG5cbiAgICAgICAgcmV0dXJuIFsuLi5fYW5jZXN0b3JzXTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoNlxuICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgdmFyIF9sZXZlbHMgPSBQYXRoLmxldmVscyhfcGF0aDYpO1xuXG4gICAgICAgIHZhciBuZXh0UGF0aCA9IFBhdGgubmV4dChfcGF0aDYpO1xuICAgICAgICByZXR1cm4gWy4uLl9sZXZlbHMsIG5leHRQYXRoXTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IHsgRWRpdG9yLCBFbGVtZW50LCBMb2NhdGlvbiwgTm9kZSwgT3BlcmF0aW9uLCBQYXRoLCBQYXRoUmVmLCBQb2ludCwgUG9pbnRSZWYsIFJhbmdlLCBSYW5nZVJlZiwgU3BhbiwgVGV4dCwgVHJhbnNmb3JtcywgY3JlYXRlRWRpdG9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiIsIi8qIVxuICogaXMtcGxhaW4tb2JqZWN0IDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1wbGFpbi1vYmplY3Q+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBpc09iamVjdCBmcm9tICdpc29iamVjdCc7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0T2JqZWN0KG8pIHtcbiAgcmV0dXJuIGlzT2JqZWN0KG8pID09PSB0cnVlXG4gICAgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvKSB7XG4gIHZhciBjdG9yLHByb3Q7XG5cbiAgaWYgKGlzT2JqZWN0T2JqZWN0KG8pID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIGhhcyBtb2RpZmllZCBjb25zdHJ1Y3RvclxuICBjdG9yID0gby5jb25zdHJ1Y3RvcjtcbiAgaWYgKHR5cGVvZiBjdG9yICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgaGFzIG1vZGlmaWVkIHByb3RvdHlwZVxuICBwcm90ID0gY3Rvci5wcm90b3R5cGU7XG4gIGlmIChpc09iamVjdE9iamVjdChwcm90KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiBjb25zdHJ1Y3RvciBkb2VzIG5vdCBoYXZlIGFuIE9iamVjdC1zcGVjaWZpYyBtZXRob2RcbiAgaWYgKHByb3QuaGFzT3duUHJvcGVydHkoJ2lzUHJvdG90eXBlT2YnKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBNb3N0IGxpa2VseSBhIHBsYWluIE9iamVjdFxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvKiFcbiAqIGlzb2JqZWN0IDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pc29iamVjdD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiBBcnJheS5pc0FycmF5KHZhbCkgPT09IGZhbHNlO1xufTtcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IHN2Z0ljb25zID0ge1xuICBmb3JtYXRfYm9sZDpcbiAgICAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgd2lkdGg9XCIyNFwiPjxwYXRoIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+PHBhdGggZD1cIk0xNS42IDEwLjc5Yy45Ny0uNjcgMS42NS0xLjc3IDEuNjUtMi43OSAwLTIuMjYtMS43NS00LTQtNEg3djE0aDcuMDRjMi4wOSAwIDMuNzEtMS43IDMuNzEtMy43OSAwLTEuNTItLjg2LTIuODItMi4xNS0zLjQyek0xMCA2LjVoM2MuODMgMCAxLjUuNjcgMS41IDEuNXMtLjY3IDEuNS0xLjUgMS41aC0zdi0zem0zLjUgOUgxMHYtM2gzLjVjLjgzIDAgMS41LjY3IDEuNSAxLjVzLS42NyAxLjUtMS41IDEuNXpcIi8+PC9zdmc+JyxcbiAgZm9ybWF0X2l0YWxpYzpcbiAgICAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgd2lkdGg9XCIyNFwiPjxwYXRoIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+PHBhdGggZD1cIk0xMCA0djNoMi4yMWwtMy40MiA4SDZ2M2g4di0zaC0yLjIxbDMuNDItOEgxOFY0elwiLz48L3N2Zz4nLFxuICBmb3JtYXRfdW5kZXJsaW5lZDpcbiAgICAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgd2lkdGg9XCIyNFwiPjxwYXRoIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+PHBhdGggZD1cIk0xMiAxN2MzLjMxIDAgNi0yLjY5IDYtNlYzaC0yLjV2OGMwIDEuOTMtMS41NyAzLjUtMy41IDMuNVM4LjUgMTIuOTMgOC41IDExVjNINnY4YzAgMy4zMSAyLjY5IDYgNiA2em0tNyAydjJoMTR2LTJINXpcIi8+PC9zdmc+JyxcbiAgZm9ybWF0X2xpc3RfYnVsbGV0ZWQ6XG4gICAgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHdpZHRoPVwiMjRcIj48cGF0aCBkPVwiTTAgMGgyNHYyNEgwVjB6XCIgZmlsbD1cIm5vbmVcIi8+PHBhdGggZD1cIk00IDEwLjVjLS44MyAwLTEuNS42Ny0xLjUgMS41cy42NyAxLjUgMS41IDEuNSAxLjUtLjY3IDEuNS0xLjUtLjY3LTEuNS0xLjUtMS41em0wLTZjLS44MyAwLTEuNS42Ny0xLjUgMS41UzMuMTcgNy41IDQgNy41IDUuNSA2LjgzIDUuNSA2IDQuODMgNC41IDQgNC41em0wIDEyYy0uODMgMC0xLjUuNjgtMS41IDEuNXMuNjggMS41IDEuNSAxLjUgMS41LS42OCAxLjUtMS41LS42Ny0xLjUtMS41LTEuNXpNNyAxOWgxNHYtMkg3djJ6bTAtNmgxNHYtMkg3djJ6bTAtOHYyaDE0VjVIN3pcIi8+PC9zdmc+JyxcbiAgZm9ybWF0X2xpc3RfbnVtYmVyZWQ6XG4gICAgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHdpZHRoPVwiMjRcIj48cGF0aCBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPjxwYXRoIGQ9XCJNMiAxN2gydi41SDN2MWgxdi41SDJ2MWgzdi00SDJ2MXptMS05aDFWNEgydjFoMXYzem0tMSAzaDEuOEwyIDEzLjF2LjloM3YtMUgzLjJMNSAxMC45VjEwSDJ2MXptNS02djJoMTRWNUg3em0wIDE0aDE0di0ySDd2MnptMC02aDE0di0ySDd2MnpcIi8+PC9zdmc+JyxcbiAgbG9va3Nfb25lOlxuICAgICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiB3aWR0aD1cIjI0XCI+PHBhdGggZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz48cGF0aCBkPVwiTTE5IDNINWMtMS4xIDAtMiAuOS0yIDJ2MTRjMCAxLjEuOSAyIDIgMmgxNGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yem0tNSAxNGgtMlY5aC0yVjdoNHYxMHpcIi8+PC9zdmc+Jyxcbn07XG5cbmNvbnN0IHN0eWxlcyA9IHtcbiAgaWNvbjoge1xuICAgIG9wYWNpdHk6IDAuNyxcbiAgfSxcbn07XG5cbmNvbnN0IEljb24gPSAoeyBjaGlsZHJlbiB9KSA9PiAoXG4gIDxpbWdcbiAgICBoZWlnaHQ9ezIwfVxuICAgIHNyYz17YGRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LCR7c3ZnSWNvbnNbY2hpbGRyZW5dfWB9XG4gICAgc3R5bGU9e3N0eWxlcy5pY29ufVxuICAvPlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgSWNvbjtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IHN0eWxlcyA9IHtcbiAganNvblZpZXdlcjoge1xuICAgIHBhZGRpbmc6IDE2LFxuICAgIGJvcmRlclJhZGl1czogNCxcbiAgICBiYWNrZ3JvdW5kOiAnbGluZW4nLFxuICB9LFxufTtcblxuY29uc3QgSnNvblZpZXdlciA9ICh7IHZhbHVlIH0pID0+IChcbiAgPHByZSBzdHlsZT17c3R5bGVzLmpzb25WaWV3ZXJ9PlxuICAgIDxjb2RlPntKU09OLnN0cmluZ2lmeSh2YWx1ZSwgbnVsbCwgMil9PC9jb2RlPlxuICA8L3ByZT5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IEpzb25WaWV3ZXI7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5jb25zdCBzdHlsZXMgPSB7XG4gIHRvb2xiYXI6IHtcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgZmxleERpcmVjdGlvbjogJ3JvdycsXG4gIH0sXG4gIGJ1dHRvbjoge1xuICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG5cbiAgICBoZWlnaHQ6IDMwLFxuICAgIG1pbldpZHRoOiAzMCxcbiAgICBtYXJnaW46IDUsXG4gICAgcGFkZGluZzogMCxcbiAgICBib3JkZXI6ICdub25lJyxcblxuICAgIGJhY2tncm91bmQ6ICd0cmFuc3BhcmVudCcsXG4gICAgYm9yZGVyUmFkaXVzOiA0LFxuICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICB9LFxuICBidXR0b25BY3RpdmU6IHtcbiAgICBiYWNrZ3JvdW5kOiAnI2Y1ZjVmNScsXG4gIH0sXG4gIHNlcGFyYXRvcjoge1xuICAgIG1hcmdpbjogJzEwcHggNXB4JyxcbiAgICBib3JkZXJSaWdodDogJ3NvbGlkIHRoaW4gI2VhZWFlYScsXG4gIH0sXG59O1xuXG5jb25zdCBUb29sYmFyID0gKHsgY2hpbGRyZW4gfSkgPT4gPGRpdiBzdHlsZT17c3R5bGVzLnRvb2xiYXJ9PntjaGlsZHJlbn08L2Rpdj47XG5cblRvb2xiYXIuQnV0dG9uID0gKHsgYWN0aXZlLCAuLi5wcm9wcyB9KSA9PiAoXG4gIDxidXR0b25cbiAgICB7Li4ucHJvcHN9XG4gICAgc3R5bGU9e3tcbiAgICAgIC4uLnN0eWxlcy5idXR0b24sXG4gICAgICAuLi4oYWN0aXZlID8gc3R5bGVzLmJ1dHRvbkFjdGl2ZSA6IHVuZGVmaW5lZCksXG4gICAgfX1cbiAgLz5cbik7XG5cblRvb2xiYXIuU2VwYXJhdG9yID0gKCkgPT4gPGRpdiBzdHlsZT17c3R5bGVzLnNlcGFyYXRvcn0gLz47XG5cbmV4cG9ydCBkZWZhdWx0IFRvb2xiYXI7XG4iLCIvLyBCbG9ja3NcbmNvbnN0IEJVTExFVEVEX0xJU1QgPSAnYnVsbGV0ZWQtbGlzdCc7XG5jb25zdCBOVU1CRVJFRF9MSVNUID0gJ251bWJlcmVkLWxpc3QnO1xuY29uc3QgTElTVF9JVEVNID0gJ2xpc3QtaXRlbSc7XG5jb25zdCBNRU5USU9OID0gJ21lbnRpb24nO1xuY29uc3QgTElOSyA9ICdsaW5rJztcbmNvbnN0IEhFQURJTkdfT05FID0gJ2hlYWRpbmctb25lJztcbmNvbnN0IEhFQURJTkdfVFdPID0gJ2hlYWRpbmctdHdvJztcbmNvbnN0IFBBUkFHUkFQSCA9ICdwYXJhZ3JhcGgnO1xuXG4vLyBNYXJrc1xuY29uc3QgQk9MRCA9ICdib2xkJztcbmNvbnN0IElUQUxJQyA9ICdpdGFsaWMnO1xuY29uc3QgVU5ERVJMSU5FID0gJ3VuZGVybGluZSc7XG5cbi8vIE90aGVyIGV2ZW50c1xuY29uc3QgRURJVE9SX0NIQU5HRSA9ICdlZGl0b3ItY2hhbmdlJztcbmNvbnN0IEVESVRPUl9GT0NVUyA9ICdlZGl0b3ItZm9jdXMnO1xuY29uc3QgRURJVE9SX0JMVVIgPSAnZWRpdG9yLWJsdXInO1xuY29uc3QgRURJVE9SX0xBWU9VVCA9ICdlZGl0b3ItbGF5b3V0JztcblxuZXhwb3J0IHtcbiAgQlVMTEVURURfTElTVCxcbiAgTlVNQkVSRURfTElTVCxcbiAgTElTVF9JVEVNLFxuICBNRU5USU9OLFxuICBMSU5LLFxuICBIRUFESU5HX09ORSxcbiAgSEVBRElOR19UV08sXG4gIFBBUkFHUkFQSCxcbiAgQk9MRCxcbiAgSVRBTElDLFxuICBVTkRFUkxJTkUsXG4gIEVESVRPUl9DSEFOR0UsXG4gIEVESVRPUl9GT0NVUyxcbiAgRURJVE9SX0JMVVIsXG4gIEVESVRPUl9MQVlPVVQsXG59O1xuIiwiY29uc3QgYXBwbHkgPSAoYXJncyA9IFtdKSA9PiAoZnVuYykgPT4gZnVuYyguLi5hcmdzKTtcblxuZXhwb3J0IGRlZmF1bHQgYXBwbHk7XG4iLCJjb25zdCBjb21wb3NlID0gKC4uLmZ1bmNzKSA9PiAoYXJnKSA9PlxuICBmdW5jcy5yZWR1Y2VSaWdodCgoY29tcG9zZWQsIGYpID0+IChmID8gZihjb21wb3NlZCkgOiBjb21wb3NlZCksIGFyZyk7XG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvc2U7XG4iLCJjb25zdCBjcmVhdGVQbHVnaW4gPSAoY29uZmlncykgPT4ge1xuICBjb25zdCBkZWZhdWx0UGx1Z2luID0ge1xuICAgIG5hbWU6ICcnLFxuICAgIHJlbmRlckxlYWY6IChuZXh0KSA9PiAocHJvcHMpID0+IG5leHQocHJvcHMpLFxuICAgIHJlbmRlckVsZW1lbnQ6IChuZXh0KSA9PiAocHJvcHMpID0+IG5leHQocHJvcHMpLFxuICAgIFRvb2xiYXJCdXR0b246ICgpID0+IG51bGwsXG4gICAgcmVuZGVyQ3VzdG9tOiAoKSA9PiBudWxsLFxuICAgIGhhbmRsZU1lc3NhZ2U6ICgpID0+ICgpID0+IHt9LFxuICAgIGVuaGFuY2VFZGl0b3I6IChlZGl0b3IpID0+IGVkaXRvcixcbiAgfTtcbiAgcmV0dXJuIHsgLi4uZGVmYXVsdFBsdWdpbiwgLi4uY29uZmlncyB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlUGx1Z2luO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEVkaXRvciB9IGZyb20gJ3NsYXRlJztcbmltcG9ydCBjb21wb3NlIGZyb20gJy4vY29tcG9zZSc7XG5pbXBvcnQgeyBOVU1CRVJFRF9MSVNULCBCVUxMRVRFRF9MSVNUIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuY29uc3QgaXNCbG9ja0FjdGl2ZSA9IChlZGl0b3IsIGZvcm1hdCkgPT4ge1xuICBjb25zdCBbbWF0Y2hdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgIG1hdGNoOiAobikgPT4gbi50eXBlID09PSBmb3JtYXQsXG4gIH0pO1xuICByZXR1cm4gISFtYXRjaDtcbn07XG5cbmNvbnN0IGlzTGlzdCA9IChub2RlKSA9PiBbQlVMTEVURURfTElTVCwgTlVNQkVSRURfTElTVF0uaW5jbHVkZXMobm9kZS50eXBlKTtcblxuY29uc3QgRGVmYXVsdEVsZW1lbnQgPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiAoXG4gIDxwIHJlZj17cmVmfSBzdHlsZT17eyBtYXJnaW46IDAsIGxpbmVIZWlnaHQ6IDEuNSB9fSB7Li4ucHJvcHN9IC8+XG4pKTtcblxuY29uc3QgcmVuZGVyRGVmYXVsdEVsZW1lbnQgPSAoeyBhdHRyaWJ1dGVzLCBjaGlsZHJlbiB9KSA9PiB7XG4gIDxEZWZhdWx0RWxlbWVudCB7Li4uYXR0cmlidXRlc30+e2NoaWxkcmVufTwvRGVmYXVsdEVsZW1lbnQ+O1xufTtcblxuY29uc3QgbWFrZVJlbmRlckVsZW1lbnQgPSAoYmxvY2ssIEN1c3RvbUVsZW1lbnQpID0+IChuZXh0KSA9PiAocHJvcHMpID0+IHtcbiAgaWYgKHByb3BzLmVsZW1lbnQudHlwZSA9PT0gYmxvY2spIHtcbiAgICByZXR1cm4gPEN1c3RvbUVsZW1lbnQgey4uLnByb3BzfSAvPjtcbiAgfVxuICByZXR1cm4gbmV4dChwcm9wcyk7XG59O1xuXG5jb25zdCBjb21wb3NlUmVuZGVyRWxlbWVudCA9IChwbHVnaW5zKSA9PlxuICBjb21wb3NlKC4uLnBsdWdpbnMubWFwKChwbHVnaW4pID0+IHBsdWdpbi5yZW5kZXJFbGVtZW50KSkoXG4gICAgcmVuZGVyRGVmYXVsdEVsZW1lbnQsXG4gICk7XG5cbmV4cG9ydCB7XG4gIGlzQmxvY2tBY3RpdmUsXG4gIGlzTGlzdCxcbiAgcmVuZGVyRGVmYXVsdEVsZW1lbnQsXG4gIG1ha2VSZW5kZXJFbGVtZW50LFxuICBjb21wb3NlUmVuZGVyRWxlbWVudCxcbn07XG4iLCJjb25zdCBmbG93ID0gKC4uLmZ1bmNzKSA9PiAoYXJnKSA9PlxuICBmdW5jcy5yZWR1Y2UoKGNvbXBvc2VkLCBmKSA9PiAoZiA/IGYoY29tcG9zZWQpIDogY29tcG9zZWQpLCBhcmcpO1xuXG5leHBvcnQgZGVmYXVsdCBmbG93O1xuIiwiY29uc3QgZ2V0ID0gKHBhdGgpID0+IChvYmplY3QpID0+IG9iamVjdFtwYXRoXTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0O1xuIiwiaW1wb3J0IHsgTm9kZSB9IGZyb20gJ3NsYXRlJztcbmltcG9ydCB7IExJTksgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZGVmYXVsdCAobm9kZSkgPT4ge1xuICBpZiAobm9kZT8udHlwZSAhPT0gTElOSykgcmV0dXJuIG51bGw7XG4gIHJldHVybiBOb2RlLnN0cmluZyhub2RlKTtcbn07XG4iLCJleHBvcnQgeyBkZWZhdWx0IGFzIGNvbXBvc2UgfSBmcm9tICcuL2NvbXBvc2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmbG93IH0gZnJvbSAnLi9mbG93JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWFwIH0gZnJvbSAnLi9tYXAnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBnZXQgfSBmcm9tICcuL2dldCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGFwcGx5IH0gZnJvbSAnLi9hcHBseSc7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgY3JlYXRlUGx1Z2luIH0gZnJvbSAnLi9jcmVhdGVQbHVnaW4nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB3aXRoSWQgfSBmcm9tICcuL3dpdGhJZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGdldFVybCB9IGZyb20gJy4vZ2V0VXJsJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaXNFbXB0eUNvbnRlbnQgfSBmcm9tICcuL2lzRW1wdHlDb250ZW50JztcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VGb3JjZVVwZGF0ZSB9IGZyb20gJy4vdXNlRm9yY2VVcGRhdGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VBbmRyb2lkSGFjayB9IGZyb20gJy4vdXNlQW5kcm9pZEhhY2snO1xuXG5leHBvcnQgKiBmcm9tICcuL2xlYWZIZWxwZXJzJztcbmV4cG9ydCAqIGZyb20gJy4vZWxlbWVudEhlbHBlcnMnO1xuZXhwb3J0ICogZnJvbSAnLi9tZXNzYWdlSGVscGVycyc7XG4iLCIvLyBUaGlzIGRvZXMgbm90IGluY2x1ZGUgdmFsaWRhdGlvblxuLy8gaHR0cHM6Ly9kb2NzLnNsYXRlanMub3JnL2NvbmNlcHRzLzEwLW5vcm1hbGl6aW5nI2J1aWx0LWluLWNvbnN0cmFpbnRzXG5leHBvcnQgZGVmYXVsdCAoY29udGVudCkgPT5cbiAgY29udGVudD8ubGVuZ3RoID09PSAxICYmXG4gIGNvbnRlbnRbMF0/LnR5cGUgPT09ICdwYXJhZ3JhcGgnICYmXG4gIGNvbnRlbnRbMF0/LmNoaWxkcmVuPy5sZW5ndGggPT09IDEgJiZcbiAgY29udGVudFswXT8uY2hpbGRyZW5bMF0/LnRleHQgPT09ICcnO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEVkaXRvciB9IGZyb20gJ3NsYXRlJztcbmltcG9ydCBjb21wb3NlIGZyb20gJy4vY29tcG9zZSc7XG5cbmNvbnN0IGlzTWFya0FjdGl2ZSA9IChlZGl0b3IsIGZvcm1hdCkgPT4ge1xuICBjb25zdCBtYXJrcyA9IEVkaXRvci5tYXJrcyhlZGl0b3IpO1xuICByZXR1cm4gbWFya3MgPyBtYXJrc1tmb3JtYXRdID09PSB0cnVlIDogZmFsc2U7XG59O1xuXG5jb25zdCB0b2dnbGVNYXJrID0gKGVkaXRvciwgZm9ybWF0KSA9PiB7XG4gIGNvbnN0IGlzQWN0aXZlID0gaXNNYXJrQWN0aXZlKGVkaXRvciwgZm9ybWF0KTtcbiAgaWYgKGlzQWN0aXZlKSB7XG4gICAgRWRpdG9yLnJlbW92ZU1hcmsoZWRpdG9yLCBmb3JtYXQpO1xuICB9IGVsc2Uge1xuICAgIEVkaXRvci5hZGRNYXJrKGVkaXRvciwgZm9ybWF0LCB0cnVlKTtcbiAgfVxufTtcblxuY29uc3QgRGVmYXVsdExlYWYgPSAnc3Bhbic7XG5cbmNvbnN0IHJlbmRlckRlZmF1bHRMZWFmID0gKHsgYXR0cmlidXRlcywgY2hpbGRyZW4gfSkgPT4gKFxuICA8RGVmYXVsdExlYWYgey4uLmF0dHJpYnV0ZXN9PntjaGlsZHJlbn08L0RlZmF1bHRMZWFmPlxuKTtcblxuY29uc3QgbWFrZVJlbmRlckxlYWYgPSAobWFyaywgQ3VzdG9tTGVhZikgPT4gKG5leHQpID0+IChwcm9wcykgPT4ge1xuICBpZiAocHJvcHMubGVhZlttYXJrXSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gPEN1c3RvbUxlYWYgey4uLnByb3BzfSAvPjtcbiAgICByZXR1cm4gbmV4dCh7IC4uLnByb3BzLCBjaGlsZHJlbiB9KTtcbiAgfVxuICByZXR1cm4gbmV4dChwcm9wcyk7XG59O1xuXG5jb25zdCBjb21wb3NlUmVuZGVyTGVhZiA9IChwbHVnaW5zKSA9PlxuICBjb21wb3NlKC4uLnBsdWdpbnMubWFwKChwbHVnaW4pID0+IHBsdWdpbi5yZW5kZXJMZWFmKSkocmVuZGVyRGVmYXVsdExlYWYpO1xuXG5leHBvcnQge1xuICBpc01hcmtBY3RpdmUsXG4gIHRvZ2dsZU1hcmssXG4gIHJlbmRlckRlZmF1bHRMZWFmLFxuICBtYWtlUmVuZGVyTGVhZixcbiAgY29tcG9zZVJlbmRlckxlYWYsXG59O1xuIiwiY29uc3QgbWFwID0gKGl0ZXJhdGVlKSA9PiAoY29sbGVjdGlvbikgPT4gY29sbGVjdGlvbi5tYXAoaXRlcmF0ZWUpO1xuXG5leHBvcnQgZGVmYXVsdCBtYXA7XG4iLCJjb25zdCBtZXNzYWdlUHJlZml4ID0gJ0BoZXJvLWVkaXRvcic7XG5cbmNvbnN0IGFkZE1lc3NhZ2VMaXN0ZW5lciA9ICh0eXBlLCBjYWxsYmFjaykgPT4gKGVkaXRvcikgPT4ge1xuICBjb25zdCBsaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5kYXRhLnR5cGUgPT09IGAke21lc3NhZ2VQcmVmaXh9LyR7ZWRpdG9yLmlkfS8ke3R5cGV9YCkge1xuICAgICAgY2FsbGJhY2soeyBlZGl0b3IsIGRhdGE6IGV2ZW50LmRhdGEuZGF0YSB9KTtcbiAgICB9XG4gIH07XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIpO1xuICByZXR1cm4gKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XG59O1xuXG5jb25zdCBwb3N0TWVzc2FnZSA9ICh0eXBlLCBkYXRhLCBlZGl0b3IpID0+IHtcbiAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICB0eXBlOiBgJHttZXNzYWdlUHJlZml4fS8ke2VkaXRvci5pZH0vJHt0eXBlfWAsXG4gICAgZGF0YSxcbiAgfTtcbiAgd2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2UsICcqJyk7XG4gIHdpbmRvdy5SZWFjdE5hdGl2ZVdlYlZpZXc/LnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKTtcbn07XG5cbmV4cG9ydCB7IGFkZE1lc3NhZ2VMaXN0ZW5lciwgcG9zdE1lc3NhZ2UgfTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pYW5zdG9ybXRheWxvci9zbGF0ZS9pc3N1ZXMvMzQ3MCNpc3N1ZWNvbW1lbnQtNjM5NDMxMzkwXG5pbXBvcnQgeyB1c2VSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgVHJhbnNmb3JtcywgRWRpdG9yIGFzIFNsYXRlRWRpdG9yIH0gZnJvbSAnc2xhdGUnO1xuaW1wb3J0IHsgUmVhY3RFZGl0b3IgfSBmcm9tICdzbGF0ZS1yZWFjdCc7XG5cbmNvbnN0IHVzZUFuZHJvaWRIYWNrID0gKGVkaXRvcikgPT4ge1xuICBjb25zdCBsYXN0Q29tcG9zZURhdGEgPSB1c2VSZWYobnVsbCk7XG5cbiAgY29uc3Qgb25ET01CZWZvcmVJbnB1dCA9IHVzZUNhbGxiYWNrKFxuICAgIChlKSA9PiB7XG4gICAgICBzd2l0Y2ggKGUuaW5wdXRUeXBlKSB7XG4gICAgICAgIGNhc2UgJ2luc2VydENvbXBvc2l0aW9uVGV4dCc6IHtcbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIHB1c2ggZWFjaCBjb21wb3NpdGlvbiBldmVudCBzbyB3ZSBjYW4gYXBwbHkgaXQgd2hlbiBmaW5pc2hlZFxuICAgICAgICAgIGlmICghbGFzdENvbXBvc2VEYXRhLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGxhc3RDb21wb3NlRGF0YS5jdXJyZW50ID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNvbnZlcnQgdGhlIHNlbGVjdGlvbiByaWdodCBhd2F5LCBhcyB0aGUgd2luZG93LmdldFNlbGVjdGlvbigpIHdpbGwgY2hhbmdlIHdpdGggdGhlIHdpbmRvd1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgY29uc3Qgc2VsID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgc2VsZWN0aW9uKTtcblxuICAgICAgICAgICAgLy8gVGhlIG9mZnNldHMgbWF5IG5vdCBtYXRjaCBiZWNhdXNlIHRoZSBjb21wb3NpdGlvbiB0ZXh0IG1pZ2h0IGJlIGZhciBhaGVhZCBldGMuLi5cbiAgICAgICAgICAgIHNlbC5hbmNob3Iub2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldDtcbiAgICAgICAgICAgIHNlbC5mb2N1cy5vZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG5cbiAgICAgICAgICAgIGxhc3RDb21wb3NlRGF0YS5jdXJyZW50LnB1c2goe1xuICAgICAgICAgICAgICBzZWxlY3Rpb246IHNlbCxcbiAgICAgICAgICAgICAgdmFsdWU6IGUuZGF0YSxcbiAgICAgICAgICAgICAgbm9kZTogc2VsZWN0aW9uPy5hbmNob3JOb2RlLFxuICAgICAgICAgICAgICBlbGVtZW50Tm9kZTogc2VsZWN0aW9uPy5hbmNob3JOb2RlPy5wYXJlbnRFbGVtZW50LmNsb3Nlc3QoXG4gICAgICAgICAgICAgICAgJ1tkYXRhLXNsYXRlLW5vZGU9XCJlbGVtZW50XCJdJyxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgbGFzdENvbXBvc2VEYXRhLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdpbnNlcnRGcm9tQ29tcG9zaXRpb24nOlxuICAgICAgICBjYXNlICdkZWxldGVCeUNvbXBvc2l0aW9uJzpcbiAgICAgICAgICAvLyBJZiB3ZSBnZXQgdGhpcyBldmVudCB3ZSBkb24ndCBuZWVkIHRvIGFwcGx5IGFueSBzb3J0IG9mIGZpeCwgdGhpcyBpcyB0aGUgY29ycmVjdCBldmVudCB0byBoYW5kbGUgdGhpbmdzXG4gICAgICAgICAgbGFzdENvbXBvc2VEYXRhLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2VkaXRvcl0sXG4gICk7XG5cbiAgY29uc3Qgb25Db21wb3NpdGlvbkVuZCA9IHVzZUNhbGxiYWNrKFxuICAgIChlKSA9PiB7XG4gICAgICBjb25zdCB7IGN1cnJlbnQgfSA9IGxhc3RDb21wb3NlRGF0YTtcbiAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgIC8vIFN0b3JlIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBzbyB3ZSBjYW4gbW92ZSBiYWNrIG9uY2Ugd2UgaGF2ZSBmaW5pc2hlZCBhcHBseWluZyBxdWV1ZWQgY2hhbmdlc1xuICAgICAgICAvLyBDb252ZXJ0IHRvIHNsYXRlIHJhbmdlIHN0cmFpZ2h0IGF3YXkgYXMgdGhlIHNlbGVjdGlvbiBjYW4gZ2V0IG1lc3NlZCB1cCBkdWUgdG8gZWxlbWVudCBmaXhpbmcgY29kZVxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYW5jaG9yTm9kZSxcbiAgICAgICAgICBhbmNob3JPZmZzZXQsXG4gICAgICAgICAgZm9jdXNOb2RlLFxuICAgICAgICAgIGZvY3VzT2Zmc2V0LFxuICAgICAgICAgIGlzQ29sbGFwc2VkLFxuICAgICAgICB9ID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgIC8vIEFwcGx5IGVhY2ggb2YgdGhlIGNoYW5nZXNcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIGN1cnJlbnQpIHtcbiAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiwgdmFsdWUsIG5vZGUsIGVsZW1lbnROb2RlIH0gPSBjO1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2VsZWN0aW9uKTtcbiAgICAgICAgICBTbGF0ZUVkaXRvci5pbnNlcnRUZXh0KGVkaXRvciwgdmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBIQUNLICMxIC0gd2hlbiBhIG5ldyBsaW5lIGlzIGNyZWF0ZWQgc2xhdGUgY3JlYXRlcyBhIHplcm8td2lkdGhcbiAgICAgICAgICAgIC8vIGJ1dCBhY3R1YWxseSBpdCB3aWxsIGJlIGZpbGxlZCBpbiwgdGhpcyBjYXVzZXMgc2xhdGUgY3Jhc2hlc1xuICAgICAgICAgICAgLy8gSGF2ZSB0byByZWNyZWF0ZSBhIGZ1bGwgZWxlbWVudCBpbnN0ZWFkIG9mIGFuIGVtcHR5IGVsZW1lbnQgaW4gc2xhdGVcbiAgICAgICAgICAgIGNvbnN0IGVsID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgaWYgKGVsICYmIGVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJykpIHtcbiAgICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXNsYXRlLWxlbmd0aCcpO1xuICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpO1xuICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtc3RyaW5nJywgJ3RydWUnKTtcbiAgICAgICAgICAgICAgZWwuaW5uZXJUZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICAgIGNvbnN0IHsgcGF0aCwgb2Zmc2V0IH0gPSBlZGl0b3Iuc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgICAgICAgICAgY29uc3QgcCA9IHsgcGF0aCwgb2Zmc2V0OiBvZmZzZXQgLSAxIH07XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgeyBhbmNob3I6IHAsIGZvY3VzOiBwIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBIQUNLICMyIC0gd2hlbiBhbiBlbGVtZW50IGlzIG1hZGUgZW1wdHkgZHVyaW5nIGNvbXBvc2VcbiAgICAgICAgICAgIC8vIHRoZSBlbGVtZW50IGlzIHJlbW92ZWQgZnJvbSBkb20sIG5lZWQgdG8gYWRkIGl0IGJhY2tcbiAgICAgICAgICAgIC8vIGFzIGEgemVyby13aWR0aCBlbGVtZW50IHRvIG1hdGNoXG4gICAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9IG5vZGUucGFyZW50RWxlbWVudC5jbG9zZXN0KFxuICAgICAgICAgICAgICAnW2RhdGEtc2xhdGUtbm9kZT1cInRleHRcIl0nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGVsID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBlbGVtZW50Tm9kZSAmJlxuICAgICAgICAgICAgICB0ZXh0Tm9kZSAmJlxuICAgICAgICAgICAgICBlbCAmJlxuICAgICAgICAgICAgICBlbGVtZW50Tm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgZWxlbWVudE5vZGUuY2hpbGRyZW5bMF0ubm9kZU5hbWUgPT09ICdCUidcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSAnJiM2NTI3OTsnO1xuICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtbGVuZ3RoJywgJzAnKTtcbiAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnLCAnbicpO1xuICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtc3RyaW5nJyk7XG4gICAgICAgICAgICAgIGVsZW1lbnROb2RlLnJlcGxhY2VDaGlsZCh0ZXh0Tm9kZSwgZWxlbWVudE5vZGUuY2hpbGRyZW5bMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RDb21wb3NlRGF0YS5jdXJyZW50ID0gbnVsbDtcblxuICAgICAgICAvLyBNb3ZlIGJhY2sgdG8gZXhpc3Rpbmcgc2VsZWN0aW9uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgc3MgPSBSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCB7XG4gICAgICAgICAgICBzdGFydENvbnRhaW5lcjogYW5jaG9yTm9kZSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBhbmNob3JPZmZzZXQsXG4gICAgICAgICAgICBlbmRDb250YWluZXI6IGZvY3VzTm9kZSxcbiAgICAgICAgICAgIGVuZE9mZnNldDogZm9jdXNPZmZzZXQsXG4gICAgICAgICAgICBjb2xsYXBzZWQ6IGlzQ29sbGFwc2VkLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIFNtYWxsIGZpeHVwIGFnYWluXG4gICAgICAgICAgc3MuYW5jaG9yLm9mZnNldCA9IGFuY2hvck9mZnNldDtcbiAgICAgICAgICBzcy5mb2N1cy5vZmZzZXQgPSBmb2N1c09mZnNldDtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHNzKTtcblxuICAgICAgICAgIC8vIFJlc2V0IHRoZSBkb20gc2VsZWN0aW9uIGFzIHdlbGwuLi4gdGhpcyBjYW4gZ2V0IG91dCBvZiBhbGlnbm1lbnRcbiAgICAgICAgICBjb25zdCBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgIGNvbnN0IG5ld0RvbVJhbmdlID0gUmVhY3RFZGl0b3IudG9ET01SYW5nZShlZGl0b3IsIHNzKTtcbiAgICAgICAgICBpZiAobmV3RG9tUmFuZ2UpIHtcbiAgICAgICAgICAgIHNlbC5hZGRSYW5nZShuZXdEb21SYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXZlbnQgc2xhdGUgZnJvbSBkb2luZyBhbnl0aGluZ1xuICAgICAgLy8gVGhpcyBwcmV2ZW50cyB0aGUgaGFjayB0aGF0IGlzIGN1cnJlbnRseSBpbiBvbkNvbXBvc2l0aW9uRW5kIHRoYXQgZG9lc24ndCB3b3JrXG4gICAgICBlLmRhdGEgPSBudWxsO1xuICAgIH0sXG4gICAgW2VkaXRvcl0sXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICBvbkNvbXBvc2l0aW9uRW5kLFxuICAgIG9uRE9NQmVmb3JlSW5wdXQsXG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VBbmRyb2lkSGFjaztcbiIsImltcG9ydCB7IHVzZVN0YXRlLCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IHVzZUZvcmNlVXBkYXRlID0gKCkgPT4ge1xuICBjb25zdCBwcmV2ID0gdXNlUmVmKDApO1xuICBjb25zdCBbY3Vyciwgc2V0Q3Vycl0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgaXNGb3JjZVVwZGF0ZWQgPSBwcmV2LmN1cnJlbnQgIT09IGN1cnI7XG4gIHByZXYuY3VycmVudCA9IGN1cnI7XG4gIHJldHVybiB7IGlzRm9yY2VVcGRhdGVkLCBmb3JjZVVwZGF0ZTogKCkgPT4gc2V0Q3VycihjdXJyICsgMSkgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUZvcmNlVXBkYXRlO1xuIiwiLy8gbG1hb1xuY29uc3QgeSA9IChmKSA9PlxuICAoKGcpID0+ICguLi5hKSA9PiBmKGcoZykpKC4uLmEpKSgoZykgPT4gKC4uLmEpID0+IGYoZyhnKSkoLi4uYSkpO1xuXG5leHBvcnQgZGVmYXVsdCB5O1xuIiwiY29uc3Qgd2l0aElkID0gKGlkKSA9PiAoZWRpdG9yKSA9PiB7XG4gIGVkaXRvci5pZCA9IGlkO1xuICByZXR1cm4gZWRpdG9yO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgd2l0aElkO1xuIiwiaW1wb3J0IFJlYWN0LCB7IHVzZU1lbW8sIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlRWRpdG9yIH0gZnJvbSAnc2xhdGUnO1xuaW1wb3J0IHsgU2xhdGUsIEVkaXRhYmxlLCB3aXRoUmVhY3QgfSBmcm9tICdzbGF0ZS1yZWFjdCc7XG5pbXBvcnQge1xuICBjb21wb3NlUmVuZGVyTGVhZixcbiAgY29tcG9zZVJlbmRlckVsZW1lbnQsXG4gIHBvc3RNZXNzYWdlLFxuICB3aXRoSWQsXG4gIG1hcCxcbiAgZ2V0LFxuICBhcHBseSxcbiAgZmxvdyxcbiAgdXNlQW5kcm9pZEhhY2ssXG59IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQgVG9vbGJhciBmcm9tICcuL2NvbXBvbmVudHMvVG9vbGJhcic7XG5pbXBvcnQge1xuICBFRElUT1JfQ0hBTkdFLFxuICBFRElUT1JfRk9DVVMsXG4gIEVESVRPUl9CTFVSLFxuICBFRElUT1JfTEFZT1VULFxufSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmNvbnN0IHN0eWxlcyA9IHtcbiAgZWRpdG9yV3JhcHBlcjoge1xuICAgIGZvbnRGYW1pbHk6ICdzYW5zLXNlcmlmJyxcbiAgICBib3JkZXI6ICdzb2xpZCB0aGluICNlYWVhZWEnLFxuICAgIGJvcmRlclJhZGl1czogNCxcbiAgfSxcbiAgZWRpdGFibGVXcmFwcGVyOiB7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gIH0sXG4gIGVkaXRhYmxlOiB7XG4gICAgcGFkZGluZzogMTYsXG4gIH0sXG59O1xuXG5jb25zdCBnZXRDdXN0b21FbGVtZW50cyA9IChlZGl0b3IpID0+XG4gIG1hcChmbG93KGdldCgncmVuZGVyQ3VzdG9tJyksIGFwcGx5KFtlZGl0b3JdKSkpO1xuXG5jb25zdCBhZGRNZXNzYWdlTGlzdGVuZXJzID0gKGVkaXRvcikgPT5cbiAgbWFwKGZsb3coZ2V0KCdoYW5kbGVNZXNzYWdlJyksIGFwcGx5KFtlZGl0b3JdKSkpO1xuXG5jb25zdCBnZXRUb29sYmFyQnV0dG9ucyA9IG1hcCgoeyBuYW1lLCBUb29sYmFyQnV0dG9uIH0pID0+IChcbiAgPFRvb2xiYXJCdXR0b24ga2V5PXtuYW1lfSAvPlxuKSk7XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcblxuY29uc3QgSGVyb0VkaXRvciA9ICh7XG4gIGlkLFxuICBzaG93VG9vbGJhciA9IHRydWUsXG4gIGF1dG9Gb2N1cyA9IGZhbHNlLFxuICBwbHVnaW5zID0gW10sXG4gIHBsYWNlaG9sZGVyLFxuICB2YWx1ZSxcbiAgb25DaGFuZ2UsXG4gIG9uRm9jdXMgPSBub29wLFxuICBvbkJsdXIgPSBub29wLFxuICBvbkxheW91dCA9IG5vb3AsXG4gIHdyYXBwZXJTdHlsZSxcbiAgZWRpdGFibGVTdHlsZSxcbiAgaXNBbmRyb2lkID0gZmFsc2UsXG59KSA9PiB7XG4gIGNvbnN0IHdyYXBwZXIgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHdyYXBwZXJMYXlvdXQgPSB1c2VSZWYoeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xuXG4gIGNvbnN0IGVkaXRvciA9IHVzZU1lbW8oXG4gICAgKCkgPT5cbiAgICAgIGZsb3coXG4gICAgICAgIGNyZWF0ZUVkaXRvcixcbiAgICAgICAgd2l0aFJlYWN0LFxuICAgICAgICB3aXRoSWQoaWQpLFxuICAgICAgICAuLi5tYXAoZ2V0KCdlbmhhbmNlRWRpdG9yJykpKHBsdWdpbnMpLFxuICAgICAgKSgpLFxuICAgIFtdLFxuICApO1xuXG4gIGNvbnN0IHJlbmRlckxlYWYgPSB1c2VNZW1vKCgpID0+IGNvbXBvc2VSZW5kZXJMZWFmKHBsdWdpbnMpLCBbcGx1Z2luc10pO1xuXG4gIGNvbnN0IHJlbmRlckVsZW1lbnQgPSB1c2VNZW1vKCgpID0+IGNvbXBvc2VSZW5kZXJFbGVtZW50KHBsdWdpbnMpLCBbcGx1Z2luc10pO1xuXG4gIGNvbnN0IHJlbmRlckN1c3RvbSA9IHVzZU1lbW8oKCkgPT4gKCkgPT4gZ2V0Q3VzdG9tRWxlbWVudHMoZWRpdG9yKShwbHVnaW5zKSwgW1xuICAgIHBsdWdpbnMsXG4gICAgdmFsdWUsXG4gIF0pO1xuXG4gIGNvbnN0IHRvb2xCYXJCdXR0b25zID0gdXNlTWVtbygoKSA9PiBnZXRUb29sYmFyQnV0dG9ucyhwbHVnaW5zKSwgW3BsdWdpbnNdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHJlbW92ZUhhbmRsZXJzID0gYWRkTWVzc2FnZUxpc3RlbmVycyhlZGl0b3IpKHBsdWdpbnMpO1xuXG4gICAgcmV0dXJuICgpID0+IHJlbW92ZUhhbmRsZXJzLmZvckVhY2goKHJlbW92ZUhhbmRsZXIpID0+IHJlbW92ZUhhbmRsZXIoKSk7XG4gIH0sIFtwbHVnaW5zXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB3aWR0aCA9IHdyYXBwZXIuY3VycmVudD8ub2Zmc2V0V2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gd3JhcHBlci5jdXJyZW50Py5vZmZzZXRIZWlnaHQ7XG5cbiAgICBpZiAoXG4gICAgICB3aWR0aCAhPT0gd3JhcHBlckxheW91dC5jdXJyZW50LndpZHRoIHx8XG4gICAgICBoZWlnaHQgIT09IHdyYXBwZXJMYXlvdXQuY3VycmVudC5oZWlnaHRcbiAgICApIHtcbiAgICAgIHdyYXBwZXJMYXlvdXQuY3VycmVudCA9IHsgd2lkdGgsIGhlaWdodCB9O1xuICAgICAgb25MYXlvdXQod3JhcHBlckxheW91dC5jdXJyZW50KTtcbiAgICAgIHBvc3RNZXNzYWdlKEVESVRPUl9MQVlPVVQsIHdyYXBwZXJMYXlvdXQuY3VycmVudCwgZWRpdG9yKTtcbiAgICB9XG4gIH0sIFt2YWx1ZV0pO1xuXG4gIC8vIEhhY2sgZm9yIFNsYXRlIDAuNTggb24gQW5kcm9pZFxuICBsZXQgb25Db21wb3NpdGlvbkVuZCwgb25ET01CZWZvcmVJbnB1dDtcblxuICBpZiAoaXNBbmRyb2lkKSB7XG4gICAgKHsgb25Db21wb3NpdGlvbkVuZCwgb25ET01CZWZvcmVJbnB1dCB9ID0gdXNlQW5kcm9pZEhhY2soZWRpdG9yKSk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHJlZj17d3JhcHBlcn1cbiAgICAgIGNsYXNzTmFtZT1cImhlcm8tZWRpdG9yLS13cmFwcGVyXCJcbiAgICAgIHN0eWxlPXt7IC4uLnN0eWxlcy5lZGl0b3JXcmFwcGVyLCAuLi53cmFwcGVyU3R5bGUgfX1cbiAgICA+XG4gICAgICA8U2xhdGVcbiAgICAgICAgZWRpdG9yPXtlZGl0b3J9XG4gICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgb25DaGFuZ2U9eyh2YWx1ZSkgPT4ge1xuICAgICAgICAgIG9uQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgICBwb3N0TWVzc2FnZShFRElUT1JfQ0hBTkdFLCB7IHZhbHVlIH0sIGVkaXRvcik7XG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIHtzaG93VG9vbGJhciA/IDxUb29sYmFyPnt0b29sQmFyQnV0dG9uc308L1Rvb2xiYXI+IDogbnVsbH1cbiAgICAgICAgPGRpdiBzdHlsZT17c3R5bGVzLmVkaXRhYmxlV3JhcHBlcn0+XG4gICAgICAgICAgPEVkaXRhYmxlXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJoZXJvLWVkaXRvci0tZWRpdGFibGVcIlxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9e3BsYWNlaG9sZGVyfVxuICAgICAgICAgICAgc3BlbGxDaGVja1xuICAgICAgICAgICAgb25Db21wb3NpdGlvbkVuZD17b25Db21wb3NpdGlvbkVuZH1cbiAgICAgICAgICAgIG9uRE9NQmVmb3JlSW5wdXQ9e29uRE9NQmVmb3JlSW5wdXR9XG4gICAgICAgICAgICBhdXRvRm9jdXM9e2F1dG9Gb2N1c31cbiAgICAgICAgICAgIHJlbmRlckxlYWY9e3JlbmRlckxlYWZ9XG4gICAgICAgICAgICByZW5kZXJFbGVtZW50PXtyZW5kZXJFbGVtZW50fVxuICAgICAgICAgICAgb25Gb2N1cz17KGUpID0+IHtcbiAgICAgICAgICAgICAgb25Gb2N1cyhlKTtcbiAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoRURJVE9SX0ZPQ1VTLCB7fSwgZWRpdG9yKTtcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICBvbkJsdXI9eyhlKSA9PiB7XG4gICAgICAgICAgICAgIG9uQmx1cihlKTtcbiAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoRURJVE9SX0JMVVIsIHt9LCBlZGl0b3IpO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIHN0eWxlPXt7IC4uLnN0eWxlcy5lZGl0YWJsZSwgLi4uZWRpdGFibGVTdHlsZSB9fVxuICAgICAgICAgIC8+XG4gICAgICAgICAge3JlbmRlckN1c3RvbSgpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvU2xhdGU+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgKiBmcm9tICcuL3BsdWdpbnMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBKc29uVmlld2VyIH0gZnJvbSAnLi9jb21wb25lbnRzL0pzb25WaWV3ZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUb29sYmFyIH0gZnJvbSAnLi9jb21wb25lbnRzL1Rvb2xiYXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwbGFpblNlcmlhbGl6ZXIgfSBmcm9tICcuL3NlcmlhbGl6ZXJzL3BsYWluJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWFrZVJlYWN0VHJhbnNmb3JtZXIgfSBmcm9tICcuL3RyYW5zZm9ybWVycy9yZWFjdCc7XG5leHBvcnQgeyBkZWZhdWx0UmVhY3RUcmFuc2Zvcm1lciB9IGZyb20gJy4vdHJhbnNmb3JtZXJzL3JlYWN0JztcbmV4cG9ydCB7IGlzRW1wdHlDb250ZW50LCBnZXRVcmwgfSBmcm9tICcuL2hlbHBlcnMnO1xuZXhwb3J0IGRlZmF1bHQgSGVyb0VkaXRvcjtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VTbGF0ZSB9IGZyb20gJ3NsYXRlLXJlYWN0JztcbmltcG9ydCB7XG4gIGNyZWF0ZVBsdWdpbixcbiAgaXNNYXJrQWN0aXZlLFxuICB0b2dnbGVNYXJrLFxuICBtYWtlUmVuZGVyTGVhZixcbiAgYWRkTWVzc2FnZUxpc3RlbmVyLFxuICBwb3N0TWVzc2FnZSxcbn0gZnJvbSAnLi4vaGVscGVycyc7XG5pbXBvcnQgVG9vbGJhciBmcm9tICcuLi9jb21wb25lbnRzL1Rvb2xiYXInO1xuaW1wb3J0IEljb24gZnJvbSAnLi4vY29tcG9uZW50cy9JY29uJztcbmltcG9ydCB7IEJPTEQgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5jb25zdCByZW5kZXJMZWFmID0gbWFrZVJlbmRlckxlYWYoQk9MRCwgKHsgY2hpbGRyZW4gfSkgPT4gKFxuICA8c3Ryb25nPntjaGlsZHJlbn08L3N0cm9uZz5cbikpO1xuXG5jb25zdCBoYW5kbGVNZXNzYWdlID0gYWRkTWVzc2FnZUxpc3RlbmVyKEJPTEQsICh7IGVkaXRvciB9KSA9PiB7XG4gIHRvZ2dsZU1hcmsoZWRpdG9yLCBCT0xEKTtcbn0pO1xuXG5jb25zdCBUb29sYmFyQnV0dG9uID0gKCkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSB1c2VTbGF0ZSgpO1xuXG4gIHJldHVybiAoXG4gICAgPFRvb2xiYXIuQnV0dG9uXG4gICAgICBhY3RpdmU9e2lzTWFya0FjdGl2ZShlZGl0b3IsIEJPTEQpfVxuICAgICAgb25Nb3VzZURvd249eyhldmVudCkgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBwb3N0TWVzc2FnZShCT0xELCB7fSwgZWRpdG9yKTtcbiAgICAgIH19XG4gICAgPlxuICAgICAgPEljb24+Zm9ybWF0X2JvbGQ8L0ljb24+XG4gICAgPC9Ub29sYmFyLkJ1dHRvbj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0ICgpID0+XG4gIGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogQk9MRCxcbiAgICByZW5kZXJMZWFmLFxuICAgIGhhbmRsZU1lc3NhZ2UsXG4gICAgVG9vbGJhckJ1dHRvbixcbiAgfSk7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgVHJhbnNmb3JtcyB9IGZyb20gJ3NsYXRlJztcbmltcG9ydCB7IHVzZVNsYXRlIH0gZnJvbSAnc2xhdGUtcmVhY3QnO1xuaW1wb3J0IHtcbiAgY3JlYXRlUGx1Z2luLFxuICBpc0Jsb2NrQWN0aXZlLFxuICBtYWtlUmVuZGVyRWxlbWVudCxcbiAgYWRkTWVzc2FnZUxpc3RlbmVyLFxuICBwb3N0TWVzc2FnZSxcbiAgaXNMaXN0LFxufSBmcm9tICcuLi9oZWxwZXJzJztcbmltcG9ydCBUb29sYmFyIGZyb20gJy4uL2NvbXBvbmVudHMvVG9vbGJhcic7XG5pbXBvcnQgSWNvbiBmcm9tICcuLi9jb21wb25lbnRzL0ljb24nO1xuaW1wb3J0IHsgQlVMTEVURURfTElTVCwgTElTVF9JVEVNIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuY29uc3QgcmVuZGVyRWxlbWVudCA9IG1ha2VSZW5kZXJFbGVtZW50KFxuICBCVUxMRVRFRF9MSVNULFxuICAoeyBhdHRyaWJ1dGVzLCBjaGlsZHJlbiB9KSA9PiA8dWwgey4uLmF0dHJpYnV0ZXN9PntjaGlsZHJlbn08L3VsPixcbik7XG5cbmNvbnN0IGhhbmRsZU1lc3NhZ2UgPSBhZGRNZXNzYWdlTGlzdGVuZXIoQlVMTEVURURfTElTVCwgKHsgZWRpdG9yIH0pID0+IHtcbiAgY29uc3QgaXNBY3RpdmUgPSBpc0Jsb2NrQWN0aXZlKGVkaXRvciwgQlVMTEVURURfTElTVCk7XG5cbiAgLy8gVW53cmFwIGFsbCB0aGUgaXRlbXMgb2YgYW55IGxpc3RcbiAgVHJhbnNmb3Jtcy51bndyYXBOb2RlcyhlZGl0b3IsIHtcbiAgICBtYXRjaDogaXNMaXN0LFxuICAgIHNwbGl0OiB0cnVlLFxuICB9KTtcblxuICBpZiAoaXNBY3RpdmUpIHtcbiAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwgeyB0eXBlOiAncGFyYWdyYXBoJyB9KTtcbiAgfSBlbHNlIHtcbiAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwgeyB0eXBlOiBMSVNUX0lURU0gfSk7XG4gICAgVHJhbnNmb3Jtcy53cmFwTm9kZXMoZWRpdG9yLCB7IHR5cGU6IEJVTExFVEVEX0xJU1QsIGNoaWxkcmVuOiBbXSB9KTtcbiAgfVxufSk7XG5cbmNvbnN0IFRvb2xiYXJCdXR0b24gPSAoKSA9PiB7XG4gIGNvbnN0IGVkaXRvciA9IHVzZVNsYXRlKCk7XG5cbiAgcmV0dXJuIChcbiAgICA8VG9vbGJhci5CdXR0b25cbiAgICAgIGFjdGl2ZT17aXNCbG9ja0FjdGl2ZShlZGl0b3IsIEJVTExFVEVEX0xJU1QpfVxuICAgICAgb25Nb3VzZURvd249eyhldmVudCkgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBwb3N0TWVzc2FnZShCVUxMRVRFRF9MSVNULCB7fSwgZWRpdG9yKTtcbiAgICAgIH19XG4gICAgPlxuICAgICAgPEljb24+Zm9ybWF0X2xpc3RfYnVsbGV0ZWQ8L0ljb24+XG4gICAgPC9Ub29sYmFyLkJ1dHRvbj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0ICgpID0+XG4gIGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogQlVMTEVURURfTElTVCxcbiAgICByZW5kZXJFbGVtZW50LFxuICAgIGhhbmRsZU1lc3NhZ2UsXG4gICAgVG9vbGJhckJ1dHRvbixcbiAgfSk7XG4iLCJpbXBvcnQgeyBSZWFjdEVkaXRvciB9IGZyb20gJ3NsYXRlLXJlYWN0JztcbmltcG9ydCB7IGNyZWF0ZVBsdWdpbiwgYWRkTWVzc2FnZUxpc3RlbmVyLCBwb3N0TWVzc2FnZSB9IGZyb20gJy4uL2hlbHBlcnMnO1xuaW1wb3J0IHsgRURJVE9SX0NIQU5HRSB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNvbnN0IGhhbmRsZU1lc3NhZ2UgPSBhZGRNZXNzYWdlTGlzdGVuZXIoRURJVE9SX0NIQU5HRSwgKHsgZWRpdG9yIH0pID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IGVkaXRvcjtcblxuICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgY29uc3QgZG9tUmFuZ2UgPSBSZWFjdEVkaXRvci50b0RPTVJhbmdlKGVkaXRvciwgc2VsZWN0aW9uKTtcbiAgICBjb25zdCByYW5nZVJlY3QgPSBkb21SYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIHBvc3RNZXNzYWdlKFxuICAgICAgJ2N1cnNvci1jaGFuZ2UnLFxuICAgICAge1xuICAgICAgICBvZmZzZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB0b3A6IHJhbmdlUmVjdC50b3AsXG4gICAgICAgICAgbGVmdDogcmFuZ2VSZWN0LmxlZnQsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgZWRpdG9yLFxuICAgICk7XG4gIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCAoKSA9PlxuICBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6ICdjdXJzb3ItdHJhY2tlcicsXG4gICAgaGFuZGxlTWVzc2FnZSxcbiAgfSk7XG4iLCJpbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlUGx1Z2luLCB1c2VGb3JjZVVwZGF0ZSwgaXNFbXB0eUNvbnRlbnQgfSBmcm9tICcuLi9oZWxwZXJzJztcblxuY29uc3Qgc3R5bGVzID0ge1xuICBwbGFjZWhvbGRlcjoge1xuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwLFxuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgcGFkZGluZzogMTYsXG4gICAgbGluZUhlaWdodDogMS41LFxuICAgIGNvbG9yOiAnbGlnaHRncmV5JyxcbiAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gIH0sXG59O1xuXG5jb25zdCBDQUNIRV9UVEwgPSA1MDtcblxuY29uc3QgaXNEZWZpbmVkID0gKHJlZikgPT4gdHlwZW9mIHJlZi5jdXJyZW50ICE9PSAndW5kZWZpbmVkJztcblxuY29uc3QgRWRpdG9yUGxhY2Vob2xkZXIgPSAoeyB2YWx1ZSwgZWRpdG9yLCBzdHlsZSB9KSA9PiB7XG4gIGNvbnN0IGNhY2hlID0gdXNlUmVmKHVuZGVmaW5lZCk7XG4gIGNvbnN0IHsgaXNGb3JjZVVwZGF0ZWQsIGZvcmNlVXBkYXRlIH0gPSB1c2VGb3JjZVVwZGF0ZSgpO1xuXG4gIGNvbnN0IGNyZWF0ZVBsYWNlaG9sZGVyID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGlzRW1wdHkgPSBpc0VtcHR5Q29udGVudChlZGl0b3IuY2hpbGRyZW4pO1xuICAgIGNvbnN0IG1lcmdlZFN0eWxlID0geyAuLi5zdHlsZXMucGxhY2Vob2xkZXIsIC4uLnN0eWxlIH07XG5cbiAgICByZXR1cm4gaXNFbXB0eSA/IDxkaXYgc3R5bGU9e21lcmdlZFN0eWxlfT57dmFsdWV9PC9kaXY+IDogbnVsbDtcbiAgfSwgW10pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzRGVmaW5lZChjYWNoZSkpIHtcbiAgICAgIGNvbnN0IHRpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY2FjaGUuY3VycmVudCA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoIWlzRm9yY2VVcGRhdGVkKSBmb3JjZVVwZGF0ZSgpO1xuICAgICAgfSwgQ0FDSEVfVFRMKTtcblxuICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChpc0RlZmluZWQoY2FjaGUpKSByZXR1cm4gY2FjaGUuY3VycmVudDtcblxuICBjYWNoZS5jdXJyZW50ID0gY3JlYXRlUGxhY2Vob2xkZXIoKTtcblxuICByZXR1cm4gY2FjaGUuY3VycmVudDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0ICh7IHZhbHVlLCBzdHlsZSB9KSA9PlxuICBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6ICdlZGl0b3ItcGxhY2Vob2xkZXInLFxuICAgIHJlbmRlckN1c3RvbTogKGVkaXRvcikgPT4gKFxuICAgICAgPEVkaXRvclBsYWNlaG9sZGVyXG4gICAgICAgIGtleT1cImVkaXRvci1wbGFjZWhvbGRlclwiXG4gICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgZWRpdG9yPXtlZGl0b3J9XG4gICAgICAgIHN0eWxlPXtzdHlsZX1cbiAgICAgIC8+XG4gICAgKSxcbiAgfSk7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgVHJhbnNmb3JtcyB9IGZyb20gJ3NsYXRlJztcbmltcG9ydCB7IHVzZVNsYXRlIH0gZnJvbSAnc2xhdGUtcmVhY3QnO1xuaW1wb3J0IHtcbiAgY3JlYXRlUGx1Z2luLFxuICBpc0Jsb2NrQWN0aXZlLFxuICBtYWtlUmVuZGVyRWxlbWVudCxcbiAgYWRkTWVzc2FnZUxpc3RlbmVyLFxuICBwb3N0TWVzc2FnZSxcbiAgaXNMaXN0LFxufSBmcm9tICcuLi9oZWxwZXJzJztcbmltcG9ydCBUb29sYmFyIGZyb20gJy4uL2NvbXBvbmVudHMvVG9vbGJhcic7XG5pbXBvcnQgSWNvbiBmcm9tICcuLi9jb21wb25lbnRzL0ljb24nO1xuaW1wb3J0IHsgSEVBRElOR19PTkUgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5jb25zdCByZW5kZXJFbGVtZW50ID0gbWFrZVJlbmRlckVsZW1lbnQoXG4gIEhFQURJTkdfT05FLFxuICAoeyBhdHRyaWJ1dGVzLCBjaGlsZHJlbiB9KSA9PiA8aDEgey4uLmF0dHJpYnV0ZXN9PntjaGlsZHJlbn08L2gxPixcbik7XG5cbmNvbnN0IGhhbmRsZU1lc3NhZ2UgPSBhZGRNZXNzYWdlTGlzdGVuZXIoSEVBRElOR19PTkUsICh7IGVkaXRvciB9KSA9PiB7XG4gIGNvbnN0IGlzQWN0aXZlID0gaXNCbG9ja0FjdGl2ZShlZGl0b3IsIEhFQURJTkdfT05FKTtcblxuICAvLyBVbndyYXAgYWxsIHRoZSBpdGVtcyBvZiBhbnkgbGlzdFxuICBUcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgIG1hdGNoOiBpc0xpc3QsXG4gICAgc3BsaXQ6IHRydWUsXG4gIH0pO1xuXG4gIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgdHlwZTogaXNBY3RpdmUgPyAncGFyYWdyYXBoJyA6IEhFQURJTkdfT05FLFxuICB9KTtcbn0pO1xuXG5jb25zdCBUb29sYmFyQnV0dG9uID0gKCkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSB1c2VTbGF0ZSgpO1xuXG4gIHJldHVybiAoXG4gICAgPFRvb2xiYXIuQnV0dG9uXG4gICAgICBhY3RpdmU9e2lzQmxvY2tBY3RpdmUoZWRpdG9yLCBIRUFESU5HX09ORSl9XG4gICAgICBvbk1vdXNlRG93bj17KGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHBvc3RNZXNzYWdlKEhFQURJTkdfT05FLCB7fSwgZWRpdG9yKTtcbiAgICAgIH19XG4gICAgPlxuICAgICAgPEljb24+bG9va3Nfb25lPC9JY29uPlxuICAgIDwvVG9vbGJhci5CdXR0b24+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoKSA9PlxuICBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6IEhFQURJTkdfT05FLFxuICAgIHJlbmRlckVsZW1lbnQsXG4gICAgaGFuZGxlTWVzc2FnZSxcbiAgICBUb29sYmFyQnV0dG9uLFxuICB9KTtcbiIsImV4cG9ydCB7IGRlZmF1bHQgYXMgYm9sZCB9IGZyb20gJy4vYm9sZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGl0YWxpYyB9IGZyb20gJy4vaXRhbGljJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdW5kZXJsaW5lIH0gZnJvbSAnLi91bmRlcmxpbmUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBsb2dnZXIgfSBmcm9tICcuL2xvZ2dlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGJ1bGxldGVkTGlzdCB9IGZyb20gJy4vYnVsbGV0ZWRMaXN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbnVtYmVyZWRMaXN0IH0gZnJvbSAnLi9udW1iZXJlZExpc3QnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBsaXN0SXRlbSB9IGZyb20gJy4vbGlzdEl0ZW0nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBtZW50aW9uIH0gZnJvbSAnLi9tZW50aW9uJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZWRpdG9yUGxhY2Vob2xkZXIgfSBmcm9tICcuL2VkaXRvclBsYWNlaG9sZGVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbGluayB9IGZyb20gJy4vbGluayc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGN1cnNvclRyYWNrZXIgfSBmcm9tICcuL2N1cnNvclRyYWNrZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBoZWFkaW5nT25lIH0gZnJvbSAnLi9oZWFkaW5nT25lJztcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VTbGF0ZSB9IGZyb20gJ3NsYXRlLXJlYWN0JztcbmltcG9ydCB7XG4gIGNyZWF0ZVBsdWdpbixcbiAgaXNNYXJrQWN0aXZlLFxuICB0b2dnbGVNYXJrLFxuICBtYWtlUmVuZGVyTGVhZixcbiAgYWRkTWVzc2FnZUxpc3RlbmVyLFxuICBwb3N0TWVzc2FnZSxcbn0gZnJvbSAnLi4vaGVscGVycyc7XG5pbXBvcnQgVG9vbGJhciBmcm9tICcuLi9jb21wb25lbnRzL1Rvb2xiYXInO1xuaW1wb3J0IEljb24gZnJvbSAnLi4vY29tcG9uZW50cy9JY29uJztcbmltcG9ydCB7IElUQUxJQyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNvbnN0IHJlbmRlckxlYWYgPSBtYWtlUmVuZGVyTGVhZihJVEFMSUMsICh7IGNoaWxkcmVuIH0pID0+IChcbiAgPGVtPntjaGlsZHJlbn08L2VtPlxuKSk7XG5cbmNvbnN0IGhhbmRsZU1lc3NhZ2UgPSBhZGRNZXNzYWdlTGlzdGVuZXIoSVRBTElDLCAoeyBlZGl0b3IgfSkgPT4ge1xuICB0b2dnbGVNYXJrKGVkaXRvciwgSVRBTElDKTtcbn0pO1xuXG5jb25zdCBUb29sYmFyQnV0dG9uID0gKCkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSB1c2VTbGF0ZSgpO1xuXG4gIHJldHVybiAoXG4gICAgPFRvb2xiYXIuQnV0dG9uXG4gICAgICBhY3RpdmU9e2lzTWFya0FjdGl2ZShlZGl0b3IsIElUQUxJQyl9XG4gICAgICBvbk1vdXNlRG93bj17KGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHBvc3RNZXNzYWdlKElUQUxJQywge30sIGVkaXRvcik7XG4gICAgICB9fVxuICAgID5cbiAgICAgIDxJY29uPmZvcm1hdF9pdGFsaWM8L0ljb24+XG4gICAgPC9Ub29sYmFyLkJ1dHRvbj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0ICgpID0+XG4gIGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogSVRBTElDLFxuICAgIHJlbmRlckxlYWYsXG4gICAgaGFuZGxlTWVzc2FnZSxcbiAgICBUb29sYmFyQnV0dG9uLFxuICB9KTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgaXNVcmwgZnJvbSAnaXMtdXJsJztcbmltcG9ydCB7IFRyYW5zZm9ybXMgfSBmcm9tICdzbGF0ZSc7XG5pbXBvcnQge1xuICBjcmVhdGVQbHVnaW4sXG4gIG1ha2VSZW5kZXJFbGVtZW50LFxuICBhZGRNZXNzYWdlTGlzdGVuZXIsXG4gIHBvc3RNZXNzYWdlLFxufSBmcm9tICcuLi9oZWxwZXJzJztcbmltcG9ydCB7IExJTksgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5jb25zdCBnZXRVcmwgPSAoZWxlbWVudCkgPT5cbiAgZWxlbWVudC5jaGlsZHJlbi5yZWR1Y2UoKHVybCwgbm9kZSkgPT4gdXJsICsgbm9kZS50ZXh0LCAnJyk7XG5cbmNvbnN0IExpbmtFbGVtZW50ID0gKHsgYXR0cmlidXRlcywgY2hpbGRyZW4sIGVsZW1lbnQgfSkgPT4gKFxuICA8YSB7Li4uYXR0cmlidXRlc30gaHJlZj17Z2V0VXJsKGVsZW1lbnQpfT5cbiAgICB7Y2hpbGRyZW59XG4gIDwvYT5cbik7XG5cbmNvbnN0IHJlbmRlckVsZW1lbnQgPSBtYWtlUmVuZGVyRWxlbWVudChMSU5LLCBMaW5rRWxlbWVudCk7XG5cbmNvbnN0IGhhbmRsZU1lc3NhZ2UgPSBhZGRNZXNzYWdlTGlzdGVuZXIoTElOSywgKHsgZWRpdG9yLCBkYXRhOiB7IHVybCB9IH0pID0+IHtcbiAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHtcbiAgICB0eXBlOiBMSU5LLFxuICAgIGRhdGE6IHsgdXJsIH0sXG4gICAgY2hpbGRyZW46IFt7IHRleHQ6IHVybCB9XSxcbiAgfSk7XG59KTtcblxuY29uc3QgZW5oYW5jZUVkaXRvciA9IChlZGl0b3IpID0+IHtcbiAgY29uc3QgeyBpc0lubGluZSwgaW5zZXJ0RGF0YSB9ID0gZWRpdG9yO1xuXG4gIGVkaXRvci5pc0lubGluZSA9IChlbGVtZW50KSA9PiB7XG4gICAgcmV0dXJuIGVsZW1lbnQudHlwZSA9PT0gTElOSyA/IHRydWUgOiBpc0lubGluZShlbGVtZW50KTtcbiAgfTtcblxuICBlZGl0b3IuaW5zZXJ0RGF0YSA9IChkYXRhKSA9PiB7XG4gICAgY29uc3QgdGV4dCA9IGRhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xuXG4gICAgaWYgKHRleHQgJiYgaXNVcmwodGV4dCkpIHtcbiAgICAgIHBvc3RNZXNzYWdlKExJTkssIHsgdXJsOiB0ZXh0IH0sIGVkaXRvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc2VydERhdGEoZGF0YSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBlZGl0b3I7XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoKSA9PlxuICBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6IExJTkssXG4gICAgcmVuZGVyRWxlbWVudCxcbiAgICBoYW5kbGVNZXNzYWdlLFxuICAgIGVuaGFuY2VFZGl0b3IsXG4gIH0pO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZVBsdWdpbiwgbWFrZVJlbmRlckVsZW1lbnQgfSBmcm9tICcuLi9oZWxwZXJzJztcbmltcG9ydCB7IExJU1RfSVRFTSB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNvbnN0IHJlbmRlckVsZW1lbnQgPSBtYWtlUmVuZGVyRWxlbWVudChcbiAgTElTVF9JVEVNLFxuICAoeyBhdHRyaWJ1dGVzLCBjaGlsZHJlbiB9KSA9PiA8bGkgey4uLmF0dHJpYnV0ZXN9PntjaGlsZHJlbn08L2xpPixcbik7XG5cbmV4cG9ydCBkZWZhdWx0ICgpID0+XG4gIGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogTElTVF9JVEVNLFxuICAgIHJlbmRlckVsZW1lbnQsXG4gIH0pO1xuIiwiaW1wb3J0IHsgY3JlYXRlUGx1Z2luIH0gZnJvbSAnLi4vaGVscGVycyc7XG5cbmNvbnN0IG5hbWUgPSAnbG9nZ2VyJztcblxuY29uc3QgaXNFbXB0eSA9IChvYmplY3QpID0+IG9iamVjdCAmJiBPYmplY3Qua2V5cyhvYmplY3QpLmxlbmd0aCA8IDE7XG5cbmNvbnN0IGhhbmRsZU1lc3NhZ2UgPSAoKSA9PiB7XG4gIGNvbnN0IGxpc3RlbmVyID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LmRhdGEudHlwZT8uc3RhcnRzV2l0aCgnQGhlcm8tZWRpdG9yJykpIHtcbiAgICAgIGNvbnN0IGdyb3VwTWV0aG9kID0gaXNFbXB0eShldmVudC5kYXRhLmRhdGEpID8gJ2dyb3VwQ29sbGFwc2VkJyA6ICdncm91cCc7XG4gICAgICBjb25zb2xlW2dyb3VwTWV0aG9kXShgJWMgJHtldmVudC5kYXRhLnR5cGV9IGAsICdjb2xvcjogbGltZWdyZWVuOycpO1xuICAgICAgY29uc29sZS5sb2coe1xuICAgICAgICBkYXRhOiBldmVudC5kYXRhLmRhdGEsXG4gICAgICAgIGV2ZW50LFxuICAgICAgfSk7XG4gICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgfVxuICB9O1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyKTtcbiAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgKCkgPT4gY3JlYXRlUGx1Z2luKHsgbmFtZSwgaGFuZGxlTWVzc2FnZSB9KTtcbiIsImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBFZGl0b3IsIFJhbmdlLCBUcmFuc2Zvcm1zIH0gZnJvbSAnc2xhdGUnO1xuaW1wb3J0IHsgdXNlU2xhdGUsIFJlYWN0RWRpdG9yIH0gZnJvbSAnc2xhdGUtcmVhY3QnO1xuaW1wb3J0IHtcbiAgY3JlYXRlUGx1Z2luLFxuICBtYWtlUmVuZGVyRWxlbWVudCxcbiAgYWRkTWVzc2FnZUxpc3RlbmVyLFxuICBwb3N0TWVzc2FnZSxcbn0gZnJvbSAnLi4vaGVscGVycyc7XG5pbXBvcnQgeyBNRU5USU9OLCBFRElUT1JfQ0hBTkdFIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuY29uc3QgTWVudGlvbkVsZW1lbnQgPSAoeyBhdHRyaWJ1dGVzLCBjaGlsZHJlbiwgZWxlbWVudCB9KSA9PiAoXG4gIDxzcGFuXG4gICAgey4uLmF0dHJpYnV0ZXN9XG4gICAgY29udGVudEVkaXRhYmxlPXtmYWxzZX1cbiAgICBzdHlsZT17eyBwYWRkaW5nOiAnMnB4IDRweCcsIGJhY2tncm91bmQ6ICcjZWVlZWVlJywgYm9yZGVyUmFkaXVzOiA0IH19XG4gID5cbiAgICBAe2VsZW1lbnQuZGF0YS5uYW1lfVxuICAgIHtjaGlsZHJlbn1cbiAgPC9zcGFuPlxuKTtcblxuY29uc3QgcmVuZGVyRWxlbWVudCA9IG1ha2VSZW5kZXJFbGVtZW50KE1FTlRJT04sIE1lbnRpb25FbGVtZW50KTtcblxuY29uc3QgaGFuZGxlTWVzc2FnZSA9IChlZGl0b3IpID0+IHtcbiAgY29uc3QgcmVtb3ZlRWRpdG9yQ2hhbmdlTGlzdGVuZXIgPSBhZGRNZXNzYWdlTGlzdGVuZXIoXG4gICAgRURJVE9SX0NIQU5HRSxcbiAgICAoeyBlZGl0b3IgfSkgPT4ge1xuICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IGVkaXRvcjtcblxuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgIGNvbnN0IFtzdGFydF0gPSBSYW5nZS5lZGdlcyhzZWxlY3Rpb24pO1xuICAgICAgICBjb25zdCB3b3JkQmVmb3JlID0gRWRpdG9yLmJlZm9yZShlZGl0b3IsIHN0YXJ0LCB7IHVuaXQ6ICd3b3JkJyB9KTtcbiAgICAgICAgY29uc3QgYmVmb3JlID0gd29yZEJlZm9yZSAmJiBFZGl0b3IuYmVmb3JlKGVkaXRvciwgd29yZEJlZm9yZSk7XG4gICAgICAgIGNvbnN0IGJlZm9yZVJhbmdlID0gYmVmb3JlICYmIEVkaXRvci5yYW5nZShlZGl0b3IsIGJlZm9yZSwgc3RhcnQpO1xuICAgICAgICBjb25zdCBiZWZvcmVUZXh0ID0gYmVmb3JlUmFuZ2UgJiYgRWRpdG9yLnN0cmluZyhlZGl0b3IsIGJlZm9yZVJhbmdlKTtcbiAgICAgICAgY29uc3QgYmVmb3JlTWF0Y2ggPSBiZWZvcmVUZXh0ICYmIGJlZm9yZVRleHQubWF0Y2goL15AKFxcdyspJC8pO1xuICAgICAgICBjb25zdCBhZnRlciA9IEVkaXRvci5hZnRlcihlZGl0b3IsIHN0YXJ0KTtcbiAgICAgICAgY29uc3QgYWZ0ZXJSYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHN0YXJ0LCBhZnRlcik7XG4gICAgICAgIGNvbnN0IGFmdGVyVGV4dCA9IEVkaXRvci5zdHJpbmcoZWRpdG9yLCBhZnRlclJhbmdlKTtcbiAgICAgICAgY29uc3QgYWZ0ZXJNYXRjaCA9IGFmdGVyVGV4dC5tYXRjaCgvXihcXHN8JCkvKTtcblxuICAgICAgICBpZiAoYmVmb3JlTWF0Y2ggJiYgYWZ0ZXJNYXRjaCkge1xuICAgICAgICAgIHBvc3RNZXNzYWdlKFxuICAgICAgICAgICAgJ21lbnRpb24tc2VhcmNoJyxcbiAgICAgICAgICAgIHsgdGFyZ2V0OiBiZWZvcmVSYW5nZSwgc2VhcmNoOiBiZWZvcmVNYXRjaFsxXSB9LFxuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zdE1lc3NhZ2UoJ21lbnRpb24tc2VhcmNoJywgeyB0YXJnZXQ6IG51bGwsIHNlYXJjaDogJycgfSwgZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICkoZWRpdG9yKTtcblxuICBjb25zdCByZW1vdmVNZW50aW9uQXBwbHlMaXN0ZW5lciA9IGFkZE1lc3NhZ2VMaXN0ZW5lcihcbiAgICAnbWVudGlvbi1hcHBseScsXG4gICAgKHsgZWRpdG9yLCBkYXRhIH0pID0+IHtcbiAgICAgIGNvbnN0IHsgaWQsIG5hbWUsIG1ldGEsIHRhcmdldCB9ID0gZGF0YTtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgdGFyZ2V0KTtcbiAgICAgIGNvbnN0IG1lbnRpb24gPSB7XG4gICAgICAgIHR5cGU6IE1FTlRJT04sXG4gICAgICAgIGRhdGE6IHsgaWQsIG5hbWUsIG1ldGEgfSxcbiAgICAgICAgY2hpbGRyZW46IFt7IHRleHQ6ICcnIH1dLFxuICAgICAgfTtcbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBtZW50aW9uKTtcbiAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IpO1xuICAgIH0sXG4gICkoZWRpdG9yKTtcblxuICByZXR1cm4gKCkgPT4ge1xuICAgIHJlbW92ZUVkaXRvckNoYW5nZUxpc3RlbmVyKCk7XG4gICAgcmVtb3ZlTWVudGlvbkFwcGx5TGlzdGVuZXIoKTtcbiAgfTtcbn07XG5cbmNvbnN0IE1lbnRpb25MaXN0V3JhcHBlciA9ICh7IHJlbmRlck1lbnRpb25MaXN0IH0pID0+IHtcbiAgY29uc3QgW3NlYXJjaCwgc2V0U2VhcmNoXSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW3RhcmdldCwgc2V0VGFyZ2V0XSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCB3cmFwcGVyID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBlZGl0b3IgPSB1c2VTbGF0ZSgpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgcmVtb3ZlTWVudGlvblNlYXJjaExpc3RlbmVyID0gYWRkTWVzc2FnZUxpc3RlbmVyKFxuICAgICAgJ21lbnRpb24tc2VhcmNoJyxcbiAgICAgICh7IGRhdGEgfSkgPT4ge1xuICAgICAgICBjb25zdCB3cmFwcGVyRWwgPSB3cmFwcGVyLmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKGRhdGEudGFyZ2V0KSB7XG4gICAgICAgICAgY29uc3QgZG9tUmFuZ2UgPSBSZWFjdEVkaXRvci50b0RPTVJhbmdlKGVkaXRvciwgZGF0YS50YXJnZXQpO1xuICAgICAgICAgIGNvbnN0IHJhbmdlUmVjdCA9IGRvbVJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIGNvbnN0IGVkaXRvclJlY3QgPSB3cmFwcGVyRWwucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgIHdyYXBwZXJFbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICB3cmFwcGVyRWwuc3R5bGUudG9wID0gYCR7cmFuZ2VSZWN0LnRvcCAtIGVkaXRvclJlY3QudG9wICsgMjB9cHhgO1xuICAgICAgICAgIHdyYXBwZXJFbC5zdHlsZS5sZWZ0ID0gYCR7cmFuZ2VSZWN0LmxlZnQgLSBlZGl0b3JSZWN0LmxlZnR9cHhgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdyYXBwZXJFbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0U2VhcmNoKGRhdGEuc2VhcmNoKTtcbiAgICAgICAgc2V0VGFyZ2V0KGRhdGEudGFyZ2V0KTtcbiAgICAgIH0sXG4gICAgKShlZGl0b3IpO1xuXG4gICAgcmV0dXJuICgpID0+IHJlbW92ZU1lbnRpb25TZWFyY2hMaXN0ZW5lcigpO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICByZWY9e3dyYXBwZXJ9XG4gICAgICBzdHlsZT17eyBwb3NpdGlvbjogJ2Fic29sdXRlJywgekluZGV4OiAxLCBkaXNwbGF5OiAnbm9uZScgfX1cbiAgICA+XG4gICAgICB7cmVuZGVyTWVudGlvbkxpc3Qoc2VhcmNoLCAoeyBpZCwgbmFtZSwgbWV0YSB9KSA9PiB7XG4gICAgICAgIHBvc3RNZXNzYWdlKCdtZW50aW9uLWFwcGx5JywgeyBpZCwgbmFtZSwgbWV0YSwgdGFyZ2V0IH0sIGVkaXRvcik7XG4gICAgICB9KX1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmNvbnN0IGVuaGFuY2VFZGl0b3IgPSAoZWRpdG9yKSA9PiB7XG4gIGNvbnN0IHsgaXNJbmxpbmUsIGlzVm9pZCB9ID0gZWRpdG9yO1xuXG4gIGVkaXRvci5pc0lubGluZSA9IChlbGVtZW50KSA9PiB7XG4gICAgcmV0dXJuIGVsZW1lbnQudHlwZSA9PT0gTUVOVElPTiA/IHRydWUgOiBpc0lubGluZShlbGVtZW50KTtcbiAgfTtcblxuICBlZGl0b3IuaXNWb2lkID0gKGVsZW1lbnQpID0+IHtcbiAgICByZXR1cm4gZWxlbWVudC50eXBlID09PSBNRU5USU9OID8gdHJ1ZSA6IGlzVm9pZChlbGVtZW50KTtcbiAgfTtcblxuICByZXR1cm4gZWRpdG9yO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgKHsgcmVuZGVyTWVudGlvbkxpc3QgfSkgPT5cbiAgY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiBNRU5USU9OLFxuICAgIHJlbmRlckVsZW1lbnQsXG4gICAgcmVuZGVyQ3VzdG9tOiAoKSA9PiAoXG4gICAgICA8TWVudGlvbkxpc3RXcmFwcGVyIGtleT17TUVOVElPTn0gcmVuZGVyTWVudGlvbkxpc3Q9e3JlbmRlck1lbnRpb25MaXN0fSAvPlxuICAgICksXG4gICAgaGFuZGxlTWVzc2FnZSxcbiAgICBlbmhhbmNlRWRpdG9yLFxuICB9KTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBUcmFuc2Zvcm1zIH0gZnJvbSAnc2xhdGUnO1xuaW1wb3J0IHsgdXNlU2xhdGUgfSBmcm9tICdzbGF0ZS1yZWFjdCc7XG5pbXBvcnQge1xuICBjcmVhdGVQbHVnaW4sXG4gIGlzQmxvY2tBY3RpdmUsXG4gIG1ha2VSZW5kZXJFbGVtZW50LFxuICBhZGRNZXNzYWdlTGlzdGVuZXIsXG4gIHBvc3RNZXNzYWdlLFxuICBpc0xpc3QsXG59IGZyb20gJy4uL2hlbHBlcnMnO1xuaW1wb3J0IFRvb2xiYXIgZnJvbSAnLi4vY29tcG9uZW50cy9Ub29sYmFyJztcbmltcG9ydCBJY29uIGZyb20gJy4uL2NvbXBvbmVudHMvSWNvbic7XG5pbXBvcnQgeyBOVU1CRVJFRF9MSVNULCBMSVNUX0lURU0gfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5jb25zdCByZW5kZXJFbGVtZW50ID0gbWFrZVJlbmRlckVsZW1lbnQoXG4gIE5VTUJFUkVEX0xJU1QsXG4gICh7IGF0dHJpYnV0ZXMsIGNoaWxkcmVuIH0pID0+IDxvbCB7Li4uYXR0cmlidXRlc30+e2NoaWxkcmVufTwvb2w+LFxuKTtcblxuY29uc3QgaGFuZGxlTWVzc2FnZSA9IGFkZE1lc3NhZ2VMaXN0ZW5lcihOVU1CRVJFRF9MSVNULCAoeyBlZGl0b3IgfSkgPT4ge1xuICBjb25zdCBpc0FjdGl2ZSA9IGlzQmxvY2tBY3RpdmUoZWRpdG9yLCBOVU1CRVJFRF9MSVNUKTtcblxuICAvLyBVbndyYXAgYWxsIHRoZSBpdGVtcyBvZiBhbnkgbGlzdFxuICBUcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgIG1hdGNoOiBpc0xpc3QsXG4gICAgc3BsaXQ6IHRydWUsXG4gIH0pO1xuXG4gIGlmIChpc0FjdGl2ZSkge1xuICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7IHR5cGU6ICdwYXJhZ3JhcGgnIH0pO1xuICB9IGVsc2Uge1xuICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7IHR5cGU6IExJU1RfSVRFTSB9KTtcbiAgICBUcmFuc2Zvcm1zLndyYXBOb2RlcyhlZGl0b3IsIHsgdHlwZTogTlVNQkVSRURfTElTVCwgY2hpbGRyZW46IFtdIH0pO1xuICB9XG59KTtcblxuY29uc3QgVG9vbGJhckJ1dHRvbiA9ICgpID0+IHtcbiAgY29uc3QgZWRpdG9yID0gdXNlU2xhdGUoKTtcblxuICByZXR1cm4gKFxuICAgIDxUb29sYmFyLkJ1dHRvblxuICAgICAgYWN0aXZlPXtpc0Jsb2NrQWN0aXZlKGVkaXRvciwgTlVNQkVSRURfTElTVCl9XG4gICAgICBvbk1vdXNlRG93bj17KGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHBvc3RNZXNzYWdlKE5VTUJFUkVEX0xJU1QsIHt9LCBlZGl0b3IpO1xuICAgICAgfX1cbiAgICA+XG4gICAgICA8SWNvbj5mb3JtYXRfbGlzdF9udW1iZXJlZDwvSWNvbj5cbiAgICA8L1Rvb2xiYXIuQnV0dG9uPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgKCkgPT5cbiAgY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiBOVU1CRVJFRF9MSVNULFxuICAgIHJlbmRlckVsZW1lbnQsXG4gICAgaGFuZGxlTWVzc2FnZSxcbiAgICBUb29sYmFyQnV0dG9uLFxuICB9KTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VTbGF0ZSB9IGZyb20gJ3NsYXRlLXJlYWN0JztcbmltcG9ydCB7XG4gIGNyZWF0ZVBsdWdpbixcbiAgaXNNYXJrQWN0aXZlLFxuICB0b2dnbGVNYXJrLFxuICBtYWtlUmVuZGVyTGVhZixcbiAgYWRkTWVzc2FnZUxpc3RlbmVyLFxuICBwb3N0TWVzc2FnZSxcbn0gZnJvbSAnLi4vaGVscGVycyc7XG5pbXBvcnQgVG9vbGJhciBmcm9tICcuLi9jb21wb25lbnRzL1Rvb2xiYXInO1xuaW1wb3J0IEljb24gZnJvbSAnLi4vY29tcG9uZW50cy9JY29uJztcbmltcG9ydCB7IFVOREVSTElORSB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNvbnN0IHJlbmRlckxlYWYgPSBtYWtlUmVuZGVyTGVhZihVTkRFUkxJTkUsICh7IGNoaWxkcmVuIH0pID0+IChcbiAgPHU+e2NoaWxkcmVufTwvdT5cbikpO1xuXG5jb25zdCBoYW5kbGVNZXNzYWdlID0gYWRkTWVzc2FnZUxpc3RlbmVyKFVOREVSTElORSwgKHsgZWRpdG9yIH0pID0+IHtcbiAgdG9nZ2xlTWFyayhlZGl0b3IsIFVOREVSTElORSk7XG59KTtcblxuY29uc3QgVG9vbGJhckJ1dHRvbiA9ICgpID0+IHtcbiAgY29uc3QgZWRpdG9yID0gdXNlU2xhdGUoKTtcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8VG9vbGJhci5CdXR0b25cbiAgICAgICAgYWN0aXZlPXtpc01hcmtBY3RpdmUoZWRpdG9yLCBVTkRFUkxJTkUpfVxuICAgICAgICBvbk1vdXNlRG93bj17KGV2ZW50KSA9PiB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBwb3N0TWVzc2FnZShVTkRFUkxJTkUsIHt9LCBlZGl0b3IpO1xuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICA8SWNvbj5mb3JtYXRfdW5kZXJsaW5lZDwvSWNvbj5cbiAgICAgIDwvVG9vbGJhci5CdXR0b24+XG4gICAgICA8VG9vbGJhci5TZXBhcmF0b3IgLz5cbiAgICA8Lz5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0ICgpID0+XG4gIGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogVU5ERVJMSU5FLFxuICAgIHJlbmRlckxlYWYsXG4gICAgaGFuZGxlTWVzc2FnZSxcbiAgICBUb29sYmFyQnV0dG9uLFxuICB9KTtcbiIsImltcG9ydCB7IE5vZGUgfSBmcm9tICdzbGF0ZSc7XG5cbi8vIFRPRE86IHdpcFxuY29uc3QgcGxhaW5TZXJpYWxpemVyID0gKG5vZGVzKSA9PiB7XG4gIHJldHVybiBub2Rlcy5tYXAoKG4pID0+IE5vZGUuc3RyaW5nKG4pKS5qb2luKCdcXG4nKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHBsYWluU2VyaWFsaXplcjtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBUZXh0LCBOb2RlIH0gZnJvbSAnc2xhdGUnO1xuaW1wb3J0IHkgZnJvbSAnLi4vaGVscGVycy93aHknO1xuXG5jb25zdCBpc1Jvb3QgPSBBcnJheS5pc0FycmF5O1xuXG5jb25zdCBtYWtlUmVhY3RUcmFuc2Zvcm1lciA9IChydWxlcykgPT5cbiAgeSgocmVhY3RUcmFuc2Zvcm1lcikgPT4gKG5vZGUsIGtleSkgPT4ge1xuICAgIGlmIChpc1Jvb3Qobm9kZSkpIHJldHVybiBub2RlLm1hcChyZWFjdFRyYW5zZm9ybWVyKTtcblxuICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkgcmV0dXJuIHJ1bGVzLmxlYWYobm9kZSwga2V5KTtcblxuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5tYXAocmVhY3RUcmFuc2Zvcm1lcik7XG5cbiAgICByZXR1cm4gcnVsZXMuZWxlbWVudChub2RlLCBjaGlsZHJlbiwga2V5KTtcbiAgfSk7XG5cbmNvbnN0IGRlZmF1bHRSdWxlcyA9IHtcbiAgbGVhZjogKG5vZGUsIGtleSkgPT4ge1xuICAgIGxldCBjaGlsZHJlbiA9IG5vZGUudGV4dDtcblxuICAgIGlmIChub2RlLmJvbGQpIGNoaWxkcmVuID0gPHN0cm9uZyBrZXk9e2tleX0+e2NoaWxkcmVufTwvc3Ryb25nPjtcblxuICAgIGlmIChub2RlLml0YWxpYykgY2hpbGRyZW4gPSA8ZW0ga2V5PXtrZXl9PntjaGlsZHJlbn08L2VtPjtcblxuICAgIGlmIChub2RlLnVuZGVybGluZSkgY2hpbGRyZW4gPSA8dSBrZXk9e2tleX0+e2NoaWxkcmVufTwvdT47XG5cbiAgICByZXR1cm4gPHNwYW4ga2V5PXtrZXl9PntjaGlsZHJlbn08L3NwYW4+O1xuICB9LFxuXG4gIGVsZW1lbnQ6IChub2RlLCBjaGlsZHJlbiwga2V5KSA9PiB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3BhcmFncmFwaCc6XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPHBcbiAgICAgICAgICAgIGtleT17a2V5fVxuICAgICAgICAgICAgc3R5bGU9e3sgbWFyZ2luOiAwLCBsaW5lSGVpZ2h0OiAxLjUsIG1pbkhlaWdodDogJzEuNWVtJyB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICA8L3A+XG4gICAgICAgICk7XG5cbiAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIDxhIGtleT17a2V5fSBocmVmPXtOb2RlLnN0cmluZyhub2RlKX0gdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgPC9hPlxuICAgICAgICApO1xuXG4gICAgICBjYXNlICdtZW50aW9uJzpcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8c3BhblxuICAgICAgICAgICAga2V5PXtrZXl9XG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICBwYWRkaW5nOiAnMnB4IDRweCcsXG4gICAgICAgICAgICAgIGJhY2tncm91bmQ6ICcjZWVlZWVlJyxcbiAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiA0LFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICBAe25vZGUuZGF0YS5uYW1lfVxuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgKTtcblxuICAgICAgY2FzZSAnYnVsbGV0ZWQtbGlzdCc6XG4gICAgICAgIHJldHVybiA8dWwga2V5PXtrZXl9PntjaGlsZHJlbn08L3VsPjtcblxuICAgICAgY2FzZSAnbnVtYmVyZWQtbGlzdCc6XG4gICAgICAgIHJldHVybiA8b2wga2V5PXtrZXl9PntjaGlsZHJlbn08L29sPjtcblxuICAgICAgY2FzZSAnbGlzdC1pdGVtJzpcbiAgICAgICAgcmV0dXJuIDxsaSBrZXk9e2tleX0+e2NoaWxkcmVufTwvbGk+O1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gPGRpdiBrZXk9e2tleX0+e2NoaWxkcmVufTwvZGl2PjtcbiAgICB9XG4gIH0sXG59O1xuXG5jb25zdCBkZWZhdWx0UmVhY3RUcmFuc2Zvcm1lciA9IG1ha2VSZWFjdFRyYW5zZm9ybWVyKGRlZmF1bHRSdWxlcyk7XG5cbmV4cG9ydCBkZWZhdWx0IG1ha2VSZWFjdFRyYW5zZm9ybWVyO1xuXG5leHBvcnQgeyBtYWtlUmVhY3RUcmFuc2Zvcm1lciwgZGVmYXVsdFJlYWN0VHJhbnNmb3JtZXIgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9yZWFjdF9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9yZWFjdF9kb21fXzsiXSwic291cmNlUm9vdCI6IiJ9